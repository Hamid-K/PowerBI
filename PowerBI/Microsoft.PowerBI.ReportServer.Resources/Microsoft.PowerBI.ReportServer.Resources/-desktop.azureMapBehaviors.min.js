"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "azureMapBehaviors" ], {
    2379: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            b: function() {
                return MapMath;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _VisualsCommon_geometry_shapes7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92379), MapMath = function() {
            function MapMath() {}
            return MapMath.createMultiPolygonCoordinatesFromPaths = function(paths, coordinates) {
                var allPolygons = [];
                if (paths.filter(function(path) {
                    return path.geographic;
                }).forEach(function(path) {
                    var latitude, polygonPoints = [];
                    path.geographic.forEach(function(val, i) {
                        i % 2 == 0 ? latitude = val : polygonPoints.push([ val, latitude ]);
                    }), allPolygons.push(polygonPoints);
                }), 0 === allPolygons.length) return [];
                for (var multiPolygons = [ [ allPolygons[0] ] ], i = 1; i < allPolygons.length; i++) {
                    var currentPolygonSeries = multiPolygons[multiPolygons.length - 1], polygon = allPolygons[i];
                    this.isPointInsidePolygon(polygon[0], currentPolygonSeries[0]) ? currentPolygonSeries.push(polygon) : multiPolygons.push([ polygon ]);
                }
                return this.combineMultiPolygonCoordinatesAtAntimeridian(coordinates, multiPolygons);
            }, MapMath.combineMultiPolygonCoordinatesAtAntimeridian = function(coordinates, multiPolygons) {
                return this.shouldCheckAntimeridianCrossing(coordinates) ? this.checkAndMergePolygonsAtAntimeridian(multiPolygons) : multiPolygons;
            }, MapMath.shouldCheckAntimeridianCrossing = function(coordinates) {
                var boundingBoxOfRussia = new atlas.data.BoundingBox([ 19.8, 41.2, -169.6, 81.45 ]);
                return coordinates.longitude > 175 || coordinates.longitude < -175 || !!atlas.data.BoundingBox.containsPosition(boundingBoxOfRussia, [ coordinates.longitude, coordinates.latitude ]);
            }, MapMath.checkAndMergePolygonsAtAntimeridian = function(multiPolygons) {
                for (var boundingBoxes = multiPolygons.map(function(p) {
                    return atlas.data.BoundingBox.fromPositions(p[0]);
                }), resultPolygons = [], remainingRightPolygons = [], leftIndices = [], i = 0; i < boundingBoxes.length; i++) {
                    var east = atlas.data.BoundingBox.getEast(boundingBoxes[i]), west = atlas.data.BoundingBox.getWest(boundingBoxes[i]), polygon = _.cloneDeep(multiPolygons[i]), boundingBox = boundingBoxes[i];
                    180 === east || -180 === east ? (resultPolygons.push({
                        polygon,
                        boundingBox
                    }), leftIndices.push(resultPolygons.length - 1)) : 180 === west || -180 === west ? remainingRightPolygons.push({
                        polygon,
                        boundingBox
                    }) : resultPolygons.push({
                        polygon,
                        boundingBox
                    });
                }
                for (var _i = 0, leftIndices_1 = leftIndices; _i < leftIndices_1.length; _i++) for (var leftPolygon = resultPolygons[leftIndices_1[_i]], rightIndex = 0; rightIndex < remainingRightPolygons.length; rightIndex++) if (this.matchAndMerge(leftPolygon.polygon, remainingRightPolygons[rightIndex].polygon)) {
                    remainingRightPolygons.splice(rightIndex, 1);
                    break;
                }
                return resultPolygons.map(function(polyInfo) {
                    return polyInfo.polygon;
                });
            }, MapMath.matchAndMerge = function(leftPolygon, rightPolygon) {
                for (var _this = this, left = (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], leftPolygon[0], !0), right = (0, 
                tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], rightPolygon[0], !0), rotatedCount = 0; Math.abs(left[0][0] - 180) < this.floatPrecision && rotatedCount < 3; ) left.push(left.shift()), 
                rotatedCount += 1;
                for (rotatedCount = 0; Math.abs(right[0][0] + 180) < this.floatPrecision && rotatedCount < 3; ) right.push(right.shift()), 
                rotatedCount += 1;
                var leftSouthSplitIndex = _.findIndex(left, function(p) {
                    return Math.abs(p[0] - 180) < _this.floatPrecision;
                }), leftNorthSplitIndex = _.findLastIndex(left, function(p) {
                    return Math.abs(p[0] - 180) < _this.floatPrecision;
                }), rightNorthSplitIndex = _.findIndex(right, function(p) {
                    return Math.abs(p[0] + 180) < _this.floatPrecision;
                }), rightSouthSplitIndex = _.findLastIndex(right, function(p) {
                    return Math.abs(p[0] + 180) < _this.floatPrecision;
                });
                if (-1 === leftSouthSplitIndex || leftNorthSplitIndex === leftSouthSplitIndex || -1 === rightNorthSplitIndex || rightSouthSplitIndex === rightNorthSplitIndex) return !1;
                var leftSouth = left[leftSouthSplitIndex][1], leftNorth = left[leftNorthSplitIndex][1], rightNorth = right[rightNorthSplitIndex][1], rightSouth = right[rightSouthSplitIndex][1], totalRange = Math.max(leftNorth, rightNorth) - Math.min(leftSouth, rightSouth), overlapRange = Math.min(leftNorth, rightNorth) - Math.max(leftSouth, rightSouth);
                if (totalRange > 0 && overlapRange / totalRange > .9) {
                    var leftLowerRing = left.slice(0, leftSouthSplitIndex + 1), leftUpperRing = left.slice(leftNorthSplitIndex);
                    right.forEach(function(p) {
                        return p[0] += 360;
                    });
                    var rightUpperRing = right.slice(0, rightNorthSplitIndex + 1), rightLowerRing = right.slice(rightSouthSplitIndex);
                    return leftPolygon[0] = leftLowerRing.concat(rightLowerRing, rightUpperRing, leftUpperRing), 
                    leftPolygon.push.apply(leftPolygon, rightPolygon.slice(1)), !0;
                }
                return !1;
            }, MapMath.isPointInsidePolygon = function(point, polygonPoints) {
                for (var crossingCount = 0, i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) this.isRayCrossEdgeUpward(point, polygonPoints[i], polygonPoints[j]) && crossingCount++;
                return crossingCount % 2 == 1;
            }, MapMath.isRayCrossEdgeUpward = function(point, edgePoint1, edgePoint2) {
                var x = point[0], y = point[1], x1 = edgePoint1[0], y1 = edgePoint1[1], x2 = edgePoint2[0], y2 = edgePoint2[1];
                return Math.abs(x2 - x1) > 180 && (x > 0 ? (x1 < 0 && (x1 += 360), x2 < 0 && (x2 += 360)) : (x1 > 0 && (x1 -= 360), 
                x2 > 0 && (x2 -= 360))), x1 > x != x2 > x && y < (y2 - y1) * (x - x1) / (x2 - x1) + y1;
            }, MapMath.shapesWithinPolygon = function(shapes, searchArea) {
                var results = [];
                if (shapes && searchArea) {
                    var id_1, idLookupTable_1 = {}, points_1 = [], sourceShapes = shapes instanceof atlas.source.DataSource ? shapes.getShapes() : shapes;
                    _.forEach(sourceShapes, function(s) {
                        id_1 = s.getId(), idLookupTable_1[id_1] = s, points_1.push({
                            id: id_1,
                            coordinates: s.getProperties().coordinates
                        });
                    }), results = MapMath.pointsWithinPolygon(points_1, searchArea).map(function(f) {
                        return idLookupTable_1[f.id];
                    });
                }
                return results;
            }, MapMath.pointsWithinPolygon = function(points, searchArea) {
                if (points && searchArea) {
                    var poly = MapMath.getPolygon(searchArea), polygonHelper_1 = MapMath.getPowerBIShapePolygon(poly);
                    return points.filter(function(p) {
                        return polygonHelper_1.inside(MapMath.getPowerBIShapePoint(p.coordinates));
                    });
                }
                return [];
            }, MapMath.getPowerBIShapePoint = function(coordinates) {
                return {
                    x: coordinates[0],
                    y: coordinates[1]
                };
            }, MapMath.getPowerBIShapePolygon = function(polygon) {
                var allShapePoints = [].concat.apply([], polygon.coordinates).map(function(p) {
                    return {
                        x: atlas.math.normalizeLongitude(p[0]),
                        y: atlas.math.normalizeLatitude(p[1])
                    };
                });
                return _VisualsCommon_geometry_shapes7__WEBPACK_IMPORTED_MODULE_1__.m.fromPolygonPoints(allShapePoints);
            }, MapMath.getPolygon = function(shape) {
                var poly;
                if (shape instanceof atlas.Shape) shape.isCircle() ? poly = new atlas.data.Polygon([ shape.getCircleCoordinates() ]) : shape.getType().indexOf("Polygon") > -1 && (poly = shape.toJson().geometry); else {
                    var f = shape;
                    "Feature" === f.type && ("Point" === f.geometry.type && "Circle" === f.properties.subType && "number" == typeof f.properties.radius ? poly = new atlas.data.Polygon(atlas.math.getRegularPolygonPath(f.geometry.coordinates, f.properties.radius, 72, "meters")) : f.geometry.type.indexOf("Polygon") > -1 && (poly = f.geometry)), 
                    -1 !== f.type.indexOf("Polygon") && (poly = shape);
                }
                return poly;
            }, MapMath.floatPrecision = 1e-4, MapMath;
        }();
    },
    49988: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            t: function() {
                return PieChartFactory;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _VisualsCommon_Utility_pbiDeferred__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65363), createPieSlice = function(options, cx, cy, r, startAngle, angle, fillColor, maskId, sliceIdx) {
            var opt = options, pi = Math.PI, mask = "";
            maskId && (mask = ' mask="url(#'.concat(maskId, '"'));
            var pieOpacity = void 0 !== options.selectionPieIndexes && void 0 === options.selectionPieIndexes.filter(function(idx) {
                return idx === sliceIdx;
            })[0] ? options.deselectedPieOpacity : 1, filterExpression = options.gaussianBlurStandardDeviation ? 'filter="url(#f1)"' : "";
            if (angle > 2 * pi * .99) return '<circle r="'.concat(r, '" cx="').concat(cx, '" cy="').concat(cy, '" ').concat(filterExpression, ' style="opacity:').concat(pieOpacity, ";stroke-opacity:").concat(opt.strokeOpacity, ";fill:").concat(fillColor, ";stroke:").concat(opt.strokeColor, ";stroke-width:").concat(opt.strokeWidth, 'px;"').concat(mask, "></circle>");
            var sin = Math.sin, cos = Math.cos, x1 = cx + r * sin(startAngle), y1 = cy - r * cos(startAngle), x2 = cx + r * sin(startAngle + angle), y2 = cy - r * cos(startAngle + angle), big = 0;
            return angle > pi && (big = 1), '<path d="M'.concat(cx, " ").concat(cy, " L ").concat(x1, " ").concat(y1, " A ").concat(r, ",").concat(r, " 0 ").concat(big, " 1 ").concat(x2, " ").concat(y2, 'z" ').concat(filterExpression, ' style="opacity:').concat(pieOpacity, ";stroke-opacity:").concat(opt.strokeOpacity, ";fill:").concat(fillColor, ";stroke:").concat(opt.strokeColor, ";stroke-width:").concat(opt.strokeWidth, 'px;"').concat(mask, "></path>");
        }, generatePieChartSVG = function(point, options, selectedIndexes) {
            return function(options) {
                var maskId, data = options.values, radius = options.radius, startAngle = 0, angle = 0, o = radius + options.strokeWidth, svg = [ '<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(2 * o, 'px" height="').concat(2 * o, 'px" opacity="').concat(void 0 !== options.opacity || null !== options.opacity ? options.opacity : 1, '">') ], filterExpression = '<filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="'.concat(options.gaussianBlurStandardDeviation, '" /></filter>');
                svg.push("\n        <defs>".concat(options.gaussianBlurStandardDeviation ? filterExpression : "", "</defs>\n    ")), 
                options.innerRadius > 0 && options.innerRadius <= options.radius && (maskId = "piechart-innercircle-" + Math.round(1e7 * Math.random()), 
                svg.push('<defs><mask id="'.concat(maskId, '"><rect width="100%" height="100%" fill="white"/><circle r="').concat(options.innerRadius, '" cx="').concat(o, '" cy="').concat(o, '" fill="black"/></mask></defs>\n            <circle r="').concat(options.innerRadius, '" cx="').concat(o, '" cy="').concat(o, '" style="fill:').concat(options.fillColor, ";stroke:").concat(options.strokeColor, ";stroke-width:").concat(2 * options.strokeWidth, 'px;"/>')));
                var _total = data.reduce(function(a, b) {
                    return a + b.count;
                }, 0);
                if (_total > 0) for (var ratio = 2 * Math.PI / _total, i = 0; i < data.length; i++) svg.push(createPieSlice(options, o, o, radius, startAngle, angle = ratio * data[i].count, data[i].fill, maskId, i)), 
                startAngle += angle;
                var text = options.text;
                return text && svg.push('<text x="'.concat(o, '" y="').concat(o + 7, '" style="font-size:').concat(16, 'px;font-family:arial;fill:#000;font-weight:bold;" class="').concat(options.textClassName || "", '" text-anchor="middle">').concat(text, "</text>")), 
                svg.push("</svg>"), svg.join("");
            }(makeOptions(point, options, selectedIndexes));
        }, makeOptions = function(point, options, selectedIndexes) {
            return {
                values: point.subDataPoints.map(function(sp) {
                    return {
                        count: Math.max(sp.size, 0),
                        fill: sp.color
                    };
                }),
                radius: point.bubbleRadius,
                pixelOffset: [ 0, 0 ],
                innerRadius: 0,
                colors: [],
                fillColor: "transparent",
                gaussianBlurStandardDeviation: options.blur,
                strokeWidth: options.strokeWidth,
                strokeColor: options.strokeColor,
                strokeOpacity: 1 - options.strokeTransparency / 100,
                textClassName: void 0,
                opacity: 1 - options.transparency / 100,
                selectionPieIndexes: selectedIndexes || point.subDataPoints.map(function(_, i) {
                    return i;
                }),
                deselectedPieOpacity: .1
            };
        }, gcd = function gcd(a, b) {
            return b ? gcd(b, a % b) : a;
        }, gcdOf = function(numbers, length) {
            for (var res = numbers[0], i = 1; i < length; i++) if (1 === (res = gcd(numbers[i], res))) return 1;
            return res;
        }, PieChartFactory = function() {
            function PieChartFactory(imageSprite) {
                this.cache = {}, this.imageSprite = imageSprite;
            }
            return PieChartFactory.prototype.clearAll = function() {
                this.imageSprite.clear(), this.cache = {};
            }, PieChartFactory.hash = function(point, options, selectedIndexes) {
                return function(options) {
                    var counts = options.values.map(function(v) {
                        return v.count;
                    }), gcd = gcdOf(counts, counts.length);
                    return function(inputStr) {
                        var i, len, hash = 0;
                        if (0 === inputStr.length) return hash;
                        var lowerInputString = inputStr.toLowerCase();
                        for (i = 0, len = lowerInputString.length; i < len; i++) hash = (hash << 5) - hash + lowerInputString.charCodeAt(i), 
                        hash |= 0;
                        return hash;
                    }(Object.keys(options).filter(function(key) {
                        return "values" !== key && (void 0 !== options[key] || null !== options[key]);
                    }).map(function(key) {
                        return {
                            key,
                            value: options[key]
                        };
                    }).concat([ {
                        key: "values",
                        value: options.values.map(function(value) {
                            return [ "fill=".concat(value.fill), "count=".concat(value.count / gcd) ].join(",");
                        }).join(";")
                    } ]).map(function(_a) {
                        var key = _a.key, value = _a.value, serializedValue = value instanceof Array ? value.join(",") : "".concat(value);
                        return "".concat(key, "=").concat(serializedValue);
                    }).join(";"));
                }(makeOptions(point, options, selectedIndexes));
            }, PieChartFactory.prototype.svgContent = function(point, options, hidden, selectedIndexes) {
                void 0 === hidden && (hidden = !1);
                var svgOptions = hidden ? (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, options), {
                    transparency: 100
                }) : options, pieHash = PieChartFactory.hash(point, svgOptions, selectedIndexes), cached = this.cache[pieHash];
                if (void 0 !== cached) return cached.svgContent;
                var svgContent = generatePieChartSVG(point, svgOptions, selectedIndexes);
                return this.cache[pieHash] = {
                    svgContent
                }, svgContent;
            }, PieChartFactory.prototype.objectUrl = function(point, options, selectedIndexes) {
                var pieHash = PieChartFactory.hash(point, options, selectedIndexes), cached = this.cache[pieHash];
                if (void 0 !== cached && cached.objectUrl) return cached.objectUrl;
                if (void 0 !== cached) {
                    var svgBlob = new Blob([ cached.svgContent ], {
                        type: "image/svg+xml;charset=utf-8"
                    }), url = URL.createObjectURL(svgBlob);
                    return cached.objectUrl = url, this.cache[pieHash].objectUrl = url, url;
                }
                var svgContent = generatePieChartSVG(point, options, selectedIndexes), objectUrl = (svgBlob = new Blob([ svgContent ], {
                    type: "image/svg+xml;charset=utf-8"
                }), URL.createObjectURL(svgBlob));
                return this.cache[pieHash] = {
                    objectUrl,
                    svgContent
                }, objectUrl;
            }, PieChartFactory.prototype.loadIcon = function(point, options, selectedIndexes, hash) {
                var pieHash = null != hash ? hash : PieChartFactory.hash(point, options, selectedIndexes);
                if (this.cache[pieHash] && this.cache[pieHash].objectUrl || this.imageSprite.hasImage(pieHash.toString())) return (0, 
                _VisualsCommon_Utility_pbiDeferred__WEBPACK_IMPORTED_MODULE_1__.DR)(void 0);
                var objectUrl = this.objectUrl(point, options, selectedIndexes);
                return this.imageSprite.add(pieHash.toString(), objectUrl);
            }, PieChartFactory;
        }();
    },
    35824: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            AzureMapBehavior: function() {
                return AzureMapBehavior;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(81337), _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66232), _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30237), _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38400), _VisualsCommon_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(64067), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62458), _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59107), _azureMapConstant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70508), _azureMapExpressionHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72118), _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81293), _azureMapOnObjectUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19076), _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(49988);
        function isClusterFeature(feature) {
            var _a;
            return feature && !0 === (null === (_a = feature.properties) || void 0 === _a ? void 0 : _a.cluster);
        }
        function isShape(shape) {
            return shape && void 0 !== shape.getProperties;
        }
        var AzureMapBehavior = function() {
            function AzureMapBehavior() {
                var _this = this;
                this.hasSelection = !1, this.visualHasSelection = function() {
                    return _this.hasSelection;
                }, this.featureMouseover = function(mouseEvent) {
                    var _a;
                    if (_this.formatMode) {
                        _this.mapControl.getCanvasContainer().style.cursor = "pointer";
                        var identifiedDataPoint = _this.findSubDataPointByMouseEvent(mouseEvent);
                        if (identifiedDataPoint) {
                            var subSelection = _this.createVisualSubSelection(mouseEvent, identifiedDataPoint, !0), subSelectableObject = null === (_a = _.first(subSelection.visualObjects)) || void 0 === _a ? void 0 : _a.objectName, regionOutline = _this.subSelectionHelper.getRegionOutline(subSelectableObject);
                            regionOutline && 0 !== regionOutline.visibility || (_this.subSelectionHelper.updateCustomOutlinesFromSubSelections([ subSelection ], 1), 
                            _this.subSelectionHelper.renderOutlines());
                        }
                    }
                }, this.featureMousemove = function(mouseEvent, showTooltipsCallback) {
                    if (!_this.formatMode) {
                        var identifiedDataPoint = _this.findSubDataPointByMouseEvent(mouseEvent);
                        if (identifiedDataPoint) {
                            _this.mapControl.getCanvasContainer().style.cursor = "pointer";
                            var originalEvent = mouseEvent.originalEvent;
                            (null == identifiedDataPoint ? void 0 : identifiedDataPoint.tooltipInfo) && showTooltipsCallback([ originalEvent.x, originalEvent.y ], identifiedDataPoint);
                        }
                    }
                }, this.featureMouseout = function(mouseEvent, hideTooltipsCallback) {
                    if (_this.mapControl.getCanvasContainer().style.cursor = "grab", _this.formatMode) {
                        var originalEvent = mouseEvent.originalEvent;
                        (0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(originalEvent), 
                        originalEvent.preventDefault(), _this.subSelectionHelper.clearHoveredOutline();
                    } else hideTooltipsCallback();
                }, this.mapClicked = function(mouseEvent) {
                    _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(mouseEvent.originalEvent) || _this.selectionHandler.handleClearSelection();
                }, this.featureClicked = function(mouseEvent) {
                    if (mouseEvent) {
                        var shapes = _.filter(mouseEvent.shapes, isShape), pointsToBeSelected = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findDataPointsByShapes(_this.selectableDataPoints, shapes);
                        if (_this.formatMode) {
                            var originalEvent = mouseEvent.originalEvent;
                            (0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(originalEvent), 
                            originalEvent.preventDefault();
                            var topMostPoint = _.last(pointsToBeSelected);
                            if (topMostPoint) {
                                var identifiedDataPoint = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findFirstDataPointByKey(_this.selectableDataPoints, topMostPoint.identity.getKey()), subSelection = _this.createVisualSubSelection(mouseEvent, identifiedDataPoint, !1);
                                _this.subSelectionHelper.subSelect(subSelection);
                            }
                        } else _this.handleSelection(mouseEvent.originalEvent, pointsToBeSelected);
                    }
                }, this.featureContextClicked = function(mouseEvent) {
                    if (mouseEvent) {
                        var originalEvent = mouseEvent.originalEvent;
                        if (!_VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(originalEvent)) {
                            var shape = _.find(mouseEvent.shapes, isShape);
                            if (shape) {
                                var selectedShapeKey = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.getFirstIdentityKey(shape), selectedDataPoint = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findFirstDataPointByKey(_this.selectableDataPoints, selectedShapeKey);
                                if ((0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(originalEvent), 
                                originalEvent.preventDefault(), _this.formatMode) {
                                    if (selectedDataPoint) {
                                        for (var identifiedSubDataPoint = void 0, key = selectedDataPoint.identity.getKey(), _i = 0, _a = _this.data.dataPoints; _i < _a.length && !(identifiedSubDataPoint = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findFirstDataPointByKey(_a[_i].subDataPoints, key)); _i++) ;
                                        var subSelection = _this.createVisualSubSelection(mouseEvent, identifiedSubDataPoint, !0);
                                        _this.subSelectionHelper.subSelect(subSelection);
                                    }
                                } else selectedDataPoint && _this.selectionHandler.handleContextMenu(selectedDataPoint, {
                                    x: originalEvent.clientX,
                                    y: originalEvent.clientY
                                });
                            }
                        }
                    }
                }, this.handleContextMenu = function(event, point) {
                    event && !_VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(event) && ((0, 
                    _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(event), event.preventDefault(), 
                    _this.formatMode || _this.selectionHandler.handleContextMenu(point, {
                        x: event.clientX,
                        y: event.clientY
                    }));
                }, this.createFocusInCallback = function(toolTipCoordinates, identifiedDataPoint, showTooltipsCallback, hideTooltipsCallback, isTooltipsVisible) {
                    return function(e) {
                        _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(e) && 72 === e.keyCode && (isTooltipsVisible() ? hideTooltipsCallback() : showTooltipsCallback(toolTipCoordinates, identifiedDataPoint), 
                        e.preventDefault());
                    };
                }, this.featureFocusIn = function(focusEvent, showTooltipsCallback, hideTooltipsCallback, isTooltipsVisible) {
                    var identifiedDataPoint;
                    if (!_this.formatMode && focusEvent.shape && (_this.setFeatureFocusedState(focusEvent, !0), 
                    (identifiedDataPoint = isClusterFeature(focusEvent.shape) ? _this.findSubDataPointByClusterFeature(focusEvent.shape) : _this.findSubDataPointByShape(focusEvent.shape)) && identifiedDataPoint.tooltipInfo)) {
                        var _a = _this.mapControl.getCanvasContainer().getBoundingClientRect(), _b = focusEvent.pixel;
                        _this.focusInCallback = _this.createFocusInCallback([ _b[0] + _a.x, _b[1] + _a.y ], identifiedDataPoint, showTooltipsCallback, hideTooltipsCallback, isTooltipsVisible), 
                        focusEvent.target.addEventListener("keydown", _this.focusInCallback), focusEvent.target.setAttribute("aria-label", isClusterFeature(focusEvent.shape) ? identifiedDataPoint.tooltipInfo[0].header : (0, 
                        _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_3__.X)(identifiedDataPoint.tooltipInfo));
                    }
                }, this.featureFocusOut = function(focusEvent, hideTooltipCallback) {
                    _this.formatMode || (_this.setFeatureFocusedState(focusEvent, !1), focusEvent.target.removeEventListener("keydown", _this.focusInCallback), 
                    hideTooltipCallback());
                }, this.setFeatureFocusedState = function(focusEvent, focused) {
                    var feature = focusEvent.shape, featureId = isClusterFeature(feature) ? feature.id.toString() : feature.getId().toString();
                    _this.mapControl.sources.setFeatureState(featureId, _azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.oy, {
                        focused
                    });
                }, this.createVisualSubSelection = function(mouseEvent, dataPoint, showUI) {
                    var originalEvent = mouseEvent.originalEvent, shape = _.find(mouseEvent.shapes, function(s) {
                        return s && s.getProperties;
                    });
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_5__.fF.assertValue(shape, "azureMap ".concat(mouseEvent.type, ": expected to find the shape"));
                    var series, subSelectableRegion = _azureMapOnObjectUtil__WEBPACK_IMPORTED_MODULE_6__.E.getSubSelectableRegionFromLayerId(mouseEvent.layerId), seriesIndex = shape.getProperties().seriesIndex, subSelectableObject = "".concat(subSelectableRegion) + (void 0 === seriesIndex ? "" : "-series-".concat(seriesIndex)), selectionOrigin = {
                        x: originalEvent.clientX,
                        y: originalEvent.clientY
                    };
                    return _this.data.hasSeries && dataPoint && !_.isUndefined(dataPoint.seriesIndex) && (series = _this.data.series[dataPoint.seriesIndex]), 
                    _azureMapOnObjectUtil__WEBPACK_IMPORTED_MODULE_6__.E.createAzureMapSubSelection(subSelectableObject, showUI, _this.hostServices, selectionOrigin, series);
                }, this.dataSelected = function(selectedShapes) {
                    if (!_this.formatMode) {
                        var pointsToBeSelected = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findDataPointsByShapes(_this.selectableDataPoints, selectedShapes);
                        _this.handleSelection(void 0, pointsToBeSelected, 1);
                    }
                }, this.handleSelection = function(event, points, mode) {
                    void 0 !== mode ? (0, _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_7__.tn)(points, mode, _this.selectionHandler) : (0, 
                    _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_7__.ct)(event, points, _this.selectionHandler);
                }, this.clusterClicked = function(mouseEvent, dataSource) {
                    var clusterFeature = _.find(mouseEvent.shapes, isClusterFeature);
                    clusterFeature && dataSource.getClusterExpansionZoom(clusterFeature.properties.cluster_id).then(function(zoom) {
                        _this.mapControl.setCamera({
                            center: clusterFeature.geometry.coordinates,
                            zoom,
                            type: "ease",
                            duration: 200
                        });
                    }).catch(function(error) {});
                }, this.updateDataSourceWithSelection = function() {
                    return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(_this, void 0, void 0, function() {
                        var allShapes, selectedDataPoints, selectedFeatures_1, pendingPromises, expressionOptionArray_1, _i, _a, shape, featureId, featureProps, _this = this;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__generator)(this, function(_b) {
                            if ((this.bubbleDataSource || this.heatMapDataSource || this.filledMapDataSource || this.barChart3DDataSource || this.referenceDataSource) && (allShapes = (0, 
                            tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                            tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                            tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], this.bubbleDataSource.getShapes(), !0), this.heatMapDataSource.getShapes(), !0), this.filledMapDataSource.getShapes(), !0), this.barChart3DDataSource.getShapes(), !0), this.referenceDataSource.getShapes(), !0), 
                            this.hasSelection ? (selectedDataPoints = _.filter(this.selectableDataPoints, function(x) {
                                return x.selected;
                            }), selectedFeatures_1 = _.map(selectedDataPoints, function(x) {
                                return x.identity.getKey();
                            }), allShapes.forEach(function(shape) {
                                var props = shape.getProperties(), isSelected = selectedFeatures_1.indexOf(props.identityKeys[0]) > -1;
                                shape.addProperty("selected", isSelected);
                            })) : allShapes.forEach(function(shape) {
                                shape.addProperty("selected", !0);
                            }), this.showPieChart)) {
                                for (pendingPromises = [], expressionOptionArray_1 = [], _i = 0, _a = allShapes.filter(function(s) {
                                    return s && s.getProperties().showPie;
                                }); _i < _a.length; _i++) featureId = (shape = _a[_i]).getId(), featureProps = shape.getProperties(), 
                                pendingPromises.push(this.loadIcon(featureId, featureProps.identityKeys[0], expressionOptionArray_1));
                                Promise.allSettled(pendingPromises).then(function() {
                                    _this.composeAndUpdatePieExpression(expressionOptionArray_1);
                                });
                            }
                            return [ 2 ];
                        });
                    });
                }, this.loadIcon = function(featureId, featureIdentityKey, expressionOptionArray) {
                    return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(_this, void 0, void 0, function() {
                        var selectedIndexes, dataPoint, index, hash;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__generator)(this, function(_a) {
                            switch (_a.label) {
                              case 0:
                                if (selectedIndexes = [], dataPoint = _.find(this.dataPoints, function(dp) {
                                    return (null == dp ? void 0 : dp.location) && (null == dp ? void 0 : dp.subDataPoints.length) > 0 && dp.subDataPoints[0].identity.getKey() === featureIdentityKey;
                                }), this.shouldUseLegacyFormat && _azureMapExpressionHelper__WEBPACK_IMPORTED_MODULE_9__.J.LEGACY_appendPieRadiusToDataPoints([ dataPoint ], this.data), 
                                !dataPoint) return [ 3, 2 ];
                                for (index = 0; index < dataPoint.subDataPoints.length; index++) this.hasSelection ? dataPoint.subDataPoints[index].selected && selectedIndexes.push(index) : selectedIndexes.push(index);
                                return hash = _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_10__.t.hash(dataPoint, this.data.properties.bubble, selectedIndexes), 
                                [ 4, this.pieChartFactory.loadIcon(dataPoint, this.data.properties.bubble, selectedIndexes, hash) ];

                              case 1:
                                _a.sent(), selectedIndexes.length > 0 && expressionOptionArray.push({
                                    dataPoint,
                                    hash,
                                    markerShapeId: featureId,
                                    selectedIndexes
                                }), _a.label = 2;

                              case 2:
                                return [ 2 ];
                            }
                        });
                    });
                }, this.composeAndUpdatePieExpression = function(expressionOptionArray) {
                    for (var opacityFilterMarkerIds = [ "literal", [] ], iconImageCaseExpressions = [], _i = 0, expressionOptionArray_2 = expressionOptionArray; _i < expressionOptionArray_2.length; _i++) {
                        var options = expressionOptionArray_2[_i], dataPoint = options.dataPoint, hash = options.hash, markerShapeId = options.markerShapeId, selectedIndexes = options.selectedIndexes;
                        opacityFilterMarkerIds[1].push(markerShapeId), dataPoint.subDataPoints.length !== selectedIndexes.length && iconImageCaseExpressions.push([ "==", [ "get", "_azureMapsShapeId" ], markerShapeId ], "".concat(hash));
                    }
                    var iconImageExpression = iconImageCaseExpressions.length > 0 ? (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                    tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([ "case" ], iconImageCaseExpressions, !0), [ [ "get", "iconId" ] ], !1) : [ "get", "iconId" ], opacityExpression = [ "case", [ "in", [ "get", "_azureMapsShapeId" ], opacityFilterMarkerIds ], (0, 
                    _VisualsCommon_color__WEBPACK_IMPORTED_MODULE_11__.TD)(_this.data.properties.bubble.transparency), (0, 
                    _VisualsCommon_color__WEBPACK_IMPORTED_MODULE_11__.TD)(_this.data.properties.commonDataOptions.unselectedTransparency) ];
                    _this.pieChartSymbolLayer.setOptions({
                        iconOptions: {
                            image: iconImageExpression,
                            opacity: opacityExpression
                        }
                    });
                };
            }
            return Object.defineProperty(AzureMapBehavior.prototype, "bubbleDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.oy);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "heatMapDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.Ol);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "filledMapDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.HC);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "barChart3DDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.zD);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "referenceDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.uL);
                },
                enumerable: !1,
                configurable: !0
            }), AzureMapBehavior.prototype.bindEvents = function(options, selectionHandler, _dataPointNavigationManagerWithKey) {
                this.mapControl = options.mapControl, this.selectableDataPoints = options.selectableDataPoints, 
                this.selectionHandler = selectionHandler, this.data = options.data, this.dataPoints = options.dataPoints, 
                this.hostServices = options.hostServices;
            }, AzureMapBehavior.prototype.setFormatMode = function(isFormatMode) {
                this.formatMode = isFormatMode;
            }, AzureMapBehavior.prototype.setSubSelectionHelper = function(subSelectionHelper) {
                this.subSelectionHelper = subSelectionHelper;
            }, AzureMapBehavior.prototype.renderSelection = function(hasSelection) {
                this.hasSelection = hasSelection, this.updateDataSourceWithSelection();
            }, AzureMapBehavior.prototype.setPieChartBehavior = function(showPieChart, pieChartFactory, pieChartSymbolLayer, shouldUseLegacyFormat) {
                void 0 === shouldUseLegacyFormat && (shouldUseLegacyFormat = !0), this.showPieChart = showPieChart, 
                this.pieChartFactory = pieChartFactory, this.pieChartSymbolLayer = pieChartSymbolLayer, 
                this.shouldUseLegacyFormat = shouldUseLegacyFormat;
            }, AzureMapBehavior.prototype.findSubDataPointByMouseEvent = function(mouseEvent) {
                if (mouseEvent) {
                    var clusterFeature = _.find(mouseEvent.shapes, isClusterFeature);
                    if (clusterFeature) return this.findSubDataPointByClusterFeature(clusterFeature);
                    var shape = _.find(mouseEvent.shapes, isShape);
                    return shape ? this.findSubDataPointByShape(shape) : void 0;
                }
            }, AzureMapBehavior.prototype.findSubDataPointByShape = function(shape) {
                for (var key = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.getFirstIdentityKey(shape), subDataPoint = void 0, _i = 0, _a = this.data.dataPoints; _i < _a.length && !(subDataPoint = _a[_i].subDataPoints.find(function(p) {
                    return p.identity.getKey() === key;
                })); _i++) ;
                return subDataPoint;
            }, AzureMapBehavior.prototype.findSubDataPointByClusterFeature = function(clusterFeature) {
                var clusterProp = clusterFeature.properties, clusterTooltip = {
                    header: this.hostServices.getLocalizedString("Visual_AzureMapsCluster_TooltipInfo", clusterProp.point_count),
                    displayName: ""
                };
                return {
                    size: clusterProp.size,
                    color: "",
                    selected: !1,
                    identity: null,
                    tooltipInfo: [ clusterTooltip ]
                };
            }, AzureMapBehavior;
        }();
    },
    70508: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Bc: function() {
                return minStrokeWidth;
            },
            C_: function() {
                return filledMapFillLayerId;
            },
            Co: function() {
                return maxTileSize;
            },
            Dy: function() {
                return defaultLabelBackgroundColorName;
            },
            Dz: function() {
                return maxHeatMapIntensity;
            },
            Fw: function() {
                return minBubbleRadius;
            },
            HC: function() {
                return filledMapDataSourceId;
            },
            I9: function() {
                return maxLogScale;
            },
            Ix: function() {
                return maxHeading;
            },
            JX: function() {
                return minLayerZoom;
            },
            Jp: function() {
                return clusterBubbleLayerId;
            },
            NI: function() {
                return maxHeatMapRadiusMeters;
            },
            NR: function() {
                return maxBezier;
            },
            Ng: function() {
                return minZoomScale;
            },
            Nq: function() {
                return minLongitude;
            },
            OH: function() {
                return maxHeatMapRadiusPixels;
            },
            Ol: function() {
                return heatMapDataSourceId;
            },
            Qv: function() {
                return maxStrokeWidth;
            },
            TJ: function() {
                return unselectedBarChart3DLayerId;
            },
            U1: function() {
                return minLatitude;
            },
            W5: function() {
                return maxBarThickness;
            },
            W8: function() {
                return accessibleIndicatorEnforcedStyles;
            },
            WL: function() {
                return minPitch;
            },
            Wv: function() {
                return barChart3DLayerId;
            },
            Y4: function() {
                return maxSafeNumber;
            },
            Yd: function() {
                return maxLayerZoom;
            },
            Yi: function() {
                return maxLongitude;
            },
            Yl: function() {
                return minHeading;
            },
            Z$: function() {
                return barChartDefaultPitch;
            },
            Z3: function() {
                return minBarHeight;
            },
            _0: function() {
                return minHeatMapRadius;
            },
            _O: function() {
                return defaultLabelBackgroundTransparency;
            },
            _u: function() {
                return clusterSymbolLayerId;
            },
            a_: function() {
                return maxPitch;
            },
            c8: function() {
                return defaultHeatMapUnit;
            },
            fI: function() {
                return maxZoomScale;
            },
            fN: function() {
                return percentMin;
            },
            fQ: function() {
                return percentMax;
            },
            hW: function() {
                return maxLatitude;
            },
            nB: function() {
                return minBezier;
            },
            nv: function() {
                return minTileSize;
            },
            oy: function() {
                return bubbleDataSourceId;
            },
            p5: function() {
                return heatMapLayerId;
            },
            pi: function() {
                return minLogScale;
            },
            rn: function() {
                return maxBubbleRadius;
            },
            t: function() {
                return maxBarHeight;
            },
            uL: function() {
                return referenceDataSourceId;
            },
            x6: function() {
                return minHeatMapIntensity;
            },
            yl: function() {
                return bubbleLayerId;
            },
            z$: function() {
                return minBarThickness;
            },
            z8: function() {
                return filledMapOutlineLayerId;
            },
            zD: function() {
                return barChart3DDataSourceId;
            }
        });
        var minPitch = 0, maxPitch = 60, minHeading = 0, maxHeading = 360, minLayerZoom = 0, maxLayerZoom = 22, maxZoomScale = 10, minZoomScale = 1, minBubbleRadius = 1, maxBubbleRadius = 50, minLogScale = 1, maxLogScale = 10, minStrokeWidth = 0, maxStrokeWidth = 20, minBezier = 0, maxBezier = 1, barChartDefaultPitch = 60, defaultLabelBackgroundColorName = "backgroundDark", defaultLabelBackgroundTransparency = .5, minBarHeight = 0, maxBarHeight = 5, minBarThickness = 0, maxBarThickness = 5, defaultHeatMapUnit = "pixels", minHeatMapRadius = 1, maxHeatMapRadiusPixels = 200, maxHeatMapRadiusMeters = 4e6, minHeatMapIntensity = 0, maxHeatMapIntensity = 5, maxTileSize = 5e3, minTileSize = 128, percentMax = 100, percentMin = 0, minLongitude = -180, maxLongitude = 180, minLatitude = -90, maxLatitude = 90, maxSafeNumber = Math.pow(2, 53) - 1, bubbleDataSourceId = "bubbleDataSource", heatMapDataSourceId = "heatMapDataSource", filledMapDataSourceId = "filledMapDataSource", barChart3DDataSourceId = "barChart3DDataSource", referenceDataSourceId = "referenceDataSource", bubbleLayerId = "bubbleLayer", heatMapLayerId = "heatMapLayer", barChart3DLayerId = "barChart3DLayer", unselectedBarChart3DLayerId = "unselectedBarChart3DLayer", filledMapFillLayerId = "filledMapFillLayer", filledMapOutlineLayerId = "filledMapOutlineLayer", clusterBubbleLayerId = "clusterBubbleLayer", clusterSymbolLayerId = "clusterSymbolLayer", accessibleIndicatorEnforcedStyles = {
            bubbleStrokeOpacity: 1,
            bubbleStrokeWidth: 2
        };
    },
    72118: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            J: function() {
                return AzureMapExpressionHelper;
            }
        });
        var tslib_es6 = __webpack_require__(81337), color = __webpack_require__(64067), CubicBezierScaler = function() {
            function CubicBezierScaler(x1, y1, x2, y2) {
                this.epsilon = 1e-5, this.cx1 = 0, this.cx2 = 0, this.cx3 = 0, this.cy1 = 0, this.cy2 = 0, 
                this.cy3 = 0, this.computeCoefficient(x1, y1, x2, y2);
            }
            return CubicBezierScaler.prototype.computeCoefficient = function(x1, y1, x2, y2) {
                this.cx3 = 1 + 3 * x1 - 3 * x2, this.cx2 = 3 * x2 - 6 * x1, this.cx1 = 3 * x1, this.cy3 = 1 + 3 * y1 - 3 * y2, 
                this.cy2 = 3 * y2 - 6 * y1, this.cy1 = 3 * y1;
            }, CubicBezierScaler.prototype.getXByT = function(t) {
                return this.cx3 * Math.pow(t, 3) + this.cx2 * Math.pow(t, 2) + this.cx1 * t;
            }, CubicBezierScaler.prototype.getYByT = function(t) {
                return this.cy3 * Math.pow(t, 3) + this.cy2 * Math.pow(t, 2) + this.cy1 * t;
            }, CubicBezierScaler.prototype.estimateTByX = function(x, precision) {
                void 0 === precision && (precision = .01);
                for (var low = 0, high = 1, t = x; low < high; ) {
                    var estimatedX = this.getXByT(t);
                    if (Math.abs(x - estimatedX) <= precision) return t;
                    estimatedX < x ? low = t : high = t, t = .5 * (low + high);
                }
                return x;
            }, CubicBezierScaler.prototype.scale = function(x) {
                if (x < this.epsilon) return 0;
                if (1 - x < this.epsilon) return 1;
                var t = this.estimateTByX(x);
                return this.getYByT(t);
            }, CubicBezierScaler;
        }(), colorUtility = __webpack_require__(1521), azureMapConstant = __webpack_require__(70508), FilterProperty = function(FilterProperty) {
            return FilterProperty.bubble = "showBubble", FilterProperty.pie = "showPie", FilterProperty.barChart3D = "showBarChart3D", 
            FilterProperty.filledMap = "showFilledMap", FilterProperty.heatMap = "showHeatMap", 
            FilterProperty;
        }({}), pixelsPerMeterZoom24 = 12776044915782906e-21 * Math.pow(2, 24), AzureMapExpressionHelper = function() {
            function AzureMapExpressionHelper() {}
            var _a;
            return AzureMapExpressionHelper.getBubbleDisplayOptions = function(properties, commonProperties, useLegacyFormat, hasSize, minValue, maxValue) {
                var radiusExpression = useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getRadiusExpression(properties, commonProperties, hasSize, minValue, maxValue) : AzureMapExpressionHelper.getRadiusExpression(properties.radius, hasSize, minValue, maxValue), colorExpression = [ "get", "color" ], strokeColorExpression = AzureMapExpressionHelper.getStrokeColor(properties.autoStrokeColor, properties.strokeColor, colorExpression), opacityFilter = [ "case", AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.transparency), (0, color.TD)(commonProperties.unselectedTransparency) ], strokeWidthExpression = properties.strokeWidth < azureMapConstant.W8.bubbleStrokeWidth ? [ "case", [ "boolean", [ "feature-state", "focused" ], !1 ], azureMapConstant.W8.bubbleStrokeWidth, properties.strokeWidth ] : properties.strokeWidth, strokeOpacityExpression = [ "case", [ "boolean", [ "feature-state", "focused" ], !1 ], azureMapConstant.W8.bubbleStrokeOpacity, AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.strokeTransparency), (0, color.TD)(commonProperties.unselectedTransparency) ], filter = useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getBubbleFilter(!0, hasSize ? commonProperties : void 0) : AzureMapExpressionHelper.bubbleLayerFilter;
                return {
                    bubbleOptions: {
                        radius: radiusExpression,
                        strokeColor: strokeColorExpression,
                        strokeWidth: strokeWidthExpression,
                        strokeOpacity: strokeOpacityExpression,
                        blur: properties.blur / 100,
                        pitchAlignment: properties.pitchAlignment,
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        color: colorExpression,
                        filter,
                        opacity: opacityFilter,
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getBubbleClusterDisplayOptions = function(bubbleOptions, properties) {
                var strokeWidthExpression = properties.clusteredBubbleStrokeWidth < azureMapConstant.W8.bubbleStrokeWidth ? [ "case", [ "boolean", [ "feature-state", "focused" ], !1 ], azureMapConstant.W8.bubbleStrokeWidth, properties.clusteredBubbleStrokeWidth ] : properties.clusteredBubbleStrokeWidth;
                return {
                    clusterBubbleOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, bubbleOptions), {
                        radius: properties.clusteredBubbleRadius,
                        color: properties.clusteredBubbleFillColor,
                        strokeColor: properties.clusteredBubbleStrokeColor,
                        strokeWidth: strokeWidthExpression,
                        filter: AzureMapExpressionHelper.clusteredDataFilter
                    }),
                    clusterSymbolOptions: {
                        visible: !0,
                        textOptions: {
                            color: properties.clusteredBubbleFontColor,
                            size: properties.clusteredBubbleFontSize
                        }
                    }
                };
            }, AzureMapExpressionHelper.getPieChartDisplayOptions = function(properties) {
                return {
                    pieChartOptions: {
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        iconOptions: {
                            pitchAlignment: "viewport",
                            anchor: "center"
                        },
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getHeatMapDisplayOptions = function(properties, hasSize) {
                var colorExpression = [ "interpolate", [ "linear" ], [ "heatmap-density" ], 0, (0, 
                colorUtility.cD)(properties.heatMapColorLow, 0), .1, properties.heatMapColorLow, .5, properties.heatMapColorCenter, 1, properties.heatMapColorHigh ], radiusExpression = "pixels" === properties.heatMapRadiusUnit ? properties.heatMapRadius : [ "interpolate", [ "exponential", 2 ], [ "zoom" ], 0, [ "*", properties.heatMapRadius, 12776044915782906e-21 ], 24, [ "*", properties.heatMapRadius, pixelsPerMeterZoom24 ] ], weightExpression = hasSize && properties.heatMapUseSize ? [ "get", "size" ] : 1;
                return {
                    heatMapOptions: {
                        color: colorExpression,
                        intensity: properties.heatMapIntensity,
                        opacity: (0, color.TD)(properties.heatMapTransparency),
                        radius: radiusExpression,
                        weight: weightExpression,
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getBarChartDisplayOptions = function(paintProperties, commonProperties, maxHeight, useLegacyFormat, hasSize) {
                var relativeScale = paintProperties.height / maxHeight, heightGetter = [ "get", "size" ], heightExp = [ "*", heightGetter, 100 * relativeScale ];
                paintProperties.scaleHeightOnZoom && (heightExp = [ "interpolate", [ "exponential", .5 ], [ "zoom" ], 0, [ "*", heightGetter, 2e6 * relativeScale ], 22, [ "*", heightGetter, 20 * relativeScale ] ]);
                var baseOptions = {
                    minZoom: paintProperties.minZoom,
                    maxZoom: paintProperties.maxZoom,
                    fillColor: [ "get", "color" ],
                    visible: !0
                };
                return {
                    selectedOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, baseOptions), {
                        height: heightExp,
                        fillOpacity: (0, color.TD)(paintProperties.transparency),
                        filter: useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getBarChart3DFilter(!0, hasSize ? commonProperties : void 0) : AzureMapExpressionHelper.getSelectionFilter(!0)
                    }),
                    unselectedOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, baseOptions), {
                        height: 0,
                        fillOpacity: (0, color.TD)(commonProperties.unselectedTransparency),
                        filter: useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getBarChart3DFilter(!1, hasSize ? commonProperties : void 0) : AzureMapExpressionHelper.getSelectionFilter(!1)
                    })
                };
            }, AzureMapExpressionHelper.getFilledMapDisplayOptions = function(properties, commonProperties, useLegacyFormat, hasSize) {
                var fillOpacityFilter = [ "case", AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.transparency), (0, color.TD)(commonProperties.unselectedTransparency) ], strokeOpacityFilter = [ "case", AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.strokeTransparency), (0, color.TD)(commonProperties.unselectedTransparency) ], filledMapFilter = useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getFilledMapFilter(!0, hasSize ? commonProperties : void 0) : void 0;
                return {
                    polygonOptions: {
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        fillColor: [ "get", "color" ],
                        fillOpacity: fillOpacityFilter,
                        filter: filledMapFilter,
                        visible: !0
                    },
                    lineOptions: {
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        strokeColor: properties.strokeColor,
                        strokeOpacity: strokeOpacityFilter,
                        strokeWidth: properties.strokeWidth,
                        filter: filledMapFilter,
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getSelectionFilter = function(selectionLayer) {
                return selectionLayer ? [ "get", "selected" ] : [ "!", [ "get", "selected" ] ];
            }, AzureMapExpressionHelper.LEGACY_getBubbleFilter = function(selectionLayer, dataOptions) {
                var filter = this.LEGACY_getLayerFilter(selectionLayer, dataOptions) || [ "all" ];
                return filter.push([ "==", [ "get", "showBubble" ], !0 ]), filter.push([ "!", this.clusteredDataFilter ]), 
                filter;
            }, AzureMapExpressionHelper.LEGACY_getBarChart3DFilter = function(selectionLayer, dataOptions) {
                return this.LEGACY_getLayerFilter(selectionLayer, dataOptions, !0);
            }, AzureMapExpressionHelper.LEGACY_getFilledMapFilter = function(selectionLayer, dataOptions) {
                return this.LEGACY_getLayerFilter(selectionLayer, dataOptions);
            }, AzureMapExpressionHelper.LEGACY_getLayerFilter = function(selectionLayer, dataOptions, addSelectionFilter) {
                void 0 === addSelectionFilter && (addSelectionFilter = !1);
                var filterCollections = [];
                if (addSelectionFilter && filterCollections.push(this.getSelectionFilter(selectionLayer)), 
                _.isEmpty(dataOptions) || (dataOptions.showZeros || filterCollections.push([ "!=", [ "get", "size" ], 0 ]), 
                dataOptions.showNegatives || filterCollections.push([ "!", [ "<", [ "get", "size" ], 0 ] ])), 
                0 !== filterCollections.length) return 1 === filterCollections.length ? filterCollections[0] : (0, 
                tslib_es6.__spreadArray)([ "all" ], filterCollections, !0);
            }, AzureMapExpressionHelper.getRadiusExpression = function(defaultRadius, hasSize, minDataValue, maxDataValue) {
                return hasSize && minDataValue !== maxDataValue ? [ "get", "size" ] : defaultRadius;
            }, AzureMapExpressionHelper.LEGACY_getRadiusExpression = function(bubbleLayerProperties, commonDataOptions, hasSize, minDataValue, maxDataValue) {
                var radiusExp, radius = hasSize ? bubbleLayerProperties.minRadius : bubbleLayerProperties.radius, scaleFactor = bubbleLayerProperties.zoomScaleFactor;
                if (hasSize) {
                    var radiusScaleMethod = bubbleLayerProperties.radiusScalingMethod, interpolation = [ "linear" ];
                    if (1 === radiusScaleMethod ? interpolation = [ "exponential", bubbleLayerProperties.logScale ] : 2 === radiusScaleMethod && (interpolation = [ "cubic-bezier", bubbleLayerProperties.x1, bubbleLayerProperties.y1, bubbleLayerProperties.x2, bubbleLayerProperties.y2 ]), 
                    minDataValue === maxDataValue) radiusExp = [ "interpolate", interpolation, [ "zoom" ], 12, radius, 20, radius * scaleFactor ]; else {
                        var sizeGetter = [ "get", "size" ];
                        commonDataOptions.showNegatives && (sizeGetter = [ "abs", sizeGetter ]), radiusExp = [ "interpolate", interpolation, sizeGetter, minDataValue, radius, maxDataValue, bubbleLayerProperties.maxRadius ], 
                        1 !== scaleFactor && (radiusExp = [ "let", "radiusSize", radiusExp, [ "interpolate", [ "linear" ], [ "zoom" ], 12, [ "var", "radiusSize" ], 20, [ "*", scaleFactor, [ "var", "radiusSize" ] ] ] ]);
                    }
                } else radiusExp = 1 !== scaleFactor ? [ "interpolate", [ "linear" ], [ "zoom" ], 12, radius, 20, radius * scaleFactor ] : radius;
                return radiusExp;
            }, AzureMapExpressionHelper.LEGACY_evaluateRadiusExpression = function(radiusExp, cameraZoom, datapointValue) {
                if ("number" == typeof radiusExp) return radiusExp;
                if (Array.isArray(radiusExp)) if ("interpolate" === radiusExp[0]) {
                    var scalingMethod = radiusExp[1], minValue = radiusExp[3], minRadius = radiusExp[4], maxValue = radiusExp[5], maxRadius = radiusExp[6], shouldTakeZoomAsInput = _.isEqual(radiusExp[2], [ "zoom" ]);
                    shouldTakeZoomAsInput && (!_.isFinite(cameraZoom) || cameraZoom < 0) && (cameraZoom = 1);
                    var ratio = (_.clamp(shouldTakeZoomAsInput ? cameraZoom : datapointValue, minValue, maxValue) - minValue) / (maxValue - minValue);
                    if ("linear" === scalingMethod[0]) return ratio * (maxRadius - minRadius) + minRadius;
                    if ("exponential" === scalingMethod[0]) {
                        var base = scalingMethod[1];
                        return (1 === base ? ratio : (Math.pow(base, ratio) - 1) / (base - 1)) * (maxRadius - minRadius) + minRadius;
                    }
                    if ("cubic-bezier" === scalingMethod[0]) return new CubicBezierScaler(scalingMethod[1], scalingMethod[2], scalingMethod[3], scalingMethod[4]).scale(ratio) * (maxRadius - minRadius) + minRadius;
                } else if ("let" === radiusExp[0] && "radiusSize" === radiusExp[1]) {
                    var radius = this.LEGACY_evaluateRadiusExpression(radiusExp[2], cameraZoom, datapointValue), interpolationExp = _.cloneDeep(radiusExp[3]);
                    return interpolationExp[4] = radius, interpolationExp[6] = radius * interpolationExp[6][1], 
                    this.LEGACY_evaluateRadiusExpression(interpolationExp, cameraZoom, datapointValue);
                }
                return 0;
            }, AzureMapExpressionHelper.LEGACY_appendPieRadiusToDataPoints = function(dataPoints, azureMapData) {
                var radiusExpression = AzureMapExpressionHelper.LEGACY_getRadiusExpression(azureMapData.properties.bubble, azureMapData.properties.commonDataOptions, azureMapData.hasSize, azureMapData.minDataValue, azureMapData.maxDataValue);
                dataPoints.forEach(function(dataPoint) {
                    var size = dataPoint.subDataPoints.reduce(function(total, subDataPoint) {
                        return total + subDataPoint.size;
                    }, 0), radiusInPixel = AzureMapExpressionHelper.LEGACY_evaluateRadiusExpression(radiusExpression, void 0, size);
                    dataPoint.bubbleRadius = radiusInPixel;
                });
            }, _a = AzureMapExpressionHelper, AzureMapExpressionHelper.getStrokeColor = function(autoStrokeColor, strokeColor, colorExpression) {
                var color = strokeColor;
                if (autoStrokeColor) {
                    var fillColorFilter = [ "var", "fillColor" ];
                    color = [ "let", "fillColor", [ "to-rgba", [ "to-color", colorExpression ] ], [ "case", [ ">", [ "sqrt", [ "+", [ "*", .299, [ "^", [ "at", 0, fillColorFilter ], 2 ] ], [ "*", .587, [ "^", [ "at", 1, fillColorFilter ], 2 ] ], [ "*", .114, [ "^", [ "at", 2, fillColorFilter ], 2 ] ] ] ], 127 ], [ "to-color", [ "rgb", [ "*", .5, [ "at", 0, fillColorFilter ] ], [ "*", .5, [ "at", 1, fillColorFilter ] ], [ "*", .5, [ "at", 2, fillColorFilter ] ] ] ], [ "to-color", [ "rgb", [ "max", 127, [ "min", 255, [ "*", 1.5, [ "at", 0, fillColorFilter ] ] ] ], [ "max", 127, [ "min", 255, [ "*", 1.5, [ "at", 1, fillColorFilter ] ] ] ], [ "max", 127, [ "min", 255, [ "*", 1.5, [ "at", 2, fillColorFilter ] ] ] ] ] ] ] ];
                }
                return color;
            }, AzureMapExpressionHelper.clusteredDataFilter = [ "has", "point_count" ], AzureMapExpressionHelper.bubbleLayerFilter = [ "all", [ "==", [ "get", FilterProperty.bubble ], !0 ], [ "!", _a.clusteredDataFilter ] ], 
            AzureMapExpressionHelper.pieLayerFilter = [ "all", [ "==", [ "get", FilterProperty.pie ], !0 ], [ "!", _a.clusteredDataFilter ] ], 
            AzureMapExpressionHelper;
        }();
    },
    81293: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            l: function() {
                return AzureMapFeatureHelper;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _MapMath_mapMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2379), _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49988), Degree = .0174532925, AzureMapFeatureHelper = function() {
            function AzureMapFeatureHelper() {}
            return AzureMapFeatureHelper.getPointFeatures = function(dataPoints, visualHasSelection, enableBubbleLayer, enablePieChartLayer, options, shouldUseLegacyFormat) {
                var _this = this, enableBothBubblePie = enableBubbleLayer && enablePieChartLayer;
                return dataPoints.filter(function(d) {
                    return d.location && d.subDataPoints && d.subDataPoints.length > 0;
                }).map(function(d) {
                    return new atlas.data.Feature(new atlas.data.Point(new atlas.data.Position(d.location.longitude, d.location.latitude)), (0, 
                    tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
                        coordinates: [ d.location.longitude, d.location.latitude ],
                        size: shouldUseLegacyFormat ? d.subDataPoints[0].size || 0 : d.bubbleRadius || 0,
                        color: d.subDataPoints[0].color,
                        identityKeys: d.subDataPoints.map(function(sp) {
                            return sp.identity.getKey();
                        }),
                        selected: !visualHasSelection || d.subDataPoints[0].selected
                    }, (enableBubbleLayer || enablePieChartLayer) && {
                        showBubble: _this.bubbleVisibility(d, enableBothBubblePie, enableBubbleLayer),
                        showPie: _this.pieVisibility(d, enableBothBubblePie, enablePieChartLayer)
                    }), {
                        iconId: enablePieChartLayer ? _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_1__.t.hash(d, options) : void 0,
                        seriesIndex: d.subDataPoints[0].seriesIndex
                    }));
                });
            }, AzureMapFeatureHelper.bubbleVisibility = function(dataPoint, enableBothBubblePie, enableBubbleLayer) {
                return !(enableBothBubblePie || !enableBubbleLayer) || !(!enableBothBubblePie || 1 !== dataPoint.subDataPoints.length);
            }, AzureMapFeatureHelper.pieVisibility = function(dataPoint, enableBothBubblePie, enablePieChartLayer) {
                return !(enableBothBubblePie || !enablePieChartLayer) || !!(enableBothBubblePie && dataPoint.subDataPoints.length > 1);
            }, AzureMapFeatureHelper.getReferenceLayerFeature = function(matcher, visualHasSelection) {
                if (!matcher) return [];
                var features = matcher.getShapes(), output = [];
                return features.forEach(function(feature) {
                    var dp = matcher.getDataPointFromShape(feature);
                    output.push(dp ? new atlas.data.Feature(feature.geometry, (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
                        coordinates: dp.location ? [ dp.location.longitude, dp.location.latitude ] : [],
                        identityKeys: dp.subDataPoints.map(function(sp) {
                            var _a;
                            return null === (_a = sp.identity) || void 0 === _a ? void 0 : _a.getKey();
                        }),
                        selected: !visualHasSelection || dp.subDataPoints[0].selected
                    }, feature.properties)) : new atlas.data.Feature(feature.geometry, (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
                        identityKeys: []
                    }, feature.properties)));
                }), output;
            }, AzureMapFeatureHelper.getPolygonFeature = function(centers, scale, barShape, visualHasSelection) {
                var _this = this;
                return centers.filter(function(center) {
                    return center.location;
                }).map(function(center) {
                    return new atlas.data.Feature(1 === barShape ? _this.getCirclePolygon(center, scale) : _this.getSquarePolygon(center, scale), {
                        coordinates: [ center.location.longitude, center.location.latitude ],
                        size: center.subDataPoints[0].size || 0,
                        color: center.subDataPoints[0].color,
                        identityKeys: center.subDataPoints.map(function(sp) {
                            return sp.identity.getKey();
                        }),
                        selected: !visualHasSelection || center.subDataPoints[0].selected
                    });
                });
            }, AzureMapFeatureHelper.getFilledMapMultiPolygonFeature = function(dataPoints, visualHasSelection) {
                return dataPoints.filter(function(d) {
                    return d.geojsonPolygons;
                }).map(function(d) {
                    return new atlas.data.Feature(new atlas.data.MultiPolygon(_MapMath_mapMath__WEBPACK_IMPORTED_MODULE_2__.b.combineMultiPolygonCoordinatesAtAntimeridian(d.location, d.geojsonPolygons.map(function(p) {
                        return p.coordinates;
                    }))), {
                        coordinates: [ d.location.longitude, d.location.latitude ],
                        size: d.subDataPoints[0].size || 0,
                        color: d.subDataPoints[0].color,
                        identityKeys: d.subDataPoints.map(function(sp) {
                            return sp.identity.getKey();
                        }),
                        selected: !visualHasSelection || d.subDataPoints[0].selected
                    });
                });
            }, AzureMapFeatureHelper.getCirclePolygon = function(center, scale) {
                for (var radius = 1e-4 * scale, latitudeScale = Math.cos(center.location.latitude * Degree), coordinates = [], i = 0; i < 18; i++) coordinates.push([ center.location.longitude + radius * Math.cos(20 * i * Degree), center.location.latitude + radius * latitudeScale * Math.sin(20 * i * Degree) ]);
                return coordinates.push([ center.location.longitude + radius, center.location.latitude ]), 
                new atlas.data.Polygon([ coordinates ]);
            }, AzureMapFeatureHelper.getSquarePolygon = function(center, scale) {
                var xOffset = 1e-4 * scale, yOffset = xOffset * Math.cos(center.location.latitude * Degree);
                return new atlas.data.Polygon([ [ [ center.location.longitude + xOffset, center.location.latitude + yOffset ], [ center.location.longitude - xOffset, center.location.latitude + yOffset ], [ center.location.longitude - xOffset, center.location.latitude - yOffset ], [ center.location.longitude + xOffset, center.location.latitude - yOffset ], [ center.location.longitude + xOffset, center.location.latitude + yOffset ] ] ]);
            }, AzureMapFeatureHelper.getIdentityKeys = function(shape) {
                return shape.getProperties().identityKeys;
            }, AzureMapFeatureHelper.getFirstIdentityKey = function(shape) {
                return this.getIdentityKeys(shape)[0];
            }, AzureMapFeatureHelper.findFirstDataPointByKey = function(selectableDataPoints, key) {
                return selectableDataPoints.find(function(dataPoint) {
                    return key === dataPoint.identity.getKey();
                });
            }, AzureMapFeatureHelper.findDataPointsByKeys = function(selectableDataPoint, keys) {
                var pointsToBeSelected = [];
                if (keys.length === selectableDataPoint.length) return selectableDataPoint;
                for (var _i = 0, selectableDataPoint_1 = selectableDataPoint; _i < selectableDataPoint_1.length; _i++) {
                    var dataPoint = selectableDataPoint_1[_i], key = dataPoint.identity.getKey();
                    if (keys.indexOf(key) >= 0 && (pointsToBeSelected.push(dataPoint), pointsToBeSelected.length === keys.length)) break;
                }
                return pointsToBeSelected;
            }, AzureMapFeatureHelper.findDataPointsByShapes = function(selectableDataPoint, shapes) {
                for (var featureKeys = [], _i = 0, shapes_1 = shapes; _i < shapes_1.length; _i++) featureKeys.push.apply(featureKeys, this.getIdentityKeys(shapes_1[_i]));
                return this.findDataPointsByKeys(selectableDataPoint, featureKeys);
            }, AzureMapFeatureHelper;
        }();
    },
    19076: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            E: function() {
                return AzureMapOnObjectUtil;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81337), _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60637), _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32379), _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96915), _azureMapConstant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70508), selectorsByColumnForAllBubbles = {
            dataMap: {
                allData: [ (0, _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_0__.Ue)(1) ]
            }
        }, AzureMapOnObjectUtil = function() {
            function AzureMapOnObjectUtil() {}
            return AzureMapOnObjectUtil.getSubSelectableRegionFromLayerId = function(layerId) {
                return layerId === _azureMapConstant__WEBPACK_IMPORTED_MODULE_1__.yl ? "bubbles" : "map";
            }, AzureMapOnObjectUtil.createAzureMapSubSelection = function(selectableObject, showUI, hostServices, selectionOrigin, series) {
                var displayName = "", selectorsByColumn = {};
                return "bubbles" === selectableObject.split("-")[0] && (series ? (displayName = hostServices.getLocalizedString("MiniToolbar_Bubbles", series.value), 
                selectorsByColumn = series.identity.getSelectorsByColumn()) : (displayName = hostServices.getLocalizedString("Visual_Bubbles"), 
                selectorsByColumn = selectorsByColumnForAllBubbles)), {
                    visualObjects: [ {
                        objectName: selectableObject,
                        selectorsByColumn
                    } ],
                    showUI,
                    displayName,
                    subSelectionType: 3,
                    selectionOrigin
                };
            }, AzureMapOnObjectUtil.getAllSubSelectables = function(data, hostServices, subSelectionHelper, filterType) {
                var subSelectables = subSelectionHelper.getAllSubSelectables(filterType);
                return (null == data ? void 0 : data.properties.bubble) && data.properties.bubble.showBubbleLayer && data.hasSeries && !_.isEmpty(data.series) && subSelectables.push.apply(subSelectables, data.series.map(function(series, seriesIndex) {
                    return AzureMapOnObjectUtil.createAzureMapSubSelection("".concat("bubbles", "-series-").concat(seriesIndex), !1, hostServices, void 0, series);
                })), subSelectables;
            }, AzureMapOnObjectUtil.getNextSubSelectable = function(data, hostServices, subSelectionHelper, currentSubSelectable, backwards) {
                var subselectableObjects = AzureMapOnObjectUtil.getAllSubSelectables(data, hostServices, subSelectionHelper);
                if (subselectableObjects.length) {
                    var nextSubSelectable;
                    if (!currentSubSelectable) return backwards ? _.last(subselectableObjects) : _.first(subselectableObjects);
                    var index = _.findIndex(subselectableObjects, function(subSelectable) {
                        return _.isEqual(currentSubSelectable, subSelectable);
                    });
                    if (index > -1) {
                        var nextIndex = backwards ? index - 1 : index + 1;
                        nextIndex > -1 && nextIndex < subselectableObjects.length && (nextSubSelectable = subselectableObjects[nextIndex]);
                    }
                    return nextSubSelectable;
                }
            }, AzureMapOnObjectUtil.getBubblesSubSelectionStyles = function(hostServices, selectorsByColumn) {
                return void 0 === selectorsByColumn && (selectorsByColumn = {}), {
                    type: 3,
                    fill: {
                        reference: (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.dataPoint.fill), {
                            selector: (0, _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_4__.fd)((0, 
                            _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_4__.tV)(selectorsByColumn))
                        }),
                        label: hostServices.getLocalizedString("Visual_Fill")
                    },
                    stroke: {
                        reference: _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.strokeColor,
                        label: hostServices.getLocalizedString("Visual_Border")
                    }
                };
            }, AzureMapOnObjectUtil.getBubblesSubSelectionShortcuts = function(hostServices) {
                return [ {
                    type: 0,
                    relatedResetFormattingIds: [ _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.dataPoint.fill, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.strokeColor, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.layerPosition ]
                }, (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({
                    type: 3
                }, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.layerPosition), {
                    label: hostServices.getLocalizedString("Visual_AzureMapsLayerPosition")
                }), {
                    type: 1,
                    destinationInfo: {
                        cardUid: "".concat("Visual", "-").concat(_azureMapConstant__WEBPACK_IMPORTED_MODULE_1__.yl),
                        groupUid: "".concat(_azureMapConstant__WEBPACK_IMPORTED_MODULE_1__.yl, "-size")
                    },
                    label: hostServices.getLocalizedString("Format_Bubbles")
                } ];
            }, AzureMapOnObjectUtil;
        }();
    }
} ]);