"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "gauge", "animatedNumber" ], {
    58914: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            AnimatedNumber: function() {
                return AnimatedNumber;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _Visuals_animators_animatorCommon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(94478), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62458), AnimatedNumber = function(_super) {
            function AnimatedNumber(svg, animator) {
                var _this = _super.call(this, "animatedNumber") || this;
                return svg && (_this.svg = svg), animator && (_this.animator = animator), _this;
            }
            return (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AnimatedNumber, _super), 
            AnimatedNumber.prototype.init = function(options) {
                this.options = options, this.svg || (this.svg = d3.select(options.element.get(0)).append("svg")), 
                this.currentViewport = options.viewport, this.hostServices = options.host, this.style = options.style, 
                this.updateViewportDependantProperties();
            }, AnimatedNumber.prototype.updateViewportDependantProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            }, AnimatedNumber.prototype.update = function(options) {
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(options, "options"), 
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (dataViews && dataViews[0]) {
                    var dataView = dataViews[0];
                    this.updateViewportDependantProperties(), this.getMetaDataColumn(dataView), this.updateInternal(dataView && dataView.single ? dataView.single.value : 0, options.suppressAnimations, !0, this.formatter);
                }
            }, AnimatedNumber.prototype.setFormatter = function(formatter) {
                this.formatter = formatter;
            }, AnimatedNumber.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            }, AnimatedNumber.prototype.onResizing = function(viewport) {
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewport
                });
            }, AnimatedNumber.prototype.canResizeTo = function(viewport) {
                return !0;
            }, AnimatedNumber.prototype.updateInternal = function(target, suppressAnimations, forceUpdate, formatter) {
                void 0 === forceUpdate && (forceUpdate = !1);
                var start = this.value, duration = (0, _Visuals_animators_animatorCommon__WEBPACK_IMPORTED_MODULE_2__.Mb)(this.animator, suppressAnimations);
                this.doValueTransition(start, target, null, this.options.animation, duration, forceUpdate, formatter), 
                this.value = target;
            }, AnimatedNumber;
        }(__webpack_require__(68193).V);
    },
    68193: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            V: function() {
                return AnimatedText;
            }
        });
        var _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(14599), _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(53197), _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(90120), _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38400), _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79154), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(62458), _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32041), _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64329), _VisualsCommon_Utility_svgUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10389), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72489), AnimatedText = function() {
            function AnimatedText(name) {
                this.defaultTitleColor = "#333333", this._animatedTextOptions = {}, this.mainText = (0, 
                _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_0__.CH)("mainText"), this.name = name, 
                this.visualConfiguration = {
                    maxFontSize: 60
                };
            }
            return AnimatedText.prototype.getMetaDataColumn = function(dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                    var column = dataView.metadata.columns[i];
                    if (column.isMeasure) {
                        this.metaDataColumn = column;
                        break;
                    }
                }
            }, AnimatedText.prototype.getAdjustedFontHeight = function(availableWidth, textToMeasure, seedFontHeight) {
                var _a, _b, _c, _d, textProperties = {
                    fontFamily: null === (_a = this._animatedTextOptions.textProperties) || void 0 === _a ? void 0 : _a.fontFamily,
                    fontWeight: null === (_b = this._animatedTextOptions.textProperties) || void 0 === _b ? void 0 : _b.fontWeight,
                    fontStyle: null === (_c = this._animatedTextOptions.textProperties) || void 0 === _c ? void 0 : _c.fontStyle,
                    textDecoration: null === (_d = this._animatedTextOptions.textProperties) || void 0 === _d ? void 0 : _d.textDecoration,
                    text: textToMeasure
                };
                return this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight, 0);
            }, AnimatedText.prototype.getAdjustedFontHeightCore = function(textProperties, availableWidth, seedFontHeight, iteration) {
                return iteration > 10 ? seedFontHeight : (textProperties.fontSize = _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__.FP.toString(seedFontHeight), 
                _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_2__.b.measureSvgTextWidth(textProperties) < availableWidth ? seedFontHeight : this.getAdjustedFontHeightCore(textProperties, availableWidth, .9 * seedFontHeight, iteration + 1));
            }, AnimatedText.prototype.clear = function() {
                this.svg.select(this.mainText.selector).text("");
            }, AnimatedText.prototype.doValueTransition = function(startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate, formatter, datumTransform) {
                var _a, _b, _c, _d;
                if (forceUpdate || startValue !== endValue || null == endValue) {
                    startValue || (startValue = 0), datumTransform || (datumTransform = this.getDefaultDatumTransform());
                    var svg = this.svg, viewport = this.currentViewport, height = viewport.height, width = viewport.width, seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(seedFontHeight), metaDataColumn = this.metaDataColumn;
                    formatter || (formatter = (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_3__.Ue)({
                        format: this.getFormatString(this.dataPointObjects, metaDataColumn),
                        value: endValue,
                        displayUnitSystemType,
                        formatSingleValues: !0,
                        allowFormatBeautification: !0,
                        columnType: metaDataColumn ? metaDataColumn.type : void 0
                    }));
                    var startText = String(startValue), endText = String(endValue);
                    (_.isEmpty(endValue) || "string" != typeof endValue) && (endText = formatter.format(endValue)), 
                    (_.isEmpty(startValue) || "string" != typeof startValue) && (startText = formatter.format(startValue)), 
                    svg.classed(this.name, !0);
                    var endValueArr = [ datumTransform.getDatum(endValue, endText) ], textElement = svg.selectAll("text").data(endValueArr), textElementUpdate = textElement.enter().append("text").classed(this.mainText.class, !0).merge(textElement), fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                    if (translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2), textElementUpdate.text(startText).attr("text-anchor", this.getTextAnchor()).attr("font-size", fontHeight).attr("transform", (0, 
                    _VisualsCommon_Utility_svgUtil__WEBPACK_IMPORTED_MODULE_4__.Iu)(translateX, translateY)).style("font-style", null === (_a = this._animatedTextOptions.textProperties) || void 0 === _a ? void 0 : _a.fontStyle).style("text-decoration", null === (_b = this._animatedTextOptions.textProperties) || void 0 === _b ? void 0 : _b.textDecoration).style("font-weight", null === (_c = this._animatedTextOptions.textProperties) || void 0 === _c ? void 0 : _c.fontWeight).style("font-family", null === (_d = this._animatedTextOptions.textProperties) || void 0 === _d ? void 0 : _d.fontFamily).style("fill", this.getTextColor()).call(_Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_5__.Q, [ startText ]), 
                    null == endValue || metaDataColumn && (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_6__.v9)(metaDataColumn.type) || "string" == typeof endValue || "string" == typeof startValue) textElementUpdate.text(endText).call(_Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_5__.Q, [ endText ]); else {
                        var interpolatedValue_1 = startValue;
                        textElementUpdate.transition().duration(duration).tween("text", function(d) {
                            var value = datumTransform.getValue(d), i = d3.interpolate(interpolatedValue_1, value);
                            return function(t) {
                                var num = i(t);
                                this.textContent = formatter.format(num);
                            };
                        });
                    }
                    return (0, _VisualsCommon_Utility_svgUtil__WEBPACK_IMPORTED_MODULE_4__.bL)(animationOptions, textElementUpdate), 
                    textElementUpdate;
                }
            }, AnimatedText.prototype.getDefaultDatumTransform = function() {
                return {
                    getDatum: function(value, _formattedValue) {
                        return {
                            value
                        };
                    },
                    getValue: function(datum) {
                        return datum.value;
                    }
                };
            }, Object.defineProperty(AnimatedText.prototype, "animatedTextOptions", {
                get: function() {
                    return this._animatedTextOptions;
                },
                set: function(options) {
                    this._animatedTextOptions = options;
                },
                enumerable: !1,
                configurable: !0
            }), AnimatedText.prototype.getTextColor = function() {
                var _a, styleForegroundColor = this.style && _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_7__.v.getThemeColor(this.style, "foreground");
                return (null === (_a = this._animatedTextOptions) || void 0 === _a ? void 0 : _a.titleColor) || styleForegroundColor || this.defaultTitleColor;
            }, AnimatedText.prototype.getSeedFontHeight = function(boundingWidth, boundingHeight) {
                var estimatedSize = Math.floor(.75 * Math.min(boundingWidth, boundingHeight)), maxFontSize = this.visualConfiguration.maxFontSize;
                return maxFontSize ? Math.min(maxFontSize, estimatedSize) : estimatedSize;
            }, AnimatedText.prototype.getTranslateX = function(width) {
                if (this.visualConfiguration) switch (this.visualConfiguration.align) {
                  case "left":
                    return 0;

                  case "right":
                    return width;
                }
                return width / 2;
            }, AnimatedText.prototype.getTranslateY = function(height) {
                return height;
            }, AnimatedText.prototype.getTextAnchor = function() {
                if (this.visualConfiguration) switch (this.visualConfiguration.align) {
                  case "left":
                    return "start";

                  case "right":
                    return "end";
                }
                return "middle";
            }, AnimatedText.prototype.getFormatString = function(dataPointObjects, column) {
                return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_8__.fF.assertAnyValue(column, "column"), 
                (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_3__.eU)(dataPointObjects, column, _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_9__.e0.formatString);
            }, AnimatedText;
        }();
    },
    27115: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            Gauge: function() {
                return Gauge;
            }
        });
        var tslib_es6 = __webpack_require__(81337), animatorCommon = __webpack_require__(94478), gauge_capabilities = __webpack_require__(5719), axisHelper = __webpack_require__(53197), renderUtil = __webpack_require__(60066), common_colorHelper = __webpack_require__(90120), dataLabelViewModel1 = __webpack_require__(21181), common_fontProperties = __webpack_require__(18664), onObjectUtil = __webpack_require__(80065), htmlSubSelectionHelper = __webpack_require__(52287), subSelectionOutlineRenderer = __webpack_require__(86900), contracts_selector = __webpack_require__(32379), invalidDataValuesChecker = __webpack_require__(33777), tooltipUtils = __webpack_require__(38400), dataViewCategoricalReader = __webpack_require__(51129), interactivityService = __webpack_require__(72902), tooltipService = __webpack_require__(40739), colorHelper = __webpack_require__(44783), CssConstants = __webpack_require__(79154), debug = __webpack_require__(62458), fontUtils = __webpack_require__(38265), d3Helper = __webpack_require__(34644), textMeasurementService = __webpack_require__(32041), browserUtils = __webpack_require__(59107), build_control_util = __webpack_require__(56578), svgUtil = __webpack_require__(10389), enums = __webpack_require__(46135), dataRoleHelper = __webpack_require__(38958), animatedNumber = __webpack_require__(58914), converterHelper = __webpack_require__(54522), visualBorderUtil = __webpack_require__(34021), tooltip = __webpack_require__(11305), dataViewObject2 = __webpack_require__(82755), valueFormatter = __webpack_require__(72489), selectionId = __webpack_require__(26543), dataLabelViewModel1Consts = __webpack_require__(56707), dataLabelViewModel1Utils = __webpack_require__(70188), GaugeConverter = function() {
            function GaugeConverter() {}
            return GaugeConverter.getDefaultGaugeLabelSettings = function(style, defaultColor, defaultFontFamily) {
                var defaultLabelSettings = (0, dataLabelViewModel1.bT)({
                    show: !0,
                    labelColor: defaultColor,
                    fontSize: dataLabelViewModel1Consts.qy,
                    style,
                    textClassName: "largeLightLabel"
                });
                return defaultFontFamily && (defaultLabelSettings.fontProperties = (0, common_fontProperties.ED)(defaultLabelSettings.fontProperties, {
                    family: defaultFontFamily
                })), defaultLabelSettings.position = null, defaultLabelSettings.bold = !1, defaultLabelSettings.italic = !1, 
                defaultLabelSettings.underline = !1, defaultLabelSettings.showDynamicLabels = !1, 
                defaultLabelSettings;
            }, GaugeConverter.getDefaultDataPointSettings = function(style) {
                var dataColors = style.colorPalette.dataColors.getAllColors();
                return {
                    fillColor: common_colorHelper.v.getDataColorByIndex(style, 0, colorHelper.fA),
                    targetColor: dataColors && dataColors.length > 1 ? common_colorHelper.v.getDataColorByIndex(style, 1, colorHelper.fA) : common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary")
                };
            }, GaugeConverter.convert = function(reader, style) {
                var _a, columnReader = reader.columns, staticObjects = reader.objects.getStaticObjects(), valueColumnMetadata = columnReader.getValueMetadataColumn(gauge_capabilities.Vd.y), data = this.parseGaugeData(reader), minLabelSettings = this.convertDataLabelSettings(staticObjects, "labels", style, data.minDynamicFormatString), maxLabelSettings = this.convertDataLabelSettings(staticObjects, "labels", style, data.maxDynamicFormatString), targetSettings = this.convertDataLabelSettings(staticObjects, "target", style, data.targetDynamicFormatString), defaultCalloutColor = common_colorHelper.v.getThemeColor(style, colorHelper.fA), calloutLabelSettings = this.convertDataLabelSettings(staticObjects, "calloutValue", style, null !== (_a = data.dynamicCalloutLabelFormatString) && void 0 !== _a ? _a : data.valueDynamicFormatString, defaultCalloutColor, fontUtils.Wn.lightSecondary.family), identity = valueColumnMetadata && null != valueColumnMetadata.queryName ? selectionId.dw.builder().withMeasure(valueColumnMetadata.queryName).createSelectionId() : void 0;
                return {
                    maxLabel: this.createLabel(data.max, columnReader.getValueMetadataColumn(gauge_capabilities.Vd.maxValue), maxLabelSettings, valueColumnMetadata),
                    minLabel: this.createLabel(data.min, columnReader.getValueMetadataColumn(gauge_capabilities.Vd.minValue), minLabelSettings, valueColumnMetadata, data.max),
                    target: {
                        label: this.createLabel(data.target, columnReader.getValueMetadataColumn(gauge_capabilities.Vd.targetValue), targetSettings, valueColumnMetadata),
                        ratio: this.getTargetRatio(data)
                    },
                    calloutLabel: this.createLabel(data.callout, valueColumnMetadata, calloutLabelSettings, valueColumnMetadata),
                    tooltipInfo: data.tooltipItems,
                    formattedTooltip: (0, tooltipUtils.X)(data.tooltipItems),
                    ratio: this.getValueRatio(data),
                    dataPointSettings: this.convertDataPointSettings(staticObjects, style),
                    identity,
                    strokeSettings: (0, visualBorderUtil.kG)(style)
                };
            }, GaugeConverter.parseGaugeData = function(reader) {
                var columnReader = reader.columns, dataViewObjects = reader.objects.getStaticObjects(), valueColumnMetadata = columnReader.getValueMetadataColumn(gauge_capabilities.Vd.y), axisObject = dataViewObjects ? dataViewObjects.axis : null, isValueDefined = reader.data.hasValues(gauge_capabilities.Vd.y), isMaxDefined = reader.data.hasValues(gauge_capabilities.Vd.maxValue), isMinDefined = reader.data.hasValues(gauge_capabilities.Vd.minValue), data = {
                    max: null,
                    min: null,
                    target: null,
                    value: null,
                    callout: null,
                    tooltipItems: [],
                    dynamicCalloutEnabled: !1
                };
                if (isValueDefined) {
                    data.value = reader.data.getValue(gauge_capabilities.Vd.y, 0), data.valueDynamicFormatString = data.minDynamicFormatString = data.maxDynamicFormatString = reader.data.getFormatString(gauge_capabilities.Vd.y, 0);
                    var value = (0, converterHelper.xq)(data.value, valueColumnMetadata, gauge_capabilities.qJ.general.formatString, !1, data.valueDynamicFormatString);
                    data.tooltipItems.push({
                        displayName: reader.data.getValueDisplayName(gauge_capabilities.Vd.y),
                        value
                    });
                }
                if (reader.data.hasValues(gauge_capabilities.Vd.targetValue)) {
                    var targetMetadata = columnReader.getValueMetadataColumn(gauge_capabilities.Vd.targetValue);
                    data.target = reader.data.getValue(gauge_capabilities.Vd.targetValue, 0), data.targetDynamicFormatString = reader.data.getFormatString(gauge_capabilities.Vd.targetValue, 0), 
                    value = (0, converterHelper.xq)(data.target, targetMetadata, gauge_capabilities.qJ.general.formatString, !1, data.targetDynamicFormatString), 
                    data.tooltipItems.push({
                        displayName: reader.data.getValueDisplayName(gauge_capabilities.Vd.targetValue),
                        value
                    });
                } else axisObject && (data.target = axisObject.target);
                if (data.dynamicCalloutEnabled = (0, dataViewObject2.NA)(dataViewObjects, gauge_capabilities.qJ.calloutValue.showDynamicLabels, !1), 
                data.dynamicCalloutEnabled) {
                    var dynamicLabelValue = (0, dataViewObject2.NA)(dataViewObjects, gauge_capabilities.qJ.calloutValue.dynamicLabelValue);
                    data.callout = dynamicLabelValue, data.dynamicCalloutLabelFormatString = reader.data.getFormatStringForRelatedObject(gauge_capabilities.qJ.calloutValue.dynamicLabelValue);
                } else data.callout = data.value;
                if (isMaxDefined) data.max = reader.data.getValue(gauge_capabilities.Vd.maxValue, 0), 
                data.maxDynamicFormatString = reader.data.getFormatString(gauge_capabilities.Vd.maxValue, 0); else if (axisObject && null != axisObject.max) data.max = axisObject.max; else if (data.max = 1, 
                isValueDefined && data.value && 0 !== data.value) {
                    var hasPercent = !1;
                    if (valueColumnMetadata) {
                        var formatString = (0, valueFormatter.EO)(valueColumnMetadata, gauge_capabilities.qJ.general.formatString, !0);
                        null != formatString && (hasPercent = (0, valueFormatter.G2)(formatString).hasPercent);
                    }
                    hasPercent || (data.max = data.value < 0 ? 0 : 2 * data.value);
                }
                return isMinDefined ? (data.min = reader.data.getValue(gauge_capabilities.Vd.minValue, 0), 
                data.minDynamicFormatString = reader.data.getFormatString(gauge_capabilities.Vd.minValue, 0)) : axisObject && null != axisObject.min ? data.min = axisObject.min : (data.min = 0, 
                isValueDefined && null != data.value && data.value < 0 && (data.min = 2 * data.value)), 
                (0, tooltip.VT)(reader, data.tooltipItems, 0, void 0, gauge_capabilities.qJ.general.formatString), 
                data;
            }, GaugeConverter.createLabel = function(value, metadata, settings, fallbackMetadata, max) {
                var textProperties = (0, common_fontProperties.qk)(settings.fontProperties), formatter = this.getFormatter(settings, metadata, fallbackMetadata, max || value);
                return settings.showDynamicLabels && (textProperties.text = formatter.format(value)), 
                textProperties.text = formatter.format(value), {
                    value,
                    requiredSpace: {
                        width: textMeasurementService.b.measureSvgTextWidth(textProperties),
                        height: textMeasurementService.b.estimateSvgTextHeight(textProperties)
                    },
                    text: textProperties.text,
                    formatter,
                    settings
                };
            }, GaugeConverter.getFormatter = function(dataLabelSettings, metadataColumn, fallbackMetadata, maxValue) {
                var max = 0 === dataLabelSettings.displayUnits ? maxValue : null;
                metadataColumn && metadataColumn.objects && !_.isEmpty((0, dataViewObject2.NA)(metadataColumn.objects, gauge_capabilities.qJ.general.formatString)) || (metadataColumn = fallbackMetadata);
                var formatString = dataLabelSettings.dynamicFormatString || (0, valueFormatter.EO)(metadataColumn, gauge_capabilities.qJ.general.formatString), precision = (0, 
                dataLabelViewModel1Utils.h1)(dataLabelSettings.precision, formatString), valueFormatterOptions = (0, 
                dataLabelViewModel1Utils.YO)(dataLabelSettings, formatString, max, precision);
                return valueFormatterOptions.formatSingleValues = !(dataLabelSettings.displayUnits > 0), 
                0 === dataLabelSettings.displayUnits && (valueFormatterOptions.value = max), (0, 
                valueFormatter.Ue)(valueFormatterOptions);
            }, GaugeConverter.getValueRatio = function(data) {
                return !_.isNumber(data.value) || !this.isValid(data) || data.value <= data.min ? 0 : data.value >= data.max ? 1 : (data.value - data.min) / (data.max - data.min);
            }, GaugeConverter.isValid = function(data) {
                return _.isNumber(data.min) && _.isNumber(data.max) && data.min <= data.max;
            }, GaugeConverter.getTargetRatio = function(data) {
                if (!this.isValid(data) || !_.isNumber(data.target)) return -1;
                var range = data.max - data.min;
                return 0 !== range ? (data.target - data.min) / range : 0;
            }, GaugeConverter.convertDataLabelSettings = function(objects, objectName, style, dynamicFormatString, defaultColor, defaultFont) {
                var dataLabelSettings = GaugeConverter.getDefaultGaugeLabelSettings(style, defaultColor, defaultFont);
                return dataLabelSettings.dynamicFormatString = dynamicFormatString, objects && (0, 
                dataLabelViewModel1.ww)(objects[objectName], dataLabelSettings, void 0, style), 
                dataLabelSettings;
            }, GaugeConverter.convertDataPointSettings = function(objects, style) {
                var defaultDataPointSettings = GaugeConverter.getDefaultDataPointSettings(style), colorHelper = common_colorHelper.v.create(style);
                return {
                    fillColor: colorHelper.getColorForPropertyWithDefaultColor(objects, gauge_capabilities.qJ.dataPoint.fill, defaultDataPointSettings.fillColor),
                    targetColor: colorHelper.getColorForPropertyWithDefaultColor(objects, gauge_capabilities.qJ.dataPoint.target, defaultDataPointSettings.targetColor)
                };
            }, GaugeConverter;
        }(), strokeLineJoin = __webpack_require__(41234), Gauge = function() {
            function Gauge(options, featureSwitches) {
                this.lastAngle = -Math.PI / 2, options && (options.gaugeSmallViewPortProperties && (this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties), 
                this.animator = options.animator, this.tooltipsEnabled = options.tooltipsEnabled, 
                this.behavior = options.behavior, this.featureSwitches = featureSwitches || {}, 
                this.onObjectEnabled = this.featureSwitches.onObject);
            }
            return Gauge.prototype.getDataLabelsCard = function() {
                var _a, _b;
                return this.generateLabelsCard("labels", "Visual_DataPointsLabels", (0, tslib_es6.__assign)((0, 
                tslib_es6.__assign)({}, gauge_capabilities.qJ.labels), {
                    displayUnits: gauge_capabilities.qJ.labels.labelDisplayUnits,
                    precision: gauge_capabilities.qJ.labels.labelPrecision
                }), this.getDataLabelSettingsOptions(void 0, null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.minLabel.settings) && void 0 !== _b ? _b : GaugeConverter.getDefaultGaugeLabelSettings(this.style)), void 0);
            }, Gauge.prototype.getTargetLabelCard = function() {
                var _a, _b, _c;
                return this.generateLabelsCard("target", "Visual_Gauge_Axis_TargetLabel", (0, tslib_es6.__assign)((0, 
                tslib_es6.__assign)({}, gauge_capabilities.qJ.target), {
                    displayUnits: gauge_capabilities.qJ.target.labelDisplayUnits,
                    precision: gauge_capabilities.qJ.target.labelPrecision
                }), this.getDataLabelSettingsOptions(void 0, null !== (_c = null === (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.target) || void 0 === _b ? void 0 : _b.label.settings) && void 0 !== _c ? _c : GaugeConverter.getDefaultGaugeLabelSettings(this.style)), !0);
            }, Gauge.prototype.getCalloutValueCard = function() {
                var _a, _b;
                return this.generateLabelsCard("calloutValue", "Visual_Gauge_CalloutValue", (0, 
                tslib_es6.__assign)((0, tslib_es6.__assign)({}, gauge_capabilities.qJ.calloutValue), {
                    displayUnits: gauge_capabilities.qJ.calloutValue.labelDisplayUnits,
                    precision: gauge_capabilities.qJ.calloutValue.labelPrecision,
                    showDynamicLabels: gauge_capabilities.qJ.calloutValue.showDynamicLabels,
                    dynamicLabelValue: gauge_capabilities.qJ.calloutValue.dynamicLabelValue
                }), this.getDataLabelSettingsOptions(void 0, null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.calloutLabel.settings) && void 0 !== _b ? _b : GaugeConverter.getDefaultGaugeLabelSettings(this.style, common_colorHelper.v.getThemeColor(this.style, colorHelper.fA), fontUtils.Wn.lightSecondary.family)), !0);
            }, Gauge.prototype.generateLabelsCard = function(objectName, cardTitle, dataLabelsProps, labelSettingsOptions, omitDescription) {
                var _this = this;
                return (0, dataLabelViewModel1.XQ)({
                    cardBuilder: new build_control_util.CQ(new build_control_util.lg(objectName), cardTitle, dataLabelsProps, function(key) {
                        return _this.hostService.getLocalizedString(key);
                    }),
                    dataLabelsProps,
                    featureSwitches: this.featureSwitches,
                    hostServices: this.hostService,
                    options: labelSettingsOptions,
                    omitDescription,
                    omitDynamicLabelSelector: !0,
                    instanceKind: 3
                });
            }, Gauge.prototype.getColorsCard = function() {
                var _a, _b, _this = this, dataPointSettings = null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.dataPointSettings) && void 0 !== _b ? _b : GaugeConverter.getDefaultDataPointSettings(this.style), dataPointProps = gauge_capabilities.qJ.dataPoint;
                return new build_control_util.CQ(new build_control_util.lg("datapoint"), "Visual_Colors", dataPointProps, function(key) {
                    return _this.hostService.getLocalizedString(key);
                }).addGroup("datapoint", function(groupBuilder) {
                    return groupBuilder.addSimpleSlice(dataPointProps.fill.propertyName, new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataPointProps.fill), {
                            instanceKind: 3
                        }),
                        value: {
                            value: dataPointSettings.fillColor
                        }
                    }).build()).addSimpleSlice(dataPointProps.target.propertyName, new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataPointProps.target), {
                            instanceKind: 3
                        }),
                        value: {
                            value: dataPointSettings.targetColor
                        }
                    }).build());
                }).build();
            }, Gauge.prototype.getGaugeAxisCard = function() {
                var _a, _this = this, dataView = this.dataView;
                if (null == dataView ? void 0 : dataView.metadata) {
                    var axisProps = gauge_capabilities.qJ.axis, min = (_a = Gauge.getGaugeObjectsProperties(dataView)).min, max = _a.max, target = _a.target;
                    return new build_control_util.CQ(new build_control_util.lg("axis"), "Visual_Gauge_Axis", axisProps, function(key) {
                        return _this.hostService.getLocalizedString(key);
                    }).addGroup("axis", function(groupBuilder) {
                        return groupBuilder.addSimpleSlice(axisProps.min.propertyName, new build_control_util.mu({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axisProps.min), {
                                instanceKind: 3
                            }),
                            value: min,
                            options: {
                                maxValue: null != max ? {
                                    type: 1,
                                    value: max
                                } : void 0
                            }
                        }).build(), function(customizer) {
                            return customizer.withDisabled((0, dataRoleHelper.c5)(dataView, gauge_capabilities.Vd.minValue));
                        }).addSimpleSlice(axisProps.max.propertyName, new build_control_util.mu({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axisProps.max), {
                                instanceKind: 3
                            }),
                            value: max,
                            options: {
                                minValue: null != min ? {
                                    type: 0,
                                    value: min
                                } : void 0
                            }
                        }).build(), function(customizer) {
                            return customizer.withDisabled((0, dataRoleHelper.c5)(dataView, gauge_capabilities.Vd.maxValue));
                        }).addSimpleSlice(axisProps.target.propertyName, new build_control_util.mu({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axisProps.target), {
                                instanceKind: 3
                            }),
                            value: target,
                            options: {
                                minValue: null != min ? {
                                    type: 0,
                                    value: min
                                } : void 0,
                                maxValue: null != max ? {
                                    type: 1,
                                    value: max
                                } : void 0
                            }
                        }).build(), function(customizer) {
                            return customizer.withDisabled((0, dataRoleHelper.c5)(dataView, gauge_capabilities.Vd.targetValue));
                        });
                    }).build();
                }
            }, Gauge.prototype.getFormattingModel = function() {
                var _this = this;
                return new build_control_util.Nq(function() {
                    return _this.getGaugeAxisCard();
                }, function() {
                    return _this.getColorsCard();
                }, function() {
                    return _this.getDataLabelsCard();
                }, function() {
                    return _this.getTargetLabelCard();
                }, function() {
                    return _this.getCalloutValueCard();
                }).build();
            }, Gauge.prototype.getDataLabelSettingsOptions = function(enumeration, labelSettings) {
                return {
                    dataLabelsSettings: labelSettings,
                    show: !0,
                    precision: !0,
                    displayUnits: !0,
                    fontSize: !0,
                    fontFamily: !0,
                    enumeration,
                    style: this.style,
                    bold: !0,
                    italic: !0,
                    underline: !0,
                    enableDynamicLabelPickers: labelSettings.showDynamicLabels,
                    dynamicLabelValue: labelSettings.dynamicLabelValue
                };
            }, Gauge.getGaugeObjectsProperties = function(dataView) {
                var properties = {}, objects = dataView.metadata.objects, hasAxisObject = !!objects && !!objects.axis;
                return (0, dataRoleHelper.c5)(dataView, gauge_capabilities.Vd.minValue) || (properties.min = hasAxisObject ? objects.axis.min : void 0), 
                (0, dataRoleHelper.c5)(dataView, gauge_capabilities.Vd.maxValue) || (properties.max = hasAxisObject ? objects.axis.max : void 0), 
                (0, dataRoleHelper.c5)(dataView, gauge_capabilities.Vd.targetValue) || (properties.target = hasAxisObject ? objects.axis.target : void 0), 
                properties;
            }, Gauge.prototype.init = function(options) {
                var _a, _this = this;
                if (this.element = options.element, this.currentViewport = options.viewport, this.style = options.style, 
                this.settings = Gauge.DefaultStyleProperties, this.tooltipService = (0, tooltipService.r)(options.host), 
                this.labelPosition = 0, this.margin = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                }, this.color = d3.scaleOrdinal([ common_colorHelper.v.getSentimentColor(this.style, "bad"), common_colorHelper.v.getSentimentColor(this.style, "neutral"), common_colorHelper.v.getSentimentColor(this.style, "good") ]).domain([ 0, 1, 2 ]), 
                this.hostService = options.host, this.behavior && (this.interactivityService = (0, 
                interactivityService.ub)(this.hostService, this.featureSwitches)), this.onObjectEnabled) {
                    var subSelectionHostService = null === (_a = this.hostService) || void 0 === _a ? void 0 : _a.getSubSelectionService(), renderer = null != subSelectionHostService ? subSelectionHostService : subSelectionOutlineRenderer.D.createWithDefaultHost();
                    this.subSelectionHelper = htmlSubSelectionHelper.O5.createHtmlSubselectionHelper({
                        hostElement: this.element.get(0),
                        hostServices: this.hostService,
                        renderer,
                        targetSource: "format",
                        scale: function() {
                            return _this.currentViewport.scale;
                        }
                    });
                }
                var svg = this.svg = d3.select(this.element.get(0)).append("svg").classed("gauge", !0);
                if (this.interactivityService) {
                    var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                    svg.attr("tabindex", 0).attr("focusable", !0).classed(renderUtil.Pg, !isEdgeOrIE);
                }
                var mainGraphicsContext = this.mainGraphicsContext = svg.append("g");
                mainGraphicsContext.attr("class", Gauge.MainGaugeGroupClassName), this.onObjectEnabled && mainGraphicsContext.attr(htmlSubSelectionHelper.CP, !0), 
                this.initKpiBands();
                var backgroundArc = this.backgroundArc = d3.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2).endAngle(Math.PI / 2), foregroundArc = this.foregroundArc = d3.arc().innerRadius(0).outerRadius(0).startAngle(-Math.PI / 2);
                this.backgroundArcPath = mainGraphicsContext.append("path").classed("backgroundArc", !0).attr("d", backgroundArc), 
                this.foregroundArcPath = mainGraphicsContext.append("path").datum({
                    endAngle: -Math.PI / 2
                }).classed("foregroundArc", !0).attr("d", foregroundArc);
                var g = this.animatedNumberGraphicsContext = svg.append("g");
                this.animatedNumber = new animatedNumber.AnimatedNumber(g), this.animatedNumber.init(options);
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties(), animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.animatedNumberGraphicsContext.attr("transform", animatedNumberProperties.transformString), 
                this.animatedNumber.onResizing(animatedNumberProperties.viewport);
            }, Gauge.prototype.update = function(options) {
                var _a;
                if (debug.fF.assertValue(options, "options"), this.currentViewport = options.viewport, 
                this.onObjectEnabled) {
                    var formatMode = options.formatMode;
                    this.subSelectionHelper.setFormatMode(formatMode), null === (_a = this.interactivityService) || void 0 === _a || _a.setFormatMode(formatMode), 
                    this.formatMode = formatMode;
                }
                if (options.dataViews && options.dataViews[0]) {
                    var dataView = this.dataView = options.dataViews[0], reader = (0, dataViewCategoricalReader.G)(dataView, {
                        formatStringProp: gauge_capabilities.qJ.general.formatString
                    });
                    if (options.type & enums.EP.Data || !this.data) {
                        this.data = GaugeConverter.convert(reader, this.style);
                        var warnings = (0, invalidDataValuesChecker.b)([ dataView ], !1, !1, !1, [ "Tooltips" ]);
                        this.hostService.setWarnings(warnings);
                    }
                    (options.type & enums.EP.Resize || options.type & enums.EP.ResizeEnd) && (options.suppressAnimations = !0), 
                    this.dataView.single = {
                        value: this.data.calloutLabel.value,
                        column: void 0
                    }, this.labels = [ this.data.minLabel, this.data.maxLabel ], this.showTargetLabel = this.data.target.ratio >= 0 && this.data.target.ratio <= 1 && this.currentViewport.width > 150 && this.showSideNumbersLabelText() && this.data.target.label.settings.show;
                    var position = Gauge.calculatePosition(this.data, this.showTargetLabel, this.currentViewport, this.gaugeSmallViewPortProperties);
                    this.labelPosition = position.labelPosition, this.margin = position.margin, this.gaugeVisualProperties = this.getGaugeVisualProperties(), 
                    this.drawViewPort(this.gaugeVisualProperties), this.updateInternal(options.suppressAnimations), 
                    this.updateCalloutValue(options.suppressAnimations);
                    var shouldAlertScreenReader = options.type & enums.EP.FormattingSubSelectionChange;
                    if (this.subSelectionHelper && (options.type & enums.EP.Data || options.type & enums.EP.Resize || options.type & enums.EP.FormattingSubSelectionChange) && (this.subSelectionHelper.updateOutlinesFromSubSelections(options.subSelections, !0), 
                    this.hostService.alertScreenReader && shouldAlertScreenReader)) {
                        var labels = this.subSelectionHelper.getLabelsFromSubSelections(options.subSelections, [ "aria-label" ]), message = (null == labels ? void 0 : labels.length) && labels.join(" ");
                        message && this.hostService.alertScreenReader(message);
                    }
                }
            }, Gauge.prototype.updateCalloutValue = function(suppressAnimations) {
                var calloutValueLabelsSettings = this.data.calloutLabel.settings;
                if (this.data.calloutLabel.settings.show) {
                    var animatedNumberProperties = this.getAnimatedNumberProperties(this.gaugeVisualProperties.radius, this.gaugeVisualProperties.innerRadiusFactor, this.gaugeVisualProperties.top, this.gaugeVisualProperties.left), textProperties = {
                        fontFamily: calloutValueLabelsSettings.fontProperties.family,
                        fontStyle: calloutValueLabelsSettings.fontProperties.style,
                        fontWeight: calloutValueLabelsSettings.fontProperties.weight,
                        textDecoration: calloutValueLabelsSettings.fontProperties.textDecoration
                    };
                    this.animatedNumberGraphicsContext.attr("transform", animatedNumberProperties.transformString), 
                    this.animatedNumber.animatedTextOptions = {
                        textProperties,
                        titleColor: calloutValueLabelsSettings.fontProperties.color
                    };
                    var formatter = this.data.calloutLabel.formatter;
                    this.animatedNumber.setFormatter(formatter), this.animatedNumber.update({
                        viewport: animatedNumberProperties.viewport,
                        dataViews: [ this.dataView ],
                        suppressAnimations
                    }), this.animatedNumberGraphicsContext.selectAll("title").remove(), this.animatedNumberGraphicsContext.append("title").text(formatter.format(this.data.calloutLabel.value)), 
                    this.onObjectEnabled && this.animatedNumberGraphicsContext.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "callout-value").attr(htmlSubSelectionHelper.CK, "Visual_Gauge_CalloutValue").attr(htmlSubSelectionHelper.QZ, 2);
                } else this.animatedNumber.clear(), this.animatedNumberGraphicsContext.selectAll("title").remove();
            }, Gauge.prototype.initKpiBands = function() {
                if (this.settings.kpiBands.show) for (var kpiArcs = this.kpiArcs = [], kpiArcPaths = this.kpiArcPaths = [], mainGraphicsContext = this.mainGraphicsContext, i = 0; i < 3; i++) {
                    var arc = d3.arc().innerRadius(0).outerRadius(0).startAngle(0).endAngle(0);
                    kpiArcs.push(arc);
                    var arcPath = mainGraphicsContext.append("path").attr("d", arc);
                    kpiArcPaths.push(arcPath);
                }
            }, Gauge.prototype.updateKpiBands = function(radius, innerRadiusFactor, tString, kpiAngleAttr) {
                if (this.settings.kpiBands.show) for (var i = 0; i < kpiAngleAttr.length; i++) this.kpiArcs[i].innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)).outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc).startAngle(kpiAngleAttr[i].start).endAngle(kpiAngleAttr[i].end), 
                this.kpiArcPaths[i].attr("fill", kpiAngleAttr[i].fill).attr("d", this.kpiArcs[i]).attr("transform", tString);
            }, Gauge.prototype.removeTargetElements = function() {
                this.targetLine && (this.targetLine.remove(), this.targetText.remove(), this.targetConnector.remove(), 
                this.targetLine = this.targetConnector = this.targetText = null, this.interactivityTarget && (this.interactivityTarget.remove(), 
                this.interactivityTarget = null));
            }, Gauge.prototype.updateTargetLine = function(radius, innerRadius, left, top) {
                var _this = this;
                this.targetLine || (this.targetLine = this.mainGraphicsContext.append("line"));
                var angle = this.data.target.ratio * Math.PI, outY = top - radius * Math.sin(angle), outX = left - radius * Math.cos(angle), inY = top - innerRadius * Math.sin(angle), inX = left - innerRadius * Math.cos(angle);
                if (this.targetLine.attr("x1", inX).attr("y1", inY).attr("x2", outX).attr("y2", outY), 
                this.onObjectEnabled) {
                    this.interactivityTarget || (this.interactivityTarget = this.mainGraphicsContext.append("line").attr("class", Gauge.InteractivityTargetClassSelector.class).classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "target").attr(htmlSubSelectionHelper.CK, "Target").attr(htmlSubSelectionHelper.QZ, 3)), 
                    this.interactivityTarget.attr("x1", inX).attr("y1", inY).attr("x2", outX).attr("y2", outY);
                    var interactivityTargetElement_1 = this.interactivityTarget.node();
                    htmlSubSelectionHelper.O5.setDataForElement(interactivityTargetElement_1, {
                        getRegionOutlines: function() {
                            return _this.getTargetOutline(interactivityTargetElement_1);
                        }
                    });
                }
            }, Gauge.prototype.getTargetOutline = function(targetElement) {
                var targetRect = targetElement.getBoundingClientRect(), x = targetRect.x, y = targetRect.y, width = targetRect.width, halfFill = this.data.ratio > .5;
                return [ {
                    id: "target",
                    outline: {
                        points: [ {
                            x: halfFill ? x + width : x,
                            y
                        }, {
                            x: halfFill ? x : x + width,
                            y: y + targetRect.height
                        } ],
                        type: 2
                    }
                } ];
            }, Gauge.prototype.getAnimatedNumberProperties = function(radius, innerRadiusFactor, top, left) {
                var boxAngle = Math.PI / 4, innerRadiusForTextBoundingBox = radius * innerRadiusFactor - (this.settings.kpiBands.show ? Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness : 0), innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle), innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle), innerY = top - innerRSin, innerX = left - innerRCos, animatedNumberWidth = 2 * innerRCos;
                return {
                    transformString: (0, svgUtil.Iu)(innerX *= 1, innerY *= 1),
                    viewport: {
                        height: innerRSin,
                        width: animatedNumberWidth,
                        scale: 1
                    }
                };
            }, Gauge.prototype.getGaugeVisualProperties = function() {
                var viewport = this.currentViewport, margin = this.margin, width = viewport.width - margin.right - margin.left, halfWidth = width / 2, height = viewport.height - margin.top - margin.bottom, radius = Math.min(halfWidth, height), innerRadiusFactor = Gauge.InnerRadiusFactor, left = margin.left + halfWidth, top = radius + (height - radius) / 2 + margin.top;
                return {
                    radius,
                    innerRadiusOfArc: radius * innerRadiusFactor,
                    left,
                    top,
                    height,
                    width,
                    margin,
                    transformString: (0, svgUtil.Iu)(left, top),
                    innerRadiusFactor
                };
            }, Gauge.prototype.drawViewPort = function(drawOptions) {
                var _this = this;
                debug.fF.assertAnyValue(drawOptions, "Gauge options");
                var separation = this.settings.kpiBands.separationRadians, innerRadiusFactor = Gauge.InnerRadiusFactor, backgroundArc = this.backgroundArc, color = this.color, attrs = [ {
                    fill: color(0),
                    start: -Math.PI / 2,
                    end: -Math.PI / 2 + Math.PI / 4 - separation
                }, {
                    fill: color(1),
                    start: -Math.PI / 2 + 1 * Math.PI / 4 + separation,
                    end: -Math.PI / 2 + 3 * Math.PI / 4 - separation
                }, {
                    fill: color(2),
                    start: -Math.PI / 2 + 3 * Math.PI / 4 + separation,
                    end: Math.PI / 2
                } ], radius = drawOptions.radius, transformString = drawOptions.transformString;
                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs);
                var innerRadius = radius * innerRadiusFactor, startAngle = -Math.PI / 2;
                backgroundArc.innerRadius(innerRadius).outerRadius(radius).startAngle(startAngle).endAngle(Math.PI / 2), 
                this.backgroundArcPath.attr("d", backgroundArc).attr("transform", transformString);
                var foregroundArc = this.foregroundArc;
                if (foregroundArc.innerRadius(innerRadius).outerRadius(radius).startAngle(startAngle), 
                this.foregroundArcPath.datum({
                    endAngle: this.lastAngle
                }).attr("transform", transformString).attr("d", foregroundArc), this.onObjectEnabled) {
                    this.foregroundArcPath.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "fill").attr(htmlSubSelectionHelper.CK, "Visual_Fill").attr(htmlSubSelectionHelper.QZ, 3);
                    var fillElement = this.foregroundArcPath.node();
                    htmlSubSelectionHelper.O5.setDataForElement(fillElement, {
                        getRegionOutlines: function() {
                            return _this.getFillOutline(innerRadius, radius, startAngle, _this.lastAngle);
                        }
                    });
                }
                var innerRadiusOfArc = drawOptions.innerRadiusOfArc, left = drawOptions.left, top = drawOptions.top, margin = drawOptions.margin, height = drawOptions.height;
                this.settings.targetLine.show && $.isNumeric(this.data.target.label.value) ? this.data.target.ratio < 0 || this.data.target.ratio > 1 ? this.removeTargetElements() : (this.updateTargetLine(radius, innerRadiusOfArc, left, top), 
                this.renderTarget(radius, height, drawOptions.width, margin)) : this.removeTargetElements(), 
                this.svg.attr("height", this.currentViewport.height).attr("width", this.currentViewport.width);
            }, Gauge.prototype.getFillOutline = function(unscaledInnerRadius, unscaledOuterRadius, startAngle, endAngle) {
                var _a, left = (_a = this.backgroundArcPath.node().getBoundingClientRect()).left, scaleFactor = this.currentViewport.scale;
                return [ {
                    id: "fill",
                    outline: {
                        type: 4,
                        center: {
                            x: left + _a.width / 2,
                            y: _a.top + _a.height
                        },
                        innerRadius: unscaledInnerRadius * scaleFactor,
                        outerRadius: unscaledOuterRadius * scaleFactor,
                        startAngle,
                        endAngle
                    }
                } ];
            }, Gauge.prototype.getSubSelectables = function(filter) {
                return this.subSelectionHelper.getAllSubSelectables(filter);
            }, Gauge.prototype.getNextSubSelectable = function(currentSubSelectable, backwards) {
                return this.subSelectionHelper.getNextSubSelectable(currentSubSelectable, backwards);
            }, Gauge.prototype.getSubSelectionStyles = function(subSelections) {
                if (this.onObjectEnabled) {
                    var visualObjects = _.first(subSelections).visualObjects;
                    debug.fF.assert(function() {
                        return 1 === visualObjects.length;
                    }, "Expected 1 visual");
                    var visualObject = visualObjects[0];
                    switch (debug.fF.assert(function() {
                        return 1 === subSelections.length || subSelections.every(function(newSubSelection) {
                            return _.isEqual(newSubSelection.visualObjects, [ visualObject ]);
                        }, "Expected 1 sub-selection or matching objects");
                    }), visualObject && visualObject.selectorsByColumn && (0, contracts_selector.fd)((0, 
                    contracts_selector.tV)(visualObject.selectorsByColumn)), visualObject.objectName) {
                      case "callout-value":
                        return this.getCalloutValueSubSelectionStyles();

                      case "data-labels":
                        return this.getDataLabelsSubSelectionStyles();

                      case "target":
                        return (0, onObjectUtil.w3)(this.hostService, void 0, (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.dataPoint.target));

                      case "target-label":
                        return this.getTargetLabelSubSelectionStyles();

                      case "fill":
                        return (0, onObjectUtil.w3)(this.hostService, void 0, (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.dataPoint.fill));
                    }
                }
            }, Gauge.prototype.getCalloutValueSubSelectionStyles = function() {
                var _a, fontFamily = (_a = gauge_capabilities.qJ.calloutValue).fontFamily;
                return (0, onObjectUtil.xs)(this.hostService, {
                    fontFamilyReference: fontFamily,
                    boldReference: _a.bold,
                    italicReference: _a.italic,
                    underlineReference: _a.underline,
                    fontColorReference: _a.color,
                    displayUnitsReference: _a.labelDisplayUnits,
                    precisionReference: _a.labelPrecision
                });
            }, Gauge.prototype.getDataLabelsSubSelectionStyles = function() {
                var _a, fontFamily = (_a = gauge_capabilities.qJ.labels).fontFamily;
                return (0, onObjectUtil.Jf)({
                    hostServices: this.hostService,
                    omitSelectorForSingleSeries: !0,
                    individualSelector: void 0,
                    selector: void 0,
                    repetitionSelector: void 0
                }, {
                    fontFamilyReference: fontFamily,
                    fontSizeReference: _a.fontSize,
                    boldReference: _a.bold,
                    italicReference: _a.italic,
                    underlineReference: _a.underline,
                    fontColorReference: _a.color,
                    displayUnitsReference: _a.labelDisplayUnits,
                    precisionReference: _a.labelPrecision
                });
            }, Gauge.prototype.getTargetLabelSubSelectionStyles = function() {
                var _a, fontFamily = (_a = gauge_capabilities.qJ.target).fontFamily;
                return (0, onObjectUtil.xs)(this.hostService, {
                    fontFamilyReference: fontFamily,
                    fontSizeReference: _a.fontSize,
                    boldReference: _a.bold,
                    italicReference: _a.italic,
                    underlineReference: _a.underline,
                    fontColorReference: _a.color,
                    displayUnitsReference: _a.labelDisplayUnits,
                    precisionReference: _a.labelPrecision
                });
            }, Gauge.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                var _this = this;
                if (this.onObjectEnabled && !filter) {
                    var visualObjects = _.first(subSelections).visualObjects;
                    debug.fF.assert(function() {
                        return 1 === visualObjects.length;
                    }, "Expected 1 visual");
                    var visualObject = visualObjects[0];
                    debug.fF.assert(function() {
                        return 1 === subSelections.length || subSelections.every(function(newSubSelection) {
                            return _.isEqual(newSubSelection.visualObjects, [ visualObject ]);
                        }, "Expected 1 sub-selection or matching objects");
                    });
                    var localize = function(value) {
                        return _this.hostService.getLocalizedString(value);
                    };
                    switch (visualObject.objectName) {
                      case "callout-value":
                        return this.getCalloutValueShortcuts(localize);

                      case "data-labels":
                        return this.getDataLabelsShortcuts(localize);

                      case "target":
                        return this.getTargetShortcuts(localize);

                      case "target-label":
                        return this.getTargetLabelShortcuts(localize);

                      case "fill":
                        return this.getFillShortcuts(localize);
                    }
                }
            }, Gauge.prototype.getCalloutValueShortcuts = function(localize) {
                return [ {
                    type: 0
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 2
                }, gauge_capabilities.qJ.calloutValue.show), {
                    disabledLabel: localize("Delete"),
                    keyboardShortcuts: [ {
                        key: "Delete",
                        nextValue: !1
                    } ]
                }), {
                    type: 1,
                    destinationInfo: (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.calloutValue.fontFamily),
                    label: localize("Format_Callout_Value")
                } ];
            }, Gauge.prototype.getDataLabelsShortcuts = function(localize) {
                return [ {
                    type: 0
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 2
                }, gauge_capabilities.qJ.labels.show), {
                    disabledLabel: localize("Delete"),
                    keyboardShortcuts: [ {
                        key: "Delete",
                        nextValue: !1
                    } ]
                }), {
                    type: 1,
                    destinationInfo: (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.labels.fontFamily),
                    label: localize("Format_Data_Labels")
                } ];
            }, Gauge.prototype.getTargetShortcuts = function(localize) {
                return [ {
                    type: 0
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 2
                }, gauge_capabilities.qJ.target.show), {
                    enabledLabel: localize("Format_AddTargetLabel")
                }), {
                    type: 1,
                    destinationInfo: (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.dataPoint.target),
                    label: localize("Format_Target")
                } ];
            }, Gauge.prototype.getTargetLabelShortcuts = function(localize) {
                return [ {
                    type: 0
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 2
                }, gauge_capabilities.qJ.target.show), {
                    disabledLabel: localize("Delete"),
                    keyboardShortcuts: [ {
                        key: "Delete",
                        nextValue: !1
                    } ]
                }), {
                    type: 1,
                    destinationInfo: (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.target.fontFamily),
                    label: localize("Format_Target_Label")
                } ];
            }, Gauge.prototype.getFillShortcuts = function(localize) {
                return [ {
                    type: 0
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 2
                }, gauge_capabilities.qJ.labels.show), {
                    enabledLabel: localize("Format_AddDataLabels")
                }), {
                    type: 1,
                    destinationInfo: (0, tslib_es6.__assign)({}, gauge_capabilities.qJ.dataPoint.fill),
                    label: localize("Format_Fill")
                } ];
            }, Gauge.prototype.updateInternal = function(suppressAnimations) {
                var height = this.gaugeVisualProperties.height, width = this.gaugeVisualProperties.width, radius = this.gaugeVisualProperties.radius, margin = this.margin, duration = (0, 
                animatorCommon.Mb)(this.animator, suppressAnimations), data = this.data, lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * this.data.ratio;
                if (this.foregroundArcPath.transition().ease((0, d3Helper.Ad)(this.settings.transition.ease)).duration(duration).call(this.arcTween, [ lastAngle, this.foregroundArc ]), 
                this.renderMinMaxLabels(this.labels, radius, height, width, margin), this.updateVisualConfigurations(), 
                this.tooltipsEnabled && (this.tooltipService.addTooltip(this.foregroundArcPath, function(_args) {
                    return data.tooltipInfo;
                }, function(_args) {
                    return data.identity && [ data.identity ];
                }), this.tooltipService.addTooltip(this.backgroundArcPath, function(_args) {
                    return data.tooltipInfo;
                }, function(_args) {
                    return data.identity && [ data.identity ];
                })), this.interactivityService) {
                    this.interactivityService.bind([], this.behavior, {
                        paths: [ this.foregroundArcPath ],
                        formatMode: this.formatMode
                    });
                    var additionalFormattedInfo = "".concat(this.hostService.getLocalizedString("Role_DisplayName_MinValue"), " ").concat(data.minLabel.text, ".") + " ".concat(this.hostService.getLocalizedString("Role_DisplayName_MaxValue"), " ").concat(data.maxLabel.text, ".");
                    this.svg.attr("aria-label", data.formattedTooltip ? data.formattedTooltip.concat(" ".concat(additionalFormattedInfo)) : additionalFormattedInfo);
                }
                this.foregroundArcPath.datum().identity = data.identity;
            }, Gauge.prototype.updateVisualConfigurations = function() {
                this.mainGraphicsContext.select("line:not(".concat(Gauge.InteractivityTargetClassSelector.selector, ")")).attr("stroke", this.data.dataPointSettings.targetColor).attr("stroke-width", this.settings.targetLine.thickness), 
                (0, visualBorderUtil.H4)(this.mainGraphicsContext.select("path"), this.data.strokeSettings), 
                this.onObjectEnabled && this.mainGraphicsContext.select(Gauge.InteractivityTargetClassSelector.selector).attr("stroke", this.data.dataPointSettings.targetColor).attr("stroke-opacity", 0).style("stroke-width", this.settings.targetLine.thickness + Gauge.InteractivityTargetPadding).style("stroke-linejoin", strokeLineJoin.t.round).style("stroke-dasharray", "none"), 
                this.backgroundArcPath.style("fill", common_colorHelper.v.getThemeColor(this.style, "backgroundLight")), 
                this.foregroundArcPath.style("fill", this.data.dataPointSettings.fillColor);
            }, Gauge.prototype.renderMinMaxLabels = function(ticks, radius, height, width, margin) {
                if (this.svg.selectAll(Gauge.LabelText.selector).remove(), this.data.minLabel.settings.show) for (var total = ticks.length, divisor = total - 1, position = this.labelPosition, fontProperties = this.data.minLabel.settings.fontProperties, fontSize = fontProperties.size.px, padding = this.settings.labels.padding, index = 0; index < total; index++) {
                    var y = this.gaugeVisualProperties.top, textProperties = (0, common_fontProperties.qk)(fontProperties, ticks[index].text);
                    if (this.showSideNumbersLabelText()) {
                        var x = margin.left + width / 2 - radius * Math.cos(Math.PI * index / divisor), anchor = void 0, onRight = 1 === index, onBottom = !1;
                        2 === position ? (onBottom = !0, y += padding, anchor = onRight ? "end" : "start", 
                        textProperties.text = textMeasurementService.b.getTailoredTextOrDefault(textProperties, radius)) : (anchor = onRight ? "start" : "end", 
                        x += padding * (onRight ? 1 : -1));
                        var text = this.mainGraphicsContext.append("text").attr("x", x).attr("y", y).attr("dy", onBottom ? fontSize : 0).classed(Gauge.LabelText.class, !0);
                        this.onObjectEnabled && text.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "data-labels").attr(htmlSubSelectionHelper.CK, "Visual_DataPointsLabels").attr(htmlSubSelectionHelper.QZ, 2), 
                        text.style("text-anchor", anchor).styles((0, common_fontProperties.E_)(fontProperties)).text(textProperties.text), 
                        onBottom || this.truncateTextIfNeeded(text, x, onRight), text.append("title").text(textProperties.text);
                    }
                }
            }, Gauge.prototype.truncateTextIfNeeded = function(text, positionX, onRight) {
                text.call(axisHelper.oq, onRight ? this.currentViewport.width - positionX : positionX, textMeasurementService.b.svgEllipsis);
            }, Gauge.prototype.renderTarget = function(radius, height, width, margin) {
                var targetLabel = this.data.target, settings = this.data.target.label.settings, target = targetLabel.label.value, tRatio = targetLabel.ratio, top = radius + (height - radius) / 2 + margin.top, flag = tRatio > .5, padding = this.settings.labels.padding, anchor = flag ? "start" : "end", formatter = this.data.target.label.formatter, maxRatio = Math.asin(10 / radius) / Math.PI, finalRatio = tRatio < maxRatio || tRatio > 1 - maxRatio ? flag ? 1 - maxRatio : maxRatio : tRatio, targetX = margin.left + width / 2 - (radius + padding) * Math.cos(Math.PI * finalRatio), targetY = top - (radius + padding) * Math.sin(Math.PI * finalRatio);
                this.targetText || (this.targetText = this.mainGraphicsContext.append("text").classed(Gauge.TargetText.class, !0)), 
                this.onObjectEnabled && this.targetText.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "target-label").attr(htmlSubSelectionHelper.CK, "Visual_Gauge_Axis_TargetLabel").attr(htmlSubSelectionHelper.QZ, 2), 
                this.targetText.attr("x", targetX).attr("y", targetY).style("display", this.showTargetLabel ? "" : "none").style("text-anchor", anchor).styles((0, 
                common_fontProperties.E_)(settings.fontProperties)).text(formatter.format(target)), 
                this.truncateTextIfNeeded(this.targetText, targetX, flag), this.targetText.call(tooltipUtils.Q, [ formatter.format(target) ]), 
                this.targetConnector || (this.targetConnector = this.mainGraphicsContext.append("line").classed(Gauge.TargetConnector.class, !0)), 
                tRatio === finalRatio ? this.targetConnector.style("display", "none") : this.targetConnector.attr("x1", margin.left + width / 2 - radius * Math.cos(Math.PI * tRatio)).attr("y1", top - radius * Math.sin(Math.PI * tRatio)).attr("x2", targetX).attr("y2", targetY).style("stroke-width", this.settings.targetLine.thickness).style("stroke", common_colorHelper.v.getThemeColor(this.style, "foregroundNeutralSecondary")).style("display", "");
            }, Gauge.prototype.arcTween = function(transition, arr) {
                transition.attrTween("d", function(d) {
                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
                    return function(t) {
                        return d.endAngle = interpolate(t), arr[1](d);
                    };
                });
            }, Gauge.calculatePosition = function(viewModel, showTargetLabel, viewport, gaugeSmallViewPortProperties) {
                var settings = Gauge.DefaultStyleProperties, result = {
                    margin: {
                        top: 0,
                        left: 0,
                        bottom: 0,
                        right: 0
                    },
                    labelPosition: 0
                };
                if (gaugeSmallViewPortProperties && gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && viewport.height < gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                    var margins = gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                    return result.margin = {
                        top: margins,
                        bottom: margins,
                        left: margins,
                        right: margins
                    }, result;
                }
                if (!viewModel) return result;
                var padding = 2 * settings.labels.padding, showLabels = viewModel && viewModel.minLabel.settings.show;
                if (showTargetLabel) {
                    var angle = (viewModel.target.ratio <= .5 ? viewModel.target.ratio : 1 - viewModel.target.ratio) * Math.PI, maxWidthRadius = (viewport.width - (viewModel.target.label.requiredSpace.width + padding)) / (Math.cos(angle) + 1), delta = viewport.width - 2 * maxWidthRadius;
                    delta > 0 && (viewModel.target.ratio < .5 ? result.margin.left = delta : result.margin.right = delta);
                    var maxHeightRadius = (viewport.height - viewModel.target.label.requiredSpace.height - padding) / Math.sin(angle);
                    (delta = viewport.height - maxHeightRadius) > 0 && (result.margin.top = delta);
                }
                if (showLabels) {
                    var leftMargin = Math.max(result.margin.left, viewModel.minLabel.requiredSpace.width + padding), rightMargin = Math.max(result.margin.right, viewModel.maxLabel.requiredSpace.width + padding), bottomMargin = viewModel.minLabel.requiredSpace.height + padding;
                    viewport.height - result.margin.top - bottomMargin > (viewport.width - leftMargin - rightMargin) / 2 ? (result.labelPosition = 2, 
                    result.margin.bottom = bottomMargin) : (result.labelPosition = 1, result.margin = {
                        left: leftMargin,
                        right: rightMargin,
                        top: result.margin.top,
                        bottom: settings.labels.padding
                    });
                }
                var strokeSettings = viewModel.strokeSettings;
                return strokeSettings && strokeSettings.visible && (result.margin = {
                    left: result.margin.left + strokeSettings.width,
                    right: result.margin.right + strokeSettings.width,
                    top: result.margin.top + strokeSettings.width,
                    bottom: result.margin.bottom + strokeSettings.width
                }), result;
            }, Gauge.prototype.showSideNumbersLabelText = function() {
                return !(this.gaugeSmallViewPortProperties && this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort && this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible);
            }, Gauge.DefaultStyleProperties = {
                transition: {
                    ease: "cubic-in-out"
                },
                targetLine: {
                    show: !0,
                    thickness: 2
                },
                labels: {
                    count: 2,
                    padding: 5,
                    fontSize: dataLabelViewModel1Consts.UU
                },
                kpiBands: {
                    show: !1,
                    separationRadians: Math.PI / 128,
                    thickness: 5
                }
            }, Gauge.InnerRadiusFactor = .7, Gauge.KpiBandDistanceFromMainArc = 2, Gauge.MainGaugeGroupClassName = "mainGroup", 
            Gauge.InteractivityTargetPadding = 8, Gauge.InteractivityTargetClassSelector = (0, 
            CssConstants.CH)("interactivity-target"), Gauge.LabelText = (0, CssConstants.CH)("labelText"), 
            Gauge.TargetConnector = (0, CssConstants.CH)("targetConnector"), Gauge.TargetText = (0, 
            CssConstants.CH)("targetText"), Gauge;
        }();
    },
    34644: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Ad: function() {
                return easeCompat;
            },
            LL: function() {
                return orderShapesByClass;
            },
            _9: function() {
                return isScaleBand;
            }
        });
        var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62458);
        function easeCompat(easeString) {
            switch (easeString) {
              case "linear":
                return d3.easeLinear;

              case "cubic-in-out":
                return d3.easeCubicInOut;

              case "cubic-out":
                return d3.easeCubicOut;

              case "back":
                return d3.easeBack;

              default:
                _debug__WEBPACK_IMPORTED_MODULE_0__.fF.assertNever(easeString);
            }
            return d3.easeCubicInOut;
        }
        function isScaleBand(scale) {
            return !!scale.bandwidth;
        }
        function orderShapesByClass(context, renderOrder) {
            var renderOrderableElements = context.selectAll(_.map(renderOrder, function(r) {
                return r.selector;
            }).join(", ")).nodes();
            renderOrderableElements.sort(function(a, b) {
                for (var result = 0, i = 0; i < renderOrder.length; i++) result += +d3.select(a).classed(renderOrder[i].class) * i, 
                result -= +d3.select(b).classed(renderOrder[i].class) * i;
                return result;
            }), d3.selectAll(renderOrderableElements).order();
        }
    }
} ]);