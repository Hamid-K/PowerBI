(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "cartesianChart" ], {
    45863: function(module, exports) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function() {
            "use strict";
            var VERSION = "14.6.2";
            function removeElement(el) {
                el.parentElement.removeChild(el);
            }
            function isSet(value) {
                return null != value;
            }
            function preventDefault(e) {
                e.preventDefault();
            }
            function isNumeric(a) {
                return "number" == typeof a && !isNaN(a) && isFinite(a);
            }
            function addClassFor(element, className, duration) {
                duration > 0 && (addClass(element, className), setTimeout(function() {
                    removeClass(element, className);
                }, duration));
            }
            function limit(a) {
                return Math.max(Math.min(a, 100), 0);
            }
            function asArray(a) {
                return Array.isArray(a) ? a : [ a ];
            }
            function countDecimals(numStr) {
                var pieces = (numStr = String(numStr)).split(".");
                return pieces.length > 1 ? pieces[1].length : 0;
            }
            function addClass(el, className) {
                el.classList && !/\s/.test(className) ? el.classList.add(className) : el.className += " " + className;
            }
            function removeClass(el, className) {
                el.classList && !/\s/.test(className) ? el.classList.remove(className) : el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
            }
            function getPageOffset(doc) {
                var supportPageOffset = void 0 !== window.pageXOffset, isCSS1Compat = "CSS1Compat" === (doc.compatMode || "");
                return {
                    x: supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft,
                    y: supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop
                };
            }
            function subRangeRatio(pa, pb) {
                return 100 / (pb - pa);
            }
            function fromPercentage(range, value, startRange) {
                return 100 * value / (range[startRange + 1] - range[startRange]);
            }
            function getJ(value, arr) {
                for (var j = 1; value >= arr[j]; ) j += 1;
                return j;
            }
            function handleEntryPoint(index, value, that) {
                var percentage;
                if ("number" == typeof value && (value = [ value ]), !Array.isArray(value)) throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
                if (!isNumeric(percentage = "min" === index ? 0 : "max" === index ? 100 : parseFloat(index)) || !isNumeric(value[0])) throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
                that.xPct.push(percentage), that.xVal.push(value[0]), percentage ? that.xSteps.push(!isNaN(value[1]) && value[1]) : isNaN(value[1]) || (that.xSteps[0] = value[1]), 
                that.xHighestCompleteStep.push(0);
            }
            function handleStepPoint(i, n, that) {
                if (n) if (that.xVal[i] !== that.xVal[i + 1]) {
                    that.xSteps[i] = fromPercentage([ that.xVal[i], that.xVal[i + 1] ], n, 0) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);
                    var highestStep = Math.ceil(Number(((that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i]).toFixed(3)) - 1);
                    that.xHighestCompleteStep[i] = that.xVal[i] + that.xNumSteps[i] * highestStep;
                } else that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];
            }
            function Spectrum(entry, snap, singleStep) {
                var index;
                this.xPct = [], this.xVal = [], this.xSteps = [ singleStep || !1 ], this.xNumSteps = [ !1 ], 
                this.xHighestCompleteStep = [], this.snap = snap;
                var ordered = [];
                for (index in entry) entry.hasOwnProperty(index) && ordered.push([ entry[index], index ]);
                for (ordered.sort(ordered.length && "object" == typeof ordered[0][0] ? function(a, b) {
                    return a[0][0] - b[0][0];
                } : function(a, b) {
                    return a[0] - b[0];
                }), index = 0; index < ordered.length; index++) handleEntryPoint(ordered[index][1], ordered[index][0], this);
                for (this.xNumSteps = this.xSteps.slice(0), index = 0; index < this.xNumSteps.length; index++) handleStepPoint(index, this.xNumSteps[index], this);
            }
            Spectrum.prototype.getDistance = function(value) {
                var index, distances = [];
                for (index = 0; index < this.xNumSteps.length - 1; index++) {
                    var step = this.xNumSteps[index];
                    if (step && value / step % 1 != 0) throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' of " + this.xPct[index] + "% range must be divisible by step.");
                    distances[index] = fromPercentage(this.xVal, value, index);
                }
                return distances;
            }, Spectrum.prototype.getAbsoluteDistance = function(value, distances, direction) {
                var start_factor, xPct_index = 0;
                if (value < this.xPct[this.xPct.length - 1]) for (;value > this.xPct[xPct_index + 1]; ) xPct_index++; else value === this.xPct[this.xPct.length - 1] && (xPct_index = this.xPct.length - 2);
                direction || value !== this.xPct[xPct_index + 1] || xPct_index++;
                var rest_factor = 1, rest_rel_distance = distances[xPct_index], range_pct = 0, rel_range_distance = 0, abs_distance_counter = 0, range_counter = 0;
                for (start_factor = direction ? (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]) : (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]); rest_rel_distance > 0; ) range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter], 
                distances[xPct_index + range_counter] * rest_factor + 100 - 100 * start_factor > 100 ? (rel_range_distance = range_pct * start_factor, 
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter], 
                start_factor = 1) : (rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor, 
                rest_factor = 0), direction ? (abs_distance_counter -= rel_range_distance, this.xPct.length + range_counter >= 1 && range_counter--) : (abs_distance_counter += rel_range_distance, 
                this.xPct.length - range_counter >= 1 && range_counter++), rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
                return value + abs_distance_counter;
            }, Spectrum.prototype.toStepping = function(value) {
                return function(xVal, xPct, value) {
                    if (value >= xVal.slice(-1)[0]) return 100;
                    var j = getJ(value, xVal), pa = xPct[j - 1], pb = xPct[j];
                    return pa + function(range, value) {
                        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
                    }([ xVal[j - 1], xVal[j] ], value) / subRangeRatio(pa, pb);
                }(this.xVal, this.xPct, value);
            }, Spectrum.prototype.fromStepping = function(value) {
                return function(xVal, xPct, value) {
                    if (value >= 100) return xVal.slice(-1)[0];
                    var j = getJ(value, xPct), pa = xPct[j - 1];
                    return function(range, value) {
                        return value * (range[1] - range[0]) / 100 + range[0];
                    }([ xVal[j - 1], xVal[j] ], (value - pa) * subRangeRatio(pa, xPct[j]));
                }(this.xVal, this.xPct, value);
            }, Spectrum.prototype.getStep = function(value) {
                return function(xPct, xSteps, snap, value) {
                    if (100 === value) return value;
                    var j = getJ(value, xPct), a = xPct[j - 1], b = xPct[j];
                    return snap ? value - a > (b - a) / 2 ? b : a : xSteps[j - 1] ? xPct[j - 1] + function(value, to) {
                        return Math.round(value / to) * to;
                    }(value - xPct[j - 1], xSteps[j - 1]) : value;
                }(this.xPct, this.xSteps, this.snap, value);
            }, Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
                var j = getJ(value, this.xPct);
                return (100 === value || isDown && value === this.xPct[j - 1]) && (j = Math.max(j - 1, 1)), 
                (this.xVal[j] - this.xVal[j - 1]) / size;
            }, Spectrum.prototype.getNearbySteps = function(value) {
                var j = getJ(value, this.xPct);
                return {
                    stepBefore: {
                        startValue: this.xVal[j - 2],
                        step: this.xNumSteps[j - 2],
                        highestStep: this.xHighestCompleteStep[j - 2]
                    },
                    thisStep: {
                        startValue: this.xVal[j - 1],
                        step: this.xNumSteps[j - 1],
                        highestStep: this.xHighestCompleteStep[j - 1]
                    },
                    stepAfter: {
                        startValue: this.xVal[j],
                        step: this.xNumSteps[j],
                        highestStep: this.xHighestCompleteStep[j]
                    }
                };
            }, Spectrum.prototype.countStepDecimals = function() {
                var stepDecimals = this.xNumSteps.map(countDecimals);
                return Math.max.apply(null, stepDecimals);
            }, Spectrum.prototype.convert = function(value) {
                return this.getStep(this.toStepping(value));
            };
            var defaultFormatter = {
                to: function(value) {
                    return void 0 !== value && value.toFixed(2);
                },
                from: Number
            }, cssClasses = {
                target: "target",
                base: "base",
                origin: "origin",
                handle: "handle",
                handleLower: "handle-lower",
                handleUpper: "handle-upper",
                touchArea: "touch-area",
                horizontal: "horizontal",
                vertical: "vertical",
                background: "background",
                connect: "connect",
                connects: "connects",
                ltr: "ltr",
                rtl: "rtl",
                textDirectionLtr: "txt-dir-ltr",
                textDirectionRtl: "txt-dir-rtl",
                draggable: "draggable",
                drag: "state-drag",
                tap: "state-tap",
                active: "active",
                tooltip: "tooltip",
                pips: "pips",
                pipsHorizontal: "pips-horizontal",
                pipsVertical: "pips-vertical",
                marker: "marker",
                markerHorizontal: "marker-horizontal",
                markerVertical: "marker-vertical",
                markerNormal: "marker-normal",
                markerLarge: "marker-large",
                markerSub: "marker-sub",
                value: "value",
                valueHorizontal: "value-horizontal",
                valueVertical: "value-vertical",
                valueNormal: "value-normal",
                valueLarge: "value-large",
                valueSub: "value-sub"
            };
            function validateFormat(entry) {
                if (function(entry) {
                    return "object" == typeof entry && "function" == typeof entry.to && "function" == typeof entry.from;
                }(entry)) return !0;
                throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
            }
            function testStep(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
                parsed.singleStep = entry;
            }
            function testKeyboardPageMultiplier(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'keyboardPageMultiplier' is not numeric.");
                parsed.keyboardPageMultiplier = entry;
            }
            function testKeyboardDefaultStep(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'keyboardDefaultStep' is not numeric.");
                parsed.keyboardDefaultStep = entry;
            }
            function testRange(parsed, entry) {
                if ("object" != typeof entry || Array.isArray(entry)) throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
                if (void 0 === entry.min || void 0 === entry.max) throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
                if (entry.min === entry.max) throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
                parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
            }
            function testStart(parsed, entry) {
                if (entry = asArray(entry), !Array.isArray(entry) || !entry.length) throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
                parsed.handles = entry.length, parsed.start = entry;
            }
            function testSnap(parsed, entry) {
                if (parsed.snap = entry, "boolean" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
            }
            function testAnimate(parsed, entry) {
                if (parsed.animate = entry, "boolean" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
            }
            function testAnimationDuration(parsed, entry) {
                if (parsed.animationDuration = entry, "number" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
            }
            function testConnect(parsed, entry) {
                var i, connect = [ !1 ];
                if ("lower" === entry ? entry = [ !0, !1 ] : "upper" === entry && (entry = [ !1, !0 ]), 
                !0 === entry || !1 === entry) {
                    for (i = 1; i < parsed.handles; i++) connect.push(entry);
                    connect.push(!1);
                } else {
                    if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
                    connect = entry;
                }
                parsed.connect = connect;
            }
            function testOrientation(parsed, entry) {
                switch (entry) {
                  case "horizontal":
                    parsed.ort = 0;
                    break;

                  case "vertical":
                    parsed.ort = 1;
                    break;

                  default:
                    throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
                }
            }
            function testMargin(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
                0 !== entry && (parsed.margin = parsed.spectrum.getDistance(entry));
            }
            function testLimit(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
                if (parsed.limit = parsed.spectrum.getDistance(entry), !parsed.limit || parsed.handles < 2) throw new Error("noUiSlider (" + VERSION + "): 'limit' option is only supported on linear sliders with 2 or more handles.");
            }
            function testPadding(parsed, entry) {
                var index;
                if (!isNumeric(entry) && !Array.isArray(entry)) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers.");
                if (Array.isArray(entry) && 2 !== entry.length && !isNumeric(entry[0]) && !isNumeric(entry[1])) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers.");
                if (0 !== entry) {
                    for (Array.isArray(entry) || (entry = [ entry, entry ]), parsed.padding = [ parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1]) ], 
                    index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number(s).");
                    if ((entry[0] + entry[1]) / (parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1] - parsed.spectrum.xVal[0]) > 1) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must not exceed 100% of the range.");
                }
            }
            function testDirection(parsed, entry) {
                switch (entry) {
                  case "ltr":
                    parsed.dir = 0;
                    break;

                  case "rtl":
                    parsed.dir = 1;
                    break;

                  default:
                    throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
                }
            }
            function testBehaviour(parsed, entry) {
                if ("string" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
                var tap = entry.indexOf("tap") >= 0, drag = entry.indexOf("drag") >= 0, fixed = entry.indexOf("fixed") >= 0, snap = entry.indexOf("snap") >= 0, hover = entry.indexOf("hover") >= 0, unconstrained = entry.indexOf("unconstrained") >= 0;
                if (fixed) {
                    if (2 !== parsed.handles) throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
                    testMargin(parsed, parsed.start[1] - parsed.start[0]);
                }
                if (unconstrained && (parsed.margin || parsed.limit)) throw new Error("noUiSlider (" + VERSION + "): 'unconstrained' behaviour cannot be used with margin or limit");
                parsed.events = {
                    tap: tap || snap,
                    drag,
                    fixed,
                    snap,
                    hover,
                    unconstrained
                };
            }
            function testTooltips(parsed, entry) {
                if (!1 !== entry) if (!0 === entry) {
                    parsed.tooltips = [];
                    for (var i = 0; i < parsed.handles; i++) parsed.tooltips.push(!0);
                } else {
                    if (parsed.tooltips = asArray(entry), parsed.tooltips.length !== parsed.handles) throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
                    parsed.tooltips.forEach(function(formatter) {
                        if ("boolean" != typeof formatter && ("object" != typeof formatter || "function" != typeof formatter.to)) throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
                    });
                }
            }
            function testAriaFormat(parsed, entry) {
                parsed.ariaFormat = entry, validateFormat(entry);
            }
            function testFormat(parsed, entry) {
                parsed.format = entry, validateFormat(entry);
            }
            function testKeyboardSupport(parsed, entry) {
                if (parsed.keyboardSupport = entry, "boolean" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'keyboardSupport' option must be a boolean.");
            }
            function testDocumentElement(parsed, entry) {
                parsed.documentElement = entry;
            }
            function testCssPrefix(parsed, entry) {
                if ("string" != typeof entry && !1 !== entry) throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
                parsed.cssPrefix = entry;
            }
            function testCssClasses(parsed, entry) {
                if ("object" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
                if ("string" == typeof parsed.cssPrefix) for (var key in parsed.cssClasses = {}, 
                entry) entry.hasOwnProperty(key) && (parsed.cssClasses[key] = parsed.cssPrefix + entry[key]); else parsed.cssClasses = entry;
            }
            function testOptions(options) {
                var parsed = {
                    margin: 0,
                    limit: 0,
                    padding: 0,
                    animate: !0,
                    animationDuration: 300,
                    ariaFormat: defaultFormatter,
                    format: defaultFormatter
                }, tests = {
                    step: {
                        r: !1,
                        t: testStep
                    },
                    keyboardPageMultiplier: {
                        r: !1,
                        t: testKeyboardPageMultiplier
                    },
                    keyboardDefaultStep: {
                        r: !1,
                        t: testKeyboardDefaultStep
                    },
                    start: {
                        r: !0,
                        t: testStart
                    },
                    connect: {
                        r: !0,
                        t: testConnect
                    },
                    direction: {
                        r: !0,
                        t: testDirection
                    },
                    snap: {
                        r: !1,
                        t: testSnap
                    },
                    animate: {
                        r: !1,
                        t: testAnimate
                    },
                    animationDuration: {
                        r: !1,
                        t: testAnimationDuration
                    },
                    range: {
                        r: !0,
                        t: testRange
                    },
                    orientation: {
                        r: !1,
                        t: testOrientation
                    },
                    margin: {
                        r: !1,
                        t: testMargin
                    },
                    limit: {
                        r: !1,
                        t: testLimit
                    },
                    padding: {
                        r: !1,
                        t: testPadding
                    },
                    behaviour: {
                        r: !0,
                        t: testBehaviour
                    },
                    ariaFormat: {
                        r: !1,
                        t: testAriaFormat
                    },
                    format: {
                        r: !1,
                        t: testFormat
                    },
                    tooltips: {
                        r: !1,
                        t: testTooltips
                    },
                    keyboardSupport: {
                        r: !0,
                        t: testKeyboardSupport
                    },
                    documentElement: {
                        r: !1,
                        t: testDocumentElement
                    },
                    cssPrefix: {
                        r: !0,
                        t: testCssPrefix
                    },
                    cssClasses: {
                        r: !0,
                        t: testCssClasses
                    }
                }, defaults = {
                    connect: !1,
                    direction: "ltr",
                    behaviour: "tap",
                    orientation: "horizontal",
                    keyboardSupport: !0,
                    cssPrefix: "noUi-",
                    cssClasses,
                    keyboardPageMultiplier: 5,
                    keyboardDefaultStep: 10
                };
                options.format && !options.ariaFormat && (options.ariaFormat = options.format), 
                Object.keys(tests).forEach(function(name) {
                    if (!isSet(options[name]) && void 0 === defaults[name]) {
                        if (tests[name].r) throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
                        return !0;
                    }
                    tests[name].t(parsed, isSet(options[name]) ? options[name] : defaults[name]);
                }), parsed.pips = options.pips;
                var d = document.createElement("div");
                return parsed.transformRule = void 0 !== d.style.transform ? "transform" : void 0 !== d.style.msTransform ? "msTransform" : "webkitTransform", 
                parsed.style = [ [ "left", "top" ], [ "right", "bottom" ] ][parsed.dir][parsed.ort], 
                parsed;
            }
            function scope(target, options, originalOptions) {
                var scope_Base, scope_Handles, scope_Connects, scope_Pips, scope_Tooltips, scope_Self, behaviour, addTarget, actions = window.navigator.pointerEnabled ? {
                    start: "pointerdown",
                    move: "pointermove",
                    end: "pointerup"
                } : window.navigator.msPointerEnabled ? {
                    start: "MSPointerDown",
                    move: "MSPointerMove",
                    end: "MSPointerUp"
                } : {
                    start: "mousedown touchstart",
                    move: "mousemove touchmove",
                    end: "mouseup touchend"
                }, supportsPassive = window.CSS && CSS.supports && CSS.supports("touch-action", "none") && function() {
                    var supportsPassive = !1;
                    try {
                        var opts = Object.defineProperty({}, "passive", {
                            get: function() {
                                supportsPassive = !0;
                            }
                        });
                        window.addEventListener("test", null, opts);
                    } catch (e) {}
                    return supportsPassive;
                }(), scope_Target = target, scope_Spectrum = options.spectrum, scope_Values = [], scope_Locations = [], scope_HandleNumbers = [], scope_ActiveHandlesCount = 0, scope_Events = {}, scope_Document = target.ownerDocument, scope_DocumentElement = options.documentElement || scope_Document.documentElement, scope_Body = scope_Document.body, PIPS_NONE = -1, PIPS_NO_VALUE = 0, PIPS_LARGE_VALUE = 1, PIPS_SMALL_VALUE = 2, scope_DirOffset = "rtl" === scope_Document.dir || 1 === options.ort ? 0 : 100;
                function addNodeTo(addTarget, className) {
                    var div = scope_Document.createElement("div");
                    return className && addClass(div, className), addTarget.appendChild(div), div;
                }
                function addOrigin(base, handleNumber) {
                    var origin = addNodeTo(base, options.cssClasses.origin), handle = addNodeTo(origin, options.cssClasses.handle);
                    return addNodeTo(handle, options.cssClasses.touchArea), handle.setAttribute("data-handle", handleNumber), 
                    options.keyboardSupport && (handle.setAttribute("tabindex", "0"), handle.addEventListener("keydown", function(event) {
                        return function(event, handleNumber) {
                            if (isSliderDisabled() || isHandleDisabled(handleNumber)) return !1;
                            var horizontalKeys = [ "Left", "Right" ], verticalKeys = [ "Down", "Up" ], largeStepKeys = [ "PageDown", "PageUp" ], edgeKeys = [ "Home", "End" ];
                            options.dir && !options.ort ? horizontalKeys.reverse() : options.ort && !options.dir && (verticalKeys.reverse(), 
                            largeStepKeys.reverse());
                            var to, key = event.key.replace("Arrow", ""), isLargeDown = key === largeStepKeys[0], isLargeUp = key === largeStepKeys[1], isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown, isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp, isMax = key === edgeKeys[1];
                            if (!(isDown || isUp || key === edgeKeys[0] || isMax)) return !0;
                            if (event.preventDefault(), isUp || isDown) {
                                var multiplier = options.keyboardPageMultiplier, direction = isDown ? 0 : 1, step = getNextStepsForHandle(handleNumber)[direction];
                                if (null === step) return !1;
                                !1 === step && (step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep)), 
                                (isLargeUp || isLargeDown) && (step *= multiplier), step = Math.max(step, 1e-7), 
                                to = scope_Values[handleNumber] + (step *= isDown ? -1 : 1);
                            } else to = isMax ? options.spectrum.xVal[options.spectrum.xVal.length - 1] : options.spectrum.xVal[0];
                            return setHandle(handleNumber, scope_Spectrum.toStepping(to), !0, !0), fireEvent("slide", handleNumber), 
                            fireEvent("update", handleNumber), fireEvent("change", handleNumber), fireEvent("set", handleNumber), 
                            !1;
                        }(event, handleNumber);
                    })), handle.setAttribute("role", "slider"), handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal"), 
                    0 === handleNumber ? addClass(handle, options.cssClasses.handleLower) : handleNumber === options.handles - 1 && addClass(handle, options.cssClasses.handleUpper), 
                    origin;
                }
                function addConnect(base, add) {
                    return !!add && addNodeTo(base, options.cssClasses.connect);
                }
                function addTooltip(handle, handleNumber) {
                    return !!options.tooltips[handleNumber] && addNodeTo(handle.firstChild, options.cssClasses.tooltip);
                }
                function isSliderDisabled() {
                    return scope_Target.hasAttribute("disabled");
                }
                function isHandleDisabled(handleNumber) {
                    return scope_Handles[handleNumber].hasAttribute("disabled");
                }
                function removeTooltips() {
                    scope_Tooltips && (removeEvent("update.tooltips"), scope_Tooltips.forEach(function(tooltip) {
                        tooltip && removeElement(tooltip);
                    }), scope_Tooltips = null);
                }
                function tooltips() {
                    removeTooltips(), scope_Tooltips = scope_Handles.map(addTooltip), bindEvent("update.tooltips", function(values, handleNumber, unencoded) {
                        if (scope_Tooltips[handleNumber]) {
                            var formattedValue = values[handleNumber];
                            !0 !== options.tooltips[handleNumber] && (formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber])), 
                            scope_Tooltips[handleNumber].innerHTML = formattedValue;
                        }
                    });
                }
                function removePips() {
                    scope_Pips && (removeElement(scope_Pips), scope_Pips = null);
                }
                function pips(grid) {
                    removePips();
                    var mode = grid.mode, filter = grid.filter || !1, spread = function(density, mode, group) {
                        var array, indexes = {}, firstInRange = scope_Spectrum.xVal[0], lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1], ignoreFirst = !1, ignoreLast = !1, prevPct = 0;
                        return (array = group.slice().sort(function(a, b) {
                            return a - b;
                        }), group = array.filter(function(a) {
                            return !this[a] && (this[a] = !0);
                        }, {}))[0] !== firstInRange && (group.unshift(firstInRange), ignoreFirst = !0), 
                        group[group.length - 1] !== lastInRange && (group.push(lastInRange), ignoreLast = !0), 
                        group.forEach(function(current, index) {
                            var step, i, q, newPct, pctDifference, pctPos, type, realSteps, stepSize, low = current, high = group[index + 1], isSteps = "steps" === mode;
                            if (isSteps && (step = scope_Spectrum.xNumSteps[index]), step || (step = high - low), 
                            !1 !== low) for (void 0 === high && (high = low), step = Math.max(step, 1e-7), i = low; i <= high; i = (i + step).toFixed(7) / 1) {
                                for (stepSize = (pctDifference = (newPct = scope_Spectrum.toStepping(i)) - prevPct) / (realSteps = Math.round(pctDifference / density)), 
                                q = 1; q <= realSteps; q += 1) indexes[(pctPos = prevPct + q * stepSize).toFixed(5)] = [ scope_Spectrum.fromStepping(pctPos), 0 ];
                                type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE, 
                                !index && ignoreFirst && i !== high && (type = 0), i === high && ignoreLast || (indexes[newPct.toFixed(5)] = [ i, type ]), 
                                prevPct = newPct;
                            }
                        }), indexes;
                    }(grid.density || 1, mode, function(mode, values, stepped) {
                        if ("range" === mode || "steps" === mode) return scope_Spectrum.xVal;
                        if ("count" === mode) {
                            if (values < 2) throw new Error("noUiSlider (" + VERSION + "): 'values' (>= 2) required for mode 'count'.");
                            var interval = values - 1, spread = 100 / interval;
                            for (values = []; interval--; ) values[interval] = interval * spread;
                            values.push(100), mode = "positions";
                        }
                        return "positions" === mode ? values.map(function(value) {
                            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                        }) : "values" === mode ? stepped ? values.map(function(value) {
                            return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                        }) : values : void 0;
                    }(mode, grid.values || !1, grid.stepped || !1)), format = grid.format || {
                        to: Math.round
                    };
                    return scope_Pips = scope_Target.appendChild(function(spread, filterFunc, formatter) {
                        var element = scope_Document.createElement("div"), valueSizeClasses = [];
                        valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal, valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge, 
                        valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;
                        var markerSizeClasses = [];
                        markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal, markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge, 
                        markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;
                        var valueOrientationClasses = [ options.cssClasses.valueHorizontal, options.cssClasses.valueVertical ], markerOrientationClasses = [ options.cssClasses.markerHorizontal, options.cssClasses.markerVertical ];
                        function getClasses(type, source) {
                            var a = source === options.cssClasses.value;
                            return source + " " + (a ? valueOrientationClasses : markerOrientationClasses)[options.ort] + " " + (a ? valueSizeClasses : markerSizeClasses)[type];
                        }
                        return addClass(element, options.cssClasses.pips), addClass(element, 0 === options.ort ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical), 
                        Object.keys(spread).forEach(function(offset) {
                            !function(offset, value, type) {
                                if ((type = filterFunc ? filterFunc(value, type) : type) !== PIPS_NONE) {
                                    var node = addNodeTo(element, !1);
                                    node.className = getClasses(type, options.cssClasses.marker), node.style[options.style] = offset + "%", 
                                    type > PIPS_NO_VALUE && ((node = addNodeTo(element, !1)).className = getClasses(type, options.cssClasses.value), 
                                    node.setAttribute("data-value", value), node.style[options.style] = offset + "%", 
                                    node.innerHTML = formatter.to(value));
                                }
                            }(offset, spread[offset][0], spread[offset][1]);
                        }), element;
                    }(spread, filter, format));
                }
                function baseSize() {
                    var rect = scope_Base.getBoundingClientRect(), alt = "offset" + [ "Width", "Height" ][options.ort];
                    return 0 === options.ort ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
                }
                function attachEvent(events, element, callback, data) {
                    var method = function(e) {
                        return !!(e = function(e, pageOffset, eventTarget) {
                            var x, y, touch = 0 === e.type.indexOf("touch"), mouse = 0 === e.type.indexOf("mouse"), pointer = 0 === e.type.indexOf("pointer");
                            if (0 === e.type.indexOf("MSPointer") && (pointer = !0), "mousedown" === e.type && !e.buttons && !e.touches) return !1;
                            if (touch) {
                                var isTouchOnTarget = function(checkTouch) {
                                    return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target) || checkTouch.target.shadowRoot && checkTouch.target.shadowRoot.contains(eventTarget);
                                };
                                if ("touchstart" === e.type) {
                                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                                    if (targetTouches.length > 1) return !1;
                                    x = targetTouches[0].pageX, y = targetTouches[0].pageY;
                                } else {
                                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                                    if (!targetTouch) return !1;
                                    x = targetTouch.pageX, y = targetTouch.pageY;
                                }
                            }
                            return pageOffset = pageOffset || getPageOffset(scope_Document), (mouse || pointer) && (x = e.clientX + pageOffset.x, 
                            y = e.clientY + pageOffset.y), e.pageOffset = pageOffset, e.points = [ x, y ], e.cursor = mouse || pointer, 
                            e;
                        }(e, data.pageOffset, data.target || element)) && !(isSliderDisabled() && !data.doNotReject) && (className = options.cssClasses.tap, 
                        !(((el = scope_Target).classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className)) && !data.doNotReject)) && !(events === actions.start && void 0 !== e.buttons && e.buttons > 1) && (!data.hover || !e.buttons) && (supportsPassive || e.preventDefault(), 
                        e.calcPoint = e.points[options.ort], void callback(e, data));
                        var el, className;
                    }, methods = [];
                    return events.split(" ").forEach(function(eventName) {
                        var options = !!supportsPassive && {
                            passive: !0
                        };
                        element.addEventListener(eventName, method, options), methods.push([ eventName, method, options ]);
                    }), methods;
                }
                function calcPointToPercentage(calcPoint) {
                    var elem, orientation, rect, doc, docElem, pageOffset, proposal = 100 * (calcPoint - (orientation = options.ort, 
                    rect = (elem = scope_Base).getBoundingClientRect(), docElem = (doc = elem.ownerDocument).documentElement, 
                    pageOffset = getPageOffset(doc), /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (pageOffset.x = 0), 
                    orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft)) / baseSize();
                    return proposal = limit(proposal), options.dir ? 100 - proposal : proposal;
                }
                function documentLeave(event, data) {
                    "mouseout" === event.type && "HTML" === event.target.nodeName && null === event.relatedTarget && eventEnd(event, data);
                }
                function eventMove(event, data) {
                    if (-1 === navigator.appVersion.indexOf("MSIE 9") && 0 === event.buttons && 0 !== data.buttonsProperty) return eventEnd(event, data);
                    var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
                    moveHandles(movement > 0, 100 * movement / data.baseSize, data.locations, data.handleNumbers);
                }
                function eventEnd(event, data) {
                    data.handle && (removeClass(data.handle, options.cssClasses.active), scope_ActiveHandlesCount -= 1), 
                    data.listeners.forEach(function(c) {
                        scope_DocumentElement.removeEventListener(c[0], c[1], c[2]);
                    }), 0 === scope_ActiveHandlesCount && (removeClass(scope_Target, options.cssClasses.drag), 
                    setZindex(), event.cursor && (scope_Body.style.cursor = "", scope_Body.removeEventListener("selectstart", preventDefault))), 
                    data.handleNumbers.forEach(function(handleNumber) {
                        fireEvent("change", handleNumber), fireEvent("set", handleNumber), fireEvent("end", handleNumber);
                    });
                }
                function eventStart(event, data) {
                    if (data.handleNumbers.some(isHandleDisabled)) return !1;
                    var handle;
                    1 === data.handleNumbers.length && (scope_ActiveHandlesCount += 1, addClass(handle = scope_Handles[data.handleNumbers[0]].children[0], options.cssClasses.active)), 
                    event.stopPropagation();
                    var listeners = [], moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                        target: event.target,
                        handle,
                        listeners,
                        startCalcPoint: event.calcPoint,
                        baseSize: baseSize(),
                        pageOffset: event.pageOffset,
                        handleNumbers: data.handleNumbers,
                        buttonsProperty: event.buttons,
                        locations: scope_Locations.slice()
                    }), endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                        target: event.target,
                        handle,
                        listeners,
                        doNotReject: !0,
                        handleNumbers: data.handleNumbers
                    }), outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                        target: event.target,
                        handle,
                        listeners,
                        doNotReject: !0,
                        handleNumbers: data.handleNumbers
                    });
                    listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)), event.cursor && (scope_Body.style.cursor = getComputedStyle(event.target).cursor, 
                    scope_Handles.length > 1 && addClass(scope_Target, options.cssClasses.drag), scope_Body.addEventListener("selectstart", preventDefault, !1)), 
                    data.handleNumbers.forEach(function(handleNumber) {
                        fireEvent("start", handleNumber);
                    });
                }
                function bindEvent(namespacedEvent, callback) {
                    scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [], scope_Events[namespacedEvent].push(callback), 
                    "update" === namespacedEvent.split(".")[0] && scope_Handles.forEach(function(a, index) {
                        fireEvent("update", index);
                    });
                }
                function removeEvent(namespacedEvent) {
                    var event = namespacedEvent && namespacedEvent.split(".")[0], namespace = event && namespacedEvent.substring(event.length);
                    Object.keys(scope_Events).forEach(function(bind) {
                        var tEvent = bind.split(".")[0], tNamespace = bind.substring(tEvent.length);
                        event && event !== tEvent || namespace && namespace !== tNamespace || delete scope_Events[bind];
                    });
                }
                function fireEvent(eventName, handleNumber, tap) {
                    Object.keys(scope_Events).forEach(function(targetEvent) {
                        var eventType = targetEvent.split(".")[0];
                        eventName === eventType && scope_Events[targetEvent].forEach(function(callback) {
                            callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || !1, scope_Locations.slice(), scope_Self);
                        });
                    });
                }
                function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
                    var distance;
                    return scope_Handles.length > 1 && !options.events.unconstrained && (lookBackward && handleNumber > 0 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, 0), 
                    to = Math.max(to, distance)), lookForward && handleNumber < scope_Handles.length - 1 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, 1), 
                    to = Math.min(to, distance))), scope_Handles.length > 1 && options.limit && (lookBackward && handleNumber > 0 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, 0), 
                    to = Math.min(to, distance)), lookForward && handleNumber < scope_Handles.length - 1 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, 1), 
                    to = Math.max(to, distance))), options.padding && (0 === handleNumber && (distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], 0), 
                    to = Math.max(to, distance)), handleNumber === scope_Handles.length - 1 && (distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], 1), 
                    to = Math.min(to, distance))), !((to = limit(to = scope_Spectrum.getStep(to))) === reference[handleNumber] && !getValue) && to;
                }
                function inRuleOrder(v, a) {
                    var o = options.ort;
                    return (o ? a : v) + ", " + (o ? v : a);
                }
                function moveHandles(upward, proposal, locations, handleNumbers) {
                    var proposals = locations.slice(), b = [ !upward, upward ], f = [ upward, !upward ];
                    handleNumbers = handleNumbers.slice(), upward && handleNumbers.reverse(), handleNumbers.length > 1 ? handleNumbers.forEach(function(handleNumber, o) {
                        var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], !1);
                        !1 === to ? proposal = 0 : (proposal = to - proposals[handleNumber], proposals[handleNumber] = to);
                    }) : b = f = [ !0 ];
                    var state = !1;
                    handleNumbers.forEach(function(handleNumber, o) {
                        state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
                    }), state && handleNumbers.forEach(function(handleNumber) {
                        fireEvent("update", handleNumber), fireEvent("slide", handleNumber);
                    });
                }
                function transformDirection(a, b) {
                    return options.dir ? 100 - a - b : a;
                }
                function setZindex() {
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        scope_Handles[handleNumber].style.zIndex = 3 + (scope_Handles.length + (scope_Locations[handleNumber] > 50 ? -1 : 1) * handleNumber);
                    });
                }
                function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
                    return exactInput || (to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, !1)), 
                    !1 !== to && (function(handleNumber, to) {
                        scope_Locations[handleNumber] = to, scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
                        var translateRule = "translate(" + inRuleOrder(10 * (transformDirection(to, 0) - scope_DirOffset) + "%", "0") + ")";
                        scope_Handles[handleNumber].style[options.transformRule] = translateRule, updateConnect(handleNumber), 
                        updateConnect(handleNumber + 1);
                    }(handleNumber, to), !0);
                }
                function updateConnect(index) {
                    if (scope_Connects[index]) {
                        var l = 0, h = 100;
                        0 !== index && (l = scope_Locations[index - 1]), index !== scope_Connects.length - 1 && (h = scope_Locations[index]);
                        var connectWidth = h - l, translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")", scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
                        scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
                    }
                }
                function resolveToValue(to, handleNumber) {
                    return null === to || !1 === to || void 0 === to ? scope_Locations[handleNumber] : ("number" == typeof to && (to = String(to)), 
                    to = options.format.from(to), !1 === (to = scope_Spectrum.toStepping(to)) || isNaN(to) ? scope_Locations[handleNumber] : to);
                }
                function valueSet(input, fireSetEvent, exactInput) {
                    var values = asArray(input);
                    fireSetEvent = void 0 === fireSetEvent || !!fireSetEvent, options.animate && !(void 0 === scope_Locations[0]) && addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration), 
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), !0, !1, exactInput);
                    });
                    for (var i = 1 === scope_HandleNumbers.length ? 0 : 1; i < scope_HandleNumbers.length; ++i) scope_HandleNumbers.forEach(function(handleNumber) {
                        setHandle(handleNumber, scope_Locations[handleNumber], !0, !0, exactInput);
                    });
                    setZindex(), scope_HandleNumbers.forEach(function(handleNumber) {
                        fireEvent("update", handleNumber), null !== values[handleNumber] && fireSetEvent && fireEvent("set", handleNumber);
                    });
                }
                function valueGet() {
                    var values = scope_Values.map(options.format.to);
                    return 1 === values.length ? values[0] : values;
                }
                function getNextStepsForHandle(handleNumber) {
                    var location = scope_Locations[handleNumber], nearbySteps = scope_Spectrum.getNearbySteps(location), value = scope_Values[handleNumber], increment = nearbySteps.thisStep.step, decrement = null;
                    if (options.snap) return [ value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null ];
                    !1 !== increment && value + increment > nearbySteps.stepAfter.startValue && (increment = nearbySteps.stepAfter.startValue - value), 
                    decrement = value > nearbySteps.thisStep.startValue ? nearbySteps.thisStep.step : !1 !== nearbySteps.stepBefore.step && value - nearbySteps.stepBefore.highestStep, 
                    100 === location ? increment = null : 0 === location && (decrement = null);
                    var stepDecimals = scope_Spectrum.countStepDecimals();
                    return null !== increment && !1 !== increment && (increment = Number(increment.toFixed(stepDecimals))), 
                    null !== decrement && !1 !== decrement && (decrement = Number(decrement.toFixed(stepDecimals))), 
                    [ decrement, increment ];
                }
                return addClass(addTarget = scope_Target, options.cssClasses.target), addClass(addTarget, 0 === options.dir ? options.cssClasses.ltr : options.cssClasses.rtl), 
                addClass(addTarget, 0 === options.ort ? options.cssClasses.horizontal : options.cssClasses.vertical), 
                addClass(addTarget, "rtl" === getComputedStyle(addTarget).direction ? options.cssClasses.textDirectionRtl : options.cssClasses.textDirectionLtr), 
                scope_Base = addNodeTo(addTarget, options.cssClasses.base), function(connectOptions, base) {
                    var connectBase = addNodeTo(base, options.cssClasses.connects);
                    scope_Handles = [], (scope_Connects = []).push(addConnect(connectBase, connectOptions[0]));
                    for (var i = 0; i < options.handles; i++) scope_Handles.push(addOrigin(base, i)), 
                    scope_HandleNumbers[i] = i, scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
                }(options.connect, scope_Base), (behaviour = options.events).fixed || scope_Handles.forEach(function(handle, index) {
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [ index ]
                    });
                }), behaviour.tap && attachEvent(actions.start, scope_Base, function(event) {
                    event.stopPropagation();
                    var proposal = calcPointToPercentage(event.calcPoint), handleNumber = function(clickedPosition) {
                        var smallestDifference = 100, handleNumber = !1;
                        return scope_Handles.forEach(function(handle, index) {
                            if (!isHandleDisabled(index)) {
                                var handlePosition = scope_Locations[index], differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
                                (differenceWithThisHandle < smallestDifference || differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition || 100 === differenceWithThisHandle && 100 === smallestDifference) && (handleNumber = index, 
                                smallestDifference = differenceWithThisHandle);
                            }
                        }), handleNumber;
                    }(proposal);
                    if (!1 === handleNumber) return !1;
                    options.events.snap || addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration), 
                    setHandle(handleNumber, proposal, !0, !0), setZindex(), fireEvent("slide", handleNumber, !0), 
                    fireEvent("update", handleNumber, !0), fireEvent("change", handleNumber, !0), fireEvent("set", handleNumber, !0), 
                    options.events.snap && eventStart(event, {
                        handleNumbers: [ handleNumber ]
                    });
                }, {}), behaviour.hover && attachEvent(actions.move, scope_Base, function(event) {
                    var proposal = calcPointToPercentage(event.calcPoint), to = scope_Spectrum.getStep(proposal), value = scope_Spectrum.fromStepping(to);
                    Object.keys(scope_Events).forEach(function(targetEvent) {
                        "hover" === targetEvent.split(".")[0] && scope_Events[targetEvent].forEach(function(callback) {
                            callback.call(scope_Self, value);
                        });
                    });
                }, {
                    hover: !0
                }), behaviour.drag && scope_Connects.forEach(function(connect, index) {
                    if (!1 !== connect && 0 !== index && index !== scope_Connects.length - 1) {
                        var handleBefore = scope_Handles[index - 1], handleAfter = scope_Handles[index], eventHolders = [ connect ];
                        addClass(connect, options.cssClasses.draggable), behaviour.fixed && (eventHolders.push(handleBefore.children[0]), 
                        eventHolders.push(handleAfter.children[0])), eventHolders.forEach(function(eventHolder) {
                            attachEvent(actions.start, eventHolder, eventStart, {
                                handles: [ handleBefore, handleAfter ],
                                handleNumbers: [ index - 1, index ]
                            });
                        });
                    }
                }), valueSet(options.start), options.pips && pips(options.pips), options.tooltips && tooltips(), 
                bindEvent("update", function(values, handleNumber, unencoded, tap, positions) {
                    scope_HandleNumbers.forEach(function(index) {
                        var handle = scope_Handles[index], min = checkHandlePosition(scope_Locations, index, 0, !0, !0, !0), max = checkHandlePosition(scope_Locations, index, 100, !0, !0, !0), now = positions[index];
                        options.ariaFormat.to(unencoded[index]), min = scope_Spectrum.fromStepping(min).toFixed(0), 
                        max = scope_Spectrum.fromStepping(max).toFixed(0), now = scope_Spectrum.fromStepping(now).toFixed(0), 
                        handle.children[0].setAttribute("aria-valuemin", min), handle.children[0].setAttribute("aria-valuemax", max), 
                        handle.children[0].setAttribute("aria-valuenow", now);
                    });
                }), scope_Self = {
                    destroy: function() {
                        for (var key in options.cssClasses) options.cssClasses.hasOwnProperty(key) && removeClass(scope_Target, options.cssClasses[key]);
                        for (;scope_Target.firstChild; ) scope_Target.removeChild(scope_Target.firstChild);
                        delete scope_Target.noUiSlider;
                    },
                    steps: function() {
                        return scope_HandleNumbers.map(getNextStepsForHandle);
                    },
                    on: bindEvent,
                    off: removeEvent,
                    get: valueGet,
                    set: valueSet,
                    setHandle: function(handleNumber, value, fireSetEvent, exactInput) {
                        if (!((handleNumber = Number(handleNumber)) >= 0 && handleNumber < scope_HandleNumbers.length)) throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);
                        setHandle(handleNumber, resolveToValue(value, handleNumber), !0, !0, exactInput), 
                        fireEvent("update", handleNumber), fireSetEvent && fireEvent("set", handleNumber);
                    },
                    reset: function(fireSetEvent) {
                        valueSet(options.start, fireSetEvent);
                    },
                    __moveHandles: function(a, b, c) {
                        moveHandles(a, b, scope_Locations, c);
                    },
                    options: originalOptions,
                    updateOptions: function(optionsToUpdate, fireSetEvent) {
                        var v = valueGet(), updateAble = [ "margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips" ];
                        updateAble.forEach(function(name) {
                            void 0 !== optionsToUpdate[name] && (originalOptions[name] = optionsToUpdate[name]);
                        });
                        var newOptions = testOptions(originalOptions);
                        updateAble.forEach(function(name) {
                            void 0 !== optionsToUpdate[name] && (options[name] = newOptions[name]);
                        }), scope_Spectrum = newOptions.spectrum, options.margin = newOptions.margin, options.limit = newOptions.limit, 
                        options.padding = newOptions.padding, options.pips ? pips(options.pips) : removePips(), 
                        options.tooltips ? tooltips() : removeTooltips(), scope_Locations = [], valueSet(optionsToUpdate.start || v, fireSetEvent);
                    },
                    target: scope_Target,
                    removePips,
                    removeTooltips,
                    getTooltips: function() {
                        return scope_Tooltips;
                    },
                    getOrigins: function() {
                        return scope_Handles;
                    },
                    pips
                };
            }
            return {
                __spectrum: Spectrum,
                version: VERSION,
                cssClasses,
                create: function(target, originalOptions) {
                    if (!target || !target.nodeName) throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
                    if (target.noUiSlider) throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
                    var api = scope(target, testOptions(originalOptions), originalOptions);
                    return target.noUiSlider = api, api;
                }
            };
        }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, []) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    },
    11956: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            DefaultInnerTickSize: function() {
                return DefaultInnerTickSize;
            },
            DefaultRotation: function() {
                return DefaultRotation;
            },
            DefaultRotationForYAxisHierarchy: function() {
                return DefaultRotationForYAxisHierarchy;
            },
            DefaultVerticalRotation: function() {
                return DefaultVerticalRotation;
            },
            Mockable: function() {
                return Mockable;
            },
            StackedAxisPadding: function() {
                return StackedAxisPadding;
            },
            adjustDomainWithConstantPixelDifference: function() {
                return adjustDomainWithConstantPixelDifference;
            },
            assertScalarDomain: function() {
                return assertScalarDomain;
            },
            axisFactory: function() {
                return axisFactory;
            },
            createAxis: function() {
                return createAxis;
            },
            createAxisLabel: function() {
                return createAxisLabel;
            },
            createD3Scale_Band: function() {
                return createD3Scale_Band;
            },
            createD3Scale_Numeric: function() {
                return createD3Scale_Numeric;
            },
            createDomain: function() {
                return createDomain;
            },
            createFormatter: function() {
                return createFormatter;
            },
            createScalarDomainOptions: function() {
                return createScalarDomainOptions;
            },
            createScale: function() {
                return createScale;
            },
            createStackedD3Axis: function() {
                return createStackedD3Axis;
            },
            createUncertaintyAwareValueDomain: function() {
                return createUncertaintyAwareValueDomain;
            },
            createValueDomain: function() {
                return createValueDomain;
            },
            defaultTickFormat: function() {
                return defaultTickFormat;
            },
            emptyDomain: function() {
                return emptyDomain;
            },
            ensureValuesInRange: function() {
                return ensureValuesInRange;
            },
            extendCreateAxisOptions: function() {
                return extendCreateAxisOptions;
            },
            generateScalarDomainSources: function() {
                return generateScalarDomainSources;
            },
            getAxisFormatString: function() {
                return getAxisFormatString;
            },
            getBestNumberOfTicks: function() {
                return getBestNumberOfTicks;
            },
            getCategoryThickness: function() {
                return getCategoryThickness;
            },
            getCategoryValueType: function() {
                return getCategoryValueType;
            },
            getHierStack: function() {
                return getHierStack;
            },
            getMaxWidth: function() {
                return getMaxWidth;
            },
            getMergedUserDomains: function() {
                return getMergedUserDomains;
            },
            getNumHierarchyLevels: function() {
                return getNumHierarchyLevels;
            },
            getRecommendedNumberOfTicksForXAxis: function() {
                return getRecommendedNumberOfTicksForXAxis;
            },
            getRecommendedNumberOfTicksForYAxis: function() {
                return getRecommendedNumberOfTicksForYAxis;
            },
            getRecommendedTickValues: function() {
                return getRecommendedTickValues;
            },
            getTickLabelMargins: function() {
                return getTickLabelMargins;
            },
            hasForcedDomain: function() {
                return hasForcedDomain;
            },
            invertOrdinalScale: function() {
                return invertOrdinalScale;
            },
            invertOrdinalSimpleScaleWithDirection: function() {
                return invertOrdinalSimpleScaleWithDirection;
            },
            invertScale: function() {
                return invertScale;
            },
            isHierarchical: function() {
                return isHierarchical;
            },
            isLogScaleAllowedFunc: function() {
                return isLogScaleAllowedFunc;
            },
            isOrdinalAxisDomain: function() {
                return isOrdinalAxisDomain;
            },
            isScalarAxisDomain: function() {
                return isScalarAxisDomain;
            },
            isStackedAxisProperties: function() {
                return isStackedAxisProperties;
            },
            mergeDomains: function() {
                return mergeDomains;
            },
            mergeScalarAxisDomains: function() {
                return mergeScalarAxisDomains;
            },
            powerOfTen: function() {
                return powerOfTen;
            },
            rotate: function() {
                return rotate;
            },
            scaleShouldClamp: function() {
                return scaleShouldClamp;
            },
            shouldIncludeZero: function() {
                return shouldIncludeZero;
            },
            willLabelsFit: function() {
                return willLabelsFit;
            },
            willLabelsWordBreak: function() {
                return willLabelsWordBreak;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(81337), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62458), _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41640), _VisualsCommon_Errors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(68365), _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(32041), _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(64329), _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(66001), _Visuals_types_axisStyle__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(41414), _VisualsData_formatting_dateTimeSequence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45059), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(72489), _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28326), _VisualsData_types_valueType__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(80777), _Visuals_common_axisTickCollisionUtils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(37274), _Visuals_common_converterHelper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(54522), _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18664), _Visuals_common_textUtil__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(44977), _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53197), _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(34969), emptyDomain = [ 0, 0 ], XLabelMaxAllowedOverflow = 35, MinTickCount = 2, DefaultBestTickCount = 3, LeftPadding = 10, ScalarTickLabelPadding = 3, StackedAxisPadding = 5, DefaultInnerTickSize = 6;
        function getRecommendedNumberOfTicksForXAxis(availableWidth) {
            return availableWidth < 300 ? 3 : availableWidth < 500 ? 5 : 8;
        }
        function getRecommendedNumberOfTicksForYAxis(availableWidth) {
            return availableWidth < 150 ? 3 : availableWidth < 300 ? 5 : 8;
        }
        function axisFactory(scale, orientation) {
            switch (orientation) {
              case _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.top:
                return d3.axisTop(scale);

              case _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.right:
                return d3.axisRight(scale);

              case _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.bottom:
                return d3.axisBottom(scale);

              case _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.left:
                return d3.axisLeft(scale);

              default:
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertNever(orientation);
            }
        }
        function defaultTickFormat(datum) {
            return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.warn('Using default (unformatted) tickFormat for value "'.concat(datum, '"')), 
            "".concat(datum);
        }
        function getBestNumberOfTicks(_a, valuesMetadata, maxTickCount, dateTime, allowSingleScalarTick) {
            var min = _a[0], max = _a[1];
            return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return maxTickCount >= 0;
            }, "maxTickCount must be greater or equal to zero"), isNaN(min) || isNaN(max) ? DefaultBestTickCount : min === max ? allowSingleScalarTick || dateTime ? 1 : DefaultBestTickCount : (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return min <= max;
            }, "min value needs to be less or equal to max value"), maxTickCount <= 1 || max <= 1 && min >= -1 || valuesMetadata.some(function(metadata) {
                return (null == metadata ? void 0 : metadata.type) && !metadata.type.integer;
            }) ? maxTickCount : Math.min(max - min + 1, maxTickCount));
        }
        function getRecommendedTickValues(options, createScaleResult) {
            var _a = options.axis, logAxisScale = (void 0 === _a ? {} : _a).logAxisScale, isScalar = options.isScalar, domainOptions = options.domainOptions, isLogScaleAllowed = options.isLogScaleAllowed, axisType = options.valueType, minTickInterval = options.minTickInterval, scale = createScaleResult.scale, maxTicks = createScaleResult.bestTickCount;
            if (createScaleResult.isInvalidDomain) return [];
            if (isScalar && !_.isEmpty(null == domainOptions ? void 0 : domainOptions.domain) && 1 === maxTicks) return [ null == domainOptions ? void 0 : domainOptions.domain[0] ];
            if (!isScalar || (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(scale)) return function(maxTicks, labels) {
                if (maxTicks <= 0) return [];
                var len = labels.length;
                if (maxTicks > len) return labels;
                for (var tickLabels = [], i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) tickLabels.push(labels[i]);
                return tickLabels;
            }(maxTicks, scale.domain());
            if ((0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.v9)(axisType)) return function(maxTicks, dataDomain) {
                return 0 === dataDomain[0] && 0 === dataDomain[1] ? [] : ensureValuesInRange(_VisualsData_formatting_dateTimeSequence__WEBPACK_IMPORTED_MODULE_3__.EP.calculate(_VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3.fromTimeValue(dataDomain[0]), _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3.fromTimeValue(dataDomain[1]), maxTicks).sequence.map(function(d) {
                    return d.getTime();
                }), dataDomain[0], dataDomain[1]);
            }(maxTicks, scale.domain());
            var tickValues = function(maxTicks, quantitativeScale, minInterval, logAxisScale) {
                if (!quantitativeScale.ticks) return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("must pass a quantitative scale to this method"), 
                [];
                if (maxTicks <= 1) return [];
                var tickCount = maxTicks, tickLabels = quantitativeScale.ticks(tickCount);
                if (tickLabels.length > maxTicks && maxTicks > 1) {
                    var domain = quantitativeScale.domain();
                    tickCount = function(start, stop, count) {
                        var step = (stop - start) / count, power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
                        if (error >= Math.sqrt(50)) {
                            var newStep_1 = Math.sqrt(2) * Math.pow(10, power + 1);
                            return Math.floor((stop - start) / newStep_1);
                        }
                        if (error >= Math.sqrt(10)) {
                            var newStep_2 = Math.sqrt(50) * Math.pow(10, power);
                            return Math.floor((stop - start) / newStep_2);
                        }
                        if (error >= Math.sqrt(2)) {
                            var newStep_3 = Math.sqrt(10) * Math.pow(10, power);
                            return Math.floor((stop - start) / newStep_3);
                        }
                        var newStep = Math.sqrt(2) * Math.pow(10, power);
                        return Math.floor((stop - start) / newStep);
                    }(domain[0], domain[1], tickLabels.length), tickLabels = quantitativeScale.ticks(tickCount);
                }
                if (tickLabels.length < MinTickCount && (tickLabels = quantitativeScale.ticks(tickCount = maxTicks + 1)), 
                minInterval && tickLabels.length > 1) for (var tickInterval = tickLabels[1] - tickLabels[0]; tickInterval > 0 && (0, 
                _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__.Po)(tickInterval, minInterval) && tickCount > 2; ) {
                    if (tickCount--, (tickLabels = quantitativeScale.ticks(tickCount)).length < MinTickCount) {
                        tickLabels = quantitativeScale.ticks(++tickCount);
                        break;
                    }
                    tickInterval = tickLabels[1] - tickLabels[0];
                }
                return tickLabels.length <= 1 ? [] : (logAxisScale || (tickLabels = function(ticks, epsilon) {
                    if (void 0 === epsilon && (epsilon = 1e-5), !ticks || ticks.length < 2) return ticks;
                    var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                    return ticks.map(function(tick) {
                        return Math.abs(tick) <= closeZero ? 0 : tick;
                    });
                }(tickLabels)), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return 0 === tickLabels.length || (0, _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__.bA)(tickLabels[0], quantitativeScale.domain()[0], _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__.BM) && (0, 
                    _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__.bl)(tickLabels[tickLabels.length - 1], quantitativeScale.domain()[1], _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__.BM);
                }, "getRecommendedTickValuesForAQuantitativeRange should not generate tick values outside the scale"), 
                tickLabels);
            }(maxTicks, scale, minTickInterval, logAxisScale);
            if (logAxisScale && isLogScaleAllowed) for (var powerOfTwo_1 = 0; tickValues.length > 10; ) tickValues = tickValues.filter(function(d) {
                return powerOfTen(d, powerOfTwo_1);
            }), powerOfTwo_1++;
            return tickValues;
        }
        function extendFlatDomain_IfNotUserSource(domain, sources, extendBy) {
            var userSourceMin = 10 === (null == sources ? void 0 : sources[0]), userSourceMax = 10 === (null == sources ? void 0 : sources[1]), skipUserSettings = userSourceMax && userSourceMin && domain[0] >= domain[1];
            userSourceMin && !skipUserSettings || (domain[0] -= Math.abs(extendBy[0]), sources && (sources[0] = 0)), 
            userSourceMax && !skipUserSettings || (domain[1] += Math.abs(extendBy[1]), sources && (sources[1] = 0));
        }
        function getTickLabelMargins(options) {
            var plotArea = options.plotArea, yMarginLimit = options.yMarginLimit, textHeightMeasurer = options.textHeightMeasurer, textWidthMeasurer = options.textWidthMeasurer, axes = options.axes, bottomMarginLimit = options.bottomMarginLimit, axesFontProperties = options.axesFontProperties, rotate90 = options.rotate90, showOnRight = options.showY1OnRight, _a = options.shouldRenderAxis, renderXAxis = _a.x, renderY1Axis = _a.y, renderY2Axis = _a.y2, numHierarchyLevels = getNumHierarchyLevels(axes), hasHierarchy = null != numHierarchyLevels && numHierarchyLevels > 0;
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(plotArea, "options.plotArea"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(axes, "axes");
            var xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2;
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(plotArea, "plotArea"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(textWidthMeasurer, "textWidthMeasurer"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(textHeightMeasurer, "textHeightMeasurer"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(xAxisProperties, "xAxis"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(y1AxisProperties, "yAxis");
            var xLabels = xAxisProperties.values, leftOverflow = 0, rightOverflow = 0, topOverflow = 0, bottomOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness * (null != xAxisProperties.innerPaddingRatio ? .5 - xAxisProperties.innerPaddingRatio / 2 : 0) : 0, scaleIsOrdinal = (0, 
            _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(xAxisProperties.scale), xLabelOuterPadding = 0;
            void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (plotArea.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2));
            var xTextHeight, yTextHeight, canRenderXAxis = renderXAxis && !_.isEmpty(xLabels);
            if (0 !== getRecommendedNumberOfTicksForXAxis(plotArea.width) || 0 !== getRecommendedNumberOfTicksForYAxis(plotArea.height)) {
                var rotation = rotate90 || hasHierarchy && xAxisProperties.isCategoryAxis ? DefaultVerticalRotation : DefaultRotation;
                if (renderY1Axis) {
                    var margins, y1TickFontProperties = axesFontProperties.y.tickLabels;
                    y1AxisProperties.categoryIdentities && (y1TickFontProperties = (0, _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_5__.ED)(y1TickFontProperties, {
                        weight: "700"
                    })), maxWidthY1 = (margins = Mockable.getAxisTickLabelMargins(y1AxisProperties, y1TickFontProperties, textWidthMeasurer, textHeightMeasurer)).maxWidth, 
                    topOverflow = Math.max(topOverflow, margins.overflow.top), bottomOverflow = Math.max(bottomOverflow, margins.overflow.bottom), 
                    yTextHeight = margins.textHeight;
                }
                y2AxisProperties && renderY2Axis && (maxWidthY2 = (margins = Mockable.getAxisTickLabelMargins(y2AxisProperties, axesFontProperties.y2.tickLabels, textWidthMeasurer, textHeightMeasurer)).maxWidth, 
                topOverflow = Math.max(topOverflow, margins.overflow.top), bottomOverflow = Math.max(bottomOverflow, margins.overflow.bottom));
                var xAxisLabelFontProperties = axesFontProperties.x.tickLabels, xTextProperties = (0, 
                _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_5__.qk)(xAxisLabelFontProperties), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                if (xTextHeight = textHeightMeasurer(xTextProperties), canRenderXAxis) {
                    var maxNumLines = Math.floor(bottomMarginLimit / xTextHeight);
                    xAxisProperties.categoryIdentities && !xAxisProperties.willLabelsWordBreak && (xTextProperties.fontWeight = "700");
                    for (var i = 0, len = xLabels.length; i < len; i++) {
                        var height = void 0;
                        xTextProperties.text = xLabels[i];
                        var width = textWidthMeasurer(xTextProperties);
                        if (xAxisProperties.willLabelsWordBreak) {
                            var maxWidth = _.isEmpty(xAxisProperties.categoryLabelMaxWidths) ? xAxisProperties.xLabelMaxWidth : xAxisProperties.categoryLabelMaxWidths[i];
                            height = (0, _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_6__.ql)(xTextProperties.text, xTextProperties, textWidthMeasurer, maxWidth, maxNumLines).length * xTextHeight, 
                            width = maxWidth;
                        } else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
                            var defaultOrSmaller = xAxisLabelFontProperties.size.pt <= _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.rZ;
                            height = width * rotation.sine + (defaultOrSmaller ? 0 : xTextHeight * rotation.cosine), 
                            width = width * rotation.cosine + (defaultOrSmaller ? 0 : xTextHeight * rotation.sine);
                        } else height = xTextHeight + -5;
                        if (0 === i) {
                            if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                            leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                var overflow = 0;
                                overflow = width / 2 - (xPos = xScale(xDomain[xAxisProperties.invertAxis ? 1 : 0])), 
                                overflow = Math.max(overflow, 0), xAxisProperties.invertAxis && showOnRight ? rightOverflow = overflow : leftOverflow = overflow;
                            }
                        } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                        rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                            overflow = 0;
                            var xPos = xScale(xDomain[xAxisProperties.invertAxis ? 0 : 1]);
                            overflow = width / 2 - (plotArea.width - xPos), overflow = Math.max(overflow, 0), 
                            xAxisProperties.invertAxis && showOnRight ? leftOverflow = overflow : rightOverflow = overflow;
                        }
                        xMax = Math.max(xMax, height);
                    }
                    leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow), rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
                }
            }
            var stackHeight, rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.max(bottomOverflow, Math.ceil(xMax)), bottomMarginLimit);
            if (showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
            rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
            rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), hasHierarchy) {
                var marginAdjust = function() {
                    return stackHeight * (numHierarchyLevels - 1);
                };
                xAxisProperties.isCategoryAxis && canRenderXAxis ? (stackHeight = xTextHeight + StackedAxisPadding, 
                bottomMargin += marginAdjust()) : y1AxisProperties.isCategoryAxis && renderY1Axis ? (stackHeight = yTextHeight + StackedAxisPadding, 
                showOnRight ? rightMargin += marginAdjust() : leftMargin += marginAdjust()) : stackHeight = 0;
            }
            return {
                yTop: Math.ceil(topOverflow),
                yLeft: Math.ceil(leftMargin),
                yBottom: Math.ceil(bottomOverflow),
                yRight: Math.ceil(rightMargin),
                xMax: Math.ceil(bottomMargin),
                stackHeight,
                axesOverflow: {
                    top: Math.ceil(topOverflow),
                    bottom: Math.ceil(bottomOverflow),
                    left: Math.ceil(leftOverflow),
                    right: Math.ceil(rightOverflow)
                }
            };
        }
        var Mockable = {
            getAxisTickLabelMargins: function(axisProperties, fontProperties, textWidthMeasurer, textHeightMeasurer) {
                var _a, axisStartValue, axisEndValue, scale = axisProperties.scale, tickValues = axisProperties.d3Axis.tickValues();
                if (_.isEmpty(tickValues)) return {
                    maxWidth: 0,
                    overflow: {
                        top: 0,
                        bottom: 0
                    }
                };
                if ((0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(scale)) axisStartValue = (_a = scale.range())[0], 
                axisEndValue = _a[1]; else {
                    var range = scale.range();
                    axisStartValue = _.head(range), axisEndValue = _.last(range);
                }
                var axisTopPosition, axisTopLabelPosition, axisBottomPosition, axisBottomLabelPosition, labels = axisProperties.values;
                axisStartValue < axisEndValue ? (axisTopPosition = axisStartValue, axisTopLabelPosition = scale(_.head(tickValues)), 
                axisBottomPosition = axisEndValue, axisBottomLabelPosition = scale(_.last(tickValues))) : (axisTopPosition = axisEndValue, 
                axisTopLabelPosition = scale(_.last(tickValues)), axisBottomPosition = axisStartValue, 
                axisBottomLabelPosition = scale(_.head(tickValues)));
                for (var textProperties = (0, _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_5__.qk)(fontProperties, "".concat(_.head(labels))), textHeight = textHeightMeasurer(textProperties), topOverflow = Math.max(0, -(axisTopLabelPosition - textHeight / 2 - axisTopPosition)), bottomOverflow = Math.max(0, axisBottomLabelPosition + textHeight / 2 - axisBottomPosition), maxWidth = 0, i = 0, len = labels.length; i < len; i++) textProperties.text = "".concat(labels[i]), 
                maxWidth = Math.max(maxWidth, textWidthMeasurer(textProperties));
                return {
                    maxWidth,
                    overflow: {
                        top: topOverflow,
                        bottom: bottomOverflow
                    },
                    textHeight
                };
            }
        };
        function invertScale(scale, x, direction, directionMode, categorySubRangeCount) {
            return (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(scale) ? 0 === direction ? {
                value: invertOrdinalScale(scale, x)
            } : invertOrdinalSimpleScaleWithDirection(scale, x, direction, directionMode, categorySubRangeCount) : {
                value: scale.invert(x)
            };
        }
        function scaleRange(scale) {
            return (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(scale) ? scale.domain().map(function(domain) {
                return scale(domain);
            }) : scale.range();
        }
        function getCategoryThickness(scale) {
            var leftEdges = scaleRange(scale);
            if (leftEdges.length < 2) {
                if ((0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(scale)) {
                    var rangeExtent = scale.range();
                    return rangeExtent[1] - rangeExtent[0];
                }
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("Unsupported axis type");
            }
            return leftEdges[1] - leftEdges[0];
        }
        function invertOrdinalScale(scale, x) {
            var width = scale.bandwidth(), range = scaleRange(scale), domain = scale.domain();
            return range.length < 2 || range[0] > x ? domain[0] || 0 : domain[d3.bisect(range, x + (range[1] - range[0] - width) / 2) - 1];
        }
        function invertOrdinalSimpleScaleWithDirection(scale, x, direction, directionMode, categorySubRangeCount) {
            var range = scaleRange(scale), domain = scale.domain(), subRangeCount = categorySubRangeCount || 1, subBandwidth = scale.bandwidth() / subRangeCount;
            if (0 !== domain.length) {
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return !_.some(domain, function(n, index) {
                        return 0 !== index && n !== domain[index - 1] + 1;
                    });
                });
                var includeCenterAdjustment = 1 === directionMode ? subBandwidth / 2 : 0;
                if (range[0] + includeCenterAdjustment > x) {
                    if (1 === direction) return;
                    return {
                        value: domain[0],
                        seriesIndex: 0
                    };
                }
                if (!(x > range[range.length - 1] + subBandwidth * subRangeCount - includeCenterAdjustment && -1 === direction)) {
                    var adjustment = includeCenterAdjustment * direction * -1, innerPadding = range[1] - range[0] - subBandwidth * subRangeCount;
                    if (subRangeCount > 1) {
                        var rangeIndex_1 = d3.bisect(range, x) - 1, subRangeStart_1 = scale(domain[rangeIndex_1]), subRange = _.map(d3.range(subRangeCount), function(d) {
                            return d * subBandwidth + subRangeStart_1;
                        }), subRangeIndex = d3.bisect(subRange, x + adjustment) - 1;
                        return subRangeIndex < 0 ? {
                            value: domain[rangeIndex_1 - 1],
                            seriesIndex: subRangeCount - 1
                        } : -1 === direction && subRangeIndex === subRangeCount - 1 && rangeIndex_1 !== range.length - 1 && x + adjustment + innerPadding > range[rangeIndex_1 + 1] ? {
                            value: domain[rangeIndex_1 + 1],
                            seriesIndex: 0
                        } : {
                            value: domain[rangeIndex_1],
                            seriesIndex: subRangeIndex
                        };
                    }
                    -1 === direction && (adjustment += innerPadding);
                    var rangeIndex = d3.bisect(range, x + adjustment) - 1;
                    return {
                        value: domain[rangeIndex],
                        seriesIndex: 0
                    };
                }
            }
        }
        function adjustDomainWithConstantPixelDifference(currentDomainMin, currentDomainMax, newDomainMin, newDomainMax) {
            if (newDomainMin < currentDomainMin || newDomainMax > currentDomainMax) {
                var clippedDomainX = Math.abs(Math.min(newDomainMin - currentDomainMin, 0)), clippedDomainY = Math.max(newDomainMax - currentDomainMax, 0), oldExtent = currentDomainMax - currentDomainMin, finalDomainMin = currentDomainMin - clippedDomainX * Math.pow(oldExtent, 2) / ((oldExtent - clippedDomainY) * (oldExtent - clippedDomainX) - clippedDomainX * clippedDomainY);
                return {
                    domain: [ finalDomainMin, currentDomainMax + clippedDomainY * (currentDomainMax - finalDomainMin) / (oldExtent - clippedDomainY) ],
                    adjusted: !0
                };
            }
            return {
                domain: void 0,
                adjusted: !1
            };
        }
        function createDomain(data, axisType, isScalar, includeDomains) {
            if (isScalar && !(0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.c$)(axisType)) {
                if (0 === data.length) return;
                var values = _.flatMap(data, function(kv) {
                    return _.flatMap(kv.data, function(d) {
                        return [ null == d ? void 0 : d.categoryValue ];
                    });
                });
                return mergeScalarAxisDomains.apply(void 0, (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([ createScalarDomainOptions(d3.extent(values), 0) ], includeDomains || [], !1));
            }
            var domain = [];
            if (!_.isEmpty(data)) for (var _i = 0, _a = data[0].data; _i < _a.length; _i++) {
                var dp = _a[_i];
                dp.highlight || domain.push(dp.categoryIndex);
            }
            return {
                domain,
                type: 0
            };
        }
        function assertScalarDomain(domain) {
            if (2 !== domain.length && !_.every(domain, function(value) {
                return null == value || _.isNumber(value);
            })) throw new _VisualsCommon_Errors__WEBPACK_IMPORTED_MODULE_9__.wJ("CartesianAxisScalarDomain");
        }
        function ensureValuesInRange(values, min, max) {
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return min <= max;
            }, "min must be less or equal to max");
            var filteredValues = values.filter(function(v) {
                return v >= min && v <= max;
            });
            return filteredValues.length >= 2 ? filteredValues : [ min, max ];
        }
        function getCategoryValueType(metadataColumn, isScalar) {
            return (dataType = null == metadataColumn ? void 0 : metadataColumn.type) && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime) ? metadataColumn.type : _VisualsData_types_valueType__WEBPACK_IMPORTED_MODULE_10__.Ge.fromDescriptor(isScalar ? {
                numeric: !0
            } : {
                text: !0
            });
            var dataType;
        }
        function shouldIncludeZero(includeYDomain) {
            var domain = null == includeYDomain ? void 0 : includeYDomain.domain;
            if (!domain || 2 !== domain.length) return !0;
            var domainSources = includeYDomain.domainSources;
            return !((10 === domainSources[0] ? domain[0] : void 0) > 0 || (10 === domainSources[1] ? domain[1] : void 0) < 0);
        }
        function createAxis(options) {
            var axisProperties = createAxisImpl(options);
            return options.axisZoom && !options.skipAxisZoomUpdate && (options.axisZoom.updateAxisOptions(axisProperties, options), 
            axisProperties = createAxisImpl(options)), axisProperties;
        }
        function extendCreateAxisOptions(options) {
            var _a, isScalar = options.isScalar, _b = options.axis.logAxisScale, logAxisScale = void 0 !== _b && _b, _c = options.orientation, orientation = void 0 === _c ? options.isVertical ? _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.left : _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.bottom : _c, metaDataColumn = options.metaDataColumn, _d = options.outerPadding, outerPadding = void 0 === _d ? 0 : _d, _e = options.innerPaddingRatio, innerPaddingRatio = void 0 === _e ? _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.$B : _e, _f = options.outerPaddingRatio, outerPaddingRatio = void 0 === _f ? 0 : _f, dataDomain = null === (_a = options.domainOptions) || void 0 === _a ? void 0 : _a.domain, valueType = getCategoryValueType(metaDataColumn instanceof Array ? (0, 
            _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.GN)(metaDataColumn) : metaDataColumn, isScalar), isLogScaleAllowed = isLogScaleAllowedFunc(dataDomain, valueType);
            return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, 
            tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, options), {
                isLogScaleAllowed,
                valueType,
                minTickInterval: isScalar ? getMinTickValueInterval(options.formatString, valueType, options.is100Pct) : void 0,
                hasDisallowedZeroInDomain: isScalar && !isLogScaleAllowed && logAxisScale,
                orientation,
                innerPaddingRatio,
                outerPaddingRatio,
                outerPadding: 0 === outerPadding && isScalar && options.isVertical ? 1 : outerPadding
            }), options.isCategoryAxis && function(dataType, formatString, axisDisplayUnits, dataDomain) {
                var _a;
                return !(!dataType || formatString && "0" !== formatString && "g" !== formatString && "G" !== formatString || axisDisplayUnits && 1 !== axisDisplayUnits || !(null === (_a = dataType.temporal) || void 0 === _a ? void 0 : _a.year) && !(dataType.integer && 2 === (null == dataDomain ? void 0 : dataDomain.length) && isFourOrFewerDigitInteger(dataDomain[0]) && isFourOrFewerDigitInteger(dataDomain[1])));
            }(valueType, options.formatString, options.axis.labelDisplayUnits, dataDomain) ? {
                formatString: "0",
                useTickIntervalForDisplayUnits: !1
            } : {});
        }
        function createAxisImpl(options) {
            var _a, extOptions = extendCreateAxisOptions(options), _b = extOptions.domainOptions, dataDomain = (void 0 === _b ? {} : _b).domain, createScaleResult = createScale(extOptions), scale = createScaleResult.scale, bestTickCount = createScaleResult.bestTickCount, scaleDomain = scale.domain(), categoryThickness = options.categoryThickness;
            if (categoryThickness && extOptions.isScalar && 2 === (null == dataDomain ? void 0 : dataDomain.length)) {
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return !(dataDomain[0] instanceof Date) || dataDomain[0] instanceof _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3;
                }, "The domain has to be a no-Date object or a PBIFormattingDate");
                var oldSpan = dataDomain[1] - dataDomain[0], newSpan = scaleDomain[1] - scaleDomain[0];
                oldSpan > 0 && newSpan > 0 && (categoryThickness = categoryThickness * oldSpan / newSpan);
            }
            var xLabelMaxWidth, categoryLabelMaxWidths, tickValues = getRecommendedTickValues(extOptions, createScaleResult), formatter = createFormatter(createScaleResult, extOptions, tickValues), d3axis = axisFactory(scale, extOptions.orientation).tickSizeInner(DefaultInnerTickSize).tickSizeOuter(0).ticks(bestTickCount).tickValues(tickValues);
            return !extOptions.isScalar && categoryThickness ? xLabelMaxWidth = Math.max(1, categoryThickness - 2 * _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.Fv) : tickValues.length > 1 ? (xLabelMaxWidth = function(scale, tickValues) {
                return scale && !_.isEmpty(tickValues) ? Math.abs(scale(tickValues[1]) - scale(tickValues[0])) : 1;
            }(scale, tickValues), xLabelMaxWidth -= 2 * ScalarTickLabelPadding, extOptions.margin && (categoryLabelMaxWidths = function(scale, tickValues, margin, outerPadding, maxLabelWidth) {
                var xLabelMaxWidths = _.times(tickValues.length, _.constant(maxLabelWidth)), marginLeft = margin.left, marginRight = margin.right, firstTickPosition = scale(_.head(tickValues)), lastTickPosition = scale(_.last(tickValues)), range = scaleRange(scale), axisEndPosition = range[1], firstLabelMaxAllowedSpace = 2 * (Math.abs(firstTickPosition - range[0]) + marginLeft + outerPadding), lastLabelMaxAllowedSpace = 2 * (Math.abs(lastTickPosition - axisEndPosition) + marginRight + outerPadding);
                return xLabelMaxWidths[0] = Math.min(firstLabelMaxAllowedSpace, maxLabelWidth), 
                xLabelMaxWidths[tickValues.length - 1] = Math.min(lastLabelMaxAllowedSpace, maxLabelWidth), 
                xLabelMaxWidths;
            }(scale, tickValues, extOptions.margin, extOptions.outerPadding, xLabelMaxWidth), 
            xLabelMaxWidth = void 0)) : xLabelMaxWidth = options.pixelSpan - 2 * ScalarTickLabelPadding, 
            {
                scale: createScaleResult.scale,
                isInvalidDomain: createScaleResult.isInvalidDomain,
                d3Axis: d3axis,
                formatter,
                values: _.isEmpty(extOptions.metaDataColumn) ? [] : formatAxisTickValues(d3axis, tickValues, formatter, extOptions.valueType, extOptions.getValueFn),
                axisLabel: (0, _Visuals_common_converterHelper__WEBPACK_IMPORTED_MODULE_11__.O1)(extOptions.metaDataColumn),
                xLabelMaxWidth,
                categoryLabelMaxWidths,
                categoryThickness,
                valueType: extOptions.valueType,
                isCategoryAxis: extOptions.isCategoryAxis,
                outerPadding: extOptions.outerPadding,
                outerPaddingRatio: extOptions.outerPaddingRatio,
                innerPaddingRatio: extOptions.innerPaddingRatio,
                isLogScaleAllowed: extOptions.isLogScaleAllowed,
                dataDomain: null === (_a = extOptions.domainOptions) || void 0 === _a ? void 0 : _a.domain,
                hasDisallowedZeroInDomain: extOptions.hasDisallowedZeroInDomain,
                invertAxis: extOptions.axis.invertAxis,
                orientation: extOptions.orientation
            };
        }
        function isFourOrFewerDigitInteger(n) {
            return _.isNumber(n) && n === Math.floor(n) && n > -1e4 && n < 1e4;
        }
        function createStackedD3Axis(options) {
            return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(options, "options is null or undefined"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(options.d3axis, "options.axis is null or undefined"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(options.scale, "options.scale is null or undefined"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(options.tickFormat, "options.tickFormat is null or undefined"), 
            axisFactory(options.scale, null != options.orient ? options.orient : _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Or.bottom).tickSizeInner(options.innerTickSize || 0).tickSizeOuter(options.outerTickSize || 0).ticks(options.d3axis.tickArguments()).tickValues(options.d3axis.tickValues()).tickFormat(options.tickFormat);
        }
        function createScale(options) {
            var pixelSpan = options.pixelSpan, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding, isScalar = options.isScalar, isVertical = options.isVertical, forcedTickCount = options.forcedTickCount, maxTickCount = options.maxTickCount, allowSingleScalarTick = options.allowSingleScalarTick, includeZero = options.includeZero, domainOptions = options.domainOptions, zeroScalarDomain = options.zeroScalarDomain, minTickInterval = options.minTickInterval, dataType = options.valueType, _a = options.axis, logAxisScale = _a.logAxisScale, invertAxis = _a.invertAxis, scalarDomainOptions = options.domainOptions, dataDomain = null == domainOptions ? void 0 : domainOptions.domain;
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return !allowSingleScalarTick || allowSingleScalarTick && isScalar;
            }, "allowSingleScalarTick should only be true if the chart is scalar"), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return !includeZero || isScalar && includeZero;
            }, "includeZero can only have an effect if the domain is scalar");
            var metadataColumnArray = metaDataColumn instanceof Array ? metaDataColumn : [ metaDataColumn ];
            if (null == dataDomain || 2 === dataDomain.length && null == dataDomain[0] && null == dataDomain[1] || 2 !== dataDomain.length && isScalar) return {
                isInvalidDomain: !0,
                scale: (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.c$)(dataType) ? createD3Scale_Band(options, dataType.dateTime ? emptyDomain : []) : createD3Scale_Numeric(options, emptyDomain, logAxisScale),
                bestTickCount: 0
            };
            var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
            maxTickCount && (maxTicks = Math.min(maxTicks, maxTickCount));
            var scale, bestTickCount = maxTicks, isLogScale = options.axis.logAxisScale && options.isLogScaleAllowed, domain = null == dataDomain ? void 0 : dataDomain.slice();
            if (domain && isScalar) {
                if (includeZero) {
                    var baselineValue = isLogScale ? _.every(domain, function(value) {
                        return value > 0;
                    }) ? 1 : -1 : 0;
                    domain[0] = Math.min(baselineValue, domain[0]), domain[domain.length - 1] = Math.max(baselineValue, domain[domain.length - 1]);
                }
                2 === domain.length && (assertScalarDomain(domain), bestTickCount = void 0 !== forcedTickCount ? 0 !== maxTicks ? forcedTickCount : 0 : getBestNumberOfTicks(domain, metadataColumnArray, maxTicks, dataType.dateTime, allowSingleScalarTick), 
                domain = function(domain, sources, minInterval, logAxisScale) {
                    return isNaN(domain[0]) || isNaN(domain[1]) ? emptyDomain : (domain[0] === domain[1] ? null == minInterval || .2 * Math.abs(domain[1]) >= minInterval ? extendFlatDomain_IfNotUserSource(domain, sources, [ .2 * domain[0], .2 * domain[1] ]) : 0 !== domain[1] && extendFlatDomain_IfNotUserSource(domain, sources, [ minInterval, minInterval ]) : logAxisScale || Math.abs(domain[0]) < 1e-4 && Math.abs(domain[0] / (domain[1] - domain[0])) < 1e-4 && 10 !== (null == sources ? void 0 : sources[0]) && (domain[0] = 0), 
                    domain);
                }(domain, scalarDomainOptions.domainSources, minTickInterval, logAxisScale));
            }
            return isScalar && (dataType.numeric || dataType.dateTime) ? (dataType.dateTime || (assertScalarDomain(domain), 
            2 === scalarDomainOptions.domain.length && 0 === scalarDomainOptions.domain[0] && 0 === scalarDomainOptions.domain[1] && zeroScalarDomain && (extendFlatDomain_IfNotUserSource(domain, scalarDomainOptions.domainSources, zeroScalarDomain), 
            void 0 === forcedTickCount && (bestTickCount = getBestNumberOfTicks(domain, metadataColumnArray, maxTicks, dataType.dateTime, allowSingleScalarTick)))), 
            scale = createD3Scale_Numeric(options, domain, isLogScale, bestTickCount)) : dataType.text || dataType.dateTime || dataType.numeric || dataType.bool ? (scale = createD3Scale_Band(options, domain), 
            bestTickCount = 0 === maxTicks ? 0 : Math.min(domain.length, (pixelSpan - 2 * outerPadding) / _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.jY)) : (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("unsupported dataType, something other than text or numeric"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return !!scale;
            }, "scale must be defined")), isVertical && isScalar && scale.range(scaleRange(scale).reverse()), 
            invertAxis && scale.range(scale.range().reverse()), function(scale) {
                for (var scaledDomain = scale.domain(), i = 0, len = scaledDomain.length; i < len; ++i) scaledDomain[i] === Number.POSITIVE_INFINITY ? scaledDomain[i] = Number.MAX_VALUE : scaledDomain[i] === Number.NEGATIVE_INFINITY && (scaledDomain[i] = -Number.MAX_VALUE);
                scale.domain(scaledDomain);
            }(scale), {
                scale,
                bestTickCount
            };
        }
        function createFormatter(_a, options, tickValues) {
            var bestTickCount = _a.bestTickCount, domainOptions = options.domainOptions, valueType = options.valueType, formatString = options.formatString, useTickIntervalForDisplayUnits = options.useTickIntervalForDisplayUnits, _b = options.axis, logAxisScale = _b.logAxisScale, labelPrecision = _b.labelPrecision, labelDisplayUnits = _b.labelDisplayUnits;
            if (options.isScalar) {
                if (valueType.dateTime) {
                    var scaleDomain = _a.scale.domain();
                    return (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_12__.Ue)({
                        format: formatString,
                        value: _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3.fromTimeValue(1 === bestTickCount ? domainOptions.domain[0] : scaleDomain[0]),
                        value2: _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3.fromTimeValue(1 === bestTickCount ? domainOptions.domain[0] : scaleDomain[1]),
                        tickCount: bestTickCount,
                        columnType: valueType
                    });
                }
                if (useTickIntervalForDisplayUnits && tickValues.length > 1) {
                    var minPrecisionTicks = [ tickValues[0], tickValues[1] ];
                    return logAxisScale && _.every(tickValues, function(value) {
                        return value <= 0;
                    }) && (minPrecisionTicks = [ tickValues[tickValues.length - 2], tickValues[tickValues.length - 1] ]), 
                    (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_12__.Ue)({
                        format: formatString,
                        value: labelDisplayUnits || minPrecisionTicks[1] - minPrecisionTicks[0],
                        value2: 0,
                        allowFormatBeautification: !0,
                        columnType: valueType,
                        precision: null != labelPrecision ? labelPrecision : (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.Gv)(minPrecisionTicks[0], minPrecisionTicks[1], labelDisplayUnits, formatString)
                    });
                }
                if (1 === tickValues.length) return (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_12__.Ue)({
                    format: formatString,
                    value: labelDisplayUnits || (useTickIntervalForDisplayUnits ? _.head(tickValues) : 0),
                    allowFormatBeautification: !0,
                    precision: labelPrecision
                });
            }
            return (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_12__.E3)(formatString, !0);
        }
        function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
            return getValueFn || (getValueFn = function(data) {
                return data;
            }), formatter ? (axis.tickFormat(function(d) {
                return formatter.format(getValueFn(d, dataType));
            }), tickValues.map(function(d) {
                return formatter.format(getValueFn(d, dataType));
            })) : tickValues.map(function(d) {
                return getValueFn(d, dataType);
            });
        }
        function getMinTickValueInterval(formatString, columnType, is100Pct) {
            if (formatString && !(0, _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.iH)(formatString)) {
                var precision = (0, _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.rH)(formatString, !0).precision;
                return formatString.indexOf("%") > -1 && (precision += 2), Math.pow(10, -precision);
            }
            return is100Pct ? .01 : columnType.integer ? 1 : 0;
        }
        function createValueDomain(data, includeZero) {
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(data, "data"), 
            0 === data.length) return null;
            var values = _.flatMap(data, function(kv) {
                return _.flatMap(kv.data, function(d) {
                    return [ null == d ? void 0 : d.value ];
                });
            });
            return includeZero && values.push(0), d3.extent(values);
        }
        function createUncertaintyAwareValueDomain(data, includeZero) {
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(data, "data"), 
            0 === data.length) return null;
            if (!_.some(data, function(series) {
                var _a;
                return null === (_a = series.uncertainty) || void 0 === _a ? void 0 : _a.renderUncertainty;
            })) return createValueDomain(data, includeZero);
            var minY = d3.min(data, function(kv) {
                var _a;
                return (null === (_a = kv.uncertainty) || void 0 === _a ? void 0 : _a.renderUncertainty) ? d3.min(kv.data, function(d) {
                    var _a;
                    return d && d3.min([ d.value, null === (_a = d.uncertainty) || void 0 === _a ? void 0 : _a.lower ]);
                }) : d3.min(kv.data, function(d) {
                    return d && d.value;
                });
            }), maxY = d3.max(data, function(kv) {
                var _a;
                return (null === (_a = kv.uncertainty) || void 0 === _a ? void 0 : _a.renderUncertainty) ? d3.max(kv.data, function(d) {
                    var _a;
                    return d && d3.max([ d.value, null === (_a = d.uncertainty) || void 0 === _a ? void 0 : _a.upper ]);
                }) : d3.max(kv.data, function(d) {
                    return d && d.value;
                });
            });
            return includeZero && (minY = null == minY ? 0 : Math.min(minY, 0), maxY = null == maxY ? 0 : Math.max(maxY, 0)), 
            [ minY, maxY ];
        }
        function getAxisFormatString(data) {
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(data, "data"), 
            data.length >= 1) for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var cartesianDataPoint = _.find(data_1[_i].data, function(dataPoint) {
                    return null == dataPoint ? void 0 : dataPoint.labelFormatString;
                });
                if (cartesianDataPoint) return cartesianDataPoint.labelFormatString;
            }
        }
        function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
            var labels = axisProperties.values;
            if (0 === labels.length) return !1;
            var labelMaxWidth = void 0 !== axisProperties.xLabelMaxWidth ? axisProperties.xLabelMaxWidth : availableWidth / labels.length;
            return !labels.some(function(d) {
                return properties.text = d, textMeasurer(properties) > labelMaxWidth;
            });
        }
        function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
            var labels = axisProperties.values, labelMaxWidth = void 0 !== axisProperties.xLabelMaxWidth ? axisProperties.xLabelMaxWidth : availableWidth / labels.length, maxRotatedLength = margin.bottom / DefaultRotation.sine, height = textHeightMeasurer(properties), maxNumLines = Math.max(1, Math.floor(margin.bottom / height));
            return 0 !== labels.length && !labels.some(function(label) {
                return properties.text = label, !(0, _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_6__.r)(label) && textWidthMeasurer(properties) > labelMaxWidth;
            }) && labels.filter(function(label, index) {
                var rotatedLength = Math.min((margin.left + axisProperties.outerPadding + axisProperties.categoryThickness * (index + .5) - LeftPadding) / DefaultRotation.cosine, maxRotatedLength), wordBreakChars = (0, 
                _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_6__.ql)(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(" ");
                properties.text = label;
                var rotateChars = textTruncator(properties, rotatedLength);
                return (0, _Visuals_common_textUtil__WEBPACK_IMPORTED_MODULE_13__.mC)(wordBreakChars).length >= (0, 
                _Visuals_common_textUtil__WEBPACK_IMPORTED_MODULE_13__.mC)(rotateChars).length;
            }).length >= labels.length >> 1;
        }
        var DefaultRotation = {
            sine: Math.sin(Math.PI * (35 / 180)),
            cosine: Math.cos(Math.PI * (35 / 180)),
            tangent: Math.tan(Math.PI * (35 / 180)),
            transform: "rotate(-35)",
            dy: "-0.5em",
            textAnchor: "end"
        }, DefaultVerticalRotation = {
            sine: Math.sin(.5 * Math.PI),
            cosine: Math.cos(.5 * Math.PI),
            tangent: Math.tan(.5 * Math.PI),
            transform: "rotate(-90)",
            dy: "-0.65em",
            textAnchor: "end"
        }, DefaultRotationForYAxisHierarchy = {
            sine: Math.sin(.5 * Math.PI),
            cosine: Math.cos(.5 * Math.PI),
            tangent: Math.tan(.5 * Math.PI),
            transform: "rotate(-90)",
            dy: "-0.45em",
            textAnchor: "middle",
            x: 0,
            y: 0,
            dx: 0
        };
        function rotate(labelSelection, options) {
            var textTruncator = options.textTruncator, textProperties = options.textProperties, needRotate = options.needRotate, needEllipsis = options.needEllipsis, axisProperties = options.axisProperties, margin = options.margin, shouldRotate90 = options.rotate90, currentNode = options.firstVisibleNode, _a = options.rotationPadding, rotationPadding = void 0 === _a ? 0 : _a, dropLabelsOnOverlap = options.dropLabelsOnOverlap, height = options.height, y1Hierarchy = options.y1Hierarchy;
            if (needRotate) {
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__._9)(axisProperties.scale);
                }, "Rotating non-ordinal scales is currently not supported");
                var maxLabelLength, rotatedXAxisPadding, rotation = y1Hierarchy ? DefaultRotationForYAxisHierarchy : shouldRotate90 ? DefaultVerticalRotation : DefaultRotation, isVertical = (0, 
                _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_2__.GG)(Math.abs(rotation.cosine), 0, 1e-10), leftMarginWithPadding = margin.left - (isVertical ? LeftPadding : 0), defaultFontHeightInPx = _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_14__.FP.fromPointToPixel(_cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.rZ), fontSizeInPx = parseFloat(textProperties.fontSize), defaultOrSmaller = fontSizeInPx <= defaultFontHeightInPx, fontHeight = _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_15__.b.estimateSvgTextHeight(textProperties), scale = axisProperties.scale, range = scaleRange(scale), categoryThickness = getCategoryThickness(scale), projectedFontWidth = fontHeight * rotation.sine, projectedFontHeight = isVertical ? 0 : fontHeight * rotation.cosine, halfProjectedFontWidth = projectedFontWidth / 2, fontOffsetLeft = (isVertical ? 0 : projectedFontHeight / rotation.tangent) + halfProjectedFontWidth, fontOffsetRight = halfProjectedFontWidth, hasHierarchy = !!currentNode;
                if (defaultOrSmaller) maxLabelLength = height / rotation.sine, rotatedXAxisPadding = -5.5; else {
                    var yAxisPadding = defaultFontHeightInPx / 2;
                    rotatedXAxisPadding = -(yAxisPadding + projectedFontHeight) * rotation.sine, maxLabelLength = needRotate ? (height - yAxisPadding - projectedFontHeight - (!shouldRotate90 || hasHierarchy ? 0 : yAxisPadding)) / rotation.sine : void 0;
                }
                var collisionDetector, halfRangeBand = scale.bandwidth() / 2, halfCategoryThickness = categoryThickness / 2;
                collisionDetector = dropLabelsOnOverlap ? hasHierarchy ? new _Visuals_common_axisTickCollisionUtils__WEBPACK_IMPORTED_MODULE_16__._F(rotationPadding + range[0] + halfRangeBand - halfCategoryThickness, fontOffsetLeft, fontOffsetRight, currentNode, scale, halfCategoryThickness, rotationPadding) : new _Visuals_common_axisTickCollisionUtils__WEBPACK_IMPORTED_MODULE_16__.LO(rotationPadding - (shouldRotate90 ? 0 : leftMarginWithPadding), fontOffsetLeft, fontOffsetRight) : new _Visuals_common_axisTickCollisionUtils__WEBPACK_IMPORTED_MODULE_16__.DR;
                var hierarchyGroupIndex = -1;
                labelSelection.each(function(_datum, index) {
                    var axisLabel = d3.select(this), categoryCenter = range[index] + halfRangeBand;
                    if (dropLabelsOnOverlap && collisionDetector.willCollide(categoryCenter)) return collisionDetector.skipItem(categoryCenter), 
                    void axisLabel.text(null);
                    collisionDetector.addItem(categoryCenter);
                    var allowedLength, labelText = axisLabel.text();
                    if (textProperties.text = labelText, isVertical) if (y1Hierarchy && shouldRotate90) {
                        if (!labelText) return;
                        var stackedAxisProps = axisProperties;
                        hierarchyGroupIndex = _.indexOf(stackedAxisProps.adjustedValues, labelText, hierarchyGroupIndex + 1), 
                        allowedLength = stackedAxisProps.categoryLabelMaxWidths[hierarchyGroupIndex], _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                            return !isNaN(allowedLength);
                        }, "stacked group allowedLength should be a valid number");
                    } else allowedLength = maxLabelLength; else allowedLength = ((defaultOrSmaller ? axisProperties.outerPadding + axisProperties.categoryThickness * (index + .5) : categoryCenter) + leftMarginWithPadding - projectedFontWidth) / rotation.cosine;
                    if (shouldRotate90 || needEllipsis || allowedLength < maxLabelLength) {
                        var newLabelText = textTruncator(textProperties, Math.min(allowedLength, maxLabelLength));
                        newLabelText !== labelText && axisLabel.text(newLabelText);
                    }
                    var x = axisLabel.attr("x");
                    axisLabel.style("text-anchor", rotation.textAnchor).attrs({
                        x: null != rotation.x ? rotation.x : x,
                        y: null != rotation.y ? rotation.y : fontSizeInPx,
                        dx: null != rotation.dx ? rotation.dx : rotatedXAxisPadding,
                        dy: rotation.dy,
                        transform: rotation.transform
                    });
                });
            } else labelSelection.each(function(datum) {
                var axisLabel = d3.select(this), labelText = axisLabel.text();
                textProperties.text = labelText;
                var maxLabelWidth = getMaxWidth(axisProperties, datum), newLabelText = textTruncator(textProperties, maxLabelWidth);
                newLabelText !== labelText && axisLabel.text(newLabelText), axisLabel.style("text-anchor", "middle").attrs({
                    dx: "0em",
                    dy: "1em",
                    transform: "rotate(0)"
                });
            });
        }
        function createD3Scale_Band(options, domain) {
            var _a, outerPaddingRatio = options.categoryThickness ? options.outerPadding / options.categoryThickness : 0;
            return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return outerPaddingRatio >= 0 && outerPaddingRatio < 4;
            }, "outerPaddingRatio should be a value between zero and four"), d3.scaleBand().range([ 0, options.pixelSpan ]).paddingInner(null !== (_a = options.innerPaddingRatio) && void 0 !== _a ? _a : _cartesianHelper__WEBPACK_IMPORTED_MODULE_7__.$B).paddingOuter(outerPaddingRatio).domain(domain);
        }
        function isLogScaleAllowedFunc(domain, axisType) {
            return null != domain && !(0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.v9)(axisType) && (domain[0] > 0 && domain[1] > 0 || domain[0] < 0 && domain[1] < 0);
        }
        function createD3Scale_Numeric(options, domain, isLogScale, niceCount) {
            var scale = (isLogScale ? d3.scaleLog() : d3.scaleLinear()).range([ options.outerPadding, options.pixelSpan - options.outerPadding ]).domain([ domain[0], domain[1] ]).clamp(isLogScale || options.shouldClamp);
            return (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_0__.v9)(options.valueType) || options.preventNice || options.allowSingleScalarTick && 2 === domain.length && domain[0] === domain[1] || domain[0] === -Number.MAX_VALUE || domain[1] === Number.MAX_VALUE || scale.nice(isLogScale ? void 0 : niceCount), 
            scale;
        }
        function isScalarAxisDomain(axisDomain) {
            return 1 === (null == axisDomain ? void 0 : axisDomain.type);
        }
        function isOrdinalAxisDomain(axisDomain) {
            return 0 === (null == axisDomain ? void 0 : axisDomain.type);
        }
        function getMergedUserDomains(axisData) {
            var _a, _b, userDomains = _.filter(axisData.includeDomains, function(domain) {
                return _.includes(domain.domainSources, 10);
            });
            return null !== (_b = null === (_a = mergeScalarAxisDomains.apply(void 0, userDomains)) || void 0 === _a ? void 0 : _a.domain) && void 0 !== _b ? _b : [ void 0, void 0 ];
        }
        function mergeDomains() {
            for (var min, max, domains = [], _i = 0; _i < arguments.length; _i++) domains[_i] = arguments[_i];
            for (var _a = 0, domains_1 = domains; _a < domains_1.length; _a++) {
                var domain = domains_1[_a];
                if (domain) {
                    var newMin = domain[0], newMax = domain[1];
                    null != newMin && (min = Math.min(newMin, void 0 === min ? Number.POSITIVE_INFINITY : min)), 
                    null != newMax && (max = Math.max(newMax, void 0 === max ? Number.NEGATIVE_INFINITY : max));
                }
            }
            return [ min, max ];
        }
        function createScalarDomainOptions(domain, source, forced) {
            if (domain) {
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return void 0 === domain[0] || void 0 === domain[1] || Number.isNaN(domain[0]) || Number.isNaN(domain[1]) || domain[0] <= domain[1];
                }, "min should be less or equal to max");
                var scalarDomain = {
                    type: 1,
                    domain,
                    domainSources: generateScalarDomainSources(domain, source),
                    forced
                };
                return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return !_.includes(scalarDomain.domainSources, 10) || !(!hasForcedDomain(scalarDomain) || !scalarDomain.domain);
                }, "For a user-set domain, `forced` must be true and `domain` must be set"), scalarDomain;
            }
        }
        function generateScalarDomainSources(domain, source) {
            return [ null != domain[0] ? source : void 0, null != domain[1] ? source : void 0 ];
        }
        function mergeScalarAxisDomains() {
            for (var scalarDomains = [], _i = 0; _i < arguments.length; _i++) scalarDomains[_i] = arguments[_i];
            var minLimit = {
                forced: !1,
                source: 0
            }, maxLimit = {
                forced: !1,
                source: 0
            }, minDataLimit = {
                forced: !1,
                source: 0,
                value: null
            }, maxDataLimit = {
                forced: !1,
                source: 0,
                value: null
            };
            function updateLimits(scalarDomain, pos) {
                var _a, _b, _c, _d, _e, _f, isMinLimit = "min" === pos, limit = isMinLimit ? minLimit : maxLimit, dataLimit = isMinLimit ? minDataLimit : maxDataLimit, currentLimSource = null !== (_b = null === (_a = scalarDomain.domainSources) || void 0 === _a ? void 0 : _a[isMinLimit ? 0 : 1]) && void 0 !== _b ? _b : 0, currentLimForced = null !== (_d = null === (_c = scalarDomain.forced) || void 0 === _c ? void 0 : _c[isMinLimit ? 0 : 1]) && void 0 !== _d && _d, currentLimValue = scalarDomain.domain[isMinLimit ? 0 : 1];
                if (null != currentLimValue) {
                    var updateDataLimit = function(newValue) {
                        0 === currentLimSource && (dataLimit.value = newValue, dataLimit.forced = currentLimForced);
                    };
                    null == dataLimit.value && updateDataLimit(currentLimValue), currentLimSource > limit.source ? (limit.value = currentLimValue, 
                    limit.source = currentLimSource, limit.forced = currentLimForced) : currentLimSource === limit.source && (currentLimForced && !limit.forced ? (limit.value = currentLimValue, 
                    limit.forced = !0, updateDataLimit(currentLimValue)) : !currentLimForced && limit.forced || (limit.value = isMinLimit ? Math.min(currentLimValue, null !== (_e = limit.value) && void 0 !== _e ? _e : Number.POSITIVE_INFINITY) : Math.max(currentLimValue, null !== (_f = limit.value) && void 0 !== _f ? _f : Number.NEGATIVE_INFINITY), 
                    updateDataLimit(limit.value)));
                }
            }
            for (var _a = 0, scalarDomains_1 = scalarDomains; _a < scalarDomains_1.length; _a++) {
                var scalarDomain = scalarDomains_1[_a];
                scalarDomain && scalarDomain.domain && (updateLimits(scalarDomain, "min"), updateLimits(scalarDomain, "max"));
            }
            if (void 0 !== minLimit.value || void 0 !== maxLimit.value) {
                var useAltLimit = null != minDataLimit.value && null != maxDataLimit.value && (0 === minLimit.source || 0 === maxLimit.source) && (minLimit.value > maxDataLimit.value || maxLimit.value < minDataLimit.value), min = useAltLimit ? minDataLimit : minLimit, max = useAltLimit ? maxDataLimit : maxLimit;
                return {
                    type: 1,
                    domain: [ min.value, max.value ],
                    forced: [ min.forced, max.forced ],
                    domainSources: [ min.source, max.source ]
                };
            }
        }
        function hasForcedDomain(domain) {
            var _a, _b;
            return (null === (_a = null == domain ? void 0 : domain.forced) || void 0 === _a ? void 0 : _a[0]) || (null === (_b = null == domain ? void 0 : domain.forced) || void 0 === _b ? void 0 : _b[1]);
        }
        function createAxisLabel(properties, label, unitType, y2) {
            void 0 === y2 && (y2 = !1);
            var propertyName = y2 ? "secAxisStyle" : "axisStyle";
            return (null == properties ? void 0 : properties[propertyName]) ? (0, _Visuals_types_axisStyle__WEBPACK_IMPORTED_MODULE_17__.O1)(properties[propertyName], label, unitType) : label;
        }
        function scaleShouldClamp(combinedDomain, domain) {
            return !(!combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2 || combinedDomain[0] === domain[0] && combinedDomain[1] === domain[1]);
        }
        function powerOfTen(d, factorOfTwo) {
            void 0 === factorOfTwo && (factorOfTwo = 0);
            var value = Math.abs(d), log10 = Math.log(value) / Math.LN10;
            return log10 = Math.ceil(log10 - 1e-12), value / Math.pow(10, log10) == 1 && log10 % Math.pow(2, factorOfTwo) == 0;
        }
        function isHierarchical(axisProperties) {
            return !0 === axisProperties.isHierarchical;
        }
        function isStackedAxisProperties(properties) {
            return !0 === properties.isStacked;
        }
        function getHierStack(axisProperties) {
            return isHierarchical(axisProperties.x) ? axisProperties.x.hierStack : isHierarchical(axisProperties.y1) ? axisProperties.y1.hierStack : [];
        }
        function getNumHierarchyLevels(axes) {
            return isHierarchical(axes.x) ? axes.x.numHierarchyLevels : isHierarchical(axes.y1) ? axes.y1.numHierarchyLevels : void 0;
        }
        function getMaxWidth(axisProperties, datum) {
            if (_.isEmpty(axisProperties.categoryLabelMaxWidths)) return axisProperties.xLabelMaxWidth;
            if (isStackedAxisProperties(axisProperties)) return axisProperties.categoryLabelMaxWidths[datum];
            var tickIndex = axisProperties.d3Axis.tickValues().indexOf(datum);
            return axisProperties.categoryLabelMaxWidths[tickIndex];
        }
    },
    3128: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            Rl: function() {
                return MaxCategoryDropdownCount;
            },
            fI: function() {
                return getFormattingModel;
            },
            Gf: function() {
                return getInnerPaddingBuilder;
            },
            l$: function() {
                return getSubSelectables;
            },
            xm: function() {
                return getSubSelectionCustomElements;
            },
            PH: function() {
                return getSubSelectionCustomOutlines;
            },
            H_: function() {
                return getSubSelectionMetadata;
            },
            yV: function() {
                return getSubSelectionShortcuts;
            },
            mv: function() {
                return getSubSelectionStyles;
            }
        });
        var tslib_es6 = __webpack_require__(81337), cartesian_capabilities = __webpack_require__(22733), dataViewObjectProperties = __webpack_require__(14599), dataLabelViewModel1Consts = __webpack_require__(56707), onObjectUtil = __webpack_require__(80065), strokeStyle = __webpack_require__(2241), visualBackgroundHelper = __webpack_require__(45545), visualLocKeys = __webpack_require__(33024), legend_formatting = __webpack_require__(86727), axisStyle = __webpack_require__(41414), axisType = __webpack_require__(48766), horizontalPosition = __webpack_require__(92374), verticalPosition = __webpack_require__(18765), CssConstants = __webpack_require__(79154), debug = __webpack_require__(62458), build_control_util = __webpack_require__(56578), contracts_selector = __webpack_require__(32379), dataViewRoleWildcard = __webpack_require__(91059), formattingService = __webpack_require__(28326), cartesianAxisHelper = __webpack_require__(11956), cartesianHelper = __webpack_require__(34969), axisZoomProperties = __webpack_require__(3087), getAxisTitleSubSelectionStyles = function(isY2Axis, isComboChart, isCategoryAxis, hostServices) {
            var titleReferences, axisProp, valueAxis = cartesian_capabilities.p.valueAxis;
            return titleReferences = isY2Axis ? {
                fontFamilyReference: (axisProp = isComboChart ? valueAxis : cartesian_capabilities.p.y2Axis).secTitleFontFamily,
                fontSizeReference: axisProp.secTitleFontSize,
                boldReference: axisProp.secTitleBold,
                italicReference: axisProp.secTitleItalic,
                underlineReference: axisProp.secTitleUnderline,
                fontColorReference: axisProp.secTitleColor
            } : {
                fontFamilyReference: (axisProp = isCategoryAxis ? cartesian_capabilities.p.categoryAxis : valueAxis).titleFontFamily,
                fontSizeReference: axisProp.titleFontSize,
                boldReference: axisProp.titleBold,
                italicReference: axisProp.titleItalic,
                underlineReference: axisProp.titleUnderline,
                fontColorReference: axisProp.titleColor
            }, debug.fF.assertValue(titleReferences, "getAxisTitleSubSelectionStyles titleReferences"), 
            (0, onObjectUtil.un)(hostServices, titleReferences);
        }, getAxisValuesSubSelectionStyles = function(isY2Axis, isComboChart, isCategoryAxis, hostServices) {
            var axisValueReferences, axisProp, valueAxis = cartesian_capabilities.p.valueAxis;
            return axisValueReferences = isY2Axis ? {
                fontFamilyReference: (axisProp = isComboChart ? valueAxis : cartesian_capabilities.p.y2Axis).secFontFamily,
                fontSizeReference: axisProp.secFontSize,
                boldReference: axisProp.secBold,
                italicReference: axisProp.secItalic,
                underlineReference: axisProp.secUnderline,
                fontColorReference: axisProp.secLabelColor,
                displayUnitsReference: axisProp.secLabelDisplayUnits,
                precisionReference: axisProp.secLabelPrecision
            } : {
                fontFamilyReference: (axisProp = isCategoryAxis ? cartesian_capabilities.p.categoryAxis : valueAxis).fontFamily,
                fontSizeReference: axisProp.fontSize,
                boldReference: axisProp.bold,
                italicReference: axisProp.italic,
                underlineReference: axisProp.underline,
                fontColorReference: axisProp.labelColor,
                displayUnitsReference: axisProp.labelDisplayUnits,
                precisionReference: axisProp.labelPrecision
            }, (0, onObjectUtil.xs)(hostServices, axisValueReferences);
        }, getAxisTitleSubSelectionShortcuts = function(isY2Axis, isComboChart, isCategoryAxis, isCategoryAxisScalar, hostServices) {
            var _a = getAxisReferences(isCategoryAxis, isY2Axis, isComboChart), axisTitleShow = _a.axisTitleShow, zoomAxisShow = _a.zoomAxisShow, subSelectionShortcuts = [ {
                type: 1,
                destinationInfo: {
                    cardUid: getAxisCardUid(isY2Axis, isCategoryAxis),
                    groupUid: getAxisGroupUid(isY2Axis, isCategoryAxis, "title")
                },
                label: hostServices.getLocalizedString("Format_AxisTitle")
            } ];
            return getIsAxisScalar(isCategoryAxis, isCategoryAxisScalar) && subSelectionShortcuts.unshift((0, 
            tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 2
            }, zoomAxisShow), {
                relatedToggledFormattingIds: [ axisZoomProperties.t.show ],
                enabledLabel: hostServices.getLocalizedString("Format_AddZoomSlider")
            })), subSelectionShortcuts.unshift((0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 2
            }, axisTitleShow), {
                disabledLabel: hostServices.getLocalizedString("Delete"),
                keyboardShortcuts: [ {
                    key: "Delete",
                    nextValue: !1
                } ]
            }), {
                type: 0,
                excludedResetFormattingIds: [ axisTitleShow, axisZoomProperties.t.show, zoomAxisShow ]
            }), subSelectionShortcuts;
        }, getAxisValuesSubSelectionShortcuts = function(isY2Axis, isComboChart, isCategoryAxis, isCategoryAxisScalar, categoryAxisSupportedType, hostServices) {
            var isAxisScalar = getIsAxisScalar(isCategoryAxis, isCategoryAxisScalar), _a = getAxisReferences(isCategoryAxis, isY2Axis, isComboChart), axisShow = _a.axisShow, axisTitleShow = _a.axisTitleShow, zoomAxisShow = _a.zoomAxisShow, subSelectionShortcuts = [ {
                type: 1,
                destinationInfo: {
                    cardUid: getAxisCardUid(isY2Axis, isCategoryAxis),
                    groupUid: getAxisGroupUid(isY2Axis, isCategoryAxis, isCategoryAxis && isAxisScalar ? "valuesScalar" : "values")
                },
                label: hostServices.getLocalizedString("Format_AxisValues")
            } ];
            return isAxisScalar || subSelectionShortcuts.unshift({
                type: 4,
                sortableField: {
                    queryName: "",
                    sortDirection: 1
                },
                label: hostServices.getLocalizedString("Format_SortAxis"),
                key: "Category"
            }), isCategoryAxis && categoryAxisSupportedType === axisType.w.both && subSelectionShortcuts.unshift((0, 
            tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 3
            }, cartesian_capabilities.p.categoryAxis.axisType), {
                label: hostServices.getLocalizedString("Format_Label_AxisType")
            })), isAxisScalar && subSelectionShortcuts.unshift((0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 2
            }, zoomAxisShow), {
                relatedToggledFormattingIds: [ axisZoomProperties.t.show ],
                enabledLabel: hostServices.getLocalizedString("Format_AddZoomSlider")
            })), subSelectionShortcuts.unshift((0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 2
            }, axisTitleShow), {
                enabledLabel: hostServices.getLocalizedString("Format_AddAxisTitle")
            })), subSelectionShortcuts.unshift((0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 2
            }, axisShow), {
                disabledLabel: hostServices.getLocalizedString("Delete"),
                keyboardShortcuts: [ {
                    key: "Delete",
                    nextValue: !1
                } ]
            }), {
                type: 0,
                excludedResetFormattingIds: [ axisShow, axisZoomProperties.t.show, zoomAxisShow ]
            }), subSelectionShortcuts;
        }, getIsAxisScalar = function(isCategoryAxis, isCategoryAxisScalar) {
            return !isCategoryAxis || isCategoryAxisScalar;
        }, getAxisReferences = function(isCategoryAxis, isY2Axis, isComboChart) {
            if (isCategoryAxis) return {
                axisShow: cartesian_capabilities.p.categoryAxis.show,
                axisTitleShow: cartesian_capabilities.p.categoryAxis.showAxisTitle,
                zoomAxisShow: axisZoomProperties.t.showOnCategoryAxis
            };
            if (isY2Axis) {
                var axisProps = isComboChart ? cartesian_capabilities.p.valueAxis : cartesian_capabilities.p.y2Axis;
                return {
                    axisShow: axisProps.show,
                    axisTitleShow: axisProps.secShowAxisTitle,
                    zoomAxisShow: axisZoomProperties.t.showOnValueSecAxis
                };
            }
            return {
                axisShow: cartesian_capabilities.p.valueAxis.show,
                axisTitleShow: cartesian_capabilities.p.valueAxis.showAxisTitle,
                zoomAxisShow: axisZoomProperties.t.showOnValueAxis
            };
        }, getAxisCardUid = function(isY2Axis, isCategoryAxis) {
            return isY2Axis ? "".concat("Visual", "-").concat("y2Axis") : isCategoryAxis ? "".concat("Visual", "-").concat("categoryAxis") : "".concat("Visual", "-").concat("valueAxis");
        }, getAxisGroupUid = function(isY2Axis, isCategoryAxis, groupUid) {
            return isY2Axis ? "".concat("y2Axis", "-").concat(groupUid) : isCategoryAxis ? "".concat("categoryAxis", "-").concat(groupUid) : "".concat("valueAxis", "-").concat(groupUid);
        }, comboChart = __webpack_require__(88439), gridLineType = __webpack_require__(49511), MaxCategoryDropdownCount = 60;
        function getFormattingModel() {
            for (var _a, _b, _c, _d, _e, _this = this, zoomAxisSupported = !(12 === this.chartType), model = new build_control_util.Nq(function() {
                return customizeFormattingCard.call(_this, getCategoryAxisCard.call(_this));
            }, function() {
                return customizeFormattingCard.call(_this, getValueAxisCard.call(_this));
            }, function() {
                return getSecondaryValueAxisCard.call(_this);
            }, function() {
                return getLegendCard.call(_this);
            }, function() {
                return getSmallMultiplesCard.call(_this);
            }, function() {
                return getGridlinesCard.call(_this);
            }, function() {
                return _this.axisZoom.getZoomCard(zoomAxisSupported);
            }).build(), layerCards = [], _i = 0, _f = this.getLayers(); _i < _f.length; _i++) {
                var layer = _f[_i];
                if (!layer.getFormattingCards) return;
                layerCards.push(layer.getFormattingCards({
                    categoryAxisData: null === (_b = null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.axesData) || void 0 === _b ? void 0 : _b.categoryAxis
                }));
            }
            if (debug.fF.assert(function() {
                return _this.isComboChart() || layerCards.length <= 1;
            }, "Formatting layer cards length is not as expected"), this.isComboChart()) {
                var cardsToPush = comboChart.pD(comboChart.GJ(layerCards, this.chartType, function(key) {
                    for (var args = [], _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
                    return _this.hostServices.getLocalizedString(key, args);
                }), this.chartType);
                null === (_c = null == model ? void 0 : model.cards) || void 0 === _c || _c.push.apply(_c, cardsToPush);
            } else 1 === layerCards.length ? null === (_d = null == model ? void 0 : model.cards) || void 0 === _d || _d.push.apply(_d, layerCards[0].card) : debug.fF.assert(function() {
                return 0 === layerCards.length;
            }, "Formatting cards for layer has unexpected length");
            var backgroundCard = (0, visualBackgroundHelper._W)(this.background, this.localizer);
            return backgroundCard && (null === (_e = null == model ? void 0 : model.cards) || void 0 === _e || _e.push(backgroundCard)), 
            model;
        }
        function getCategoryAxisCard() {
            var _a, _this = this, originalAxesData = null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.axesData, axes = this.axes;
            if (axes.hasCategoryAxis() && originalAxesData) {
                var categoryAxisProps = cartesian_capabilities.p.categoryAxis, categoryAxisData = originalAxesData.categoryAxis, isYAxisCategorical = axes.isYAxisCategorical, cardDisplayName = isYAxisCategorical ? "Visual_YAxis_Hyphen" : "Visual_XAxis_Hyphen", cardBuilder = new build_control_util.CQ(new build_control_util.lg("categoryAxis"), cardDisplayName, [ categoryAxisProps.show, categoryAxisProps.axisType, categoryAxisProps.start, categoryAxisProps.end, categoryAxisProps.fontFamily, categoryAxisProps.fontSize, categoryAxisProps.bold, categoryAxisProps.italic, categoryAxisProps.underline, categoryAxisProps.labelColor, categoryAxisProps.labelDisplayUnits, categoryAxisProps.labelPrecision, categoryAxisProps.maxMarginFactor, categoryAxisProps.preferredCategoryWidth, categoryAxisProps.showAxisTitle, categoryAxisProps.titleText, categoryAxisProps.axisStyle, categoryAxisProps.titleFontFamily, categoryAxisProps.titleFontSize, categoryAxisProps.titleBold, categoryAxisProps.titleItalic, categoryAxisProps.titleUnderline, categoryAxisProps.titleColor, categoryAxisProps.concatenateLabels, categoryAxisProps.show, categoryAxisProps.invertAxis, categoryAxisProps.logAxisScale, categoryAxisProps.switchAxisPosition ], this.localizer), _b = this.categoryAxisIsScalar(), isScalar = _b.isScalar;
                _b.supportedType === axisType.w.both && cardBuilder.addGroup("type", function(groupBuilder) {
                    groupBuilder.addSimpleSlice("type", new build_control_util.uY({
                        descriptor: categoryAxisProps.axisType,
                        value: isScalar ? axisType.w.scalar : axisType.w.categorical
                    }).build());
                }), isScalar && cardBuilder.addGroup("range", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_Axis_Range");
                    var _a = (0, cartesianAxisHelper.getMergedUserDomains)(categoryAxisData), start = _a[0], end = _a[1];
                    if (axes.isCategoryAxisDateTime()) {
                        var startDate = start && formattingService.y3.fromTimeValue(start), endDate = end && formattingService.y3.fromTimeValue(end);
                        groupBuilder.addSimpleSlice("min", new build_control_util.hz({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisProps.start), {
                                propertyTypes: {
                                    dateTime: !0
                                },
                                instanceKind: 3
                            }),
                            value: startDate,
                            placeholder: "",
                            validators: {
                                max: {
                                    type: 1,
                                    value: endDate
                                }
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Gradient_MinValue");
                        }).addSimpleSlice("max", new build_control_util.hz({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisProps.end), {
                                propertyTypes: {
                                    dateTime: !0
                                },
                                instanceKind: 3
                            }),
                            value: endDate,
                            placeholder: "",
                            validators: {
                                min: {
                                    type: 0,
                                    value: startDate
                                }
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Gradient_MaxValue");
                        });
                    } else groupBuilder.addSimpleSlice("min", new build_control_util.mu({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisProps.start), {
                            propertyTypes: {
                                numeric: !0
                            },
                            instanceKind: 3
                        }),
                        value: start,
                        options: {
                            maxValue: {
                                type: 1,
                                value: end
                            }
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_Gradient_MinValue");
                    }).addSimpleSlice("max", new build_control_util.mu({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisProps.end), {
                            propertyTypes: {
                                numeric: !0
                            },
                            instanceKind: 3
                        }),
                        value: end,
                        options: {
                            minValue: {
                                type: 0,
                                value: start
                            }
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_Gradient_MaxValue");
                    });
                    groupBuilder.addSimpleSlice("logAxisScale", new build_control_util.bd({
                        descriptor: categoryAxisProps.logAxisScale,
                        value: categoryAxisData.logAxisScale
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(!_this.isLogAxisScaleAllowed(!1)).withCustomDescriptionIf(function() {
                            return !_this.isLogAxisScaleAllowed(!1);
                        }, "Visual_LogarithmicScaleDescription");
                    }), groupBuilder.addSimpleSlice("invertAxis", new build_control_util.bd({
                        descriptor: categoryAxisProps.invertAxis,
                        value: categoryAxisData.invertAxis
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_InvertRange");
                    });
                });
                var labelFontProperties = categoryAxisData.labelFontProperties, titleFontProperties = categoryAxisData.titleFontProperties, labelFontControlBuilder = (new build_control_util.UN).withFontFamily({
                    descriptor: categoryAxisProps.fontFamily,
                    value: labelFontProperties.family
                }).withFontSizeProperties({
                    descriptor: categoryAxisProps.fontSize,
                    value: labelFontProperties.size.pt
                }).withBold({
                    descriptor: categoryAxisProps.bold,
                    value: labelFontProperties.weight === CssConstants.en
                }).withItalic({
                    descriptor: categoryAxisProps.italic,
                    value: labelFontProperties.style === CssConstants.BF
                }).withUnderline({
                    descriptor: categoryAxisProps.underline,
                    value: labelFontProperties.textDecoration === CssConstants.f0
                }), titleFontControlBuilder = (new build_control_util.UN).withFontFamily({
                    descriptor: categoryAxisProps.titleFontFamily,
                    value: titleFontProperties.family
                }).withFontSizeProperties({
                    descriptor: categoryAxisProps.titleFontSize,
                    value: titleFontProperties.size.pt
                }).withBold({
                    descriptor: categoryAxisProps.titleBold,
                    value: titleFontProperties.weight === CssConstants.en
                }).withItalic({
                    descriptor: categoryAxisProps.titleItalic,
                    value: titleFontProperties.style === CssConstants.BF
                }).withUnderline({
                    descriptor: categoryAxisProps.titleUnderline,
                    value: titleFontProperties.textDecoration === CssConstants.f0
                }), labelFontControl = labelFontControlBuilder.build(), titleFontControl = titleFontControlBuilder.build();
                return cardBuilder.addGroup(isScalar ? "valuesScalar" : "values", function(groupBuilder) {
                    var _a;
                    groupBuilder.withDisplayName("Role_DisplayName_Values").addCompositeSlice("font", "Font", labelFontControl).addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: categoryAxisProps.show,
                            value: categoryAxisData.show
                        }).build();
                    }).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisProps.labelColor), {
                            instanceKind: 3
                        }),
                        value: {
                            value: labelFontProperties.color
                        }
                    }).build()), isScalar ? groupBuilder.addSimpleSlice("displayUnits", new build_control_util.uY({
                        descriptor: categoryAxisProps.labelDisplayUnits,
                        value: categoryAxisData.labelDisplayUnits
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withAliasName("Decimal");
                    }).addSimpleSlice("precision", new build_control_util.mu({
                        descriptor: categoryAxisProps.labelPrecision,
                        value: categoryAxisData.labelPrecision,
                        options: {
                            minValue: {
                                type: 0,
                                value: 0
                            },
                            maxValue: {
                                type: 1,
                                value: dataLabelViewModel1Consts.vo
                            }
                        }
                    }).build()) : groupBuilder.addSimpleSlice("maxMarginFactor", new build_control_util.JN({
                        descriptor: categoryAxisProps.maxMarginFactor,
                        value: Math.round(100 * categoryAxisData.maxMarginFactor),
                        options: {
                            minValue: {
                                type: 0,
                                value: 15
                            },
                            maxValue: {
                                type: 1,
                                value: 50
                            },
                            unitSymbol: visualLocKeys.t2
                        },
                        localize: _this.localizer
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName(isYAxisCategorical ? "Visual_Max_Width" : "Visual_Max_Height");
                    }), isYAxisCategorical && groupBuilder.addSimpleSlice("switchAxisPosition", new build_control_util.bd({
                        descriptor: categoryAxisProps.switchAxisPosition,
                        value: categoryAxisData.switchAxisPosition
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_SwitchAxisPosition");
                    }), (null === (_a = _this.cartesianVisualCapabilities) || void 0 === _a ? void 0 : _a.supportsHierarchicalCategoryAxis) && !isScalar && groupBuilder.addSimpleSlice("concatenateLabels", new build_control_util.bd({
                        descriptor: categoryAxisProps.concatenateLabels,
                        value: categoryAxisData.concatenateLabels
                    }).build());
                }).addGroup("title", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_Title").withInheritDisabled(!1).addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: categoryAxisProps.showAxisTitle,
                            value: categoryAxisData.showAxisTitle
                        }).build();
                    }).addSimpleSlice("text", new build_control_util.fq({
                        descriptor: categoryAxisProps.titleText,
                        value: categoryAxisData.titleText,
                        placeholder: ""
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_Title_Text");
                    }).addSimpleSlice("style", function() {
                        return new build_control_util.uY({
                            descriptor: categoryAxisProps.axisStyle,
                            value: categoryAxisData.axisStyle,
                            filterValues: axes.categoryAxisHasUnitType ? [ axisStyle.DO.showTitleOnly, axisStyle.DO.showUnitOnly, axisStyle.DO.showBoth ] : [ axisStyle.DO.showTitleOnly ]
                        }).build();
                    }).addCompositeSlice("font", "Font", titleFontControl).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisProps.titleColor), {
                            instanceKind: 3
                        }),
                        value: {
                            value: titleFontProperties.color
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Generic_Color");
                    });
                }), isScalar || cardBuilder.addGroup("layout", function(axisLayoutBuilder) {
                    axisLayoutBuilder.withDisplayName("Layout").withInheritDisabled(!1).addSimpleSlice("preferredCategoryWidth", new build_control_util.JN({
                        descriptor: cartesian_capabilities.p.categoryAxis.preferredCategoryWidth,
                        value: categoryAxisData.preferredCategoryWidth,
                        options: {
                            minValue: {
                                type: 0,
                                value: 20
                            },
                            maxValue: {
                                type: 1,
                                value: 180
                            },
                            unitSymbol: visualLocKeys.e_
                        },
                        localize: _this.localizer
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName(isYAxisCategorical ? "Visual_Category_Height" : "Visual_Category_Width").withCustomDescription(isYAxisCategorical ? "Visual_Category_Height_Description" : "Visual_Category_Width_Description").withHidden(isScalar);
                    });
                }), cardBuilder.build();
            }
        }
        function getValueAxisCard() {
            var _a, _this = this, originalAxesData = null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.axesData;
            if (null == originalAxesData ? void 0 : originalAxesData.isValueAxisSet) {
                var axes = this.axes, valueAxisProps = cartesian_capabilities.p.valueAxis, valueAxisData = originalAxesData.valueAxis, isYAxisCategorical = axes.isYAxisCategorical, cardDisplayName = isYAxisCategorical ? "Visual_XAxis_Hyphen" : "Visual_YAxis_Hyphen", cardBuilder = new build_control_util.CQ(new build_control_util.lg("valueAxis"), cardDisplayName, [ valueAxisProps.show, valueAxisProps.start, valueAxisProps.end, valueAxisProps.invertAxis, valueAxisProps.sharedAxis, valueAxisProps.scaleToFit, valueAxisProps.fontFamily, valueAxisProps.fontSize, valueAxisProps.bold, valueAxisProps.italic, valueAxisProps.underline, valueAxisProps.labelColor, valueAxisProps.labelDisplayUnits, valueAxisProps.labelPrecision, valueAxisProps.showAxisTitle, valueAxisProps.titleText, valueAxisProps.axisStyle, valueAxisProps.titleFontFamily, valueAxisProps.titleFontSize, valueAxisProps.titleBold, valueAxisProps.titleItalic, valueAxisProps.titleUnderline, valueAxisProps.titleColor, valueAxisProps.logAxisScale, valueAxisProps.switchAxisPosition ], this.localizer), labelFontProperties = valueAxisData.labelFontProperties, titleFontProperties = valueAxisData.titleFontProperties, labelFontControlBuilder = (new build_control_util.UN).withFontFamily({
                    descriptor: valueAxisProps.fontFamily,
                    value: labelFontProperties.family
                }).withFontSizeProperties({
                    descriptor: valueAxisProps.fontSize,
                    value: labelFontProperties.size.pt
                }).withBold({
                    descriptor: valueAxisProps.bold,
                    value: valueAxisData.labelBold
                }).withItalic({
                    descriptor: valueAxisProps.italic,
                    value: valueAxisData.labelItalic
                }).withUnderline({
                    descriptor: valueAxisProps.underline,
                    value: valueAxisData.labelUnderline
                }), titleFontControlBuilder = (new build_control_util.UN).withFontFamily({
                    descriptor: valueAxisProps.titleFontFamily,
                    value: titleFontProperties.family
                }).withFontSizeProperties({
                    descriptor: valueAxisProps.titleFontSize,
                    value: titleFontProperties.size.pt
                }).withBold({
                    descriptor: valueAxisProps.titleBold,
                    value: valueAxisData.titleBold
                }).withItalic({
                    descriptor: valueAxisProps.titleItalic,
                    value: valueAxisData.titleItalic
                }).withUnderline({
                    descriptor: valueAxisProps.titleUnderline,
                    value: valueAxisData.titleUnderline
                }), labelFontControl = labelFontControlBuilder.build(), titleFontControl = titleFontControlBuilder.build();
                return cardBuilder.addGroup("range", function(groupBuilder) {
                    var _a = (0, cartesianAxisHelper.getMergedUserDomains)(valueAxisData), start = _a[0], end = _a[1];
                    groupBuilder.withDisplayName("Visual_Axis_Range").withInheritDisabled(!1).addSimpleSlice("min", new build_control_util.mu({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, valueAxisProps.start), {
                            propertyTypes: {
                                numeric: !0
                            },
                            instanceKind: 3
                        }),
                        value: start,
                        options: {
                            maxValue: {
                                type: 1,
                                value: end
                            }
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_Gradient_MinValue");
                    }).addSimpleSlice("max", new build_control_util.mu({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, valueAxisProps.end), {
                            propertyTypes: {
                                numeric: !0
                            },
                            instanceKind: 3
                        }),
                        value: end,
                        options: {
                            minValue: {
                                type: 0,
                                value: start
                            }
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_Gradient_MaxValue");
                    }), 12 !== _this.chartType && groupBuilder.addSimpleSlice("logAxisScale", new build_control_util.bd({
                        descriptor: valueAxisProps.logAxisScale,
                        value: valueAxisData.logAxisScale
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(!_this.isLogAxisScaleAllowed(!0)).withCustomDescriptionIf(function() {
                            return !_this.isLogAxisScaleAllowed(!0);
                        }, "Visual_LogarithmicScaleDescription");
                    }), groupBuilder.addSimpleSlice("invertAxis", new build_control_util.bd({
                        descriptor: valueAxisProps.invertAxis,
                        value: valueAxisData.invertAxis
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_InvertRange");
                    }), _this.isSmallMultiples() && groupBuilder.addSimpleSlice("sharedAxis", new build_control_util.bd({
                        descriptor: valueAxisProps.sharedAxis,
                        value: valueAxisData.sharedAxis
                    }).build(), function(sliceBuilder) {
                        axes.isYAxisCategorical && sliceBuilder.withCustomDisplayName("Visual_Shared_XAxis");
                    }).addSimpleSlice("scaleToFit", new build_control_util.bd({
                        descriptor: valueAxisProps.scaleToFit,
                        value: valueAxisData.scaleToFit
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(valueAxisData.sharedAxis);
                    });
                }).addGroup("values", function(groupBuilder) {
                    groupBuilder.withDisplayName("Role_DisplayName_Values").addCompositeSlice("font", "Font", labelFontControl).addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: valueAxisProps.show,
                            value: valueAxisData.show
                        }).build();
                    }).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, valueAxisProps.labelColor), {
                            instanceKind: 3
                        }),
                        value: {
                            value: labelFontProperties.color
                        }
                    }).build()), originalAxesData.isValueAxisIrregular && groupBuilder.withDisabled(!0, "Visual_Axis_Disabled_IrregularAxis"), 
                    _this.is100Stacked() || groupBuilder.addSimpleSlice("displayUnits", new build_control_util.uY({
                        descriptor: valueAxisProps.labelDisplayUnits,
                        value: valueAxisData.labelDisplayUnits
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withAliasName("Decimal");
                    }).addSimpleSlice("precision", new build_control_util.mu({
                        descriptor: valueAxisProps.labelPrecision,
                        value: valueAxisData.labelPrecision,
                        options: {
                            minValue: {
                                type: 0,
                                value: 0
                            },
                            maxValue: {
                                type: 1,
                                value: dataLabelViewModel1Consts.vo
                            }
                        }
                    }).build()), isYAxisCategorical || groupBuilder.addSimpleSlice("switchAxisPosition", new build_control_util.bd({
                        descriptor: valueAxisProps.switchAxisPosition,
                        value: valueAxisData.switchAxisPosition
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_SwitchAxisPosition");
                    });
                }).addGroup("title", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_Title").withInheritDisabled(!1).addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: valueAxisProps.showAxisTitle,
                            value: valueAxisData.showAxisTitle
                        }).build();
                    }).addSimpleSlice("text", new build_control_util.fq({
                        descriptor: valueAxisProps.titleText,
                        value: valueAxisData.titleText,
                        placeholder: ""
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Visual_Title_Text");
                    }).addSimpleSlice("style", function() {
                        return new build_control_util.uY({
                            descriptor: valueAxisProps.axisStyle,
                            value: valueAxisData.axisStyle,
                            filterValues: axes.valueAxisHasUnitType ? [ axisStyle.DO.showTitleOnly, axisStyle.DO.showUnitOnly, axisStyle.DO.showBoth ] : [ axisStyle.DO.showTitleOnly ]
                        }).build();
                    }).addCompositeSlice("font", "Font", titleFontControl).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, valueAxisProps.titleColor), {
                            instanceKind: 3
                        }),
                        value: {
                            value: titleFontProperties.color
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Generic_Color");
                    });
                }), cardBuilder.build();
            }
        }
        function getSecondaryValueAxisCard() {
            var _a, _this = this, originalAxesData = null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.axesData;
            if ((null == originalAxesData ? void 0 : originalAxesData.isValueAxisSet) && !originalAxesData.isValueAxisIrregular) {
                var secondaryValueAxisSupported, showProp, secondaryValueAxisProps;
                switch (this.chartType) {
                  case 0:
                  case 1:
                    secondaryValueAxisSupported = !0, showProp = cartesian_capabilities.p.y2Axis.show, 
                    secondaryValueAxisProps = cartesian_capabilities.p.y2Axis;
                    break;

                  case 13:
                  case 14:
                    secondaryValueAxisSupported = !0, showProp = cartesian_capabilities.p.valueAxis.secShow, 
                    secondaryValueAxisProps = cartesian_capabilities.p.valueAxis;
                    break;

                  default:
                    secondaryValueAxisSupported = !1;
                }
                if (secondaryValueAxisSupported) {
                    var axes = this.axes, axesData = originalAxesData, secondaryValueAxisData = axesData.y2, cardBuilder = new build_control_util.CQ(new build_control_util.lg("y2Axis"), "Visual_Y2Axis_Hyphen", (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, secondaryValueAxisProps), {
                        alignZeros: cartesian_capabilities.p.valueAxis.alignZeros
                    }), this.localizer), labelFontProperties = secondaryValueAxisData.labelFontProperties, titleFontProperties = secondaryValueAxisData.titleFontProperties, labelFontControlBuilder = (new build_control_util.UN).withFontFamily({
                        descriptor: secondaryValueAxisProps.secFontFamily,
                        value: labelFontProperties.family
                    }).withFontSizeProperties({
                        descriptor: secondaryValueAxisProps.secFontSize,
                        value: labelFontProperties.size.pt
                    }).withBold({
                        descriptor: secondaryValueAxisProps.secBold,
                        value: secondaryValueAxisData.labelBold
                    }).withItalic({
                        descriptor: secondaryValueAxisProps.secItalic,
                        value: secondaryValueAxisData.labelItalic
                    }).withUnderline({
                        descriptor: secondaryValueAxisProps.secUnderline,
                        value: secondaryValueAxisData.labelUnderline
                    }), titleFontControlBuilder = (new build_control_util.UN).withFontFamily({
                        descriptor: secondaryValueAxisProps.secTitleFontFamily,
                        value: titleFontProperties.family
                    }).withFontSizeProperties({
                        descriptor: secondaryValueAxisProps.secTitleFontSize,
                        value: titleFontProperties.size.pt
                    }).withBold({
                        descriptor: secondaryValueAxisProps.secTitleBold,
                        value: secondaryValueAxisData.titleBold
                    }).withItalic({
                        descriptor: secondaryValueAxisProps.secTitleItalic,
                        value: secondaryValueAxisData.titleItalic
                    }).withUnderline({
                        descriptor: secondaryValueAxisProps.secTitleUnderline,
                        value: secondaryValueAxisData.titleUnderline
                    }), labelFontControl = labelFontControlBuilder.build(), titleFontControl = titleFontControlBuilder.build();
                    return cardBuilder.addGroup("range", function(groupBuilder) {
                        var _a = (0, cartesianAxisHelper.getMergedUserDomains)(secondaryValueAxisData), start = _a[0], end = _a[1];
                        groupBuilder.withDisplayName("Visual_Axis_Range").addSimpleSlice("min", new build_control_util.mu({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, secondaryValueAxisProps.secStart), {
                                instanceKind: 3
                            }),
                            value: start,
                            options: {
                                maxValue: {
                                    type: 1,
                                    value: end
                                }
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Gradient_MinValue");
                        }).addSimpleSlice("max", new build_control_util.mu({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, secondaryValueAxisProps.secEnd), {
                                instanceKind: 3
                            }),
                            value: end,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: start
                                }
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Gradient_MaxValue");
                        }), groupBuilder.addSimpleSlice("logAxisScale", new build_control_util.bd({
                            descriptor: secondaryValueAxisProps.secLogAxisScale,
                            value: secondaryValueAxisData.logAxisScale
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withDisabled(!_this.isLogAxisScaleAllowed(!0, !0)).withCustomDescriptionIf(function() {
                                return !_this.isLogAxisScaleAllowed(!0, !0);
                            }, "Visual_LogarithmicScaleDescription");
                        }), _this.isComboChart() && groupBuilder.addSimpleSlice("alignZeroes", new build_control_util.bd({
                            descriptor: cartesian_capabilities.p.valueAxis.alignZeros,
                            value: axesData.valueAxis.alignZeros
                        }).build());
                    }).addGroup("values", function(groupBuilder) {
                        groupBuilder.withDisplayName("Role_DisplayName_Values").addTopLevelToggle("show", function() {
                            return new build_control_util.bd({
                                descriptor: showProp,
                                value: secondaryValueAxisData.show
                            }).build();
                        }).addCompositeSlice("font", "Font", labelFontControl).addSimpleSlice("color", new build_control_util.BT({
                            descriptor: secondaryValueAxisProps.secLabelColor,
                            value: {
                                value: labelFontProperties.color
                            }
                        }).build()), _this.is100Stacked() || groupBuilder.addSimpleSlice("displayUnits", new build_control_util.uY({
                            descriptor: secondaryValueAxisProps.secLabelDisplayUnits,
                            value: secondaryValueAxisData.labelDisplayUnits
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withAliasName("Decimal");
                        }).addSimpleSlice("precision", new build_control_util.mu({
                            descriptor: secondaryValueAxisProps.secLabelPrecision,
                            value: secondaryValueAxisData.labelPrecision,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: 0
                                },
                                maxValue: {
                                    type: 1,
                                    value: dataLabelViewModel1Consts.vo
                                }
                            }
                        }).build());
                    }).addGroup("title", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Title").withInheritDisabled(!1).addTopLevelToggle("show", function() {
                            return new build_control_util.bd({
                                descriptor: secondaryValueAxisProps.secShowAxisTitle,
                                value: secondaryValueAxisData.showAxisTitle
                            }).build();
                        }).addSimpleSlice("text", new build_control_util.fq({
                            descriptor: secondaryValueAxisProps.secTitleText,
                            value: secondaryValueAxisData.titleText,
                            placeholder: ""
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Title_Text");
                        }).addSimpleSlice("style", function() {
                            return new build_control_util.uY({
                                descriptor: secondaryValueAxisProps.secAxisStyle,
                                value: secondaryValueAxisData.axisStyle,
                                filterValues: axes.valueAxisHasUnitType ? [ axisStyle.DO.showTitleOnly, axisStyle.DO.showUnitOnly, axisStyle.DO.showBoth ] : [ axisStyle.DO.showTitleOnly ]
                            }).build();
                        }).addCompositeSlice("font", "Font", titleFontControl).addSimpleSlice("color", new build_control_util.BT({
                            descriptor: secondaryValueAxisProps.secTitleColor,
                            value: {
                                value: titleFontProperties.color
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Generic_Color");
                        });
                    }), cardBuilder.build();
                }
            }
        }
        function getLegendCard() {
            var _a, legendData = null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.legendData;
            if (!_.isEmpty(this.dataViews) && legendData) {
                for (var disabledReason, legendFormattingModelOptions = {
                    legendData
                }, _i = 0, layers_1 = this.getLayers(); _i < layers_1.length; _i++) {
                    var layer = layers_1[_i];
                    layer.customizeLegendFormattingModelOptions && (legendFormattingModelOptions = layer.customizeLegendFormattingModelOptions(legendFormattingModelOptions));
                }
                return disabledReason = this.featureSwitches.onObject ? "Visual_LegendCard_DisabledReasonNew" : 13 === this.chartType ? "Visual_LegendCard_ComboLineClustered_DisabledReason" : 14 === this.chartType ? "Visual_LegendCard_ComboLineStacked_DisabledReason" : "Visual_LegendCard_DisabledReason", 
                (0, legend_formatting.ZF)(legendFormattingModelOptions, this.hostServices, this.featureSwitches, !this.shouldShowLegendCard(), disabledReason);
            }
        }
        function getGridlinesCard() {
            var _a, _this = this, axesData = null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.axesData;
            if (!_.isEmpty(this.dataViews) && axesData) {
                var horizontalProps, horizontalData, verticalProps, verticalData, axes = this.axes, hasCategoryAxis = axes.hasCategoryAxis(), isYAxisCategorical = axes.isYAxisCategorical, shouldShowCategoricalGridlines = this.categoryAxisIsScalar().isScalar || this.hasHierarchicalAxisRenderMode;
                isYAxisCategorical ? (horizontalProps = cartesian_capabilities.p.categoryAxis, horizontalData = axesData.categoryAxis, 
                hasCategoryAxis && (verticalProps = cartesian_capabilities.p.valueAxis, verticalData = axesData.valueAxis)) : (horizontalProps = cartesian_capabilities.p.valueAxis, 
                horizontalData = axesData.valueAxis, hasCategoryAxis && 12 !== this.chartType && (verticalProps = cartesian_capabilities.p.categoryAxis, 
                verticalData = axesData.categoryAxis));
                var cardBuilder = new build_control_util.CQ(new build_control_util.lg("gridlines"), "Visual_Gridline_Show", [ cartesian_capabilities.p.categoryAxis.gridlineShow, cartesian_capabilities.p.categoryAxis.gridlineStyle, cartesian_capabilities.p.categoryAxis.gridlineColor, cartesian_capabilities.p.categoryAxis.gridlineTransparency, cartesian_capabilities.p.categoryAxis.gridlineThickness, cartesian_capabilities.p.categoryAxis.gridlineDashArray, cartesian_capabilities.p.categoryAxis.gridlineDashCap, cartesian_capabilities.p.categoryAxis.gridlineAutoScale, cartesian_capabilities.p.valueAxis.gridlineShow, cartesian_capabilities.p.valueAxis.gridlineStyle, cartesian_capabilities.p.valueAxis.gridlineColor, cartesian_capabilities.p.valueAxis.gridlineTransparency, cartesian_capabilities.p.valueAxis.gridlineThickness, cartesian_capabilities.p.valueAxis.gridlineDashArray, cartesian_capabilities.p.valueAxis.gridlineDashCap, cartesian_capabilities.p.valueAxis.gridlineAutoScale ], this.localizer), buildGridlineGroup = function(groupBuilder, props, data, title) {
                    props && groupBuilder.withDisplayName(title).addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: props.gridlineShow,
                            value: !!data.show && data.gridline.strokeShow
                        }).build();
                    }, function(sliceBuilder) {
                        return sliceBuilder.withDisabled(!data.show);
                    }).addSlices((0, strokeStyle.Iq)({
                        containerItemBuilder: groupBuilder,
                        descriptors: {
                            strokePattern: props.gridlineStyle,
                            strokeColor: props.gridlineColor,
                            strokeTransparency: props.gridlineTransparency,
                            strokeWidth: props.gridlineThickness,
                            strokeDashArray: props.gridlineDashArray,
                            strokeDashCap: props.gridlineDashCap,
                            strokeAutoScale: props.gridlineAutoScale
                        },
                        strokeData: data.gridline,
                        selector: void 0,
                        featureSwitches: _this.featureSwitches,
                        localize: _this.localizer,
                        isSVGStroke: !0,
                        colorInstanceKind: 3,
                        maxWidth: 4
                    }).map(function(slice) {
                        return slice.build();
                    }));
                };
                return (horizontalData && !isYAxisCategorical || isYAxisCategorical && shouldShowCategoricalGridlines) && cardBuilder.addGroup("horizontal", function(groupBuilder) {
                    return buildGridlineGroup(groupBuilder, horizontalProps, horizontalData, "Visual_LabelOrientation_Horizontal");
                }), (verticalProps && verticalData && isYAxisCategorical || !isYAxisCategorical && shouldShowCategoricalGridlines) && cardBuilder.addGroup("vertical", function(groupBuilder) {
                    return buildGridlineGroup(groupBuilder, verticalProps, verticalData, "Visual_LabelOrientation_Vertical");
                }), cardBuilder.build();
            }
        }
        function getSmallMultiplesCard() {
            var _this = this;
            if (11 !== this.chartType && 12 !== this.chartType && !_.isEmpty(this.dataViews)) {
                var layoutProps = dataViewObjectProperties.N_.smallMultiplesLayout, subheaderProps = dataViewObjectProperties.N_.subheader, cardBuilder = new build_control_util.CQ(new build_control_util.lg("smallMultiples"), "Role_DisplayName_SmallMultiples", [ layoutProps.rowCount, layoutProps.columnCount, layoutProps.gridPadding, layoutProps.advancedPaddingOptions, layoutProps.columnPaddingInner, layoutProps.columnPaddingOuter, layoutProps.rowPaddingInner, layoutProps.rowPaddingOuter, layoutProps.gridLineType, layoutProps.gridLineShow, layoutProps.gridLineStyle, layoutProps.gridLineColor, layoutProps.gridLineTransparency, layoutProps.gridLineWidth, layoutProps.backgroundColor, layoutProps.backgroundTransparency, subheaderProps.show, subheaderProps.fontFamily, subheaderProps.fontSize, subheaderProps.fontColor, subheaderProps.underline, subheaderProps.bold, subheaderProps.italic, subheaderProps.position, subheaderProps.alignment, subheaderProps.titleWrap ], this.localizer);
                if (!this.showSmallMultiplesCard()) return cardBuilder.withDisabled(!0, "Visual_SmallMultipleCard_DisabledReason"), 
                cardBuilder.build();
                var layout = (0, cartesianHelper.Zw)(this.dataViews[0].metadata.objects, this.layerStyle), subheaderData = (0, 
                cartesianHelper.yA)(this.dataViews[0].metadata.objects, this.layerStyle), maxMultiples = cartesianHelper.LK(layout);
                return cardBuilder.withDescription("Small_Multiples_Layout_Description").addGroup("layout", function(groupBuilder) {
                    debug.fF.assert(function() {
                        return 0 !== layout.layoutType;
                    }, "Unexpected auto layout"), groupBuilder.withDisplayName("Layout").addSimpleSlice("rowCount", new build_control_util.mu({
                        descriptor: layoutProps.rowCount,
                        value: layout.rowCount,
                        options: {
                            minValue: {
                                type: 0,
                                value: cartesianHelper.$W
                            },
                            maxValue: {
                                type: 1,
                                value: maxMultiples.maxRowCount
                            }
                        }
                    }).build()).addSimpleSlice("columnCount", new build_control_util.mu({
                        descriptor: layoutProps.columnCount,
                        value: layout.columnCount,
                        options: {
                            minValue: {
                                type: 0,
                                value: cartesianHelper.fw
                            },
                            maxValue: {
                                type: 1,
                                value: maxMultiples.maxColumnCount
                            }
                        }
                    }).build());
                    var advancedPaddingEnabled = layout.advancedPaddingOptions, paddingOptions = {
                        minValue: {
                            type: 0,
                            value: 0
                        },
                        maxValue: {
                            type: 1,
                            value: 40
                        }
                    };
                    groupBuilder.addSimpleSlice("gridPadding", new build_control_util.mu({
                        descriptor: layoutProps.gridPadding,
                        value: layout.gridPadding,
                        options: paddingOptions
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(advancedPaddingEnabled).withCustomDisplayName("Small_Multiples_All_Padding");
                    }).addSimpleSlice("advancedPadding", new build_control_util.bd({
                        descriptor: layoutProps.advancedPaddingOptions,
                        value: layout.advancedPaddingOptions
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Small_Multiples_Customize_Padding");
                    }), advancedPaddingEnabled && groupBuilder.addSimpleSlice("columnPaddingInner", new build_control_util.JN({
                        descriptor: layoutProps.columnPaddingInner,
                        value: layout.columnPaddingInner,
                        options: paddingOptions,
                        localize: _this.localizer
                    }).build()).addSimpleSlice("columnPaddingOuter", new build_control_util.JN({
                        descriptor: layoutProps.columnPaddingOuter,
                        value: layout.columnPaddingOuter,
                        options: paddingOptions,
                        localize: _this.localizer
                    }).build()).addSimpleSlice("rowPaddingInner", new build_control_util.JN({
                        descriptor: layoutProps.rowPaddingInner,
                        value: layout.rowPaddingInner,
                        options: paddingOptions,
                        localize: _this.localizer
                    }).build()).addSimpleSlice("rowPaddingOuter", new build_control_util.JN({
                        descriptor: layoutProps.rowPaddingOuter,
                        value: layout.rowPaddingOuter,
                        options: paddingOptions,
                        localize: _this.localizer
                    }).build());
                }), cardBuilder.addGroup("border", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Visual_Border").addSimpleSlice("gridLineType", new build_control_util.uY({
                        descriptor: layoutProps.gridLineType,
                        value: layout.gridline.region === gridLineType.o.none ? gridLineType.o.inner : layout.gridline.region
                    }).build()).addSlices((0, strokeStyle.Iq)({
                        containerItemBuilder: groupBuilder,
                        descriptors: {
                            strokeShow: layoutProps.gridLineShow,
                            strokeColor: layoutProps.gridLineColor,
                            strokeTransparency: layoutProps.gridLineTransparency,
                            strokePattern: layoutProps.gridLineStyle,
                            strokeWidth: layoutProps.gridLineWidth
                        },
                        strokeData: layout.gridline,
                        selector: void 0,
                        featureSwitches: _this.featureSwitches,
                        localize: _this.localizer
                    }).map(function(slice) {
                        return slice.build();
                    }));
                }), cardBuilder.addGroup("title", function(groupBuilder) {
                    groupBuilder.withDisplayName("Title"), groupBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: subheaderProps.show,
                            value: !!_this.showSubheaderCard() && subheaderData.show
                        }).build();
                    });
                    var fontProperties = subheaderData.fontProperties, fontControl = (new build_control_util.UN).withFontFamily({
                        descriptor: subheaderProps.fontFamily,
                        value: fontProperties.family
                    }).withFontSizeProperties({
                        descriptor: subheaderProps.fontSize,
                        value: fontProperties.size.pt
                    }).withBold({
                        descriptor: subheaderProps.bold,
                        value: subheaderData.labelBold
                    }).withItalic({
                        descriptor: subheaderProps.italic,
                        value: subheaderData.labelItalic
                    }).withUnderline({
                        descriptor: subheaderProps.underline,
                        value: subheaderData.labelUnderline
                    }).build();
                    groupBuilder.addSimpleSlice("position", function() {
                        var value;
                        switch (subheaderData.vertical) {
                          default:
                          case 0:
                            value = verticalPosition.cL.top;
                            break;

                          case 1:
                            value = verticalPosition.cL.bottom;
                        }
                        return new build_control_util.uY({
                            descriptor: subheaderProps.position,
                            value
                        }).build();
                    }).addCompositeSlice("font", "Font", fontControl).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, subheaderProps.fontColor), {
                            instanceKind: 3,
                            selector: {
                                data: [ (0, dataViewRoleWildcard.Yp)([ cartesian_capabilities.x.rows ]) ]
                            },
                            altConstantValueSelector: null
                        }),
                        value: {
                            value: fontProperties.color
                        }
                    }).build()).addSimpleSlice("alignment", function() {
                        var value;
                        switch (subheaderData.horizontal) {
                          default:
                          case 0:
                            value = horizontalPosition.D.left;
                            break;

                          case 1:
                            value = horizontalPosition.D.center;
                            break;

                          case 2:
                            value = horizontalPosition.D.right;
                        }
                        return new build_control_util.Gp({
                            descriptor: subheaderProps.alignment,
                            value,
                            mode: "horizontalAlignment"
                        }).build();
                    }), groupBuilder.addSimpleSlice("titleWrap", new build_control_util.bd({
                        descriptor: subheaderProps.titleWrap,
                        value: subheaderData.titleWrap
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("TextWrap");
                    });
                }), cardBuilder.addGroup("background", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Visual_Background").addSimpleSlice("color", new build_control_util.BT({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, layoutProps.backgroundColor), {
                            selector: {
                                data: [ (0, dataViewRoleWildcard.Yp)([ cartesian_capabilities.x.rows ]) ]
                            },
                            altConstantValueSelector: null,
                            instanceKind: 3
                        }),
                        value: {
                            value: layout.backgroundColor
                        },
                        isNoFillItemSupported: !0
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Generic_Color");
                    }).addSimpleSlice("transparency", build_control_util.JN.getTransparencySliderBuilder({
                        descriptor: layoutProps.backgroundTransparency,
                        value: layout.backgroundTransparency,
                        localize: _this.localizer
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Transparency");
                    });
                }), cardBuilder.build();
            }
        }
        function getInnerPaddingBuilder(axisData, localize) {
            return new build_control_util.JN({
                descriptor: cartesian_capabilities.p.categoryAxis.innerPadding,
                value: cartesianHelper.qE(axisData),
                options: {
                    minValue: {
                        type: 0,
                        value: cartesianHelper.T4
                    },
                    maxValue: {
                        type: 1,
                        value: cartesianHelper.zn
                    },
                    unitSymbol: visualLocKeys.t2
                },
                localize
            }).build();
        }
        function customizeFormattingCard(card) {
            if (card) for (var customizedCard = card, _i = 0, layers_2 = this.getLayers(); _i < layers_2.length; _i++) {
                var layer = layers_2[_i];
                return layer.customizeFormattingCard && (customizedCard = layer.customizeFormattingCard(card)), 
                customizedCard;
            }
        }
        function getSubSelectionCustomOutlines(subSelection) {
            for (var _i = 0, layers_3 = this.getLayers(); _i < layers_3.length; _i++) {
                var layer = layers_3[_i];
                if (layer.getSubSelectionCustomOutlines) {
                    var result = layer.getSubSelectionCustomOutlines(subSelection);
                    if (result) return result;
                }
            }
            return [];
        }
        function getSubSelectionCustomElements(subSelection) {
            for (var _i = 0, layers_4 = this.getLayers(); _i < layers_4.length; _i++) {
                var layer = layers_4[_i];
                if (layer.getSubSelectionCustomElements) {
                    var result = layer.getSubSelectionCustomElements(subSelection);
                    if (result) return result;
                }
            }
            return [];
        }
        function getSubSelectionMetadata(subSelectionElement) {
            for (var _i = 0, layers_5 = this.getLayers(); _i < layers_5.length; _i++) {
                var layer = layers_5[_i];
                if (layer.getSubSelectionMetadata) {
                    var result = layer.getSubSelectionMetadata(subSelectionElement);
                    if (result) return result;
                }
            }
            return null;
        }
        function getSubSelectionStyles(subSelections) {
            if (this.featureSwitches.onObject) {
                var visualObject, selector, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0) {
                    (null == (visualObject = visualObjects[0]) ? void 0 : visualObject.selectorsByColumn) && (selector = (0, 
                    contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn)));
                    var omitForSingleSeries = 1 === this.getLayers().length && this.cartesianData.legendData.dataPoints.length <= 1, isComboChart = this.isComboChart();
                    switch (visualObject.objectName) {
                      case "legend-title":
                        return (0, legend_formatting.aJ)();

                      case "x-axis-zoom-slider":
                      case "y1-axis-zoom-slider":
                      case "y2-axis-zoom-slider":
                        return;

                      case "legend-items":
                        return (0, legend_formatting.Gh)(this.hostServices);

                      case "horizontal-gridlines":
                        return onObjectUtil.w3(this.hostServices, this.axes.isYAxisCategorical ? cartesian_capabilities.p.categoryAxis.gridlineColor : cartesian_capabilities.p.valueAxis.gridlineColor);

                      case "vertical-gridlines":
                        return onObjectUtil.w3(this.hostServices, this.axes.isYAxisCategorical ? cartesian_capabilities.p.valueAxis.gridlineColor : cartesian_capabilities.p.categoryAxis.gridlineColor);

                      case "series-labels":
                        var givenSelector = omitForSingleSeries ? void 0 : selector;
                        return onObjectUtil.un(this.hostServices, {
                            fontFamilyReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.seriesFontFamily), {
                                selector: givenSelector
                            }),
                            fontSizeReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.textSize), {
                                selector: givenSelector
                            }),
                            boldReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.bold), {
                                selector: givenSelector
                            }),
                            italicReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.italic), {
                                selector: givenSelector
                            }),
                            underlineReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.underline), {
                                selector: givenSelector
                            }),
                            fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.seriesColor), {
                                selector: givenSelector
                            }),
                            backgroundReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.backgroundColor), {
                                selector: givenSelector
                            }),
                            wordWrapReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.seriesWordWrap), {
                                selector: givenSelector
                            })
                        });

                      case "x-axis-title":
                        return getAxisTitleSubSelectionStyles(!1, isComboChart, !this.axes.isYAxisCategorical, this.hostServices);

                      case "y1-axis-title":
                        return getAxisTitleSubSelectionStyles(!1, isComboChart, this.axes.isYAxisCategorical, this.hostServices);

                      case "y2-axis-title":
                        return getAxisTitleSubSelectionStyles(!0, isComboChart, this.axes.isYAxisCategorical, this.hostServices);

                      case "x-axis-values":
                        return getAxisValuesSubSelectionStyles(!1, isComboChart, !this.axes.isYAxisCategorical, this.hostServices);

                      case "y1-axis-values":
                        return getAxisValuesSubSelectionStyles(!1, isComboChart, this.axes.isYAxisCategorical, this.hostServices);

                      case "y2-axis-values":
                        return getAxisValuesSubSelectionStyles(!0, isComboChart, this.axes.isYAxisCategorical, this.hostServices);

                      case "grid-cell-subheader":
                        var subheaderProps = dataViewObjectProperties.N_.subheader;
                        return onObjectUtil.un(this.hostServices, {
                            fontFamilyReference: subheaderProps.fontFamily,
                            fontSizeReference: subheaderProps.fontSize,
                            boldReference: subheaderProps.bold,
                            italicReference: subheaderProps.italic,
                            underlineReference: subheaderProps.underline,
                            fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, subheaderProps.fontColor), {
                                selector: {
                                    data: [ (0, dataViewRoleWildcard.Yp)([ cartesian_capabilities.x.rows ]) ]
                                }
                            }),
                            horizontalAlignmentReference: subheaderProps.alignment,
                            wordWrapReference: subheaderProps.titleWrap
                        });

                      case "small-multiples-gridlines":
                        var smallMultiplesLayoutProps = dataViewObjectProperties.N_.smallMultiplesLayout;
                        return onObjectUtil.w3(this.hostServices, smallMultiplesLayoutProps.gridLineColor, (0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, smallMultiplesLayoutProps.backgroundColor), {
                            selector: {
                                data: [ (0, dataViewRoleWildcard.Yp)([ cartesian_capabilities.x.rows ]) ]
                            }
                        }), this.localizer("Visual_Border"));

                      default:
                        for (var _i = 0, _a = this.getLayers(); _i < _a.length; _i++) {
                            var layer = _a[_i];
                            if (layer.getSubSelectionStyles) {
                                var subSelectionStyles = layer.getSubSelectionStyles(subSelections);
                                if (subSelectionStyles) return subSelectionStyles;
                            }
                        }
                    }
                }
            }
        }
        function getSubSelectionShortcuts(subSelections, filter) {
            if (this.featureSwitches.onObject && !filter) {
                var visualObject, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0) {
                    visualObject = visualObjects[0];
                    var selector, layers = this.getLayers(), isComboChart = this.isComboChart(), useTopLevelToggle = layers.length <= 1 && this.cartesianData.legendData.dataPoints.length <= 1, deleteKeyboardShortcut = {
                        key: "Delete",
                        nextValue: !1
                    };
                    switch (useTopLevelToggle || _.isEmpty(visualObject.selectorsByColumn) || (selector = (0, 
                    contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn))), 
                    visualObject.objectName) {
                      case "legend-title":
                        return (0, legend_formatting.tV)(this.hostServices);

                      case "legend-items":
                        return (0, legend_formatting.tY)({
                            hostServices: this.hostServices,
                            showSort: !0
                        });

                      case "horizontal-gridlines":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, (this.axes.isYAxisCategorical ? cartesian_capabilities.p.categoryAxis : cartesian_capabilities.p.valueAxis).gridlineShow), {
                            disabledLabel: this.localizer("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0
                        }, {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("gridlines"),
                                groupUid: "".concat("gridlines", "-").concat("horizontal")
                            },
                            label: this.localizer("Format_Gridlines")
                        } ];

                      case "vertical-gridlines":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, (this.axes.isYAxisCategorical ? cartesian_capabilities.p.valueAxis : cartesian_capabilities.p.categoryAxis).gridlineShow), {
                            disabledLabel: this.localizer("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0
                        }, {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("gridlines"),
                                groupUid: "".concat("gridlines", "-").concat("vertical")
                            },
                            label: this.localizer("Format_Gridlines")
                        } ];

                      case "data-labels":
                        var dataLabelsToggle = useTopLevelToggle ? dataViewObjectProperties.N_.labels.show : dataViewObjectProperties.N_.labels.showSeries;
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, dataLabelsToggle), {
                            disabledLabel: this.localizer("Delete"),
                            selector,
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            excludedResetFormattingIds: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataLabelsToggle), {
                                selector
                            }) ],
                            relatedResetFormattingIds: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.labels.enableBackground), {
                                selector
                            }) ]
                        }, {
                            type: 1,
                            destinationInfo: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.labels.labelPosition), {
                                selector
                            }),
                            label: this.localizer("Format_Data_Labels")
                        } ];

                      case "series-labels":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, dataViewObjectProperties.N_.seriesLabels.show), {
                            disabledLabel: this.localizer("Delete"),
                            selector,
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            relatedResetFormattingIds: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.enableBackground), {
                                selector
                            }) ],
                            excludedResetFormattingIds: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.show), {
                                selector
                            }) ]
                        }, {
                            type: 1,
                            destinationInfo: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataViewObjectProperties.N_.seriesLabels.seriesPosition), {
                                selector
                            }),
                            label: this.localizer("Format_Series_Labels")
                        } ];

                      case "total-labels":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, dataViewObjectProperties.N_.totals.show), {
                            disabledLabel: this.localizer("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            excludedResetFormattingIds: [ dataViewObjectProperties.N_.totals.show ]
                        }, {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("totals"),
                                groupUid: "".concat("totals", "-").concat("values")
                            },
                            label: this.localizer("Format_Total_Labels")
                        } ];

                      case "x-axis-title":
                        return getAxisTitleSubSelectionShortcuts(!1, isComboChart, !this.axes.isYAxisCategorical, this.categoryAxisIsScalar().isScalar, this.hostServices);

                      case "y1-axis-title":
                        return getAxisTitleSubSelectionShortcuts(!1, isComboChart, this.axes.isYAxisCategorical, this.categoryAxisIsScalar().isScalar, this.hostServices);

                      case "y2-axis-title":
                        return getAxisTitleSubSelectionShortcuts(!0, isComboChart, this.axes.isYAxisCategorical, this.categoryAxisIsScalar().isScalar, this.hostServices);

                      case "x-axis-values":
                        return getAxisValuesSubSelectionShortcuts(!1, isComboChart, !this.axes.isYAxisCategorical, this.categoryAxisIsScalar().isScalar, this.categoryAxisIsScalar().supportedType, this.hostServices);

                      case "y1-axis-values":
                        return getAxisValuesSubSelectionShortcuts(!1, isComboChart, this.axes.isYAxisCategorical, this.categoryAxisIsScalar().isScalar, this.categoryAxisIsScalar().supportedType, this.hostServices);

                      case "y2-axis-values":
                        return getAxisValuesSubSelectionShortcuts(!0, isComboChart, this.axes.isYAxisCategorical, this.categoryAxisIsScalar().isScalar, this.categoryAxisIsScalar().supportedType, this.hostServices);

                      case "grid-cell-subheader":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, dataViewObjectProperties.N_.subheader.show), {
                            disabledLabel: this.localizer("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0
                        }, {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("smallMultiples"),
                                groupUid: "".concat("smallMultiples", "-").concat("title")
                            },
                            label: this.localizer("Format_Small_Multiples_Title")
                        } ];

                      case "small-multiples-gridlines":
                        return [ {
                            type: 0
                        }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 3
                        }, dataViewObjectProperties.N_.smallMultiplesLayout.gridLineType), {
                            label: this.localizer("Small_Multiples_Gridlines_Style")
                        }), {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("smallMultiples"),
                                groupUid: "".concat("smallMultiples", "-").concat("border")
                            },
                            label: this.localizer("Format_Small_Multiples_Border")
                        } ];

                      case "x-axis-zoom-slider":
                      case "y1-axis-zoom-slider":
                      case "y2-axis-zoom-slider":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, "y2-axis-zoom-slider" === visualObject.objectName ? axisZoomProperties.t.showOnValueSecAxis : !("x-axis-zoom-slider" !== visualObject.objectName) == !!this.axes.isYAxisCategorical ? axisZoomProperties.t.showOnValueAxis : axisZoomProperties.t.showOnCategoryAxis), {
                            disabledLabel: this.localizer("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            excludedResetFormattingIds: [ axisZoomProperties.t.showOnValueSecAxis ]
                        }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, axisZoomProperties.t.showLabels), {
                            enabledLabel: this.localizer("Format_AddSliderLabels")
                        }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, axisZoomProperties.t.showTooltip), {
                            enabledLabel: this.localizer("Format_AddSliderTooltips")
                        }), {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("zoom"),
                                groupUid: "".concat("zoom", "-").concat("default")
                            },
                            label: this.localizer("Format_ZoomSlider")
                        } ];

                      default:
                        for (var _i = 0, layers_6 = layers; _i < layers_6.length; _i++) {
                            var layer = layers_6[_i];
                            if (layer.getSubSelectionShortcuts) {
                                var subSelectionShortcuts = layer.getSubSelectionShortcuts(subSelections, filter);
                                if (subSelectionShortcuts) return subSelectionShortcuts;
                            }
                        }
                    }
                }
            }
        }
        function getSubSelectables(filterType) {
            for (var subSelectables = this.subSelectionHelper.getAllSubSelectables(filterType), _i = 0, layers_7 = this.getLayers(); _i < layers_7.length; _i++) {
                var layer = layers_7[_i];
                layer.getDisambiguationSubSelectables && subSelectables.push.apply(subSelectables, layer.getDisambiguationSubSelectables(this.subSelectionHelper, filterType));
            }
            return subSelectables;
        }
    },
    63616: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            CartesianAxisRenderModeSelector: function() {
                return CartesianAxisRenderModeSelector;
            },
            CartesianCategoryLoadMoreDataHandler: function() {
                return CartesianCategoryLoadMoreDataHandler;
            },
            CartesianChart: function() {
                return CartesianChart;
            },
            SharedColorPalette: function() {
                return SharedColorPalette;
            }
        });
        var tslib_es6 = __webpack_require__(81337), cartesian_capabilities = __webpack_require__(22733), scalarUtils = __webpack_require__(86946), common_colorHelper = __webpack_require__(90120), concatenateUtils = __webpack_require__(95938), dataViewObjectChangeHelper = __webpack_require__(51650), dataViewHelper = __webpack_require__(95309), invalidDataValuesChecker = __webpack_require__(33777), objectEnumerationBuilder = __webpack_require__(28579), referenceLineHelper1 = __webpack_require__(47006), htmlSubSelectionHelper = __webpack_require__(52287), subSelectionOutlineRenderer = __webpack_require__(86900), trendLineHelper = __webpack_require__(92783), visualBackgroundHelper = __webpack_require__(45545), legend = __webpack_require__(65741), services_interactivityService = __webpack_require__(72902), tooltipService = __webpack_require__(40739), axisType = __webpack_require__(48766), visualWarnings = __webpack_require__(45296), colorHelper = __webpack_require__(44783), debug = __webpack_require__(62458), Prototype = __webpack_require__(39681), bubblingEventManager = __webpack_require__(58778), build_control_util = __webpack_require__(56578), loadMoreDataHandler = __webpack_require__(60810), enums = __webpack_require__(46135), dataRoleHelper = __webpack_require__(38958), dataViewObject2 = __webpack_require__(82755), CssConstants = __webpack_require__(79154), textMeasurementService = __webpack_require__(32041), StandaloneUtility1 = __webpack_require__(64329), axisZoomProperties = __webpack_require__(3087), labelPosition2 = __webpack_require__(38168), common_fontProperties = __webpack_require__(18664), seriesLabelViewModel = __webpack_require__(95519), onObjectUtil = __webpack_require__(80065), cartesianAxisHelper = __webpack_require__(11956), noUiSlider = __webpack_require__(45863), axisHelper = __webpack_require__(53197), NoUiTargetClass = (0, 
        CssConstants.CH)("noUi-target"), NoUiBaseClass = (0, CssConstants.CH)("noUi-base"), NoUiValueClass = (0, 
        CssConstants.CH)("noUi-value"), noUiHandleClass = (0, CssConstants.CH)("noUi-handle"), AxisZoomSlider = function() {
            function AxisZoomSlider() {}
            return AxisZoomSlider.createOrUpdateSliders = function(options) {
                var axesData = options.axesData, zoomAxes = options.zoomAxes, zoomData = options.zoomData, zoomExtents = options.zoomExtents, hasYAxisCategorical = options.hasYAxisCategorical, yFlipped = options.yFlipped, maxLabelWidthLeft = options.maxLabelWidthLeft, maxLabelWidthRight = options.maxLabelWidthRight, resetEventHandlers = options.resetEventHandlers, hideSliders = options.hideSliders, visualHostServices = options.visualHostServices, invertedState = options.invertedState;
                options.containers.each(function(position) {
                    var axisProperties, extent, axisType = AxisZoomSlider.getAxisType(position, yFlipped), reCreateSlider = !1;
                    if ("y2" === axisType ? (axisProperties = zoomAxes.valueSecAxis, extent = zoomExtents.valueSecExtent) : "y1" === axisType && hasYAxisCategorical || "x" === axisType && !hasYAxisCategorical ? (axisProperties = zoomAxes.categoryAxis, 
                    extent = zoomExtents.categoryExtent) : (axisProperties = zoomAxes.valueAxis, extent = zoomExtents.valueExtent), 
                    axisProperties) {
                        var axisData = AxisZoomSlider.getAxisData(axisType, axesData), scaleDomain = axisProperties.scale.domain(), labelValues = axisProperties.d3Axis.tickValues(), isLogScale = axisData.logAxisScale && (0, 
                        cartesianAxisHelper.isLogScaleAllowedFunc)(scaleDomain), scaleType = hideSliders ? "none" : AxisZoomSlider.getScaleType(scaleDomain, isLogScale);
                        "none" !== scaleType && isLogScale && (extent = AxisZoomSlider.calcLogSliderValues(extent), 
                        scaleDomain = AxisZoomSlider.calcLogSliderValues(scaleDomain), labelValues = AxisZoomSlider.calcLogSliderValues(labelValues));
                        var formatFn = AxisZoomSlider.getFormatFn(axisProperties, scaleType), container = d3.select(this), slider = container.select(NoUiTargetClass.selector);
                        AxisZoomSlider.wasInverted(axisType, axesData, invertedState) && (slider.node() && slider.node().noUiSlider.destroy(), 
                        reCreateSlider = !0), slider.node() && !reCreateSlider ? AxisZoomSlider.updateSlider({
                            slider,
                            axisType,
                            axisData,
                            zoomData,
                            hasYAxisCategorical,
                            extent,
                            scaleDomain,
                            labelValues,
                            maxLabelWidth: "left" === position ? maxLabelWidthLeft : maxLabelWidthRight,
                            scaleType,
                            formatFn,
                            resetEventHandlers,
                            visualHostServices
                        }) : AxisZoomSlider.createSlider({
                            container,
                            axisType,
                            axisData,
                            zoomData,
                            hasYAxisCategorical,
                            extent,
                            scaleDomain,
                            labelValues,
                            maxLabelWidth: "left" === position ? maxLabelWidthLeft : maxLabelWidthRight,
                            scaleType,
                            formatFn,
                            visualHostServices
                        });
                    }
                });
            }, AxisZoomSlider.createSlider = function(options) {
                var axisType = options.axisType, axisData = options.axisData, zoomData = options.zoomData, hasYAxisCategorical = options.hasYAxisCategorical, extent = options.extent, scaleDomain = options.scaleDomain, labelValues = options.labelValues, maxLabelWidth = options.maxLabelWidth, scaleType = options.scaleType, formatFn = options.formatFn, visualHostServices = options.visualHostServices;
                if ("none" !== scaleType) {
                    var slider = options.container.append("div").attr("rtl", "rtl" === document.dir);
                    (0, noUiSlider.create)(slider.node(), {
                        start: extent,
                        range: {
                            min: scaleDomain[0],
                            max: scaleDomain[1]
                        },
                        margin: .001 * (scaleDomain[1] - scaleDomain[0]),
                        connect: !0,
                        behaviour: "tap-drag",
                        orientation: "x" === axisType ? "horizontal" : "vertical",
                        direction: "x" === axisType ? axisData.invertAxis ? "rtl" : "ltr" : axisData.invertAxis ? "ltr" : "rtl",
                        tooltips: !!zoomData.showTooltip && [ {
                            to: formatFn
                        }, {
                            to: formatFn
                        } ],
                        pips: zoomData.showLabels ? {
                            mode: "values",
                            values: labelValues,
                            format: {
                                to: formatFn,
                                from: void 0
                            }
                        } : void 0
                    }), slider.select(NoUiBaseClass.selector).attr("drag-resize-disabled", !0).on("keydown", function() {
                        return d3.event.stopPropagation();
                    }), this.applyVisualAxisStyles(slider, axisType, axisData, maxLabelWidth);
                    var propertyNames = this.getAxisZoomPropertyNames(axisType, hasYAxisCategorical);
                    slider.node().querySelectorAll(noUiHandleClass.selector).forEach(function(element) {
                        element.setAttribute("aria-label", options.visualHostServices.getLocalizedString("Visual_ZoomSlider"));
                    }), slider.node().noUiSlider.on("slide", _.throttle(function(values, handle, rawValues) {
                        AxisZoomSlider.onSlide(propertyNames.min, propertyNames.max, propertyNames.size, rawValues, this.options.range.min, this.options.range.max, scaleType, visualHostServices);
                    }, 100)), this.convertSliderToSubSelectable(slider, axisType);
                }
            }, AxisZoomSlider.updateSlider = function(options) {
                var slider = options.slider, axisType = options.axisType, axisData = options.axisData, zoomData = options.zoomData, hasYAxisCategorical = options.hasYAxisCategorical, extent = options.extent, scaleDomain = options.scaleDomain, labelValues = options.labelValues, maxLabelWidth = options.maxLabelWidth, scaleType = options.scaleType, formatFn = options.formatFn, resetEventHandlers = options.resetEventHandlers, visualHostServices = options.visualHostServices;
                if ("none" !== scaleType) {
                    if (slider.node().noUiSlider.updateOptions({
                        start: extent,
                        range: {
                            min: scaleDomain[0],
                            max: scaleDomain[1]
                        },
                        margin: .001 * (scaleDomain[1] - scaleDomain[0]),
                        tooltips: !!zoomData.showTooltip && [ {
                            to: formatFn
                        }, {
                            to: formatFn
                        } ],
                        pips: zoomData.showLabels ? {
                            mode: "values",
                            values: labelValues,
                            format: {
                                to: formatFn,
                                from: void 0
                            }
                        } : null
                    }, !1), this.applyVisualAxisStyles(slider, axisType, axisData, maxLabelWidth), resetEventHandlers) {
                        var propertyNames_1 = this.getAxisZoomPropertyNames(axisType, hasYAxisCategorical);
                        slider.node().noUiSlider.off("slide"), slider.node().noUiSlider.on("slide", _.throttle(function(values, handle, rawValues) {
                            AxisZoomSlider.onSlide(propertyNames_1.min, propertyNames_1.max, propertyNames_1.size, rawValues, this.options.range.min, this.options.range.max, scaleType, visualHostServices);
                        }, 100));
                    }
                    this.convertSliderToSubSelectable(slider, axisType);
                } else slider.node().noUiSlider.destroy();
            }, AxisZoomSlider.convertSliderToSubSelectable = function(slider, axisType) {
                var _this = this;
                slider.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, this.getAxisZoomSliderSubSelectableRegionAttribute(axisType)).attr(htmlSubSelectionHelper.CK, "Visual_ZoomSlider").attr(htmlSubSelectionHelper.QZ, 0);
                var sliderElement = slider.node();
                htmlSubSelectionHelper.O5.setDataForElement(sliderElement, {
                    getRegionOutlines: function() {
                        return _this.getSliderOutlines(sliderElement, axisType);
                    }
                });
            }, AxisZoomSlider.getSliderOutlines = function(sliderElement, axisType) {
                var sliderRect = sliderElement.getBoundingClientRect(), handleRadius = sliderElement.querySelector(noUiHandleClass.selector).getBoundingClientRect().width / 2;
                return [ {
                    id: this.getAxisZoomSliderSubSelectableRegionAttribute(axisType),
                    outline: {
                        x: sliderRect.x - handleRadius,
                        y: sliderRect.y - handleRadius,
                        width: handleRadius + sliderRect.width + handleRadius,
                        height: handleRadius + sliderRect.height + handleRadius,
                        type: 1
                    }
                } ];
            }, AxisZoomSlider.getAxisZoomSliderSubSelectableRegionAttribute = function(axisType) {
                switch (axisType) {
                  case "x":
                    return "x-axis-zoom-slider";

                  case "y1":
                    return "y1-axis-zoom-slider";

                  case "y2":
                    return "y2-axis-zoom-slider";

                  default:
                    debug.fF.assertFail("Unsupported axis type");
                }
            }, AxisZoomSlider.destroySliders = function(options) {
                var hasYAxisCategorical = options.hasYAxisCategorical, yFlipped = options.yFlipped, visualHostServices = options.visualHostServices;
                options.containers.each(function(position) {
                    var axisType = AxisZoomSlider.getAxisType(position, yFlipped);
                    AxisZoomSlider.destroySlider({
                        axisType,
                        hasYAxisCategorical,
                        visualHostServices
                    });
                });
            }, AxisZoomSlider.destroySlider = function(options) {
                var visualHostServices = options.visualHostServices, propertyNames = this.getAxisZoomPropertyNames(options.axisType, options.hasYAxisCategorical), removeProperties = {};
                removeProperties[propertyNames.min] = !0, removeProperties[propertyNames.max] = !0, 
                removeProperties[propertyNames.size] = !0, visualHostServices.persistProperties({
                    remove: [ {
                        objectName: "zoom",
                        properties: removeProperties,
                        selector: void 0
                    } ]
                }, !0);
            }, AxisZoomSlider.onSlide = function(minPropertyName, maxPropertyName, sizePropertyName, rawValues, sliderMin, sliderMax, scaleType, visualHostServices) {
                var mergeProperties = {}, removeProperties = {};
                rawValues = _.map(rawValues, function(rawValue) {
                    return AxisZoomSlider.calcOriginalValue(rawValue, scaleType);
                }), sliderMin = AxisZoomSlider.calcOriginalValue(sliderMin, scaleType), sliderMax = AxisZoomSlider.calcOriginalValue(sliderMax, scaleType);
                var size = rawValues[1] - rawValues[0];
                rawValues[0] === sliderMin && rawValues[1] === sliderMax ? (removeProperties[minPropertyName] = !0, 
                removeProperties[maxPropertyName] = !0, removeProperties[sizePropertyName] = !0) : rawValues[0] === sliderMin ? (removeProperties[minPropertyName] = !0, 
                mergeProperties[maxPropertyName] = Number(!0), mergeProperties[sizePropertyName] = size) : rawValues[1] === sliderMax ? (mergeProperties[minPropertyName] = Number(!0), 
                removeProperties[maxPropertyName] = !0, mergeProperties[sizePropertyName] = size) : (mergeProperties[minPropertyName] = rawValues[0], 
                mergeProperties[maxPropertyName] = rawValues[1], removeProperties[sizePropertyName] = !0), 
                visualHostServices.persistProperties({
                    merge: [ {
                        objectName: "zoom",
                        properties: mergeProperties,
                        selector: void 0
                    } ],
                    remove: [ {
                        objectName: "zoom",
                        properties: removeProperties,
                        selector: void 0
                    } ]
                }, !0);
            }, AxisZoomSlider.getAxisType = function(position, yFlipped) {
                switch (position) {
                  case "bottom":
                    return "x";

                  case "left":
                    return yFlipped ? "y2" : "y1";

                  case "right":
                    return yFlipped ? "y1" : "y2";

                  default:
                    debug.fF.assertNever(position);
                }
            }, AxisZoomSlider.getFormatFn = function(axisProperties, scaleType) {
                var _a;
                if ("none" !== scaleType) {
                    var format = null !== (_a = axisProperties.d3Axis.tickFormat()) && void 0 !== _a ? _a : cartesianAxisHelper.defaultTickFormat;
                    return function(value) {
                        return format(AxisZoomSlider.calcOriginalValue(value, scaleType), 0);
                    };
                }
            }, AxisZoomSlider.calcLogSliderValues = function(values) {
                return _.map(values, function(value) {
                    return AxisZoomSlider.log10(Math.abs(value));
                });
            }, AxisZoomSlider.calcOriginalValue = function(value, scaleType) {
                switch (scaleType) {
                  case "linear":
                    return value;

                  case "log":
                    return Math.pow(10, value);

                  case "rLog":
                    return -Math.pow(10, value);

                  default:
                    debug.fF.assertNever(scaleType);
                }
            }, AxisZoomSlider.applyVisualAxisStyles = function(slider, axisType, axisData, maxLabelWidth) {
                var fontProperties = axisData.labelFontProperties;
                slider.selectAll(NoUiValueClass.selector).styles((0, common_fontProperties.wB)(fontProperties)), 
                "x" !== axisType && slider.selectAll(NoUiValueClass.selector).call(axisHelper.oq, maxLabelWidth, textMeasurementService.b.svgEllipsis);
            }, AxisZoomSlider.getAxisData = function(axisType, axesData) {
                return axesData["y1" === axisType ? "y" : axisType];
            }, AxisZoomSlider.getScaleType = function(scaleDomain, isLogScale) {
                return debug.fF.assert(function() {
                    return scaleDomain[0] !== scaleDomain[1];
                }, "Scale domain should not have zero width"), isLogScale ? (debug.fF.assert(function() {
                    return scaleDomain[0] < 0 && scaleDomain[1] < 0 || scaleDomain[0] > 0 && scaleDomain[1] > 0;
                }, "Log scale domain should not cross or contain 0"), scaleDomain[0] < 0 ? "rLog" : "log") : "linear";
            }, AxisZoomSlider.log10 = function(value) {
                return Math.log(value) / Math.log(10);
            }, AxisZoomSlider.wasInverted = function(axisType, axesData, invertedState) {
                return "x" === axisType && (null == invertedState ? void 0 : invertedState.x) !== axesData.x.invertAxis || "y1" === axisType && (null == invertedState ? void 0 : invertedState.y) !== axesData.y.invertAxis || "y2" === axisType && (null == invertedState ? void 0 : invertedState.y2) !== axesData.y2.invertAxis;
            }, AxisZoomSlider.getAxisZoomPropertyNames = function(axisType, hasYAxisCategorical) {
                return "y2" === axisType ? {
                    min: axisZoomProperties.t.valueSecMin.propertyName,
                    max: axisZoomProperties.t.valueSecMax.propertyName,
                    size: axisZoomProperties.t.valueSecSize.propertyName
                } : "y1" === axisType && hasYAxisCategorical || "x" === axisType && !hasYAxisCategorical ? {
                    min: axisZoomProperties.t.categoryMin.propertyName,
                    max: axisZoomProperties.t.categoryMax.propertyName,
                    size: axisZoomProperties.t.categorySize.propertyName
                } : {
                    min: axisZoomProperties.t.valueMin.propertyName,
                    max: axisZoomProperties.t.valueMax.propertyName,
                    size: axisZoomProperties.t.valueSize.propertyName
                };
            }, AxisZoomSlider;
        }(), ZoomClass = (0, CssConstants.CH)("zoom"), AxisZoom = function() {
            function AxisZoom(element, hostServices, isScrollable, featureSwitches) {
                this.hostServices = hostServices, this.isScrollable = isScrollable, this.featureSwitches = featureSwitches, 
                this._zoomData = (0, tslib_es6.__assign)({}, AxisZoom.DefaultOptions), this.axesLabels = {}, 
                this.zoomContext = d3.select(element.get(0)).append("div").attr("class", "axisZoom").style("position", "absolute"), 
                this.zoomAxes = {
                    categoryAxis: void 0,
                    valueAxis: void 0,
                    valueSecAxis: void 0
                }, this.zoomExtents = {
                    categoryExtent: void 0,
                    valueExtent: void 0,
                    valueSecExtent: void 0
                };
            }
            return AxisZoom.prototype.destroy = function() {
                this.zoomContext.selectAll(ZoomClass.selector).remove();
            }, AxisZoom.prototype.update = function(options) {
                var _a, _b, _c, dataViews = options.dataViews, hasScalarCategoryAxis = options.hasScalarCategoryAxis;
                if (this.hasSmallMultiples = options.hasSmallMultiples, this.hasYAxisCategorical = options.hasYAxisCategorical, 
                this._zoomData = this.hasSmallMultiples || !this.isScrollable ? (0, tslib_es6.__assign)({}, AxisZoom.DefaultOptions) : options.zoomData, 
                hasScalarCategoryAxis || (this._zoomData.showOnCategoryAxis = !1), this.hasValueAxis = !1, 
                this.hasCategoryAxis = !1, this.hasY2Axis = !1, dataViews) {
                    for (var _i = 0, dataViews_1 = dataViews; _i < dataViews_1.length; _i++) {
                        var dataView = dataViews_1[_i];
                        this.hasCategoryAxis || (this.hasCategoryAxis = hasScalarCategoryAxis && ((0, dataRoleHelper.c5)(dataView, cartesian_capabilities.x.category) || (0, 
                        dataRoleHelper.c5)(dataView, cartesian_capabilities.x.x))), this.hasValueAxis || (this.hasValueAxis = (0, 
                        dataRoleHelper.c5)(dataView, cartesian_capabilities.x.y)), this.hasY2Axis || (this.hasY2Axis = (0, 
                        dataRoleHelper.c5)(dataView, cartesian_capabilities.x.y2));
                    }
                    (_a = this._zoomData).showOnValueAxis && (_a.showOnValueAxis = this.hasValueAxis), 
                    (_b = this._zoomData).showOnValueSecAxis && (_b.showOnValueSecAxis = this.hasY2Axis), 
                    (_c = this._zoomData).showOnCategoryAxis && (_c.showOnCategoryAxis = this.hasCategoryAxis);
                }
            }, AxisZoom.prototype.render = function(options) {
                var _a, _b, _c, _d, _this = this, axesMargin = (_a = options.axesLayout).margin, shouldRenderAxis = _a.shouldRenderAxis, axesData = options.axesData, position = (0, 
                tslib_es6.__assign)({}, this.baseZoomAxesPosition);
                if (position.bottom) {
                    position.bottom.width -= axesMargin.left + axesMargin.right;
                    var seriesLabelWidth = (null == axesData ? void 0 : axesData.showsSeriesLabels()) ? (0, 
                    seriesLabelViewModel.lr)(axesData.seriesLabelSettings, position.bottom.width) : 0;
                    position.bottom.width -= seriesLabelWidth, position.bottom.left += axesMargin.left + (axesData.seriesLabelSettings.position === labelPosition2.M.left ? seriesLabelWidth : 0), 
                    !this.hasYAxisCategorical && this.xOuterPadding && (position.bottom.left += this.xOuterPadding, 
                    position.bottom.width -= 2 * this.xOuterPadding);
                }
                position.left && (position.left.top += axesMargin.top, position.left.height -= axesMargin.top + axesMargin.bottom), 
                position.right && (position.right.top += axesMargin.top, position.right.height -= axesMargin.top + axesMargin.bottom);
                var axesLabels = this.axesLabels, yFlipped = this.yFlipped, categoryScaleDomain = null === (_b = this.zoomAxes.categoryAxis) || void 0 === _b ? void 0 : _b.scale.domain(), valueScaleDomain = null === (_c = this.zoomAxes.valueAxis) || void 0 === _c ? void 0 : _c.scale.domain(), valueSecScaleDomain = null === (_d = this.zoomAxes.valueSecAxis) || void 0 === _d ? void 0 : _d.scale.domain(), hideSliders = !(shouldRenderAxis.x || shouldRenderAxis.y || shouldRenderAxis.y2) || categoryScaleDomain && categoryScaleDomain[0] === categoryScaleDomain[1] || valueScaleDomain && valueScaleDomain[0] === valueScaleDomain[1] || valueSecScaleDomain && valueSecScaleDomain[0] === valueSecScaleDomain[1], supportsOnObjectFormatting = this.featureSwitches && this.featureSwitches.onObject, self = this;
                this.zoomContext.selectAll(ZoomClass.selector).style("top", function(d) {
                    return position[d].top ? "".concat(position[d].top, "px") : null;
                }).style("left", function(d) {
                    return position[d].left ? "".concat(position[d].left, "px") : null;
                }).style("width", function(d) {
                    return "".concat(position[d].width, "px");
                }).style("height", function(d) {
                    return "".concat(position[d].height, "px");
                }).call(function(containers) {
                    return AxisZoomSlider.createOrUpdateSliders({
                        containers,
                        axesData,
                        zoomAxes: _this.zoomAxes,
                        zoomData: _this.zoomData,
                        zoomExtents: _this.zoomExtents,
                        hasYAxisCategorical: _this.hasYAxisCategorical,
                        yFlipped: _this.yFlipped,
                        maxLabelWidthLeft: _this.maxZoomLabelWidthLeft,
                        maxLabelWidthRight: _this.maxZoomLabelWidthRight,
                        resetEventHandlers: _this.resetEventHandlers,
                        hideSliders,
                        visualHostServices: _this.hostServices,
                        invertedState: _this.invertedState
                    });
                }).each(function(axis) {
                    var axisType, thisContainer = d3.select(this);
                    switch (axis) {
                      case "bottom":
                        axisType = "x";
                        break;

                      case "left":
                        axisType = yFlipped ? "y2" : "y";
                        break;

                      case "right":
                        axisType = yFlipped ? "y" : "y2";
                        break;

                      default:
                        debug.fF.assertFail(axis);
                    }
                    var isPlaceholder, axisTitleFormatting = axesData[axisType].titleFontProperties, axisLabelData = [];
                    if (axesData[axisType].showAxisTitle && !hideSliders) {
                        var axisLabel = axesLabels[axisType];
                        debug.fF.assertValue("axisZoom: axisLabel", axisLabel), !axisLabel && options.showTitlePlaceholders && supportsOnObjectFormatting && (axisLabel = self.hostServices.getLocalizedString("Format_AddAxisTitle"), 
                        isPlaceholder = !0), axisLabelData = [ axisLabel ];
                    }
                    thisContainer.selectAll(".title").data(axisLabelData, function(d) {
                        return d;
                    }).join(function(enter) {
                        return enter.append("span").attr("class", "title");
                    }).each(function(axisTitle) {
                        var textWidth, titleElement = d3.select(this), titleTextProperties = (0, common_fontProperties.qk)(axisTitleFormatting, axisTitle), height = position[axis].height, width = position[axis].width, textHeight = axisTitleFormatting.size.px;
                        switch (axis) {
                          case "bottom":
                            textWidth = width, titleElement.style("top", "".concat(height - textHeight, "px")).style("left", "50%").style("width", "100%").style("transform", "translateX(-50%)");
                            break;

                          case "left":
                            textWidth = height, titleElement.style("width", "".concat(height, "px")).style("transform", "translateX(-".concat(height / 2, "px)rotate(-90deg)")).style("top", "".concat(height / 2 - AxisZoom.SliderHandleRadius, "px"));
                            break;

                          case "right":
                            textWidth = height, titleElement.style("width", "".concat(height, "px")).style("transform", "translateX(-".concat(height / 2 - 8, "px)rotate(-90deg)")).style("top", "".concat(height / 2 - AxisZoom.SliderHandleRadius, "px")).style("left", "".concat(width - textHeight, "px"));
                            break;

                          default:
                            debug.fF.assertNever(axis);
                        }
                        if (titleElement.styles((0, common_fontProperties.wB)(axisTitleFormatting)).text(textMeasurementService.b.getTailoredTextOrDefault(titleTextProperties, textWidth)), 
                        supportsOnObjectFormatting) {
                            titleElement.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.CK, "Visual_Axis_Title").attr(htmlSubSelectionHelper.QZ, 1);
                            var directEdit = void 0;
                            switch (axisType) {
                              case "x":
                                titleElement.attr(htmlSubSelectionHelper.Ez, "x-axis-title"), directEdit = (0, onObjectUtil.s4)(axesData.categoryAxis === axesData.x ? cartesian_capabilities.p.categoryAxis.titleText : cartesian_capabilities.p.valueAxis.titleText, axesLabels.x);
                                break;

                              case "y":
                                titleElement.attr(htmlSubSelectionHelper.Ez, "y1-axis-title"), directEdit = (0, 
                                onObjectUtil.Mw)(axesData.categoryAxis === axesData.y ? cartesian_capabilities.p.categoryAxis.titleText : cartesian_capabilities.p.valueAxis.titleText, axesLabels.y);
                                break;

                              case "y2":
                                titleElement.attr(htmlSubSelectionHelper.Ez, "y2-axis-title"), directEdit = (0, 
                                onObjectUtil.Mw)(cartesian_capabilities.p.valueAxis.secTitleText, axesLabels.y2);
                                break;

                              default:
                                debug.fF.assertFail(axisType);
                            }
                            isPlaceholder && titleElement.classed(htmlSubSelectionHelper.Qh.class, !0), directEdit && titleElement.attr(htmlSubSelectionHelper.kv, JSON.stringify(directEdit));
                        }
                    });
                }), this.invertedState = {
                    x: axesData.x.invertAxis,
                    y: axesData.y.invertAxis,
                    y2: axesData.y2.invertAxis
                };
            }, AxisZoom.prototype.renderContainers = function(chartAreaViewport, axesData, offsetHeight, _featureSwitches) {
                var _a, _this = this;
                void 0 === offsetHeight && (offsetHeight = 0), this.resetEventHandlers = void 0 !== this.yFlipped && axesData.y.switchAxisPosition !== this.yFlipped || void 0 !== this.isLogScaleX && axesData.x.logAxisScale !== this.isLogScaleX || void 0 !== this.isLogScaleY1 && axesData.y.logAxisScale !== this.isLogScaleY1 || void 0 !== this.isLogScaleY2 && axesData.y2.logAxisScale !== this.isLogScaleY2, 
                this.yFlipped = axesData.y.switchAxisPosition, this.isLogScaleX = axesData.x.logAxisScale, 
                this.isLogScaleY1 = axesData.y.logAxisScale, this.isLogScaleY2 = axesData.y2.logAxisScale;
                var zoomMargins = {
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0
                }, zoomAxesToShow = [];
                if (this.zoomData.show) {
                    var show = (_a = this.zoomData).show, showOnCategoryAxis = _a.showOnCategoryAxis, showOnValueAxis = _a.showOnValueAxis, showLabels = _a.showLabels;
                    if (show) {
                        var showLeft = showOnValueAxis && !this.hasYAxisCategorical || showOnCategoryAxis && this.hasYAxisCategorical, showRight = _a.showOnValueSecAxis;
                        (showOnCategoryAxis && !this.hasYAxisCategorical || showOnValueAxis && this.hasYAxisCategorical) && (zoomMargins.bottom += 16, 
                        showLabels && (zoomMargins.bottom += axesData.x.labelFontProperties.size.px + AxisZoom.StaticPadding), 
                        axesData.x.showAxisTitle && (zoomMargins.bottom += axesData.x.titleFontProperties.size.px + AxisZoom.StaticPadding), 
                        zoomAxesToShow.push("bottom")), (showLeft && !this.yFlipped || showRight && this.yFlipped) && (this.maxZoomLabelWidthLeft = this.getMaxYLabelWidth("left", this.yFlipped, axesData), 
                        zoomMargins.left += (showLabels ? 16 + this.maxZoomLabelWidthLeft + AxisZoom.StaticPadding : 16) + 8, 
                        axesData.y.showAxisTitle && !this.yFlipped ? zoomMargins.left += axesData.y.titleFontProperties.size.px + AxisZoom.StaticPadding : axesData.y2.showAxisTitle && this.yFlipped && (zoomMargins.left += axesData.y2.titleFontProperties.size.px + AxisZoom.StaticPadding), 
                        zoomAxesToShow.push("left")), (showRight && !this.yFlipped || showLeft && this.yFlipped) && (this.maxZoomLabelWidthRight = this.getMaxYLabelWidth("right", this.yFlipped, axesData), 
                        zoomMargins.right += (showLabels ? 16 + this.maxZoomLabelWidthRight + AxisZoom.StaticPadding : 16) + 8, 
                        axesData.y2.showAxisTitle && !this.yFlipped ? zoomMargins.right += axesData.y2.titleFontProperties.size.px + AxisZoom.StaticPadding : axesData.y.showAxisTitle && this.yFlipped && (zoomMargins.right += axesData.y.titleFontProperties.size.px + AxisZoom.StaticPadding), 
                        zoomAxesToShow.push("right"));
                    }
                }
                this.baseZoomAxesPosition = this.calculateZoomAxesPositions(zoomAxesToShow, chartAreaViewport, zoomMargins, offsetHeight);
                var zoomAxes = this.zoomContext.selectAll(".zoom").data(zoomAxesToShow, function(d) {
                    return d;
                });
                zoomAxes.enter().append("div").attr("class", function(d) {
                    return "zoom zoom-".concat(d);
                }).attr("tabindex", 0).attr("focus-nav-mode", "Hierarchy").attr("role", "group").attr("aria-label", this.hostServices.getLocalizedString("Slicer_Slider")).style("position", "absolute");
                var zoomAxesExit = zoomAxes.exit();
                return this.resetEventHandlers || zoomAxesExit.call(function(containers) {
                    return AxisZoomSlider.destroySliders({
                        containers,
                        hasYAxisCategorical: _this.hasYAxisCategorical,
                        yFlipped: _this.yFlipped,
                        visualHostServices: _this.hostServices
                    });
                }), zoomAxesExit.remove(), _.some(zoomMargins, function(margin) {
                    return 0 !== margin;
                }) ? zoomMargins : void 0;
            }, AxisZoom.prototype.updateShowAxisTitles = function(showAxisTitles) {
                var _a, show = (_a = this.zoomData).show, showOnCategoryAxis = _a.showOnCategoryAxis, showOnValueAxis = _a.showOnValueAxis;
                return show ? {
                    x: showAxisTitles.x && !(this.hasYAxisCategorical ? showOnValueAxis : showOnCategoryAxis),
                    y: showAxisTitles.y && !(this.hasYAxisCategorical ? showOnCategoryAxis : showOnValueAxis),
                    y2: showAxisTitles.y2 && !_a.showOnValueSecAxis
                } : showAxisTitles;
            }, AxisZoom.prototype.updateAxisTitles = function(axisLabels) {
                this.zoomData.show && (this.axesLabels = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, this.axesLabels), axisLabels));
            }, AxisZoom.prototype.getCategoryZoomFactor = function() {
                var _a, orgDomain = null === (_a = this.zoomAxes.categoryAxis) || void 0 === _a ? void 0 : _a.scale.domain(), zoomDomain = this.zoomExtents.categoryExtent;
                if (_.isEmpty(orgDomain) || _.isEmpty(zoomDomain)) return 1;
                var orgDomainSize = Math.abs(orgDomain[1] - orgDomain[0]), zoomDomainSize = Math.abs(zoomDomain[1] - zoomDomain[0]);
                return 0 === zoomDomainSize ? 1 : Math.max(1, orgDomainSize / zoomDomainSize);
            }, AxisZoom.prototype.updateAxisOptions = function(axisProperties, axisOptions) {
                var _a, _b, _c;
                if (axisOptions.isScalar && this.zoomData.show) {
                    var updateAxisOptions = function(domain, force) {
                        if (axisOptions.domainOptions) {
                            var dataDomain = axisOptions.domainOptions.domain, axisDomain = axisProperties.scale.domain();
                            domain = [ Math.max(domain[0], Math.min(dataDomain[0], axisDomain[0])), Math.min(domain[1], Math.max(dataDomain[1], axisDomain[1])) ];
                        }
                        domain[0] = Math.min(domain[0], domain[1]), axisOptions.domainOptions = (0, cartesianAxisHelper.createScalarDomainOptions)(domain), 
                        axisOptions.preventNice || (axisOptions.preventNice = force), axisOptions.includeZero && (axisOptions.includeZero = !force);
                    };
                    if (axisOptions.isCategoryAxis) {
                        if (this.zoomData.showOnCategoryAxis) {
                            this.zoomAxes.categoryAxis = axisProperties;
                            var domain = (_a = AxisZoom.getAxisRange(axisProperties, this.zoomData.categoryMin, this.zoomData.categoryMax, this.zoomData.categorySize)).domain, force = _a.force;
                            this.zoomExtents.categoryExtent = domain, updateAxisOptions(domain, force), this.hasYAxisCategorical || (this.xOuterPadding = axisProperties.outerPadding);
                        }
                    } else axisOptions.isSecValueAxis ? this.zoomData.showOnValueSecAxis && (this.zoomAxes.valueSecAxis = axisProperties, 
                    domain = (_b = AxisZoom.getAxisRange(axisProperties, this.zoomData.valueSecMin, this.zoomData.valueSecMax, this.zoomData.valueSecSize)).domain, 
                    force = _b.force, this.zoomExtents.valueSecExtent = domain, updateAxisOptions(domain, force)) : this.zoomData.showOnValueAxis && (this.zoomAxes.valueAxis = axisProperties, 
                    domain = (_c = AxisZoom.getAxisRange(axisProperties, this.zoomData.valueMin, this.zoomData.valueMax, this.zoomData.valueSize)).domain, 
                    force = _c.force, this.zoomExtents.valueExtent = domain, updateAxisOptions(domain, force));
                }
            }, AxisZoom.prototype.skipMergingValueAxisDomains = function() {
                return this.zoomData.show && (this.zoomData.showOnValueAxis || this.zoomData.showOnValueSecAxis);
            }, AxisZoom.getAxisRange = function(axisProperties, min, max, size) {
                var originalDomain = axisProperties.scale.domain(), domain = [ void 0, void 0 ];
                return null != size ? (debug.fF.assert(function() {
                    return min !== max;
                }, "axisZoom: only one of min/max should be set if size is set"), null != max ? (debug.fF.assert(function() {
                    return null == min;
                }, "axisZoom: if size and max is set, min should not (zooming linked to min extent)"), 
                domain = [ originalDomain[0], Math.min(originalDomain[0] + size, originalDomain[1]) ]) : (debug.fF.assert(function() {
                    return null == max;
                }, "axisZoom: if size and min is set, max should not (zooming linked to max extent)"), 
                domain = [ Math.max(originalDomain[1] - size, originalDomain[0]), originalDomain[1] ])) : (domain[0] = null != min && min >= originalDomain[0] && min < originalDomain[1] ? min : originalDomain[0], 
                domain[1] = null != max && max > originalDomain[0] && max <= originalDomain[1] ? max : originalDomain[1]), 
                {
                    domain,
                    force: !(null == size && null == max && null == min || domain[0] === originalDomain[0] && domain[1] === originalDomain[1])
                };
            }, Object.defineProperty(AxisZoom.prototype, "zoomData", {
                get: function() {
                    return this._zoomData;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AxisZoom.prototype, "context", {
                get: function() {
                    return this.zoomContext;
                },
                enumerable: !1,
                configurable: !0
            }), AxisZoom.converter = function(dataView) {
                var _a, objects = null === (_a = null == dataView ? void 0 : dataView.metadata) || void 0 === _a ? void 0 : _a.objects;
                return {
                    show: (0, dataViewObject2.NA)(objects, axisZoomProperties.t.show, AxisZoom.DefaultOptions.show),
                    showOnValueAxis: (0, dataViewObject2.NA)(objects, axisZoomProperties.t.showOnValueAxis, AxisZoom.DefaultOptions.showOnValueAxis),
                    valueMin: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.valueMin, null)),
                    valueMax: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.valueMax, null)),
                    valueSize: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.valueSize, null)),
                    showOnCategoryAxis: (0, dataViewObject2.NA)(objects, axisZoomProperties.t.showOnCategoryAxis, AxisZoom.DefaultOptions.showOnCategoryAxis),
                    categoryMin: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.categoryMin, null)),
                    categoryMax: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.categoryMax, null)),
                    categorySize: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.categorySize, null)),
                    showOnValueSecAxis: (0, dataViewObject2.NA)(objects, axisZoomProperties.t.showOnValueSecAxis, AxisZoom.DefaultOptions.showOnValueSecAxis),
                    valueSecMin: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.valueSecMin, null)),
                    valueSecMax: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.valueSecMax, null)),
                    valueSecSize: this.clampValue((0, dataViewObject2.NA)(objects, axisZoomProperties.t.valueSecSize, null)),
                    showLabels: (0, dataViewObject2.NA)(objects, axisZoomProperties.t.showLabels, AxisZoom.DefaultOptions.showLabels),
                    showTooltip: (0, dataViewObject2.NA)(objects, axisZoomProperties.t.showTooltip, AxisZoom.DefaultOptions.showTooltip)
                };
            }, AxisZoom.clampValue = function(value) {
                return isNaN(value) || "number" != typeof value ? null : value;
            }, AxisZoom.prototype.getZoomCard = function(zoomAxisSupported) {
                var _this = this;
                if (!this.hasSmallMultiples && zoomAxisSupported) {
                    var zoomData = this.zoomData;
                    return new build_control_util.CQ(new build_control_util.lg("zoom"), "Visual_ZoomSlider", [ axisZoomProperties.t.show, axisZoomProperties.t.showOnCategoryAxis, axisZoomProperties.t.showOnValueAxis, axisZoomProperties.t.showOnValueSecAxis, axisZoomProperties.t.showLabels, axisZoomProperties.t.showTooltip ], function(key) {
                        return _this.hostServices.getLocalizedString(key);
                    }).addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: axisZoomProperties.t.show,
                            value: zoomData.show
                        }).build();
                    }).addGroup(void 0, function(groupBuilder) {
                        _this.hasCategoryAxis && groupBuilder.addSimpleSlice("categoryAxis", new build_control_util.bd({
                            descriptor: axisZoomProperties.t.showOnCategoryAxis,
                            value: zoomData.showOnCategoryAxis
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName(_this.hasYAxisCategorical ? "Visual_YAxis_Hyphen" : "Visual_XAxis_Hyphen");
                        }), _this.hasValueAxis && groupBuilder.addSimpleSlice("valueAxis", new build_control_util.bd({
                            descriptor: axisZoomProperties.t.showOnValueAxis,
                            value: zoomData.showOnValueAxis
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName(_this.hasYAxisCategorical ? "Visual_XAxis_Hyphen" : "Visual_YAxis_Hyphen");
                        }), _this.hasY2Axis && groupBuilder.addSimpleSlice("valueSecAxis", new build_control_util.bd({
                            descriptor: axisZoomProperties.t.showOnValueSecAxis,
                            value: zoomData.showOnValueSecAxis
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Y2Axis_Hyphen");
                        }), groupBuilder.addSimpleSlice("labels", new build_control_util.bd({
                            descriptor: axisZoomProperties.t.showLabels,
                            value: zoomData.showLabels
                        }).build()).addSimpleSlice("tooltips", new build_control_util.bd({
                            descriptor: axisZoomProperties.t.showTooltip,
                            value: zoomData.showTooltip
                        }).build());
                    }).build();
                }
            }, AxisZoom.prototype.calculateZoomAxesPositions = function(zoomAxes, chartAreaViewport, zoomMargins, offsetHeight) {
                void 0 === offsetHeight && (offsetHeight = 0);
                for (var zoomAxesPosition = {}, zoomAxisOffsetBottom = chartAreaViewport.height - zoomMargins.bottom - offsetHeight, zoomAxisOffsetRight = chartAreaViewport.width - zoomMargins.right, finalViewport_height = zoomAxisOffsetBottom - zoomMargins.top, finalViewport_width = zoomAxisOffsetRight - zoomMargins.left, sliderHandleRadius = AxisZoom.SliderHandleRadius, _i = 0, zoomAxes_1 = zoomAxes; _i < zoomAxes_1.length; _i++) {
                    var axisType = zoomAxes_1[_i];
                    switch (axisType) {
                      case "bottom":
                        zoomAxesPosition.bottom = {
                            top: zoomAxisOffsetBottom,
                            left: zoomMargins.left - sliderHandleRadius,
                            width: finalViewport_width + 2 * sliderHandleRadius,
                            height: zoomMargins.bottom
                        };
                        break;

                      case "left":
                        zoomAxesPosition.left = {
                            top: -sliderHandleRadius,
                            left: null,
                            width: zoomMargins.left,
                            height: finalViewport_height + 2 * sliderHandleRadius
                        };
                        break;

                      case "right":
                        zoomAxesPosition.right = {
                            top: -sliderHandleRadius,
                            left: zoomAxisOffsetRight,
                            width: zoomMargins.right,
                            height: finalViewport_height + 2 * sliderHandleRadius
                        };
                        break;

                      default:
                        debug.fF.assertNever(axisType);
                    }
                }
                return zoomAxesPosition;
            }, AxisZoom.prototype.getMaxYLabelWidth = function(position, yFlipped, axesData) {
                if (!axesData) return 50;
                var axisType = this.getAxisType(position, yFlipped), fontProperties = axesData["y1" === axisType ? "y" : axisType].labelFontProperties, textProperties = {
                    text: "1234567",
                    fontFamily: fontProperties.family,
                    fontSize: StandaloneUtility1.FP.toString(fontProperties.size.px),
                    fontWeight: fontProperties.weight,
                    fontStyle: fontProperties.style,
                    fontVariant: fontProperties.variant,
                    whiteSpace: fontProperties.whiteSpace
                };
                return textMeasurementService.b.measureSvgTextWidth(textProperties);
            }, AxisZoom.prototype.getAxisType = function(position, yFlipped) {
                var axisType;
                switch (position) {
                  case "bottom":
                    axisType = "x";
                    break;

                  case "left":
                    axisType = yFlipped ? "y2" : "y1";
                    break;

                  case "right":
                    axisType = yFlipped ? "y1" : "y2";
                    break;

                  default:
                    debug.fF.assertNever(position);
                }
                return axisType;
            }, AxisZoom.DefaultOptions = {
                show: !1,
                showOnValueAxis: !0,
                showOnValueSecAxis: !1,
                showOnCategoryAxis: !0,
                showLabels: !1,
                showTooltip: !1
            }, AxisZoom.StaticPadding = 5, AxisZoom.SliderHandleRadius = 8, AxisZoom;
        }(), dataViewObject3 = __webpack_require__(76045), dataLabelViewModel1Consts = __webpack_require__(56707), units = __webpack_require__(32105), axisStyle = __webpack_require__(41414), strokePattern = __webpack_require__(47316), Double = __webpack_require__(41640), dataViewScopeIdentity = __webpack_require__(78843), selection_selectionId = __webpack_require__(26543), scopeIdentityExtractor = __webpack_require__(26743), converterHelper = __webpack_require__(54522), hierarchyNodeUtils = __webpack_require__(39407), cartesianHelper = __webpack_require__(34969), forecastHelper1 = __webpack_require__(82173), anomalyDetection_converter = __webpack_require__(51490), dataLabelViewModel1 = __webpack_require__(21181), visualStyles = __webpack_require__(48708);
        function supportsStaticReferenceLines(dataViews, layers, layerIndex) {
            return allLayerSupports(function(layer) {
                return !layer.supportsStaticReferenceLines || layer.supportsStaticReferenceLines();
            }, dataViews, layers, layerIndex);
        }
        function supportsTrendLines(dataViews, layers, layerIndex) {
            return allLayerSupports(function(layer) {
                return layer.supportsTrendLine && layer.supportsTrendLine();
            }, dataViews, layers, layerIndex);
        }
        function isValueAxisIrregular(dataViews, layers, layerIndex) {
            return !allLayerSupports(function(layer) {
                return !layer.getCartesianVisualCapabilities().isValueAxisIrregular;
            }, dataViews, layers, layerIndex);
        }
        function allLayerSupports(predicate, dataViews, layers, layerIndex) {
            var layerDataViews = getLayerDataViews(dataViews);
            return !_.isEmpty(layers) && _.every(null == layerIndex ? layers : [ layers[layerIndex] ], function(layer, index) {
                return !layerDataViews[index] || predicate(layer);
            });
        }
        function getLayerDataViews(dataViews) {
            return _.isEmpty(dataViews) ? [] : _.filter(dataViews, function(dataView) {
                return !(0, trendLineHelper.Qp)(dataView) && !(0, forecastHelper1.Aq)(dataView) && !(0, 
                anomalyDetection_converter.Ik)(dataView);
            });
        }
        function getSeriesLabelSettings(layers, chartType, style) {
            return layers && (0, cartesianHelper.PC)(chartType) ? function(layers) {
                if (layers.length > 1) {
                    var layerOneSettings = layers[0].getSeriesLabelsSettings(), layerTwoSettings = layers[1].getSeriesLabelsSettings();
                    return layerOneSettings.maxWidthPercentage > layerTwoSettings.maxWidthPercentage ? layerOneSettings : layerTwoSettings;
                }
                return layers[0].getSeriesLabelsSettings();
            }(layers) : getDefaultSeriesLabelSettings(style);
        }
        function getDefaultSeriesLabelSettings(style) {
            var labelColor = common_colorHelper.v.getThemeColor(style || (0, visualStyles.Ue)(), dataLabelViewModel1Consts.uQ);
            return {
                show: !1,
                seriesColor: labelColor,
                position: labelPosition2.M.right,
                fontProperties: (0, dataLabelViewModel1.bT)({
                    style,
                    labelColor,
                    textClassName: "smallLightLabel"
                }).fontProperties,
                wordWrap: !1,
                maxWidthPercentage: 20,
                defaultSeriesWidth: 20,
                showLabelPerSeries: !1,
                enableBackground: !1,
                bold: !1,
                italic: !1,
                underline: !1
            };
        }
        function extractCategoryFromDataPoint(dataPoint, hierarchyCategoryLevels) {
            if (dataPoint) return {
                categoryIndex: dataPoint.categoryIndex,
                categoryValue: dataPoint.categoryValue,
                hierarchyCategoryLevels,
                hasData: null != dataPoint.value
            };
        }
        function generateConcatenatedNames(categories, data) {
            return categories.map(function(dataPoint) {
                return (0, concatenateUtils.BJ)(data.categoryData[dataPoint.categoryIndex].hierarchyCategoryLevels);
            });
        }
        var CartesianAxes = function() {
            function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
                this.scrollbarWidth = scrollbarWidth, this.isScrollable = isScrollable, this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
            }
            return CartesianAxes.prototype.init = function(options) {
                this.axesData = options.axesData, this.axisZoom = options.axisZoom, this.interactivityService = options.interactivityService;
            }, CartesianAxes.prototype.shouldShowY1OnRight = function() {
                return !0 === this.axesData.y.switchAxisPosition;
            }, Object.defineProperty(CartesianAxes.prototype, "isYAxisCategorical", {
                get: function() {
                    return (0, cartesianHelper.Au)(this.axesData.chartType);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianAxes.prototype, "categoryAxis", {
                get: function() {
                    return this.getAxis(this.isYAxisCategorical ? 1 : 0);
                },
                enumerable: !1,
                configurable: !0
            }), CartesianAxes.prototype.hasCategoryAxis = function() {
                return null != this.categoryAxis;
            }, CartesianAxes.prototype.isCategoryAxisDateTime = function() {
                var _a, _b, _c;
                return null !== (_c = null === (_b = null === (_a = this.categoryAxis) || void 0 === _a ? void 0 : _a.valueType) || void 0 === _b ? void 0 : _b.dateTime) && void 0 !== _c && _c;
            }, CartesianAxes.getLeafHeight = function(tickLabelMargins, pos, numStacks) {
                var availableSpace = pos === axisHelper.Or.bottom ? tickLabelMargins.xMax : pos === axisHelper.Or.right ? tickLabelMargins.yRight : tickLabelMargins.yLeft, stackHeight = tickLabelMargins.stackHeight;
                return debug.fF.assertValue(availableSpace, "getLeafHeight: availableSpace"), debug.fF.assertValue(stackHeight, "getLeafHeight: stackHeight"), 
                debug.fF.assertValue(numStacks, "getLeafHeight: numStacks"), availableSpace - stackHeight * (numStacks - 1) + cartesianAxisHelper.StackedAxisPadding + 1;
            }, CartesianAxes.prototype.getYAxisPosition = function(location) {
                return debug.fF.assert(function() {
                    return 0 !== location;
                }, "cannot ask y-axis specific position for x-axis"), 1 === location ? this.getY1AxisPosition() : this.getY2AxisPosition();
            }, CartesianAxes.prototype.getY1AxisPosition = function() {
                return this.axesData.y.switchAxisPosition ? "right" : "left";
            }, CartesianAxes.prototype.getY2AxisPosition = function() {
                return this.axesData.y.switchAxisPosition ? "left" : "right";
            }, CartesianAxes.prototype.update = function(categories, axesData, categoricalAxisRenderMode, scrollbarWidth) {
                this.categories = categories, this.axesData = axesData, this.updateScrollbarWidthIfNeeded(scrollbarWidth), 
                this.isHierarchicalCategoryAxis = 3 === categoricalAxisRenderMode;
            }, CartesianAxes.prototype.updateResize = function(axesData, scrollbarWidth) {
                this.axesData = axesData, this.updateScrollbarWidthIfNeeded(scrollbarWidth);
            }, CartesianAxes.prototype.addWarnings = function(warningBuilder) {
                var axes = this.layout && this.layout.axes;
                if (axes && axes.x && axes.x.hasDisallowedZeroInDomain) {
                    var zeroValuesWarning = {
                        selector: null,
                        warnings: [ new visualWarnings.MX ]
                    };
                    warningBuilder.addForVisualObject(this.isYAxisCategorical ? "valueAxis" : "categoryAxis", zeroValuesWarning);
                }
                if (axes && (axes.y1 && axes.y1.hasDisallowedZeroInDomain || axes.y2 && axes.y2.hasDisallowedZeroInDomain) && (zeroValuesWarning = {
                    selector: null,
                    warnings: [ new visualWarnings.MX ]
                }, warningBuilder.addForVisualObject(this.isYAxisCategorical ? "categoryAxis" : "valueAxis", zeroValuesWarning)), 
                this.alignZerosWithCustomDomainWarning) {
                    var alignZeroObjectWarning = {
                        selector: null,
                        warnings: [ new visualWarnings.rO ]
                    };
                    warningBuilder.addForVisualObject("valueAxis", alignZeroObjectWarning);
                }
            }, CartesianAxes.prototype.getScrollbarWidth = function() {
                return this.scrollbarWidth;
            }, CartesianAxes.prototype.updateScrollbarWidthIfNeeded = function(scrollbarWidth) {
                null != scrollbarWidth && (this.scrollbarWidth = scrollbarWidth);
            }, CartesianAxes.prototype.calculateAxes = function(renderOptions, viewport, axesMargins, existingAxisProperties, tickLabelMargins, shouldRenderAxis) {
                var _a, _b, _c, options = renderOptions.options, isScalar = renderOptions.isScalar, isScrollVisible = renderOptions.isScrollVisible, layers = options.layers, playAxisControlLayout = options.playAxisControlLayout;
                debug.fF.assertValue(layers, "layers");
                var outerPaddingRatio = CartesianAxes.shouldRenderAnyAxis(shouldRenderAxis) || isScalar ? cartesianHelper.K8 : 0, innerPaddingRatio = this.axesData.categoryAxis.innerPadding, result = {
                    x: null,
                    y1: null
                }, categoryAxis = (_a = this.axesData).categoryAxis, valueAxis = _a.valueAxis, hasForcedY2Domain = _.some(_a.y2.includeDomains, function(domain) {
                    return cartesianAxisHelper.hasForcedDomain(domain);
                }), forceMerge = this.axesData.isValueAxisSet && !1 === this.axesData.y2.show && !hasForcedY2Domain, getEnsuredDomain = function(ensureDomain) {
                    return ensureDomain && cartesianAxisHelper.createScalarDomainOptions([ ensureDomain.min, ensureDomain.max ], 0);
                }, getCalculateAxisOptions = function(axis, ensureDomain) {
                    return {
                        includeDomain: cartesianAxisHelper.mergeScalarAxisDomains.apply(cartesianAxisHelper, (0, 
                        tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], axis.includeDomains, !1), [ getEnsuredDomain(ensureDomain) ], !1)),
                        axis
                    };
                }, categoryAxisOptions = getCalculateAxisOptions(categoryAxis, options.ensureXDomain), layer1ValueAxisOptions = getCalculateAxisOptions(valueAxis, options.ensureYDomain), layer1VisualOptions = {
                    viewport,
                    margin: axesMargins,
                    categoryAxisOptions,
                    forceMerge,
                    trimOrdinalDataOnOverflow: this.trimOrdinalDataOnOverflow,
                    outerPaddingRatio,
                    innerPaddingRatio,
                    playAxisControlLayout,
                    valueAxisOptions: layer1ValueAxisOptions,
                    axisZoom: this.axisZoom
                }, showY2 = this.axesData.isValueAxisSet && this.axesData.y2.show, shouldAlignZeros = this.axesData.isValueAxisSet && this.axesData.y.alignZeros, skipMerge = options.skipMergeValueAxes || !forceMerge && (!0 === showY2 || hasForcedY2Domain || void 0 === showY2 && (shouldAlignZeros || layer1ValueAxisOptions.includeDomain)), yAxisWillMerge = !1;
                if (hasMultipleYAxes(layers) && !skipMerge) {
                    var mergeResult = function(layers, visualOptions) {
                        debug.fF.assert(function() {
                            return layers.length < 3;
                        }, "merging of more than 2 layers is not supported");
                        var tickCount = void 0, noMerge = function() {
                            return {
                                domain: void 0,
                                merged: !1,
                                tickCount
                            };
                        };
                        if (layers.length < 2) return noMerge();
                        var visualOptions2 = (0, Prototype.ED)(visualOptions);
                        visualOptions2.roleName = "Y2";
                        var y1props = layers[0].calculateAxesProperties(visualOptions)[1], y2props = layers[1].calculateAxesProperties(visualOptions2)[1], firstYDomain = y1props.scale.domain(), secondYDomain = y2props.scale.domain();
                        if (y1props.dataDomain && y2props.dataDomain) {
                            var y1HasZeroDomain = 0 === y1props.dataDomain[0] && 0 === y1props.dataDomain[1], y2HasZeroDomain = 0 === y2props.dataDomain[0] && 0 === y2props.dataDomain[1];
                            y1HasZeroDomain && !y2HasZeroDomain ? firstYDomain = [ 0, 0 ] : !y1HasZeroDomain && y2HasZeroDomain && (secondYDomain = [ 0, 0 ]);
                        }
                        y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0 && (tickCount = Math.max(y1props.values.length, y2props.values.length));
                        var min = Math.min(firstYDomain[0], secondYDomain[0]), max = Math.max(firstYDomain[1], secondYDomain[1]);
                        if (visualOptions.forceMerge) return {
                            domain: [ min, max ],
                            merged: !0,
                            tickCount
                        };
                        if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0]) return noMerge();
                        var range = max - min;
                        if (0 === range) return noMerge();
                        var maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]), minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
                        return Math.abs((minOfMax - maxOfMin) / range) < .1 ? noMerge() : {
                            domain: [ min, max ],
                            merged: !0,
                            tickCount
                        };
                    }(layers, layer1VisualOptions);
                    (yAxisWillMerge = mergeResult.merged) ? layer1ValueAxisOptions.includeDomain = cartesianAxisHelper.mergeScalarAxisDomains(layer1ValueAxisOptions.includeDomain, cartesianAxisHelper.createScalarDomainOptions(mergeResult.domain, 0, [ !0, !0 ])) : layer1VisualOptions.forcedTickCount = mergeResult.tickCount;
                }
                var shouldBuildY2 = hasMultipleYAxes(layers) ? !yAxisWillMerge && !1 !== showY2 || showY2 : this.axesData.y2.hasY2Role;
                shouldBuildY2 = shouldBuildY2 || hasForcedY2Domain, shouldAlignZeros = shouldAlignZeros && shouldBuildY2;
                var layer2VisualOptions = (0, Prototype.ED)(layer1VisualOptions);
                if (shouldBuildY2) {
                    var secondaryValueAxis = this.axesData.y2, layer2ValueAxisOptions = layer2VisualOptions.valueAxisOptions = (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, (0, Prototype.ED)(layer1ValueAxisOptions)), {
                        axis: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, secondaryValueAxis), {
                            invertAxis: valueAxis.invertAxis
                        }),
                        includeDomain: cartesianAxisHelper.mergeScalarAxisDomains.apply(cartesianAxisHelper, (0, 
                        tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], secondaryValueAxis.includeDomains, !1), [ getEnsuredDomain(options.ensureY2Domain) ], !1))
                    });
                    if (shouldAlignZeros) {
                        var layer1AxesDomains = layers[0].getAxesDomains(!0, {
                            valueAxis: !0
                        }), valueAxisDomain = cartesianAxisHelper.mergeScalarAxisDomains.apply(cartesianAxisHelper, (0, 
                        tslib_es6.__spreadArray)([ cartesianAxisHelper.createScalarDomainOptions(layer1AxesDomains.valueAxis, 0) ], valueAxis.includeDomains, !1)), layer2AxesDomains = layers[1].getAxesDomains(!0, {
                            valueAxis: !0
                        }), secondaryValueAxisDomain = cartesianAxisHelper.mergeScalarAxisDomains(cartesianAxisHelper.createScalarDomainOptions(layer2AxesDomains.valueAxis, 0), layer2ValueAxisOptions.includeDomain), hasTwoDomains = valueAxisDomain && secondaryValueAxisDomain, hasForcedDomain = hasTwoDomains && (cartesianAxisHelper.hasForcedDomain(valueAxisDomain) || cartesianAxisHelper.hasForcedDomain(secondaryValueAxisDomain));
                        if (result.alignZerosWithCustomDomainWarning = hasForcedDomain, hasTwoDomains && !hasForcedDomain) {
                            var layer1AlignedDomain = (_b = function(domain1, domain2, bufferMultiplier) {
                                debug.fF.assert(function() {
                                    return domain1 && 2 === domain1.length;
                                }, "domain1 length"), debug.fF.assert(function() {
                                    return domain2 && 2 === domain2.length;
                                }, "domain2 length"), debug.fF.assert(function() {
                                    return !0;
                                }, "bufferMultiplier should be between 0 and 0.15");
                                var d1Out = domain1.slice(), d2Out = domain2.slice(), d1Range = domain1[1] - domain1[0], d2Range = domain2[1] - domain2[0];
                                if (d1Out[0] = d1Out[0] - .05 * d1Range, d1Out[1] = d1Out[1] + .05 * d1Range, d2Out[0] = d2Out[0] - .05 * d2Range, 
                                d2Out[1] = d2Out[1] + .05 * d2Range, domain1[0] >= 0 && domain2[0] >= 0) d1Out[0] = 0, 
                                d2Out[0] = 0; else if (domain1[1] <= 0 && domain2[1] <= 0) d1Out[1] = 0, d2Out[1] = 0; else {
                                    var d1Ratios = getPositiveAndNegativeDomainRatios(d1Out), d2Ratios = getPositiveAndNegativeDomainRatios(d2Out);
                                    if (d1Ratios.pos < d1Ratios.neg && d2Ratios.pos < d2Ratios.neg) d1Ratios.pos < d2Ratios.pos ? d1Out[1] = -d2Ratios.pos * d1Out[0] / (1 - d2Ratios.pos) : d2Out[1] = -d1Ratios.pos * d2Out[0] / (1 - d1Ratios.pos); else if (d1Ratios.pos > d1Ratios.neg && d2Ratios.pos > d2Ratios.neg) d1Ratios.neg < d2Ratios.neg ? d1Out[0] = -d2Ratios.neg * d1Out[1] / (1 - d2Ratios.neg) : d2Out[0] = -d1Ratios.neg * d2Out[1] / (1 - d1Ratios.neg); else {
                                        var d1AbsMax = Math.max(Math.abs(d1Out[0]), Math.abs(d1Out[1])), d2AbsMax = Math.max(Math.abs(d2Out[0]), Math.abs(d2Out[1]));
                                        d1Out = [ -d1AbsMax, d1AbsMax ], d2Out = [ -d2AbsMax, d2AbsMax ];
                                    }
                                }
                                return [ d1Out, d2Out ];
                            }(valueAxisDomain.domain, secondaryValueAxisDomain.domain))[0], layer2AlignedDomain = _b[1];
                            layer1ValueAxisOptions.includeDomain = cartesianAxisHelper.createScalarDomainOptions(layer1AlignedDomain, 0, [ !0, !0 ]), 
                            layer2ValueAxisOptions.includeDomain = cartesianAxisHelper.createScalarDomainOptions(layer2AlignedDomain, 0, [ !0, !0 ]);
                        } else layer2ValueAxisOptions.includeDomain = cartesianAxisHelper.mergeScalarAxisDomains(layer2ValueAxisOptions.includeDomain, secondaryValueAxisDomain);
                    } else yAxisWillMerge || (layer2ValueAxisOptions.includeDomain = this.axesData.isValueAxisSet && layer2ValueAxisOptions.includeDomain);
                }
                for (var visualOptionsArr = [ layer1VisualOptions, layer2VisualOptions ], loopCount = hasMultipleYAxes(layers) || this.axesData.y2.hasY2Role ? 2 : 1, layerNumber = 0; layerNumber < loopCount; layerNumber++) {
                    var currentVisualOptions = visualOptionsArr[layerNumber], currentLayer = null !== (_c = layers[layerNumber]) && void 0 !== _c ? _c : layers[0];
                    yAxisWillMerge || 1 !== layerNumber || (currentVisualOptions.roleName = "Y2"), debug.fF.assertValue(currentVisualOptions, "currentVisualOptions must be set");
                    var axes = currentLayer.calculateAxesProperties(currentVisualOptions);
                    0 === layerNumber ? (result.x = axes[0], result.y1 = axes[1]) : axes && !result.y2 && (result.x.isInvalidDomain || _.isEmpty(result.x.dataDomain) ? (result.x = axes[0], 
                    result.y1 = axes[1]) : (currentLayer.overrideXAxis(result.x), yAxisWillMerge || axes[1].isInvalidDomain || _.isEmpty(axes[1].values) || (result.y2 = axes[1])));
                    var axisTextProperties = (0, common_fontProperties.qk)(options.axesFontProperties.x.tickLabels), resultX = result.x;
                    if (existingAxisProperties && existingAxisProperties.x) resultX.willLabelsFit = existingAxisProperties.x.willLabelsFit, 
                    resultX.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak; else {
                        var width = viewport.width - (axesMargins.left + axesMargins.right);
                        resultX.willLabelsFit = cartesianAxisHelper.willLabelsFit(resultX, width, textMeasurementService.b.measureSvgTextWidth, axisTextProperties), 
                        resultX.willLabelsWordBreak = !resultX.willLabelsFit && !isScrollVisible && cartesianAxisHelper.willLabelsWordBreak(result.x, axesMargins, width, textMeasurementService.b.measureSvgTextWidth, textMeasurementService.b.estimateSvgTextHeight, textMeasurementService.b.getTailoredTextOrDefault, axisTextProperties);
                    }
                    var isX = result.x.isCategoryAxis;
                    if (this.isHierarchicalCategoryAxis && (isX ? this.axesData.x.show : this.axesData.y.show)) {
                        var hierarchyAxisProperties = isX ? result.x : result.y1;
                        hierarchyAxisProperties.isHierarchical = !0, hierarchyAxisProperties.rootNode = (0, 
                        hierarchyNodeUtils.J_)(this.categories), hierarchyAxisProperties.numHierarchyLevels = this.categories.length, 
                        tickLabelMargins && (hierarchyAxisProperties.hierStack = CartesianAxes.createStackedAxis(this.categories, hierarchyAxisProperties, tickLabelMargins, isX ? axisHelper.Or.bottom : this.axesData.y.switchAxisPosition ? axisHelper.Or.right : axisHelper.Or.left));
                    }
                }
                return this.finalizeAxisLabels(result, options.showAxisTitles), result;
            }, CartesianAxes.createStackedAxis = function(categories, axis, tickLabelMargins, orientation) {
                if (debug.fF.assertValue(axis, "axis"), !_.isEmpty(categories)) {
                    for (var stackLength = categories.length, stackHeight = tickLabelMargins.stackHeight, leafHeight = CartesianAxes.getLeafHeight(tickLabelMargins, orientation, stackLength), stack = [], singleCategoryWidth = cartesianAxisHelper.getCategoryThickness(axis.scale), levelIdentitySubsetExprs = [], _loop_1 = function(columnIndex) {
                        var isLeafLevel = columnIndex === stackLength - 1, levelIndex = stackLength - columnIndex - 1, levelCategory = categories[columnIndex];
                        isLeafLevel || (debug.fF.assertValue(levelCategory.source.identityExprs, "levelCategory.source.identityExprs"), 
                        levelIdentitySubsetExprs.push.apply(levelIdentitySubsetExprs, levelCategory.source.identityExprs || []));
                        for (var newValues = [], newIdentities = [], newHierarchyPointers = [], newValuesMaxWidth = [], lineStyleInfoArray = [], categorySpanCount = 0, lastValueLevelIdentity = void 0, levelCategoryValuesLength = levelCategory.values.length, _loop_2 = function(valueIndex) {
                            var valueLevelIdentity = isLeafLevel ? levelCategory.identity[valueIndex] : CartesianAxes.getSpecificIdentityFromCompositeIdentity(levelCategory, valueIndex, levelIdentitySubsetExprs), formattedLevelValue = (0, 
                            converterHelper.xq)(levelCategory.values[valueIndex], levelCategory.source, cartesian_capabilities.p.general.formatString);
                            if (!isLeafLevel && lastValueLevelIdentity && (0, dataViewScopeIdentity.fS)(lastValueLevelIdentity, valueLevelIdentity)) newValues[valueIndex] = axisHelper.Pt, 
                            categorySpanCount++; else {
                                if (categorySpanCount > 0 && !isLeafLevel) {
                                    var adjustedIndex = valueIndex - categorySpanCount;
                                    newValuesMaxWidth[adjustedIndex] = CartesianAxes.getMaxCategoryWidth(categorySpanCount, singleCategoryWidth), 
                                    lineStyleInfoArray[adjustedIndex] = CartesianAxes.getHierarchyLineStyleInfo({
                                        levelIndex,
                                        stackHeight,
                                        leafHeight,
                                        categorySpanCount,
                                        categoryWidth: singleCategoryWidth,
                                        orientation
                                    });
                                }
                                categorySpanCount = 1, newValues[valueIndex] = formattedLevelValue, newIdentities[valueIndex] = function() {
                                    return selection_selectionId.dw.builder().withCategoryIdentity(levelCategory, valueIndex, valueLevelIdentity).createSelectionId();
                                }, newHierarchyPointers[valueIndex] = {
                                    categoryIndex: valueIndex,
                                    seriesIndex: columnIndex
                                };
                            }
                            lastValueLevelIdentity = valueLevelIdentity;
                        }, valueIndex = 0; valueIndex < levelCategoryValuesLength; valueIndex++) _loop_2(valueIndex);
                        if (categorySpanCount > 0 && !isLeafLevel) {
                            var adjustedIndex = levelCategoryValuesLength - categorySpanCount;
                            newValuesMaxWidth[adjustedIndex] = CartesianAxes.getMaxCategoryWidth(categorySpanCount, singleCategoryWidth), 
                            lineStyleInfoArray[adjustedIndex] = CartesianAxes.getHierarchyLineStyleInfo({
                                levelIndex,
                                stackHeight,
                                leafHeight,
                                categorySpanCount,
                                categoryWidth: singleCategoryWidth,
                                orientation
                            });
                        }
                        var newAxisProps = (0, Prototype.ED)(axis);
                        newAxisProps.isStacked = !0, newAxisProps.adjustedValues = newValues, axis.categoryIdentities && (newAxisProps.categoryIdentities = newIdentities, 
                        newAxisProps.categoryHierarchyPointers = newHierarchyPointers, debug.fF.assert(function() {
                            return newIdentities.length === newHierarchyPointers.length;
                        }, "keep identities and pointers in sync")), newAxisProps.d3Axis = cartesianAxisHelper.createStackedD3Axis({
                            d3axis: newAxisProps.d3Axis,
                            scale: newAxisProps.scale,
                            tickFormat: function(valueIndex) {
                                return newValues[valueIndex] !== axisHelper.Pt ? newValues[valueIndex] : null;
                            }
                        }), newAxisProps.categoryThickness = singleCategoryWidth, newAxisProps.levelIndex = levelIndex, 
                        newAxisProps.lineStyleInfo = lineStyleInfoArray, newAxisProps.values = newValues, 
                        newAxisProps.categoryLabelMaxWidths = newValuesMaxWidth, isLeafLevel || (newAxisProps.willLabelsFit = !0, 
                        newAxisProps.willLabelsWordBreak = !1), stack.unshift(newAxisProps);
                    }, columnIndex = 0; columnIndex < stackLength; columnIndex++) _loop_1(columnIndex);
                    return stack;
                }
            }, CartesianAxes.shouldRenderAnyAxis = function(shouldRenderAxis) {
                return shouldRenderAxis && (shouldRenderAxis.x || shouldRenderAxis.y);
            }, CartesianAxes.getSpecificIdentityFromCompositeIdentity = function(column, valueIndex, groupIdentityFields) {
                var columnIdentities = column.identity;
                debug.fF.assertNonEmpty(columnIdentities, "columnIdentities");
                var identity = columnIdentities[valueIndex];
                debug.fF.assertValue(identity, "identity");
                var identitySubsetExpr = (0, scopeIdentityExtractor.J2)(identity.expr, groupIdentityFields);
                return (0, dataViewScopeIdentity.TZ)(identitySubsetExpr);
            }, CartesianAxes.getCategorySpanSize = function(categorySpanCount, categoryWidth) {
                return categorySpanCount * categoryWidth;
            }, CartesianAxes.getMaxCategoryWidth = function(categorySpanCount, categoryWidth) {
                return debug.fF.assertValue(categorySpanCount, "categorySpanCount"), debug.fF.assertAnyValue(categoryWidth, "categoryWidth"), 
                CartesianAxes.getCategorySpanSize(categorySpanCount, categoryWidth) - 2 * cartesianHelper.Fv;
            }, CartesianAxes.getHierarchyLineStyleInfo = function(options) {
                return debug.fF.assertValue(options, "options"), debug.fF.assertValue(options.levelIndex, "levelIndex"), 
                debug.fF.assertValue(options.stackHeight, "stackHeight"), debug.fF.assertValue(options.leafHeight, "leafHeight"), 
                debug.fF.assertValue(options.categorySpanCount, "categorySpanCount"), debug.fF.assertValue(options.categoryWidth, "categoryWidth"), 
                options.orientation === axisHelper.Or.bottom ? CartesianAxes.createXHierarchyLineStyleInfo(options) : CartesianAxes.createYHierarchyLineStyleInfo(options);
            }, CartesianAxes.createXHierarchyLineStyleInfo = function(options) {
                var levelIndex = options.levelIndex, stackHeight = options.stackHeight, leafHeight = options.leafHeight;
                if (0 !== levelIndex) {
                    var maxWidth = CartesianAxes.getCategorySpanSize(options.categorySpanCount, options.categoryWidth);
                    return (0, tslib_es6.__spreadArray)([ {
                        x1: -maxWidth / 2,
                        y1: stackHeight,
                        x2: -maxWidth / 2,
                        y2: 1 === levelIndex ? -leafHeight : 0
                    }, {
                        x1: maxWidth / 2,
                        y1: stackHeight,
                        x2: maxWidth / 2,
                        y2: 1 === levelIndex ? -leafHeight : 0
                    } ], levelIndex > 1 ? [ {
                        x1: -maxWidth / 2,
                        y1: 0,
                        x2: maxWidth / 2,
                        y2: 0
                    } ] : [], !0);
                }
            }, CartesianAxes.createYHierarchyLineStyleInfo = function(options) {
                var levelIndex = options.levelIndex, stackHeight = options.stackHeight, leafHeight = options.leafHeight;
                if (0 !== levelIndex) {
                    var maxWidth = CartesianAxes.getCategorySpanSize(options.categorySpanCount, options.categoryWidth);
                    return (0, tslib_es6.__spreadArray)([ {
                        x1: -stackHeight,
                        x2: 1 === levelIndex ? leafHeight : 0,
                        y1: -maxWidth / 2,
                        y2: -maxWidth / 2
                    }, {
                        x1: -stackHeight,
                        x2: 1 === levelIndex ? leafHeight : 0,
                        y1: maxWidth / 2,
                        y2: maxWidth / 2
                    } ], levelIndex > 1 ? [ {
                        x1: 0,
                        x2: 0,
                        y1: -maxWidth / 2,
                        y2: maxWidth / 2
                    } ] : [], !0).map(function(val) {
                        return options.orientation === axisHelper.Or.right && (val.x1 = -val.x1 - stackHeight, 
                        val.x2 = -val.x2 - stackHeight), val;
                    });
                }
            }, CartesianAxes.prototype.negotiateAxes = function(options) {
                var _a, _b, _c, scrollBarVisibility, layers = options.layers, padding = options.padding, showAxisTitles = options.showAxisTitles, axesMargins = (0, 
                Prototype.ED)(CartesianAxes.MinimumMargin), scrollHandleMargins = {
                    left: 0,
                    top: 0,
                    bottom: 0,
                    right: 0
                }, axesOverflow = {
                    left: 0,
                    top: 0,
                    bottom: 0,
                    right: 0
                }, axesData = this.axesData, maxMarginFactor = (null === (_a = null == axesData ? void 0 : axesData.categoryAxis) || void 0 === _a ? void 0 : _a.maxMarginFactor) || CartesianAxes.DefaultMaxMarginFactor, viewport = (0, 
                Prototype.ED)(options.parentViewport), leftRightMarginLimit = viewport.width * maxMarginFactor, marginLimits = {
                    left: leftRightMarginLimit,
                    right: leftRightMarginLimit,
                    top: 0,
                    bottom: Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * maxMarginFactor))
                }, isScalar = null === (_c = null === (_b = null == layers ? void 0 : layers[0]) || void 0 === _b ? void 0 : _b.getVisualCategoryAxisIsScalar) || void 0 === _c ? void 0 : _c.call(_b), axesRenderOptions = this.calculateAxesRenderOptions({
                    options,
                    viewport,
                    axesMargins,
                    scrollHandleMargins,
                    axesOverflow,
                    isScalar,
                    marginLimits,
                    isScrollVisible: !1
                }), axesMarginFactors = this.getAxesMarginFactors(axesRenderOptions.axes);
                axesMargins = (axesRenderOptions = this.calculateAxesRenderOptions({
                    options,
                    viewport,
                    axesMargins,
                    scrollHandleMargins,
                    axesOverflow,
                    isScalar,
                    marginLimits,
                    isScrollVisible: !1,
                    axesRenderOptions
                })).axesMargins, options.rotateXTickLabels90 = options.rotateXTickLabels90 || !this.willAllCategoriesFitInPlotArea(axesRenderOptions.plotArea, axesRenderOptions.preferredPlotArea), 
                this.shouldRecalculateRenderOptions(axesMarginFactors, axesRenderOptions.axes, options.rotateXTickLabels90) && (axesMargins = (axesRenderOptions = this.calculateAxesRenderOptions({
                    options,
                    viewport,
                    axesMargins,
                    axesOverflow,
                    scrollHandleMargins,
                    isScalar,
                    marginLimits,
                    isScrollVisible: options.rotateXTickLabels90,
                    skipWordBreakUpdate: !0,
                    axesRenderOptions
                })).axesMargins, !this.willAllCategoriesFitInPlotArea(axesRenderOptions.plotArea, axesRenderOptions.preferredPlotArea) && (scrollBarVisibility = this.updateScrollMargins(axesRenderOptions.axes, viewport, scrollHandleMargins), 
                axesMargins = (axesRenderOptions = this.calculateAxesRenderOptions({
                    options,
                    viewport,
                    axesMargins,
                    scrollHandleMargins,
                    axesOverflow,
                    isScalar,
                    marginLimits,
                    isScrollVisible: !0,
                    skipWordBreakUpdate: !0,
                    axesRenderOptions,
                    skipTickMarginsUpdate: !0,
                    isXScrollBarVisible: scrollBarVisibility.isXVisible,
                    isYScrollBarVisible: scrollBarVisibility.isYVisible
                })).axesMargins));
                var axes = axesRenderOptions.axes;
                return this.layout = {
                    axes,
                    axisLabels: {
                        x: showAxisTitles.x && axes.x ? axes.x.axisLabel : null,
                        y: showAxisTitles.y && axes.y1 ? axes.y1.axisLabel : null,
                        y2: showAxisTitles.y2 && axes.y2 ? axes.y2.axisLabel : null
                    },
                    margin: axesMargins,
                    marginLimits,
                    viewport,
                    plotArea: axesRenderOptions.plotArea,
                    preferredPlotArea: axesRenderOptions.preferredPlotArea,
                    tickLabelMargins: axesRenderOptions.tickLabelMargins,
                    tickPadding: padding,
                    titleMargins: axesRenderOptions.titleMargins,
                    rotateXTickLabels90: options.rotateXTickLabels90,
                    shouldRenderAxis: axesRenderOptions.shouldRenderAxis,
                    isXScrollBarVisible: scrollBarVisibility && scrollBarVisibility.isXVisible,
                    isYScrollBarVisible: scrollBarVisibility && scrollBarVisibility.isYVisible,
                    scrollHandleMargins
                }, this.alignZerosWithCustomDomainWarning = axes.alignZerosWithCustomDomainWarning, 
                this.layout;
            }, CartesianAxes.prototype.updateScrollMargins = function(axes, viewport, scrollHandleMargins) {
                var _a, _b, isXVisible = !1, isYVisible = !1;
                return axes.x.isCategoryAxis && (isXVisible = !0, viewport.height -= this.scrollbarWidth, 
                scrollHandleMargins.bottom = this.scrollbarWidth), axes.y1.isCategoryAxis && (isYVisible = !0, 
                viewport.width -= this.scrollbarWidth, (null === (_b = null === (_a = this.axesData) || void 0 === _a ? void 0 : _a.y) || void 0 === _b ? void 0 : _b.switchAxisPosition) ? scrollHandleMargins.right = this.scrollbarWidth : scrollHandleMargins.left = this.scrollbarWidth), 
                {
                    isXVisible,
                    isYVisible
                };
            }, CartesianAxes.prototype.shouldRecalculateRenderOptions = function(marginFactors, axes, rotateXTickLabels90) {
                var newMarginFactors = this.getAxesMarginFactors(axes);
                return !!(axes.y1 && newMarginFactors.tickCountY1 !== marginFactors.tickCountY1 || axes.y2 && newMarginFactors.tickCountY2 !== marginFactors.tickCountY2 || axes.x && newMarginFactors.willFitX !== marginFactors.willFitX || axes.x && newMarginFactors.willBreakX !== marginFactors.willBreakX || axes.x && newMarginFactors.xLabelMaxWidth !== marginFactors.xLabelMaxWidth || rotateXTickLabels90 || this.isHierarchicalCategoryAxis || axes.x && newMarginFactors.categoryThickness !== marginFactors.categoryThickness);
            }, CartesianAxes.prototype.getAxesMarginFactors = function(axes) {
                return {
                    tickCountY1: axes.y1 && axes.y1.values.length,
                    tickCountY2: axes.y2 && axes.y2.values.length,
                    willFitX: axes.x && axes.x.willLabelsFit,
                    willBreakX: axes.x && axes.x.willLabelsWordBreak,
                    xLabelMaxWidth: axes.x && axes.x.xLabelMaxWidth,
                    categoryThickness: axes.x && axes.x.categoryThickness
                };
            }, CartesianAxes.prototype.calculateAxesRenderOptions = function(renderOptions) {
                var _a, _b, _c, _d, _e, tickLabelMargins, options = renderOptions.options, viewport = renderOptions.viewport, scrollHandleMargins = renderOptions.scrollHandleMargins, isScalar = renderOptions.isScalar, marginLimits = renderOptions.marginLimits, axesRenderOptions = renderOptions.axesRenderOptions, skipTickMarginsUpdate = renderOptions.skipTickMarginsUpdate, axesMargins = renderOptions.axesMargins, axesOverflow = renderOptions.axesOverflow, shouldRenderAxis = null !== (_b = null == axesRenderOptions ? void 0 : axesRenderOptions.shouldRenderAxis) && void 0 !== _b ? _b : options.shouldRenderAxis, axes = null == axesRenderOptions ? void 0 : axesRenderOptions.axes, titleMargins = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                };
                if (axesRenderOptions) {
                    var showY1OnRight = this.shouldShowY1OnRight();
                    tickLabelMargins = skipTickMarginsUpdate ? axesRenderOptions.tickLabelMargins : cartesianAxisHelper.getTickLabelMargins({
                        plotArea: axesRenderOptions.plotArea,
                        yMarginLimit: marginLimits.left,
                        textWidthMeasurer: textMeasurementService.b.measureSvgTextWidth,
                        textHeightMeasurer: textMeasurementService.b.estimateSvgTextHeight,
                        axes: axesRenderOptions.axes,
                        bottomMarginLimit: marginLimits.bottom,
                        axesFontProperties: options.axesFontProperties,
                        rotate90: options.rotateXTickLabels90,
                        showY1OnRight,
                        shouldRenderAxis: axesRenderOptions.shouldRenderAxis
                    }), axesMargins = (_a = this.updateAxisMargins(renderOptions, tickLabelMargins, showY1OnRight)).axesMargins, 
                    titleMargins = _a.titleMargins, axesOverflow = tickLabelMargins.axesOverflow;
                }
                var plotArea = options.calculatePlotArea({
                    viewport,
                    axesMargins,
                    axesOverflow,
                    titleMargins,
                    shouldRenderAxis,
                    axes,
                    scrollHandleMargins,
                    seriesLabelSettings: getSeriesLabelSettings(options.layers, this.axesData.chartType),
                    showSeriesLabels: this.axesData.showsSeriesLabels()
                });
                return axes = this.calculateAxes(renderOptions, this.calculateLayerViewport(plotArea, axesMargins), axesMargins, renderOptions.skipWordBreakUpdate ? axes : null, tickLabelMargins, shouldRenderAxis), 
                {
                    plotArea,
                    preferredPlotArea: this.getPreferredPlotArea(axes, options.layers, isScalar),
                    axes,
                    axesMargins,
                    titleMargins,
                    shouldRenderAxis: {
                        x: shouldRenderAxis.x && !_.isEmpty(null === (_c = axes.x) || void 0 === _c ? void 0 : _c.values),
                        y: shouldRenderAxis.y && !_.isEmpty(null === (_d = axes.y1) || void 0 === _d ? void 0 : _d.values),
                        y2: shouldRenderAxis.y2 && !_.isEmpty(null === (_e = axes.y2) || void 0 === _e ? void 0 : _e.values)
                    },
                    tickLabelMargins
                };
            }, CartesianAxes.prototype.getPreferredPlotArea = function(axes, layers, isScalar) {
                if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
                    var axisProps = axes.x.isCategoryAxis ? axes.x : axes.y1;
                    return layers[0].getPreferredPlotArea({
                        isScalar,
                        categoryCount: axisProps.dataDomain.length,
                        categoryThickness: axisProps.categoryThickness,
                        outerPaddingRatio: axisProps.outerPaddingRatio
                    });
                }
            }, CartesianAxes.prototype.calculateLayerViewport = function(plotArea, axesMargins) {
                return {
                    width: plotArea.width + axesMargins.left + axesMargins.right,
                    height: plotArea.height + axesMargins.top + axesMargins.bottom,
                    scale: plotArea.scale
                };
            }, CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function(plotArea, preferredPlotArea) {
                return !(!this.isYAxisCategorical && preferredPlotArea && (0, Double.aP)(preferredPlotArea.width, plotArea.width) || this.isYAxisCategorical && preferredPlotArea && (0, 
                Double.aP)(preferredPlotArea.height, plotArea.height));
            }, CartesianAxes.prototype.updateAxisMargins = function(renderOptions, tickLabelMargins, showY1OnRight) {
                var _a, _b, _c, isScalar = renderOptions.isScalar, axes = (_a = renderOptions.axesRenderOptions).axes, shouldRenderAxis = _a.shouldRenderAxis, padding = (_b = renderOptions.options).padding, showAxisTitles = _b.showAxisTitles, axesFontProperties = _b.axesFontProperties, forceMarginMin = _b.forceMarginMin, interactivityRightMargin = _b.interactivityRightMargin, titleMargins = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }, maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
                if (shouldRenderAxis.y && (maxY1Padding += showY1OnRight ? padding.right : padding.left), 
                shouldRenderAxis.y2 && (maxY2Padding += showY1OnRight ? padding.left : padding.right), 
                shouldRenderAxis.x && (maxXAxisBottom += padding.bottom), null != axes.x.axisLabel && showAxisTitles.x) {
                    var titleTextHeight = textMeasurementService.b.estimateSvgTextHeight((0, common_fontProperties.qk)(axesFontProperties.x.title));
                    titleMargins.bottom = titleTextHeight + CartesianAxes.XAxisLabelPadding + CartesianAxes.XAxisPaddingDeltaForTitle, 
                    maxXAxisBottom += titleMargins.bottom;
                }
                if (null != axes.y1.axisLabel && showAxisTitles.y) {
                    var yTitlePadding = (titleTextHeight = textMeasurementService.b.estimateSvgTextHeight((0, 
                    common_fontProperties.qk)(axesFontProperties.y.title))) + CartesianAxes.YAxisLabelPadding;
                    showY1OnRight ? titleMargins.right = yTitlePadding : titleMargins.left = yTitlePadding, 
                    maxY1Padding += yTitlePadding;
                }
                if (null != (null === (_c = axes.y2) || void 0 === _c ? void 0 : _c.axisLabel) && showAxisTitles.y2) {
                    var y2TitlePadding = (titleTextHeight = textMeasurementService.b.estimateSvgTextHeight((0, 
                    common_fontProperties.qk)(axesFontProperties.y2.title))) + CartesianAxes.YAxisLabelPadding;
                    showY1OnRight ? titleMargins.left = y2TitlePadding : titleMargins.right = y2TitlePadding, 
                    maxY2Padding += y2TitlePadding;
                }
                var rightMargin = (showY1OnRight ? maxY1Padding : maxY2Padding) + (isScalar ? 0 : interactivityRightMargin);
                rightMargin = renderOptions.isYScrollBarVisible ? Math.max(rightMargin, CartesianAxes.MinimumAxisMarginFromScrollbar) : rightMargin;
                var bottomMargin = maxXAxisBottom;
                bottomMargin = renderOptions.isXScrollBarVisible ? Math.max(bottomMargin, CartesianAxes.MinimumAxisMarginFromScrollbar) : bottomMargin, 
                tickLabelMargins.axesOverflow.top = Math.max(tickLabelMargins.yTop, CartesianAxes.MinimumMargin.top);
                var axesMargins = {
                    top: tickLabelMargins.axesOverflow.top,
                    left: showY1OnRight ? maxY2Padding : maxY1Padding,
                    right: rightMargin,
                    bottom: bottomMargin
                };
                return forceMarginMin && (axesMargins = {
                    top: Math.max(axesMargins.top, forceMarginMin.top),
                    bottom: Math.max(axesMargins.bottom, forceMarginMin.bottom),
                    left: Math.max(axesMargins.left, forceMarginMin.left),
                    right: Math.max(axesMargins.right, forceMarginMin.right)
                }), {
                    axesMargins,
                    titleMargins
                };
            }, CartesianAxes.prototype.getAxis = function(location) {
                var _a, _b, _c, _d, _e, _f;
                switch (location) {
                  case 0:
                    return null === (_b = null === (_a = this.layout) || void 0 === _a ? void 0 : _a.axes) || void 0 === _b ? void 0 : _b.x;

                  case 1:
                    return null === (_d = null === (_c = this.layout) || void 0 === _c ? void 0 : _c.axes) || void 0 === _d ? void 0 : _d.y1;

                  case 2:
                    return null === (_f = null === (_e = this.layout) || void 0 === _e ? void 0 : _e.axes) || void 0 === _f ? void 0 : _f.y2;

                  default:
                    debug.fF.assertNever(location);
                }
            }, CartesianAxes.prototype.isLogScaleAllowed = function(location) {
                var _a, _b;
                return null !== (_b = null === (_a = this.getAxis(location)) || void 0 === _a ? void 0 : _a.isLogScaleAllowed) && void 0 !== _b && _b;
            }, CartesianAxes.prototype.axesHaveTicks = function(viewport) {
                if (!this.layout) return !1;
                var margin = this.layout.margin, height = viewport.height - (margin.top + margin.bottom);
                return 0 !== cartesianAxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width - (margin.left + margin.right)) || 0 !== cartesianAxisHelper.getRecommendedNumberOfTicksForYAxis(height);
            }, CartesianAxes.prototype.finalizeAxisLabels = function(axes, showAxisTitles) {
                var _a, _b, _c, _d;
                if (this.axesData.x.showAxisTitle || this.axesData.y.showAxisTitle || this.axesData.y2.showAxisTitle) {
                    var axisLabels = {
                        x: axes.x ? null !== (_a = this.axesData.x.titleText) && void 0 !== _a ? _a : axes.x.axisLabel : void 0,
                        y: axes.y1 ? null !== (_b = this.axesData.y.titleText) && void 0 !== _b ? _b : axes.y1.axisLabel : void 0,
                        y2: axes.y2 ? null !== (_c = this.axesData.y2.titleText) && void 0 !== _c ? _c : axes.y2.axisLabel : void 0
                    }, xUnitType = CartesianAxes.getUnitType(axes.x.formatter);
                    axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null != xUnitType : this.valueAxisHasUnitType = null != xUnitType, 
                    axisLabels.x && xUnitType && (axisLabels.x = (0, axisStyle.O1)(this.axesData.x.axisStyle, axisLabels.x, xUnitType));
                    var yUnitType = CartesianAxes.getUnitType(axes.y1.formatter);
                    if (axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null != yUnitType : this.valueAxisHasUnitType = null != yUnitType, 
                    axisLabels.y && yUnitType && (axisLabels.y = (0, axisStyle.O1)(this.axesData.y.axisStyle, axisLabels.y, yUnitType)), 
                    axes.y2) {
                        var y2UnitType = CartesianAxes.getUnitType(axes.y2.formatter);
                        this.secondaryValueAxisHasUnitType = null != y2UnitType, axisLabels.y2 && y2UnitType && (axisLabels.y2 = (0, 
                        axisStyle.O1)(this.axesData.y2.axisStyle, axisLabels.y2, y2UnitType));
                    }
                    null === (_d = this.axisZoom) || void 0 === _d || _d.updateAxisTitles(axisLabels), 
                    axes.x && (axes.x.axisLabel = showAxisTitles.x ? axisLabels.x : null), axes.y1 && (axes.y1.axisLabel = showAxisTitles.y ? axisLabels.y : null), 
                    axes.y2 && (axes.y2.axisLabel = showAxisTitles.y2 ? axisLabels.y2 : null);
                }
            }, CartesianAxes.getUnitType = function(formatter) {
                var _a;
                if ((null === (_a = null == formatter ? void 0 : formatter.displayUnit) || void 0 === _a ? void 0 : _a.value) > 1) return formatter.displayUnit.title;
            }, CartesianAxes.YAxisLabelPadding = 5, CartesianAxes.XAxisLabelPadding = 3, CartesianAxes.XAxisPaddingDeltaForTitle = -6, 
            CartesianAxes.DefaultMaxMarginFactor = .25, CartesianAxes.MinimumMargin = {
                left: 1,
                right: 1,
                top: 8,
                bottom: 25
            }, CartesianAxes.MinimumAxisMarginFromScrollbar = 5, CartesianAxes;
        }();
        function hasMultipleYAxes(layers) {
            return debug.fF.assertValue(layers, "layers"), layers.length > 1;
        }
        function getPositiveAndNegativeDomainRatios(domain) {
            return debug.fF.assert(function() {
                return 2 === domain.length;
            }, "domain length must be 2"), debug.fF.assert(function() {
                return domain[1] - domain[0] != 0;
            }, "div by zero warning"), {
                pos: (domain[1] - 0) / (domain[1] - domain[0]),
                neg: (0 - domain[0]) / (domain[1] - domain[0])
            };
        }
        var dataLabelUtil = __webpack_require__(46769), visualBorderUtil = __webpack_require__(34021), Visuals_tooltip = __webpack_require__(11305), markerShape = __webpack_require__(61193), dataViewCategoricalReader = __webpack_require__(51129), Lazy = __webpack_require__(45034), formatUtil = __webpack_require__(59694), contracts_selector = __webpack_require__(32379), sqExpr = __webpack_require__(94419), legend_converter = __webpack_require__(79811), valueType = __webpack_require__(80777), valueFormatter = __webpack_require__(72489), WaterfallChartConverter = function() {
            function WaterfallChartConverter() {}
            return WaterfallChartConverter.convert = function(options) {
                var dataView = options.dataView;
                if (dataView) return dataView.categorical ? function(options) {
                    var _a, _b, _c, _d, categoryMetadata, tooltipMetadataColumns, dataView = options.dataView, hostServices = options.hostServices, dataLabelSettings = options.dataLabelSettings, sentimentColors = options.sentimentColors, interactivityService = options.interactivityService, tooltipsEnabled = options.tooltipsEnabled, formatStringProp = cartesian_capabilities.p.general.formatString, reader = (0, 
                    dataViewCategoricalReader.G)(dataView, {
                        formatStringProp
                    }), dataReader = reader.data, totalsEnabled = (0, dataViewObject2.NA)(reader.objects.getStaticObjects(), cartesian_capabilities.p.valueAxis.totalsEnabled, !0), categories = dataView.categorical.categories || [], totalLabel = hostServices.getLocalizedString("Waterfall_TotalLabel"), pos = {
                        current: 0,
                        min: 0,
                        max: 0,
                        formatString: void 0
                    }, dataPoints = [], categoryValues = [], categoryIdentities = [], valuesMetadata = [];
                    if (dataReader.hasValues("Tooltips") && (tooltipMetadataColumns = reader.columns.getAllValueMetadataColumnsForRole("Tooltips", void 0)), 
                    dataReader.hasValues("Y")) {
                        var labelFormatString = (valuesMetadata = [ reader.columns.getValueMetadataColumn("Y") ])[0].format;
                        if (_.isEmpty(categories)) {
                            var value = dataReader.getValue("Y", 0), formatString = dataReader.getFormatString("Y", 0);
                            pos = {
                                current: value,
                                max: value,
                                min: 0,
                                formatString
                            };
                        } else {
                            var categoryColumn_1 = categories[0];
                            categoryMetadata = categoryColumn_1.source, (categoryValues = categoryColumn_1.values.slice()).push(totalLabel);
                            for (var withCategory = null !== (_a = dataView.categorical.originalCategories) && void 0 !== _a ? _a : [ categoryColumn_1 ], defaultLabelColor = dataLabelSettings.fontProperties.color, _loop_1 = function(categoryIndex, catLen) {
                                var category = categoryValues[categoryIndex], value = dataReader.getValue("Y", categoryIndex) || 0, formatString = dataReader.getFormatString("Y", categoryIndex);
                                void 0 !== formatString && void 0 === labelFormatString && (labelFormatString = formatString);
                                var identity = selection_selectionId.dw.builder().withCategory(withCategory, categoryIndex, null === (_b = null == categoryColumn_1 ? void 0 : categoryColumn_1.source) || void 0 === _b ? void 0 : _b.queryName, !0).withMeasure(valuesMetadata[0].queryName, reader.columns.getValueColumn("Y"), categoryIndex).createSelectionId(), tooltipBuilder = void 0;
                                if (tooltipsEnabled) {
                                    tooltipBuilder = createCategoryTooltip(categoryMetadata ? [ categoryMetadata ] : null, valuesMetadata[0], [ category ], value, formatString, formatStringProp);
                                    var tooltipValues = dataReader.getAllValuesForRole("Tooltips", categoryIndex), tooltipFormatStrings = dataReader.getAllFormatStringsForRole("Tooltips", categoryIndex);
                                    tooltipValues && tooltipMetadataColumns && appendTooltipMeasures(tooltipValues, tooltipFormatStrings, tooltipBuilder, tooltipMetadataColumns, formatStringProp, hostServices);
                                }
                                var labelColor = (0, dataLabelUtil.t$)({
                                    defaultColor: defaultLabelColor,
                                    categoricalDataReader: reader,
                                    categoryIndex
                                }), fontPropColor = (0, dataLabelUtil.B8)(labelColor) ? labelColor.color : defaultLabelColor;
                                dataLabelSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropColor, dataLabelSettings.fontProperties), 
                                dataPoints.push(createDataPoint(value, pos.current, sentimentColors, category, categoryIndex, identity, tooltipBuilder, labelColor.color, formatString || labelFormatString, 0)), 
                                categoryIdentities[categoryIndex] = function() {
                                    return (0, cartesianHelper.MH)(categoryIndex, categoryColumn_1);
                                }, pos = getNewPositionContext(pos, value);
                            }, categoryIndex = 0, catLen = dataReader.getCategoryCount(); categoryIndex < catLen; categoryIndex++) _loop_1(categoryIndex);
                        }
                        var totalTooltipBuilder = void 0;
                        tooltipsEnabled && (totalTooltipBuilder = createCategoryTooltip(categoryMetadata ? [ categoryMetadata ] : null, valuesMetadata[0], [ totalLabel ], pos.current, labelFormatString, formatStringProp)), 
                        totalsEnabled && dataPoints.push(createDataPoint(pos.current, 0, sentimentColors, totalLabel, dataReader.getCategoryCount(), selection_selectionId.l0.createNull(), totalTooltipBuilder, dataLabelSettings.fontProperties.color, labelFormatString, 1, {
                            text: !0
                        }));
                    }
                    return interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                    {
                        series: [ {
                            data: dataPoints,
                            type: null === (_c = null == valuesMetadata ? void 0 : valuesMetadata[0]) || void 0 === _c ? void 0 : _c.type,
                            measureDisplayName: null === (_d = null == valuesMetadata ? void 0 : valuesMetadata[0]) || void 0 === _d ? void 0 : _d.displayName
                        } ],
                        categories: categoryValues,
                        categoryIdentities,
                        categoryMetadata,
                        preferredCategoryWidth: (0, cartesianHelper.$K)((0, cartesianHelper.Vk)(dataView.metadata, void 0)),
                        valuesMetadata,
                        legendData: createLegend(sentimentColors, hostServices, reader.objects.getStaticObjects(), options.style, !1, totalsEnabled),
                        hasHighlights: !1,
                        positionMin: pos.min,
                        positionMax: pos.max,
                        dataLabelsSettings: dataLabelSettings,
                        sentimentColors,
                        strokeSettings: (0, visualBorderUtil.kG)(options.style),
                        totalsEnabled
                    };
                }(options) : dataView.matrix ? function(options) {
                    var _a, _b, _c, _d, dataView = options.dataView, hostServices = options.hostServices, dataLabelSettings = options.dataLabelSettings, sentimentColors = options.sentimentColors, interactivityService = options.interactivityService, tooltipsEnabled = options.tooltipsEnabled, numberOfBreakdowns = options.numberOfBreakdowns, matrix = dataView.matrix, breakdownMetadata = !_.isEmpty(matrix.columns.levels) && matrix.columns.levels[0].sources[0];
                    debug.fF.assert(function() {
                        return !!breakdownMetadata;
                    }, "breakdown role should be defined when using matrix converter");
                    var categoryMetadata = !_.isEmpty(matrix.rows.levels) && matrix.rows.levels[0].sources, yIndex = _.findIndex(matrix.valueSources, function(s) {
                        return (0, dataRoleHelper.nu)(s, "Y");
                    }), valueMetadata = matrix.valueSources[yIndex], tooltipsMetadata = _.filter(matrix.valueSources, function(s) {
                        return (0, dataRoleHelper.nu)(s, "Tooltips");
                    }), dataPoints = [], categoryValues = [], pos = {
                        current: 0,
                        min: 0,
                        max: 0
                    }, totalBreakdownCategories = 0, staticObjects = null === (_b = null == dataView ? void 0 : dataView.metadata) || void 0 === _b ? void 0 : _b.objects;
                    if (breakdownMetadata && categoryMetadata && valueMetadata) {
                        debug.fF.assert(function() {
                            return (0, dataRoleHelper.nu)(breakdownMetadata, "Breakdown");
                        }, "matrix column should have breakdown role"), debug.fF.assert(function() {
                            return _.every(categoryMetadata, function(m) {
                                return (0, dataRoleHelper.nu)(m, "Category");
                            });
                        }, "matrix row should have category role");
                        var helper_1 = new ConverterHelper(breakdownMetadata, categoryMetadata, valueMetadata), labelFormatString = valueMetadata.format, otherLabel = hostServices.getLocalizedString("Waterfall_OtherLabel"), formatStringProp_1 = cartesian_capabilities.p.general.formatString, rows = matrix.rows.root.children, columns = matrix.columns.root.children;
                        if (!_.isEmpty(rows) && !_.isEmpty(columns)) {
                            var rowCount = rows.length, columnCount = columns.length, categoryIndex = 0, formattedPreviousRowCategoryValue = void 0, previousCategoryIdentityExprs = void 0, valuesLength = _.size(tooltipsMetadata) + 1;
                            rowCount > 0 && (totalBreakdownCategories = _.size(rows[0].values) / valuesLength - 1), 
                            numberOfBreakdowns = Math.min(numberOfBreakdowns, totalBreakdownCategories);
                            for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
                                for (var firstFormatStringInRow = void 0, row = rows[rowIndex], previousRow = rowIndex > 0 ? rows[rowIndex - 1] : void 0, rowCategoryValues = _.map(row.levelValues, function(v) {
                                    return v.value;
                                }), formattedRowCategoryValue = _.map(rowCategoryValues, function(c, i) {
                                    return (0, converterHelper.xq)(c, categoryMetadata[i], formatStringProp_1);
                                }).join(" "), categoryIdentityExprs = helper_1.splitIdentity(row.identity.expr), sorted = [], length_1 = _.size(row.values), columnIndex = 0; columnIndex < length_1; columnIndex += valuesLength) {
                                    for (var currentValue = void 0, previousValue = void 0, currentFormatString = void 0, labelColor = void 0, currentTooltipValues = [], previousTooltipValues = [], breakdownIndex = 0; breakdownIndex < valuesLength; breakdownIndex++) if (breakdownIndex === yIndex) {
                                        var matrixMeasure = row.values[columnIndex + breakdownIndex];
                                        currentValue = (0, axisHelper.eT)(matrixMeasure.value), currentFormatString = (0, 
                                        dataViewObject2.NA)(matrixMeasure.objects, formatStringProp_1), labelColor = (0, 
                                        dataViewObject3.y)(null === (_c = matrixMeasure.objects) || void 0 === _c ? void 0 : _c.labels, "color"), 
                                        firstFormatStringInRow || (firstFormatStringInRow = currentFormatString), previousValue = previousRow && (0, 
                                        axisHelper.eT)(previousRow.values[columnIndex + breakdownIndex].value);
                                    } else currentTooltipValues.push(row.values[columnIndex + breakdownIndex].value), 
                                    previousTooltipValues.push(previousRow && previousRow.values[columnIndex + breakdownIndex].value);
                                    sorted.push({
                                        key: columnIndex,
                                        currentValue,
                                        previousValue,
                                        difference: (currentValue || 0) - (previousValue || 0),
                                        column: columns[columnIndex / valuesLength],
                                        currentTooltipValues,
                                        previousTooltipValues,
                                        formatString: currentFormatString,
                                        labelColor: null != labelColor ? labelColor : void 0
                                    });
                                }
                                sorted = _.sortBy(sorted, function(d) {
                                    return -1 * Math.abs(d.difference);
                                });
                                var topColumns = _.chain(sorted).filter(function(d) {
                                    return !d.column.isSubtotal;
                                }).take(numberOfBreakdowns).sortBy(function(d) {
                                    return -1 * d.difference;
                                }).value(), subtotalColumn = _.find(sorted, function(d) {
                                    return d.column.isSubtotal;
                                }), subtotalCurrent = subtotalColumn.currentValue, subtotalPrevious = subtotalColumn.previousValue;
                                if (previousRow) {
                                    var topCurrent = _.sumBy(topColumns, function(c) {
                                        return c.currentValue;
                                    }), topPrevious = _.sumBy(topColumns, function(c) {
                                        return c.previousValue;
                                    }), topColumnIdentityExprs = _.chain(topColumns).map(function(d) {
                                        return helper_1.splitIdentity(d.column.identity.expr);
                                    }).flatten().value(), showOther = columnCount > numberOfBreakdowns + 1, otherDifference = 0, otherIdentity = void 0, otherTooltipBuilder = void 0;
                                    if (showOther) {
                                        var otherCurrent = subtotalCurrent - topCurrent, otherPrevious = subtotalPrevious - topPrevious;
                                        if (otherDifference = otherCurrent - otherPrevious, otherIdentity = helper_1.createBreakdownOtherIdentity(topColumnIdentityExprs, categoryIdentityExprs, previousCategoryIdentityExprs), 
                                        tooltipsEnabled) {
                                            otherTooltipBuilder = helper_1.createBreakdownTooltip(formattedRowCategoryValue, formattedPreviousRowCategoryValue, otherLabel, otherCurrent, otherPrevious, otherDifference, formatStringProp_1, hostServices);
                                            for (var otherTooltipMeasures = [], previousValues = [], _loop_2 = function(k) {
                                                var currentTooltipValue = subtotalColumn.currentTooltipValues[k], previousTooltipValue = subtotalColumn.previousTooltipValues[k];
                                                if (_.isNumber(currentTooltipValue) && _.isNumber(previousTooltipValue)) {
                                                    var currentValue = currentTooltipValue - _.sumBy(topColumns, function(c) {
                                                        return c.currentTooltipValues[k];
                                                    }), previousValue = previousTooltipValue - _.sumBy(topColumns, function(c) {
                                                        return c.previousTooltipValues[k];
                                                    });
                                                    otherTooltipMeasures.push(currentValue - previousValue), previousValues.push(previousValue);
                                                }
                                            }, k = 0; k < subtotalColumn.currentTooltipValues.length; k++) _loop_2(k);
                                            appendTooltipMeasures(otherTooltipMeasures, void 0, otherTooltipBuilder, tooltipsMetadata, formatStringProp_1, hostServices, previousValues, formattedRowCategoryValue, formattedPreviousRowCategoryValue);
                                        }
                                    }
                                    for (var otherAdded = !1, _loop_3 = function(dataPoint) {
                                        showOther && otherDifference > dataPoint.difference && !otherAdded && (otherAdded = !0, 
                                        dataPoints.push(createDataPoint(otherDifference, pos.current, sentimentColors, otherLabel, categoryIndex++, otherIdentity, otherTooltipBuilder, dataLabelSettings.fontProperties.color, labelFormatString || firstFormatStringInRow, 3, {
                                            text: !0
                                        })), categoryValues.push(otherLabel), pos = getNewPositionContext(pos, otherDifference));
                                        var formattedCategoryValue = (0, converterHelper.xq)(dataPoint.column.value, breakdownMetadata, formatStringProp_1), breakdownIdentityExprs = helper_1.splitIdentity(dataPoint.column.identity.expr);
                                        debug.fF.assertValue(breakdownIdentityExprs, "breakdown identity must be a compare expr");
                                        var identity = helper_1.createBreakdownIdentity(categoryIdentityExprs, previousCategoryIdentityExprs, breakdownIdentityExprs), tooltipBuilder_1 = void 0;
                                        tooltipsEnabled && (tooltipBuilder_1 = helper_1.createBreakdownTooltip(formattedRowCategoryValue, formattedPreviousRowCategoryValue, formattedCategoryValue, dataPoint.currentValue, dataPoint.previousValue, dataPoint.difference, formatStringProp_1, hostServices), 
                                        appendTooltipMeasures(_.map(dataPoint.currentTooltipValues, function(value, index) {
                                            return _.isNumber(value) ? value - dataPoint.previousTooltipValues[index] : value;
                                        }), void 0, tooltipBuilder_1, tooltipsMetadata, formatStringProp_1, hostServices, dataPoint.previousTooltipValues, formattedRowCategoryValue, formattedPreviousRowCategoryValue)), 
                                        dataPoints.push(createDataPoint(dataPoint.difference, pos.current, sentimentColors, formattedCategoryValue, categoryIndex++, identity, tooltipBuilder_1, null !== (_d = dataPoint.labelColor) && void 0 !== _d ? _d : dataLabelSettings.fontProperties.color, dataPoint.formatString || labelFormatString, 0, {
                                            text: !0
                                        })), categoryValues.push(formattedCategoryValue), pos = getNewPositionContext(pos, dataPoint.difference);
                                    }, _i = 0, topColumns_1 = topColumns; _i < topColumns_1.length; _i++) _loop_3(topColumns_1[_i]);
                                    showOther && !otherAdded && (otherAdded = !0, dataPoints.push(createDataPoint(otherDifference, pos.current, sentimentColors, otherLabel, categoryIndex++, otherIdentity, otherTooltipBuilder, dataLabelSettings.fontProperties.color, labelFormatString || firstFormatStringInRow, 3, {
                                        text: !0
                                    })), categoryValues.push(otherLabel), pos = getNewPositionContext(pos, otherDifference));
                                }
                                var selectorsByColumn = {
                                    dataMap: (_a = {}, _a[categoryMetadata[0].queryName] = [ row.identity ], _a),
                                    metadata: [ valueMetadata.queryName ]
                                }, tooltipBuilder = void 0;
                                tooltipsEnabled && (tooltipBuilder = createCategoryTooltip(categoryMetadata, valueMetadata, rowCategoryValues, subtotalCurrent, void 0, formatStringProp_1), 
                                appendTooltipMeasures(subtotalColumn.currentTooltipValues, void 0, tooltipBuilder, tooltipsMetadata, formatStringProp_1, hostServices)), 
                                dataPoints.push(createDataPoint(subtotalCurrent, 0, sentimentColors, formattedRowCategoryValue, categoryIndex++, new selection_selectionId.l0((0, 
                                contracts_selector.tV)(selectorsByColumn), !1, selectorsByColumn), tooltipBuilder, dataLabelSettings.fontProperties.color, labelFormatString || firstFormatStringInRow, 2, {
                                    text: !0
                                })), categoryValues.push(formattedRowCategoryValue), 0 === rowIndex && (pos = {
                                    current: subtotalCurrent,
                                    max: subtotalCurrent,
                                    min: subtotalCurrent
                                }), formattedPreviousRowCategoryValue = formattedRowCategoryValue, previousCategoryIdentityExprs = categoryIdentityExprs;
                            }
                        }
                    }
                    return interactivityService && interactivityService.applySelectionStateToData(dataPoints), 
                    {
                        series: [ {
                            data: dataPoints,
                            type: null == valueMetadata ? void 0 : valueMetadata.type,
                            measureDisplayName: null == valueMetadata ? void 0 : valueMetadata.displayName
                        } ],
                        categories: categoryValues,
                        categoryIdentities: _.map(dataPoints, function(point) {
                            return function() {
                                return point.identity;
                            };
                        }),
                        categoryMetadata: categoryMetadata[0],
                        preferredCategoryWidth: (0, cartesianHelper.$K)((0, cartesianHelper.Vk)(dataView.metadata, void 0)),
                        valuesMetadata: matrix.valueSources,
                        legendData: createLegend(sentimentColors, hostServices, staticObjects, options.style, !0, !0),
                        hasHighlights: !1,
                        positionMin: pos.min,
                        positionMax: pos.max,
                        dataLabelsSettings: dataLabelSettings,
                        sentimentColors,
                        isBreakdown: !0,
                        numberOfBreakdowns,
                        totalBreakdownCategories,
                        strokeSettings: (0, visualBorderUtil.kG)(options.style),
                        totalsEnabled: !0
                    };
                }(options) : void 0;
            }, WaterfallChartConverter;
        }();
        function createLegend(sentimentColors, hostServices, objects, style, includeOther, totalsEnabled) {
            var generateLabelDataPoint = function(color, labelId, measureId, index) {
                return {
                    label: hostServices.getLocalizedString(labelId),
                    marker: {
                        show: !0,
                        color,
                        shape: markerShape.ZO.circle
                    },
                    identity: selection_selectionId.dw.builder().withMeasure(measureId).createSelectionId(),
                    selected: !1,
                    index
                };
            }, legendDataPoints = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([ generateLabelDataPoint(sentimentColors.increaseFill.solid.color, "Increase", "increase", 0), generateLabelDataPoint(sentimentColors.decreaseFill.solid.color, "Decrease", "decrease", 1) ], includeOther ? [ generateLabelDataPoint(sentimentColors.otherFill.solid.color, "Waterfall_OtherLabel", "other", 3) ] : [], !0), totalsEnabled ? [ generateLabelDataPoint(sentimentColors.totalFill.solid.color, "Waterfall_TotalLabel", "total", 2) ] : [], !0);
            return (0, legend_converter.RS)(objects, legendDataPoints, !0, "", !1, style);
        }
        function createCategoryTooltip(categoryMetadata, valueMetadata, category, value, formatString, formatStringProp_) {
            var tooltipBuilder = new Visuals_tooltip.E4;
            return _.isEmpty(categoryMetadata) || tooltipBuilder.withLazyValue(new Lazy.o(function() {
                return {
                    displayName: _.map(categoryMetadata, function(c) {
                        return c.displayName;
                    }).join(" "),
                    value: _.map(category, function(c, i) {
                        return (0, converterHelper.xq)(c, categoryMetadata[i], formatStringProp_);
                    }).join(" ")
                };
            })), null != value && valueMetadata && tooltipBuilder.withLazyValue(new Lazy.o(function() {
                return {
                    displayName: valueMetadata.displayName,
                    value: (0, converterHelper.xq)(value, valueMetadata, formatStringProp_, !1, formatString)
                };
            })), tooltipBuilder;
        }
        function createDataPoint(value, position, colors, categoryValue, categoryIndex, identity, tooltipBuilder, labelFill, labelFormatString, barType, type) {
            var fill, sentimentColorType;
            return 1 === barType || 2 === barType ? (fill = colors.totalFill, sentimentColorType = 2) : 3 === barType ? (fill = colors.otherFill, 
            sentimentColorType = 3) : value > 0 ? (fill = colors.increaseFill, sentimentColorType = 0) : (fill = colors.decreaseFill, 
            sentimentColorType = 1), {
                value,
                position,
                color: fill.solid.color,
                sentimentColorType,
                categoryValue,
                categoryIndex,
                identity,
                seriesIndex: 0,
                selected: !1,
                highlight: !1,
                key: identity.getKey(),
                tooltipInfo: tooltipBuilder && function() {
                    return tooltipBuilder.getTooltipItems();
                },
                labelFill,
                labelFormatString,
                type: valueType.Ge.fromDescriptor(type),
                barType
            };
        }
        function getNewPositionContext(context, position) {
            var newPosition = context.current + position;
            return {
                current: newPosition,
                min: Math.min(context.min, newPosition),
                max: Math.max(context.max, newPosition)
            };
        }
        function appendTooltipMeasures(tooltipValues, tooltipFormatStrings, tooltipBuilder, tooltipMetadataColumns, formatStringProp_, hostServices, previousValues, categoryValue, previousCategoryValue) {
            if (!_.isEmpty(tooltipValues) && !_.isEmpty(tooltipMetadataColumns)) for (var _loop_4 = function(j) {
                if (null != tooltipValues[j] && tooltipMetadataColumns[j]) {
                    var displayName_1 = tooltipMetadataColumns[j].displayName, formattedValue_1 = (0, 
                    converterHelper.xq)(tooltipValues[j], tooltipMetadataColumns[j], formatStringProp_, !1, null == tooltipFormatStrings ? void 0 : tooltipFormatStrings[j]);
                    if (_.isEmpty(previousValues)) tooltipBuilder.withLazyValue(new Lazy.o(function() {
                        return {
                            displayName: displayName_1,
                            value: formattedValue_1
                        };
                    })); else {
                        var currentValue = tooltipValues[j], previousValue = previousValues[j];
                        if (_.isNumber(currentValue) && _.isNumber(previousValue)) displayName_1 = (0, formatUtil.W)(hostServices.getLocalizedString("Waterfall_BreakdownDifferenceTooltip"), displayName_1), 
                        formattedValue_1 = createPercentTooltipValue(formattedValue_1, currentValue, previousValue), 
                        tooltipBuilder.withLazyValue(new Lazy.o(function() {
                            return {
                                displayName: displayName_1,
                                value: formattedValue_1
                            };
                        })); else {
                            if (null != previousValue) {
                                var formattedPreviousValue_1 = (0, converterHelper.xq)(previousValue, tooltipMetadataColumns[j], formatStringProp_, !1);
                                tooltipBuilder.withLazyValue(new Lazy.o(function() {
                                    return {
                                        displayName: "".concat(previousCategoryValue, " ").concat(displayName_1),
                                        value: formattedPreviousValue_1
                                    };
                                }));
                            }
                            null != currentValue && tooltipBuilder.withLazyValue(new Lazy.o(function() {
                                return {
                                    displayName: "".concat(categoryValue, " ").concat(displayName_1),
                                    value: formattedValue_1
                                };
                            }));
                        }
                    }
                }
            }, j = 0; j < tooltipValues.length; j++) _loop_4(j);
        }
        function createPercentTooltipValue(formattedDifferenceValue, difference, previousValue) {
            if (!previousValue) return formattedDifferenceValue;
            var percentValue = difference / Math.abs(previousValue), formatString = (0, valueFormatter.Z)("Percentage"), formattedPercentChange = (0, 
            valueFormatter.WU)(percentValue, formatString);
            return "".concat(formattedDifferenceValue, " (").concat(formattedPercentChange, ")");
        }
        var ConverterHelper = function() {
            function ConverterHelper(breakdownMetadata, categoryMetadata, valueMetadata) {
                this.breakdownMetadata = breakdownMetadata, this.categoryMetadata = categoryMetadata, 
                this.valueMetadata = valueMetadata;
            }
            return ConverterHelper.prototype.splitIdentity = function(expr) {
                return (0, scopeIdentityExtractor.Dh)(expr);
            }, ConverterHelper.prototype.createBreakdownIdentity = function(categoryIdentityExprs, previousCategoryIdentityExprs, breakdownIdentityExprs) {
                var _a, selectorsByColumn = {
                    dataMap: (_a = {}, _a[this.breakdownMetadata.queryName] = [ (0, dataViewScopeIdentity.TZ)((0, 
                    sqExpr.Sh)((0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], _.map(categoryIdentityExprs, function(c) {
                        return c.left;
                    }), !0), _.map(breakdownIdentityExprs, function(c) {
                        return c.left;
                    }), !0), [ (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], _.map(previousCategoryIdentityExprs, function(c) {
                        return c.right;
                    }), !0), _.map(breakdownIdentityExprs, function(c) {
                        return c.right;
                    }), !0), (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], _.map(categoryIdentityExprs, function(c) {
                        return c.right;
                    }), !0), _.map(breakdownIdentityExprs, function(c) {
                        return c.right;
                    }), !0) ])) ], _a),
                    metadata: [ this.valueMetadata.queryName ]
                }, selector = (0, contracts_selector.tV)(selectorsByColumn);
                return new selection_selectionId.l0(selector, !1, selectorsByColumn);
            }, ConverterHelper.prototype.createBreakdownOtherIdentity = function(topValues, categoryIdentityExprs, previousCategoryIdentityExprs) {
                var _a, selectorsByColumn = {
                    dataMap: (_a = {}, _a[this.breakdownMetadata.queryName] = [ (0, dataViewScopeIdentity.TZ)((0, 
                    sqExpr.ff)((0, sqExpr.Sh)([ this.breakdownMetadata.expr ], _.map(topValues, function(v) {
                        return [ v.right ];
                    })))) ], _a),
                    metadata: [ this.valueMetadata.queryName ]
                };
                selectorsByColumn.dataMap[this.categoryMetadata[0].queryName] = [ (0, dataViewScopeIdentity.TZ)((0, 
                sqExpr.Sh)(_.map(categoryIdentityExprs, function(c) {
                    return c.left;
                }), [ _.map(previousCategoryIdentityExprs, function(c) {
                    return c.right;
                }), _.map(categoryIdentityExprs, function(c) {
                    return c.right;
                }) ])) ];
                var selector = (0, contracts_selector.tV)(selectorsByColumn);
                return new selection_selectionId.l0(selector, !1, selectorsByColumn);
            }, ConverterHelper.prototype.createBreakdownTooltip = function(category, previousCategory, breakdownCategory, value, previousValue, difference, formatStringProp, hostServices) {
                var _this = this, tooltipBuilder = new Visuals_tooltip.E4;
                if (this.breakdownMetadata && tooltipBuilder.withLazyValue(new Lazy.o(function() {
                    return {
                        displayName: _this.breakdownMetadata.displayName,
                        value: (0, converterHelper.xq)(breakdownCategory, _this.breakdownMetadata, formatStringProp)
                    };
                })), this.valueMetadata && (null != previousValue && tooltipBuilder.withLazyValue(new Lazy.o(function() {
                    return {
                        displayName: "".concat(previousCategory, " ").concat(_this.valueMetadata.displayName),
                        value: (0, converterHelper.xq)(previousValue, _this.valueMetadata, formatStringProp, !1)
                    };
                })), null != value && tooltipBuilder.withLazyValue(new Lazy.o(function() {
                    return {
                        displayName: "".concat(category, " ").concat(_this.valueMetadata.displayName),
                        value: (0, converterHelper.xq)(value, _this.valueMetadata, formatStringProp, !1)
                    };
                })), null != difference)) {
                    var formattedValue_2 = (0, converterHelper.xq)(difference, this.valueMetadata, formatStringProp, !1);
                    formattedValue_2 = createPercentTooltipValue(formattedValue_2, difference, previousValue), 
                    tooltipBuilder.withLazyValue(new Lazy.o(function() {
                        return {
                            displayName: (0, formatUtil.W)(hostServices.getLocalizedString("Waterfall_BreakdownDifferenceTooltip"), _this.valueMetadata.displayName),
                            value: formattedValue_2
                        };
                    }));
                }
                return tooltipBuilder;
            }, ConverterHelper;
        }(), AxesData = function() {
            function AxesData(options) {
                var valueAxisProperties = options.valueAxisProperties, y2AxisProperties = options.y2AxisProperties, categoryAxisProperties = options.categoryAxisProperties, _a = options.isValueAxisIrregular, isValueAxisIrregular = void 0 !== _a && _a, style = options.style, hasY2Role = options.hasY2Role, forceShowY2 = options.forceShowY2;
                this.chartType = options.chartType;
                var isYCategorical = (0, cartesianHelper.Au)(this.chartType), isScatter = 11 === this.chartType;
                debug.fF.assert(function() {
                    return !(isYCategorical && isScatter);
                }, "You can't have a categorical Y axis with a Scatter chart"), this.isCategoryAxisSet = !!categoryAxisProperties, 
                this.isValueAxisSet = !!valueAxisProperties, this.isValueAxisIrregular = isValueAxisIrregular;
                var xProperties = isYCategorical ? valueAxisProperties : categoryAxisProperties, yProperties = isYCategorical ? categoryAxisProperties : valueAxisProperties, y2Properties = this.isComboChart ? valueAxisProperties : y2AxisProperties, innerPaddingDefault = this.isRibbonChart ? cartesianHelper.cI : cartesianHelper.$B, valueShowAxisLabels = !this.isRibbonChart, xDefaults = (0, 
                tslib_es6.__assign)((0, tslib_es6.__assign)({}, AxesData.AxisDataDefaults), {
                    innerPadding: isYCategorical || isScatter ? void 0 : innerPaddingDefault
                });
                xDefaults.gridline.strokeShow = isYCategorical || isScatter;
                var yDefaults = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, AxesData.AxisDataDefaults), {
                    innerPadding: isYCategorical ? innerPaddingDefault : void 0,
                    show: !!isYCategorical || valueShowAxisLabels
                });
                yDefaults.gridline.strokeShow = !isYCategorical, this.x = AxesData.createSingleAxisFromObject(xProperties, xDefaults, style), 
                this.y = AxesData.createSingleAxisFromObject(yProperties, yDefaults, style), this.categoryAxis = isYCategorical ? this.y : this.x, 
                this.valueAxis = isYCategorical ? this.x : this.y, isValueAxisIrregular && (this.valueAxis.show = !1);
                var y2Defaults = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, AxesData.AxisDataDefaults), {
                    show: forceShowY2 && hasY2Role || (this.isComboChart ? void 0 : hasY2Role),
                    labelFontProperties: (0, common_fontProperties.ED)(isYCategorical ? this.x.labelFontProperties : this.y.labelFontProperties, {
                        weight: CssConstants.zu,
                        style: CssConstants.zu,
                        textDecoration: CssConstants.AI
                    }),
                    showAxisTitle: isYCategorical ? this.x.showAxisTitle : this.y.showAxisTitle,
                    switchAxisPosition: !0
                });
                this.y2 = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, AxesData.createSingleAxisFromObject(y2Properties, y2Defaults, style, !0, this.isComboChart)), {
                    hasY2Role
                }), this.secondaryValueAxis = this.y2, this.seriesLabelSettings = options.seriesLabelSettings || {
                    show: !1,
                    maxWidthPercentage: 0,
                    defaultSeriesWidth: 0,
                    position: void 0
                }, this.hasY2Role = hasY2Role;
            }
            return Object.defineProperty(AxesData, "AxisDataDefaults", {
                get: function() {
                    return {
                        show: !0,
                        alignZeros: !1,
                        showAxisTitle: !1,
                        includeDomains: [],
                        axisType: void 0,
                        axisStyle: axisStyle.DO.showTitleOnly,
                        labelDisplayUnits: 0,
                        labelPrecision: dataLabelViewModel1Consts.NZ,
                        titleText: void 0,
                        preferredCategoryWidth: cartesianHelper.jY,
                        maxMarginFactor: CartesianAxes.DefaultMaxMarginFactor,
                        concatenateLabels: cartesianHelper.SM,
                        labelFontProperties: {
                            color: void 0,
                            family: cartesianHelper.se,
                            size: units.B.createFromPt(cartesianHelper.rZ),
                            style: void 0,
                            variant: void 0,
                            weight: void 0,
                            whiteSpace: void 0,
                            textDecoration: void 0
                        },
                        titleFontProperties: {
                            family: cartesianHelper.se,
                            size: units.B.createFromPt(cartesianHelper.rZ)
                        },
                        axisLabel: void 0,
                        logAxisScale: !1,
                        gridline: {
                            strokeShow: void 0,
                            strokeColor: void 0,
                            strokeTransparency: 0,
                            strokePattern: strokePattern.Dv.solid,
                            strokeWidth: 1,
                            strokeDashArray: strokePattern.YU,
                            strokeDashCap: strokePattern.xm,
                            strokeAutoScale: !1
                        },
                        innerPadding: void 0,
                        invertAxis: !1,
                        sharedAxis: !0,
                        scaleToFit: !1,
                        totalsEnabled: !0,
                        switchAxisPosition: !1,
                        labelBold: !1,
                        labelItalic: !1,
                        labelUnderline: !1,
                        titleBold: !1,
                        titleItalic: !1,
                        titleUnderline: !1
                    };
                },
                enumerable: !1,
                configurable: !0
            }), AxesData.prototype.showsSeriesLabels = function() {
                var _a;
                return (null === (_a = this.seriesLabelSettings) || void 0 === _a ? void 0 : _a.show) && (!this.isComboChart || this.hasY2Role);
            }, Object.defineProperty(AxesData.prototype, "isComboChart", {
                get: function() {
                    return (0, cartesianHelper.LQ)(this.chartType);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AxesData.prototype, "isRibbonChart", {
                get: function() {
                    return 10 === this.chartType;
                },
                enumerable: !1,
                configurable: !0
            }), AxesData.createSingleAxisFromObject = function(properties, defaults, style, isSecond, isCombo) {
                var getPropName = isSecond ? function(prop) {
                    return _.camelCase("sec ".concat(prop.propertyName));
                } : function(prop) {
                    return prop.propertyName;
                }, axisProps = cartesian_capabilities.p.valueAxis, colorHelper = common_colorHelper.v.create(style), ensureValueIsRatio = function(v) {
                    return v >= 1 ? v / 100 : v;
                }, concatenateLabels = (0, dataViewObject3.N)(properties, getPropName(axisProps.concatenateLabels), defaults.concatenateLabels), strokePattern = (0, 
                dataViewObject3.N)(properties, getPropName(axisProps.gridlineStyle), defaults.gridline.strokePattern), names = {
                    family: getPropName(axisProps.fontFamily),
                    size: getPropName(axisProps.fontSize),
                    color: getPropName(axisProps.labelColor),
                    sizeInPixels: !1,
                    bold: getPropName(axisProps.bold),
                    italic: getPropName(axisProps.italic),
                    underline: getPropName(axisProps.underline)
                }, labelFontProperties = (0, common_fontProperties.Zi)(properties, names, colorHelper, style, defaults.labelFontProperties.color ? void 0 : cartesianHelper.eX, "smallLightLabel", defaults.labelFontProperties);
                names.family = getPropName(axisProps.titleFontFamily), names.size = getPropName(axisProps.titleFontSize), 
                names.color = getPropName(axisProps.titleColor), names.bold = getPropName(axisProps.titleBold), 
                names.italic = getPropName(axisProps.titleItalic), names.underline = getPropName(axisProps.titleUnderline);
                var v, titleFontProperties = (0, common_fontProperties.Zi)(properties, names, colorHelper, style, void 0, "title", (0, 
                common_fontProperties.ED)(defaults.titleFontProperties, {
                    color: labelFontProperties.color,
                    family: labelFontProperties.family,
                    size: labelFontProperties.size,
                    variant: labelFontProperties.variant,
                    whiteSpace: labelFontProperties.whiteSpace
                })), mergedUserDomain = (0, cartesianAxisHelper.getMergedUserDomains)(defaults), start = (0, 
                dataViewObject3.N)(properties, getPropName(axisProps.start), mergedUserDomain[0]), end = (0, 
                dataViewObject3.N)(properties, getPropName(axisProps.end), mergedUserDomain[1]), hasStart = void 0 !== start, hasEnd = void 0 !== end;
                return {
                    show: (0, dataViewObject3.N)(properties, isCombo ? getPropName(axisProps.show) : axisProps.show.propertyName, defaults.show),
                    alignZeros: (0, dataViewObject3.N)(properties, getPropName(axisProps.alignZeros), defaults.alignZeros),
                    showAxisTitle: (0, dataViewObject3.N)(properties, getPropName(axisProps.showAxisTitle), defaults.showAxisTitle),
                    includeDomains: hasStart || hasEnd ? [ (0, cartesianAxisHelper.createScalarDomainOptions)([ start, end ], 10, [ hasStart, hasEnd ]) ] : [],
                    axisType: (0, dataViewObject3.N)(properties, getPropName(axisProps.axisType), defaults.axisType),
                    axisStyle: (0, dataViewObject3.N)(properties, getPropName(axisProps.axisStyle), defaults.axisStyle),
                    labelDisplayUnits: (0, dataViewObject3.N)(properties, getPropName(axisProps.labelDisplayUnits), defaults.labelDisplayUnits),
                    labelPrecision: (v = (0, dataViewObject3.N)(properties, getPropName(axisProps.labelPrecision), defaults.labelPrecision), 
                    null == v || v < 0 ? defaults.labelPrecision : v),
                    titleText: (0, dataViewObject3.N)(properties, getPropName(axisProps.titleText), defaults.titleText),
                    preferredCategoryWidth: (0, dataViewObject3.N)(properties, getPropName(axisProps.preferredCategoryWidth), defaults.preferredCategoryWidth),
                    maxMarginFactor: ensureValueIsRatio((0, dataViewObject3.N)(properties, getPropName(cartesian_capabilities.p.categoryAxis.maxMarginFactor), defaults.maxMarginFactor)),
                    concatenateLabels,
                    labelFontProperties,
                    titleFontProperties,
                    axisLabel: (0, dataViewObject3.N)(properties, getPropName(axisProps.axisLabel)),
                    logAxisScale: (0, dataViewObject3.N)(properties, getPropName(axisProps.logAxisScale), defaults.logAxisScale),
                    gridline: {
                        strokeShow: (0, dataViewObject3.N)(properties, getPropName(axisProps.gridlineShow), defaults.gridline.strokeShow || !1 === concatenateLabels),
                        strokeColor: colorHelper.getColorForPropertyName(properties, getPropName(axisProps.gridlineColor), AxesData.getGridlineDefaultColorFromGridlineStyle(strokePattern)),
                        strokeTransparency: (0, dataViewObject3.N)(properties, getPropName(axisProps.gridlineTransparency), defaults.gridline.strokeTransparency),
                        strokeWidth: (0, dataViewObject3.N)(properties, getPropName(axisProps.gridlineThickness), defaults.gridline.strokeWidth),
                        strokePattern,
                        strokeDashArray: (0, dataViewObject3.N)(properties, getPropName(axisProps.gridlineDashArray), defaults.gridline.strokeDashArray),
                        strokeDashCap: (0, dataViewObject3.N)(properties, getPropName(axisProps.gridlineDashCap), defaults.gridline.strokeDashCap),
                        strokeAutoScale: (0, dataViewObject3.N)(properties, getPropName(axisProps.gridlineAutoScale), defaults.gridline.strokeAutoScale)
                    },
                    innerPadding: ensureValueIsRatio((0, dataViewObject3.N)(properties, getPropName(cartesian_capabilities.p.categoryAxis.innerPadding), defaults.innerPadding)),
                    invertAxis: (0, dataViewObject3.N)(properties, getPropName(axisProps.invertAxis), defaults.invertAxis),
                    sharedAxis: (0, dataViewObject3.N)(properties, axisProps.sharedAxis.propertyName, defaults.sharedAxis),
                    scaleToFit: (0, dataViewObject3.N)(properties, axisProps.scaleToFit.propertyName, defaults.scaleToFit),
                    totalsEnabled: (0, dataViewObject3.N)(properties, getPropName(axisProps.totalsEnabled), defaults.totalsEnabled),
                    labelBold: (0, dataViewObject3.N)(properties, getPropName(axisProps.bold), defaults.labelBold),
                    labelItalic: (0, dataViewObject3.N)(properties, getPropName(axisProps.italic), defaults.labelItalic),
                    labelUnderline: (0, dataViewObject3.N)(properties, getPropName(axisProps.underline), defaults.labelUnderline),
                    titleBold: (0, dataViewObject3.N)(properties, getPropName(axisProps.titleBold), defaults.titleBold),
                    titleItalic: (0, dataViewObject3.N)(properties, getPropName(axisProps.titleItalic), defaults.titleItalic),
                    titleUnderline: (0, dataViewObject3.N)(properties, getPropName(axisProps.titleUnderline), defaults.titleUnderline),
                    switchAxisPosition: (0, dataViewObject3.N)(properties, getPropName(axisProps.switchAxisPosition), defaults.switchAxisPosition)
                };
            }, AxesData.getGridlineDefaultColorFromGridlineStyle = function(pattern) {
                switch (pattern) {
                  case strokePattern.Dv.dashed:
                  case strokePattern.Dv.solid:
                  case strokePattern.Dv.custom:
                    return cartesianHelper.Ao;

                  case strokePattern.Dv.dotted:
                    return cartesianHelper.JI;

                  default:
                    return debug.fF.assertFail("unknown gridline style: ".concat(pattern)), cartesianHelper.Ao;
                }
            }, AxesData;
        }(), cartesianChart_formatter = __webpack_require__(3128), animatorCommon = __webpack_require__(94478), responsiveVisualUtil2 = __webpack_require__(10034), legend_util = __webpack_require__(77686), browserUtils = __webpack_require__(59107), interactivityUtils = __webpack_require__(30237), CategoricalAxisBehavior = function() {
            function CategoricalAxisBehavior() {}
            return CategoricalAxisBehavior.prototype.bindEvents = function(options, selectionHandler, dataPointNavigationManagerWithKey, formatMode) {
                var _a, _this = this;
                if (options && !formatMode) {
                    if (this.ticks = options.ticks, dataPointNavigationManagerWithKey) {
                        var dataPointNavigationManager = dataPointNavigationManagerWithKey.dataPointNavigationManager, pointSourceKey = dataPointNavigationManagerWithKey.pointSourceKey;
                        dataPointNavigationManager.isEmpty(pointSourceKey) || ((0, interactivityUtils.W3)(options.root, dataPointNavigationManager, pointSourceKey), 
                        (0, interactivityUtils.I8)(options.root, dataPointNavigationManager, pointSourceKey), 
                        (0, interactivityUtils.lt)(options.root, selectionHandler));
                    }
                    this.ticks.on("click.select", function() {
                        return _this.handleSelection(selectionHandler);
                    }).on("keydown.select", function() {
                        var d3Event = d3.event, keyCode = d3Event.keyCode;
                        32 !== keyCode && 13 !== keyCode || (d3Event.preventDefault(), d3Event.stopPropagation(), 
                        _this.handleSelection(selectionHandler));
                    });
                } else null === (_a = this.ticks) || void 0 === _a || _a.on("click.select", null).on("keydown.select", null);
            }, CategoricalAxisBehavior.prototype.renderSelection = function(hasSelection) {
                var _a;
                null === (_a = this.ticks) || void 0 === _a || _a.style("font-weight", function(d) {
                    return d.selected ? "700" : null;
                }).select("text").attr("aria-selected", function(d) {
                    return hasSelection && d.selected;
                });
            }, CategoricalAxisBehavior.prototype.renderFocus = function(element) {
                browserUtils.M.focus(element);
            }, CategoricalAxisBehavior.prototype.handleSelection = function(selectionHandler) {
                (0, interactivityUtils.kW)(function(d) {
                    return (0, interactivityUtils.c8)(d, selectionHandler);
                }, !0);
            }, CategoricalAxisBehavior;
        }(), svgScrollbar = __webpack_require__(70450), gridLayoutBehaviors = __webpack_require__(63194), renderUtil = __webpack_require__(60066), common_strokeStyle = __webpack_require__(2241), textUtil = __webpack_require__(44977), tooltipUtils = __webpack_require__(38400), strokeLineJoin = __webpack_require__(41234), DOMConstants = __webpack_require__(65195), svgUtil = __webpack_require__(10389);
        function getAvailableViewport(layout) {
            var viewport = layout.viewport, margin = layout.margin;
            return {
                width: viewport.width - margin.left - margin.right,
                height: viewport.height - margin.top - margin.bottom
            };
        }
        var AxisPadding = {
            left: 10,
            right: 10,
            top: 0,
            bottom: 13
        };
        function build(options) {
            var _a = options.rendererSettings, interactivityOptions = _a.interactivity, axes = _a.axes, calculatePlotArea = _a.calculatePlotArea, chartType = _a.cartesianOptions.chartType, axisZoom = options.axisZoom, axesData = options.axesData, layers = options.layers, playAxesRect = options.playAxesRect, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, viewport = options.viewport, rotateXTickLabels90 = options.rotateXTickLabels90, forceMarginMin = options.forceMarginMin, xs = [], ys = [], y2s = [];
            function getArrayMinMax(s) {
                var e = d3.extent(s);
                return {
                    min: e[0],
                    max: e[1]
                };
            }
            return (0, referenceLineHelper1.Lp)(options.referenceLines, xs, ys, y2s, (0, cartesianHelper.RN)(layers)), 
            axes.negotiateAxes({
                layers,
                parentViewport: viewport,
                padding: (0, Prototype.ED)(AxisPadding),
                playAxisControlLayout: playAxesRect,
                showAxisTitles: calculateShowAxisTitles(axesData, axisZoom),
                shouldRenderAxis: (0, cartesianHelper.QB)(axesData, (0, cartesianHelper.LQ)(chartType)),
                axesFontProperties: getAxesFontProperties(axesData),
                interactivityRightMargin: (null == interactivityOptions ? void 0 : interactivityOptions.mobileTileInteractive) && !trimOrdinalDataOnOverflow ? 6 : 0,
                calculatePlotArea,
                skipMergeValueAxes: null == axisZoom ? void 0 : axisZoom.skipMergingValueAxisDomains(),
                ensureXDomain: getArrayMinMax(xs),
                ensureYDomain: getArrayMinMax(ys),
                ensureY2Domain: getArrayMinMax(y2s),
                rotateXTickLabels90,
                forceMarginMin
            });
        }
        function hasVisibleScrollbar(layout) {
            return layout.isXScrollBarVisible || layout.isYScrollBarVisible;
        }
        function getAxesFontProperties(data) {
            return {
                x: {
                    tickLabels: data.x.labelFontProperties,
                    title: data.x.titleFontProperties
                },
                y: {
                    tickLabels: data.y.labelFontProperties,
                    title: data.y.titleFontProperties
                },
                y2: {
                    tickLabels: data.y2.labelFontProperties,
                    title: data.y2.titleFontProperties
                }
            };
        }
        function calculateShowAxisTitles(axesData, axisZoom) {
            var result = {
                x: axesData.x.showAxisTitle,
                y: axesData.y.showAxisTitle,
                y2: axesData.y2.showAxisTitle
            };
            return axisZoom && (result = axisZoom.updateShowAxisTitles(result)), result;
        }
        var SvgCartesianAxes = function() {
            function SvgCartesianAxes(settings) {
                this.settings = settings, this.axesData = settings.data;
                var useManagedTabIndex = this.axesData.useManagedTabIndex, axisGraphicsContext = this.axisGraphicsContext = this.settings.container.append("g").attr(htmlSubSelectionHelper.CP, !0).classed(SvgCartesianAxes.AxisGraphicsContext.class, !0);
                this.svgScrollable = this.settings.container.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").attr(htmlSubSelectionHelper.CP, !0).classed(SvgCartesianAxes.AxisGraphicsContext.class, !0);
                this.labelBackgroundRegion = this.svgScrollable.append("g").classed(dataLabelViewModel1Consts.u9.class, !0), 
                this.labelRegion = this.svgScrollable.append("g").classed(dataLabelViewModel1Consts.ZL.class, !0), 
                this.labelContainerRegion = this.svgScrollable.append("g").classed(dataLabelViewModel1Consts.LV.class, !0).attr(htmlSubSelectionHelper.CP, !0), 
                this.labelSeriesBackgroundRegion = this.svgScrollable.append("g").classed(dataLabelViewModel1Consts.pJ.class, !0), 
                this.labelSeriesRegion = this.svgScrollable.append("g").classed(dataLabelViewModel1Consts.oA.class, !0), 
                this.axes.isYAxisCategorical ? (this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "y axis").attr("data-automation-type", "y axis").classed(gridLayoutBehaviors.rG.class, useManagedTabIndex).attr(DOMConstants.Rh, useManagedTabIndex), 
                this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "y axis").attr("data-automation-type", "y2 axis"), 
                this.xAxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "x axis").attr("data-automation-type", "x axis").attr(htmlSubSelectionHelper.CP, !0)) : (this.y1AxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "y axis").attr("data-automation-type", "y axis"), 
                this.y2AxisGraphicsContext = axisGraphicsContext.append("g").attr("class", "y axis").attr("data-automation-type", "y2 axis"), 
                this.xAxisGraphicsContext = axisGraphicsContextScrollable.append("g").attr("class", "x axis").attr("data-automation-type", "x axis").classed(gridLayoutBehaviors.rG.class, useManagedTabIndex).attr(DOMConstants.Rh, useManagedTabIndex));
            }
            return Object.defineProperty(SvgCartesianAxes.prototype, "axes", {
                get: function() {
                    return this.settings.axes;
                },
                enumerable: !1,
                configurable: !0
            }), SvgCartesianAxes.prototype.getScrollableRegion = function() {
                return this.axisGraphicsContextScrollable;
            }, SvgCartesianAxes.prototype.getLabelsRegion = function() {
                return this.labelRegion;
            }, SvgCartesianAxes.prototype.getSeriesLabelsRegion = function() {
                return this.labelSeriesRegion;
            }, SvgCartesianAxes.prototype.getLabelBackground = function() {
                return this.labelBackgroundRegion;
            }, SvgCartesianAxes.prototype.getLabelsContainers = function() {
                return {
                    foreground: this.labelRegion,
                    background: this.labelBackgroundRegion
                };
            }, SvgCartesianAxes.prototype.getLabelContainerRegion = function() {
                return {
                    foreground: this.labelContainerRegion
                };
            }, SvgCartesianAxes.prototype.getSeriesLabelsContainers = function() {
                return {
                    seriesForeground: this.labelSeriesRegion,
                    seriesBackground: this.labelSeriesBackgroundRegion
                };
            }, SvgCartesianAxes.prototype.update = function(axesData) {
                this.axesData = axesData;
            }, Object.defineProperty(SvgCartesianAxes.prototype, "featureSwitches", {
                get: function() {
                    return this.settings.cartesianOptions.featureSwitches;
                },
                enumerable: !1,
                configurable: !0
            }), SvgCartesianAxes.updateTickTooltips = function(axisSelection, axisProps) {
                var tickValues = axisProps.d3Axis.tickValues(), tickFormatter = SvgCartesianAxes.getTickFormatter(axisProps.d3Axis);
                axisSelection.selectAll(SvgCartesianAxes.TickTextSelector).each(function(datum) {
                    var textElement = d3.select(this), tickIndex = tickValues.indexOf(datum);
                    tickIndex < 0 || textElement.append("title").text(tickFormatter(datum, tickIndex));
                });
            }, SvgCartesianAxes.getTickFormatter = function(axis) {
                return axis.tickFormat() || cartesianAxisHelper.defaultTickFormat;
            }, SvgCartesianAxes.prototype.renderAxis = function(options) {
                var _a, _b, _c, _d, _e, _f, _h, _j, axesLayout = options.axesLayout, isStacked = options.isStacked, gridlineOptions = options.gridlineOptions, firstVisibleNode = options.firstVisibleNode, isXAxis = 0 === options.location, isY1Axis = 1 === options.location, isYAxis = !isXAxis, tickPadding = axesLayout.tickPadding, margin = axesLayout.margin, leftRightMarginLimit = axesLayout.marginLimits.left, tickLabelMargins = axesLayout.tickLabelMargins, plotAreaWidth = axesLayout.plotArea.width, axes = axesLayout.axes, graphicsElement = this.getGraphicsElement(options), renderMode = isStacked ? 1 : this.getAxisRenderMode(options);
                if (0 !== renderMode) {
                    var axisProps = SvgCartesianAxes.getAxisProps(options), fontProperties = SvgCartesianAxes.getAxisTickLabelFontProperties(options), isScalar = !(0, 
                    axisHelper._9)(axisProps.scale), showYOnRight = !isXAxis && "right" === this.axes.getYAxisPosition(options.location), yTickPadding = showYOnRight ? tickPadding.right : tickPadding.left;
                    if (_.isEmpty((0, cartesianAxisHelper.getHierStack)(axes)) || !axisProps.isCategoryAxis || isStacked) {
                        graphicsElement.selectAll(SvgCartesianAxes.HierarchicalStackCS.selector).remove(), 
                        isXAxis ? (axisProps.d3Axis.tickSizeInner(isScalar ? -axesLayout.plotArea.height : 0).tickSizeOuter(0), 
                        axisProps.willLabelsFit || isScalar || axisProps.d3Axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX)) : isScalar ? axisProps.d3Axis.tickSize(isStacked ? tickLabelMargins.stackHeight : isY1Axis ? -plotAreaWidth : SvgCartesianAxes.Y2TickSize).tickPadding(yTickPadding) : axisProps.d3Axis.tickSize(cartesianAxisHelper.DefaultInnerTickSize), 
                        axisProps.d3Axis = SvgCartesianAxes.orient(graphicsElement, axisProps.d3Axis, isXAxis ? "bottom" : this.axes.getYAxisPosition(options.location));
                        var animateCategoryAxis = (_b = void 0 === (_a = options.cartesianOptions) ? {} : _a).animateCategoryAxis, animateValueAxis = _b.animateValueAxis, duration = (_d = void 0 === (_c = options.axesAnimationOptions) ? {} : _c).duration, ease = _d.ease, xIsCategoryAxis = (_e = options.axesLayout.axes).x.isCategoryAxis, y1IsCategoryAxis = _e.y1.isCategoryAxis, y2IsCategoryAxis = (void 0 === (_f = _e.y2) ? {} : _f).isCategoryAxis;
                        debug.fF.assert(function() {
                            return !y2IsCategoryAxis;
                        }, "Unit test scream check -  Y2 cannot be categorical, must be always numeric"), 
                        (duration && ease && (isXAxis ? animateValueAxis && xIsCategoryAxis : isY1Axis ? animateCategoryAxis && y1IsCategoryAxis || animateValueAxis && !y1IsCategoryAxis : animateCategoryAxis && y2IsCategoryAxis || animateValueAxis && !y2IsCategoryAxis) ? graphicsElement.transition().duration(duration).ease(ease) : graphicsElement).call(axisProps.d3Axis);
                        var axisTextNodes = graphicsElement.selectAll(SvgCartesianAxes.TickTextSelector).attr("style", null).styles((0, 
                        common_fontProperties.E_)(fontProperties)).style("visibility", null).style("fill", null !== (_h = this.getAxisData(options.location).labelFontProperties.color) && void 0 !== _h ? _h : null);
                        if (graphicsElement.selectAll("g.tick line").classed("zero-line", !1), isScalar && graphicsElement.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).select("line").classed("zero-line", !0), graphicsElement.classed("showLinesOnAxis", gridlineOptions.strokeShow).classed("hideLinesOnAxis", !gridlineOptions.strokeShow), 
                        graphicsElement.selectAll("g.tick line:not(".concat(SvgCartesianAxes.InteractivityGridlineClassSelector.selector, ")")).styles((0, 
                        common_strokeStyle.bc)(gridlineOptions)), (null === (_j = this.featureSwitches) || void 0 === _j ? void 0 : _j.onObject) && (this.convertAxisValuesToSubSelectable(options), 
                        this.renderInteractivityGridline(options)), 2 !== renderMode) {
                            if (isStacked) {
                                var stackedAxisProps_1 = axisProps;
                                graphicsElement.selectAll("g.tick").filter(function(d) {
                                    return stackedAxisProps_1.adjustedValues[d] === axisHelper.Pt;
                                }).selectAll("line").remove(), _.isEmpty(axisProps.categoryLabelMaxWidths) ? graphicsElement.selectAll("g.tick").selectAll("line").remove() : (SvgCartesianAxes.centerHierarchyTicks(graphicsElement, stackedAxisProps_1), 
                                SvgCartesianAxes.styleHierarchyTicks(graphicsElement, stackedAxisProps_1, gridlineOptions), 
                                isYAxis && axisTextNodes.call(cartesianAxisHelper.rotate, {
                                    textTruncator: textMeasurementService.b.getTailoredTextOrDefault,
                                    textProperties: (0, common_fontProperties.qk)(fontProperties),
                                    needRotate: !0,
                                    needEllipsis: !0,
                                    axisProperties: axisProps,
                                    margin,
                                    rotate90: !0,
                                    firstVisibleNode,
                                    rotationPadding: cartesianHelper.Fv,
                                    height: options.height,
                                    y1Hierarchy: !0
                                }));
                            }
                            isXAxis ? axisProps.willLabelsWordBreak ? SvgCartesianAxes.xAxisWordBreak(axisTextNodes, options) : axisTextNodes.call(cartesianAxisHelper.rotate, {
                                textTruncator: textMeasurementService.b.getTailoredTextOrDefault,
                                textProperties: (0, common_fontProperties.qk)(fontProperties),
                                needRotate: !axisProps.willLabelsFit && !isScalar,
                                needEllipsis: !0,
                                axisProperties: axisProps,
                                margin,
                                rotate90: hasVisibleScrollbar(axesLayout) || !axisProps.willLabelsFit && (!!isStacked || axesLayout.rotateXTickLabels90),
                                firstVisibleNode,
                                rotationPadding: cartesianHelper.Fv,
                                height: options.height
                            }) : !((showYOnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft) >= leftRightMarginLimit) || isStacked && !_.isEmpty(axisProps.categoryLabelMaxWidths) || graphicsElement.selectAll(SvgCartesianAxes.TickTextSelector).call(axisHelper.oq, leftRightMarginLimit - yTickPadding, textMeasurementService.b.svgEllipsis), 
                            SvgCartesianAxes.updateTickTooltips(graphicsElement, axisProps), (isXAxis || isY1Axis) && this.axes.interactivityService && (isY1Axis ? this.axes.isYAxisCategorical : !this.axes.isYAxisCategorical) && axisProps.categoryIdentities && (isScalar ? this.removeFocusAbility(graphicsElement) : this.renderCategoricalInteractivity(options));
                        } else gridlineOptions.strokeShow && (graphicsElement.selectAll(SvgCartesianAxes.TickTextSelector).style("visibility", "hidden"), 
                        this.removeFocusAbility(graphicsElement));
                    } else this.renderHierarchicalAxis(options);
                } else graphicsElement.selectAll("*").remove();
            }, SvgCartesianAxes.prototype.renderHierarchicalAxis = function(options) {
                var _a, _this = this, axes = (_a = options.axesLayout).axes, tickLabelMargins = _a.tickLabelMargins, graphicsElement = this.getGraphicsElement(options), hierStack = (0, 
                cartesianAxisHelper.getHierStack)(axes);
                debug.fF.assertValue(!_.isEmpty(hierStack), "one of the axis must be hierarchical and have sub-axes");
                var isX = axes.x.isCategoryAxis;
                debug.fF.assert(function() {
                    return isX || axes.y1.isCategoryAxis;
                }, "renderHierarchicalAxis should only be called if one axis is categorical"), this.axisGraphicsContextScrollable.selectAll(".".concat(isX ? "x" : "y", ".axis > .tick")).remove(), 
                (isX ? axes.x : axes.y1).categoryIdentities && graphicsElement.attr("tabindex", 0).attr("focusable", !0).attr("aria-label", isX ? axes.x.axisLabel : axes.y1.axisLabel).attr("role", "listbox").classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge());
                var pos = isX ? axisHelper.Or.bottom : "left" === this.axes.getY1AxisPosition() ? axisHelper.Or.left : axisHelper.Or.right, leafHeight = CartesianAxes.getLeafHeight(tickLabelMargins, pos, hierStack.length);
                graphicsElement.selectAll(SvgCartesianAxes.HierarchicalStackCS.selector).data(hierStack).join(function(enter) {
                    return enter.append("g").classed(SvgCartesianAxes.HierarchicalStackCS.class, !0).classed("showLinesOnAxis", options.gridlineOptions.strokeShow).classed("hideLinesOnAxis", !options.gridlineOptions.strokeShow);
                }).each(function(stackedAxisProps, stackLevel, nodes) {
                    var transformY = 0, transformX = 0, isLeaf = 0 === stackLevel;
                    isLeaf || (pos === axisHelper.Or.bottom ? transformY = leafHeight + (stackLevel - 1) * tickLabelMargins.stackHeight : pos === axisHelper.Or.left ? transformX = -leafHeight - (stackLevel - 1) * tickLabelMargins.stackHeight : pos === axisHelper.Or.right ? transformX = leafHeight + stackLevel * tickLabelMargins.stackHeight : debug.fF.assertAnyValue(pos, "AxisOrientation is not expected to be top.")), 
                    _this.renderAxis((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                        axisProps: stackedAxisProps,
                        graphicsElement: d3.select(nodes[stackLevel]).attr("transform", (0, svgUtil.Iu)(transformX, transformY)),
                        isStacked: !0,
                        firstVisibleNode: (0, hierarchyNodeUtils.y$)(stackedAxisProps.rootNode, stackedAxisProps.scale.domain()[0], hierStack.length - stackLevel),
                        useManagedTabIndex: !!isX && options.useManagedTabIndex,
                        height: function() {
                            if (!isX) return 999;
                            var fontProperties = SvgCartesianAxes.getAxisTickLabelFontProperties(options);
                            return isLeaf ? fontProperties.size.pt <= cartesianHelper.rZ ? options.axesLayout.marginLimits.bottom : leafHeight : tickLabelMargins.stackHeight;
                        }()
                    }));
                }), this.categoryAxisGraphicsContext = graphicsElement;
            }, SvgCartesianAxes.prototype.renderCategoricalInteractivity = function(options) {
                var axisProps = SvgCartesianAxes.getAxisProps(options), graphicsElement = this.getGraphicsElement(options), categoryIdentities = axisProps.categoryIdentities;
                this.categoryAxisGraphicsContext = graphicsElement;
                var isStack = (0, cartesianAxisHelper.isStackedAxisProperties)(axisProps);
                isStack || (graphicsElement.attr("aria-label", axisProps.axisLabel), options.useManagedTabIndex || graphicsElement.attr("tabindex", 0).attr("focusable", !0).attr("role", "listbox").classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()));
                for (var values = (0, cartesianAxisHelper.isStackedAxisProperties)(axisProps) ? axisProps.adjustedValues : axisProps.values, hierarchyPointers = (0, 
                cartesianAxisHelper.isStackedAxisProperties)(axisProps) ? axisProps.categoryHierarchyPointers : [], tickData = _.map(axisProps.d3Axis.tickValues(), function(categoryIndex, i) {
                    var _a, _b, adjustedIndex;
                    0 !== i || _.isEmpty(hierarchyPointers) || (adjustedIndex = categoryIndex, categoryIndex = _.findLastIndex(hierarchyPointers, function(address) {
                        return !!address;
                    }, categoryIndex));
                    var hierarchyAddress = hierarchyPointers[categoryIndex];
                    return {
                        value: values[categoryIndex],
                        selected: !1,
                        categoryIndex: null !== (_a = null == hierarchyAddress ? void 0 : hierarchyAddress.categoryIndex) && void 0 !== _a ? _a : categoryIndex,
                        adjustedCategoryIndex: adjustedIndex,
                        seriesIndex: null !== (_b = null == hierarchyAddress ? void 0 : hierarchyAddress.seriesIndex) && void 0 !== _b ? _b : 0,
                        identity: categoryIdentities[categoryIndex] ? categoryIdentities[categoryIndex]() : void 0
                    };
                }), tickDataIndex = 0, i = 0, numCategories = categoryIdentities.length; i < numCategories; i++) {
                    var tickDataItem = tickData[tickDataIndex];
                    if ((null == tickDataItem ? void 0 : tickDataItem.categoryIndex) === i) tickDataItem.value !== axisHelper.Pt && this.categoryDataPoints.push(tickDataItem), 
                    tickDataIndex++; else {
                        var hierarchyAddress = hierarchyPointers[i];
                        isStack && !hierarchyAddress || this.categoryDataPoints.push({
                            value: void 0,
                            categoryIndex: hierarchyAddress ? hierarchyAddress.categoryIndex : i,
                            seriesIndex: hierarchyAddress ? hierarchyAddress.seriesIndex : 0,
                            selected: !1,
                            identity: void 0
                        });
                    }
                }
                graphicsElement.selectAll(".tick").data(tickData, function(d) {
                    var _a, _b, _c, _d;
                    return null !== (_d = null !== (_b = null === (_a = d.adjustedCategoryIndex) || void 0 === _a ? void 0 : _a.toString()) && void 0 !== _b ? _b : null === (_c = d.categoryIndex) || void 0 === _c ? void 0 : _c.toString()) && void 0 !== _d ? _d : d.toString();
                }).select("text").each(function(d) {
                    d.value !== axisHelper.Pt && d3.select(this).attr("tabindex", 0).attr("focusable", !0).attr("role", "option").attr("aria-selected", function(dataPoint) {
                        return dataPoint.selected;
                    }).attr("data-automation-type", "axis-tick-text").classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()).selectAll("tspan").datum(d);
                });
            }, SvgCartesianAxes.prototype.removeFocusAbility = function(y1AxisGraphicsElement) {
                y1AxisGraphicsElement.attr("tabindex", null).attr("focusable", null);
            }, SvgCartesianAxes.prototype.getAxisData = function(location) {
                return 0 === location ? this.axesData.x : 1 === location ? this.axesData.y : this.axesData.y2;
            }, SvgCartesianAxes.getAxisProps = function(options) {
                var _a, axes = options.axesLayout.axes;
                return null !== (_a = options.axisProps) && void 0 !== _a ? _a : 0 === options.location ? axes.x : 1 === options.location ? axes.y1 : axes.y2;
            }, SvgCartesianAxes.prototype.getGraphicsElement = function(options) {
                var _a, location = options.location;
                return null !== (_a = options.graphicsElement) && void 0 !== _a ? _a : 0 === location ? this.xAxisGraphicsContext : 1 === location ? this.y1AxisGraphicsContext : this.y2AxisGraphicsContext;
            }, SvgCartesianAxes.getAxisTickLabelFontProperties = function(options) {
                var location = options.location, axesFontProperties = options.axesFontProperties;
                return (0 === location ? axesFontProperties.x : 1 === location ? axesFontProperties.y : axesFontProperties.y2).tickLabels;
            }, SvgCartesianAxes.prototype.getAxisRenderMode = function(options) {
                var location = options.location, shouldRenderAxis = options.axesLayout.shouldRenderAxis;
                return SvgCartesianAxes.getAxisProps(options) ? options.shouldRenderGridLinesOnly && options.gridlineOptions.strokeShow ? 2 : (0 === location ? shouldRenderAxis.x : 1 === location ? shouldRenderAxis.y : shouldRenderAxis.y2) ? 1 : 0 : 0;
            }, SvgCartesianAxes.prototype.convertAxisValuesToSubSelectable = function(options) {
                var subSelectableRegionAttribute = 0 === options.location ? "x-axis-values" : 1 === options.location ? "y1-axis-values" : "y2-axis-values", axisValueSelections = this.getGraphicsElement(options).selectAll(SvgCartesianAxes.TickTextSelector).filter(function() {
                    return "visible" === d3.select(this).style("visibility");
                }), axisValueElements = axisValueSelections.nodes();
                _.isEmpty(axisValueElements) || (axisValueSelections.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, subSelectableRegionAttribute).attr(htmlSubSelectionHelper.CK, "Role_DisplayName_Values").attr(htmlSubSelectionHelper.QZ, 2), 
                axisValueElements.forEach(function(element) {
                    return htmlSubSelectionHelper.O5.setDataForElement(element, {
                        getRegionOutlines: function() {
                            return SvgCartesianAxes.getAxisValuesOutlines(axisValueElements, subSelectableRegionAttribute, options.multipleId);
                        }
                    });
                }));
            }, SvgCartesianAxes.getAxisValuesOutlines = function(axisValueElements, subSelectableRegionAttribute, multipleId) {
                for (var _a, minX = Number.MAX_SAFE_INTEGER, minY = Number.MAX_SAFE_INTEGER, maxBottom = Number.MIN_SAFE_INTEGER, maxRight = Number.MIN_SAFE_INTEGER, _i = 0, axisValueElements_1 = axisValueElements; _i < axisValueElements_1.length; _i++) {
                    var x = (_a = axisValueElements_1[_i].getBoundingClientRect()).x, y = _a.y, bottom = _a.bottom, right = _a.right;
                    minX = Math.min(minX, x), minY = Math.min(minY, y), maxBottom = Math.max(maxBottom, bottom), 
                    maxRight = Math.max(maxRight, right);
                }
                return [ {
                    id: "".concat(subSelectableRegionAttribute).concat(null != multipleId ? multipleId : ""),
                    outline: {
                        x: minX,
                        y: minY,
                        width: maxRight - minX,
                        height: maxBottom - minY,
                        type: 1
                    }
                } ];
            }, SvgCartesianAxes.prototype.renderAxes = function(options) {
                var _a, _b, _c, _d;
                debug.fF.assertValue(options.axesLayout, "axesLayout");
                var defaultOrSmaller, height, axesLayout = options.axesLayout, axesFontProperties = options.axesFontProperties, axes = axesLayout.axes, hasHierarchicalStacked = !_.isEmpty((0, 
                cartesianAxisHelper.getHierStack)(axes));
                this.categoryDataPoints = [], this.categoryAxisGraphicsContext = void 0, debug.fF.assert(function() {
                    return null != axes.x;
                }, "axes.x must be defined."), this.renderAxis((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    location: 0,
                    height: (defaultOrSmaller = axesFontProperties.x.tickLabels.size.pt <= cartesianHelper.rZ, 
                    height = defaultOrSmaller ? axesLayout.marginLimits.bottom : axesLayout.margin.bottom, 
                    defaultOrSmaller || null == axesLayout.axisLabels.x ? height : height - (textMeasurementService.b.estimateSvgTextHeight((0, 
                    common_fontProperties.qk)(axesFontProperties.x.tickLabels)) + CartesianAxes.XAxisLabelPadding)),
                    gridlineOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, null === (_a = this.axesData) || void 0 === _a ? void 0 : _a.x.gridline), {
                        strokeShow: (!(0, axisHelper._9)(axes.x.scale) || axes.x.isCategoryAxis && hasHierarchicalStacked) && (null === (_b = this.axesData) || void 0 === _b ? void 0 : _b.x.gridline.strokeShow)
                    })
                }));
                var yGridlineOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, null === (_c = this.axesData) || void 0 === _c ? void 0 : _c.y.gridline), {
                    strokeShow: (!(0, axisHelper._9)(axes.y1.scale) || axes.y1.isCategoryAxis && hasHierarchicalStacked) && (null === (_d = this.axesData) || void 0 === _d ? void 0 : _d.y.gridline.strokeShow)
                });
                if (this.renderAxis((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    location: 1,
                    gridlineOptions: yGridlineOptions
                })), this.renderAxis((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    location: 2,
                    gridlineOptions: yGridlineOptions
                })), this.renderAxesTitles(options), this.valueGridlines = this.axisGraphicsContext.selectAll("g.tick line"), 
                this.translateAxes(axesLayout), this.axes.interactivityService && this.categoryAxisGraphicsContext) return {
                    dataPoints: this.categoryDataPoints,
                    behaviorOptions: {
                        root: this.categoryAxisGraphicsContext,
                        ticks: this.categoryAxisGraphicsContext.selectAll(".tick")
                    },
                    navigationOptions: {
                        helper: this,
                        navigationStrategy: hasHierarchicalStacked ? services_interactivityService.jN.SeriesFirst : services_interactivityService.jN.CategoryOnly
                    },
                    animateLabels: !1,
                    labelDataPointGroups: [],
                    labelDataPoints: [],
                    labelOrientation: void 0,
                    labelsAreNumeric: void 0,
                    labelDataPointSeriesGroups: []
                };
            }, SvgCartesianAxes.prototype.renderInteractivityGridline = function(options) {
                var location = options.location, multipleId = options.multipleId, gridlineOptions = options.gridlineOptions, axisGraphicsContext = this.getGraphicsElement(options), subSelectableObjectName = 0 === location ? "vertical-gridlines" : 1 === location ? "horizontal-gridlines" : "secondary-horizontal-gridlines", isHorizontal = "vertical-gridlines" !== subSelectableObjectName, tickLines = axisGraphicsContext.selectAll("g.tick line:not(".concat(SvgCartesianAxes.InteractivityGridlineClassSelector.selector, ")"));
                tickLines.each(function() {
                    var _a, tick = d3.select(this.parentNode), line = d3.select(this), lineElement = line.node(), height = (_a = lineElement.getBoundingClientRect()).height, showInteractivityGridline = gridlineOptions.strokeShow && (isHorizontal && _a.width > 0 || !isHorizontal && height > 0);
                    tick.selectAll(SvgCartesianAxes.InteractivityGridlineClassSelector.selector).filter(function(d) {
                        return d === lineElement;
                    }).data(function() {
                        return showInteractivityGridline ? [ lineElement ] : [];
                    }).join("line").attr("class", SvgCartesianAxes.InteractivityGridlineClassSelector.class).classed(htmlSubSelectionHelper.cy, !0).style("stroke-width", SvgCartesianAxes.interactivityGridlinePadding).style("stroke-linejoin", strokeLineJoin.t.round).style("stroke-dasharray", "none").attrs({
                        x1: line.attr("x1"),
                        y1: line.attr("y1"),
                        x2: line.attr("x2"),
                        y2: line.attr("y2")
                    }).attr(htmlSubSelectionHelper.Ez, subSelectableObjectName).attr(htmlSubSelectionHelper.CK, isHorizontal ? "Visual_Gridline_Horizontal" : "Visual_Gridline_Vertical").attr(htmlSubSelectionHelper.QZ, 3).each(function() {
                        htmlSubSelectionHelper.O5.setDataForElement(this, {
                            getRegionOutlines: function() {
                                var lines = tickLines.nodes();
                                return SvgCartesianAxes.getGridlinesOutlines(lines, subSelectableObjectName, multipleId);
                            }
                        });
                    });
                });
            }, SvgCartesianAxes.prototype.getFirstElement = function() {
                var _a;
                return {
                    element: null === (_a = this.categoryAxisGraphicsContext) || void 0 === _a ? void 0 : _a.selectAll(SvgCartesianAxes.TickTextSelector).node()
                };
            }, SvgCartesianAxes.prototype.getDataPointsAtSeries = function(seriesIndex) {
                return _.filter(this.categoryDataPoints, function(point) {
                    return point.seriesIndex === seriesIndex;
                });
            }, SvgCartesianAxes.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var _a, _b;
                if (_.isEmpty(this.categoryDataPoints)) return {
                    element: this.categoryAxisGraphicsContext.select(SvgCartesianAxes.TickTextSelector).node(),
                    targetCategoryIndex: 0
                };
                switch (direction) {
                  case services_interactivityService.x0.PreviousCategory:
                  case services_interactivityService.x0.NextCategory:
                    var indexModifier = direction === services_interactivityService.x0.PreviousCategory ? -1 : 1, currentGroupPointData = this.getDataPointsAtSeries(seriesIndex), indexNextCategory = indexModifier + _.findIndex(currentGroupPointData, function(point) {
                        return point.categoryIndex === categoryIndex;
                    });
                    indexNextCategory >= currentGroupPointData.length || indexNextCategory < 0 ? (_a = this.rollToNextSeries(seriesIndex, direction), 
                    categoryIndex = _a[0], seriesIndex = _a[1]) : categoryIndex = currentGroupPointData[indexNextCategory].categoryIndex;
                    break;

                  case services_interactivityService.x0.PreviousSeries:
                  case services_interactivityService.x0.NextSeries:
                    indexModifier = direction === services_interactivityService.x0.PreviousSeries ? -1 : 1, 
                    currentGroupPointData = _.filter(this.categoryDataPoints, function(point) {
                        return point.categoryIndex === categoryIndex;
                    });
                    var indexNextSeries = indexModifier + _.findIndex(currentGroupPointData, function(point) {
                        return point.seriesIndex === seriesIndex;
                    });
                    indexNextSeries >= currentGroupPointData.length || indexNextSeries < 0 ? (_b = this.findNearestSeries(categoryIndex, seriesIndex, direction), 
                    categoryIndex = _b[0], seriesIndex = _b[1]) : seriesIndex = currentGroupPointData[indexNextSeries].seriesIndex;
                }
                return {
                    element: this.categoryAxisGraphicsContext.selectAll(SvgCartesianAxes.TickTextSelector).filter(function(d) {
                        return (!d.adjustedCategoryIndex || d.adjustedCategoryIndex === d.categoryIndex) && d.categoryIndex === categoryIndex && d.seriesIndex === seriesIndex;
                    }).node(),
                    targetCategoryIndex: categoryIndex
                };
            }, SvgCartesianAxes.getGridlinesOutlines = function(gridlineElements, objectName, multipleId) {
                var groupOutline = {
                    type: 0,
                    outlines: gridlineElements.map(function(el) {
                        var gridlineRect = el.getBoundingClientRect(), x = gridlineRect.x, y = gridlineRect.y;
                        return {
                            points: [ {
                                x,
                                y
                            }, {
                                x: x + gridlineRect.width,
                                y: y + gridlineRect.height
                            } ],
                            type: 2
                        };
                    })
                };
                return [ {
                    id: multipleId ? "".concat(objectName).concat(multipleId) : objectName,
                    outline: groupOutline
                } ];
            }, SvgCartesianAxes.prototype.rollToNextSeries = function(seriesIndex, direction) {
                debug.fF.assert(function() {
                    return direction === services_interactivityService.x0.PreviousCategory || direction === services_interactivityService.x0.NextCategory;
                }, "expected a direction having to do with category");
                var indexModifier = direction === services_interactivityService.x0.PreviousCategory ? -1 : 1, findFunc = direction === services_interactivityService.x0.PreviousCategory ? _.last : _.first, numSeries = _.maxBy(this.categoryDataPoints, function(d) {
                    return d.seriesIndex;
                }).seriesIndex + 1;
                return (seriesIndex += indexModifier) >= numSeries ? seriesIndex = 0 : seriesIndex < 0 && (seriesIndex = numSeries - 1), 
                [ findFunc(this.getDataPointsAtSeries(seriesIndex)).categoryIndex, seriesIndex ];
            }, SvgCartesianAxes.prototype.findNearestSeries = function(categoryIndex, seriesIndex, direction) {
                debug.fF.assert(function() {
                    return direction === services_interactivityService.x0.PreviousSeries || direction === services_interactivityService.x0.NextSeries;
                }, "expected a direction having to do with series");
                var numSeries = _.maxBy(this.categoryDataPoints, function(d) {
                    return d.seriesIndex;
                }).seriesIndex + 1;
                (seriesIndex += direction === services_interactivityService.x0.PreviousSeries ? -1 : 1) >= numSeries && (seriesIndex = 0), 
                seriesIndex < 0 && (seriesIndex = numSeries - 1);
                var nextSeriesPoints = this.getDataPointsAtSeries(seriesIndex), indexNextCategory = _.sortedLastIndexBy(nextSeriesPoints, {
                    categoryIndex
                }, function(point) {
                    return point.categoryIndex;
                }) - 1;
                return debug.fF.assertValue(categoryIndex = nextSeriesPoints[indexNextCategory].categoryIndex, "sortedLastIndexBy failed"), 
                [ categoryIndex, seriesIndex ];
            }, SvgCartesianAxes.prototype.renderAxesTitles = function(options) {
                var _a, _this = this;
                this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                var axesFontProperties = options.axesFontProperties, axisLabels = (_a = options.axesLayout).axisLabels, viewport = _a.viewport, margin = _a.margin, axes = _a.axes;
                if (debug.fF.assertValue(viewport, "viewport"), debug.fF.assertValue(axisLabels, "axisLabels"), 
                (null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2) && !options.shouldRenderGridLinesOnly) {
                    var plotAreaWidth = viewport.width - (margin.left + margin.right), viewportBottom = viewport.height - margin.top, showY1OnRight = this.axes.shouldShowY1OnRight(), renderAxisTitle = function(location) {
                        var _a, _b, _c, _d, _e, _f, _g, _h, isX = 0 === location, isY1 = 1 === location, isY2 = 2 === location, titleText = isX ? axisLabels.x : isY1 ? axisLabels.y : axisLabels.y2, titleFontProperties = null === (_a = isX ? axesFontProperties.x : isY1 ? axesFontProperties.y : axesFontProperties.y2) || void 0 === _a ? void 0 : _a.title;
                        if (null != titleText && titleFontProperties) {
                            var isPlaceholder, directEdit;
                            if (null === (_b = _this.featureSwitches) || void 0 === _b ? void 0 : _b.onObject) {
                                var formattingId = isY2 ? cartesian_capabilities.p.valueAxis.secTitleText : isX && axes.x.isCategoryAxis || isY1 && (null === (_c = axes.y1) || void 0 === _c ? void 0 : _c.isCategoryAxis) ? cartesian_capabilities.p.categoryAxis.titleText : cartesian_capabilities.p.valueAxis.titleText;
                                (directEdit = isX ? (0, onObjectUtil.s4)(formattingId, titleText) : (0, onObjectUtil.Mw)(formattingId, titleText)) && !titleText && options.showTitlePlaceholders && (isPlaceholder = !0, 
                                titleText = _this.settings.hostServices.getLocalizedString("Format_AddAxisTitle"));
                            }
                            if (titleText || !isY2) {
                                var axisTextProperties = (0, common_fontProperties.qk)(titleFontProperties, titleText), baselineDelta = textMeasurementService.b.estimateSvgTextBaselineDelta(axisTextProperties), textHeight = textMeasurementService.b.estimateSvgTextHeight(axisTextProperties), yRightSide = plotAreaWidth + margin.right - textHeight - CartesianAxes.YAxisLabelPadding + 3, yLeftSide = -(margin.left + 3);
                                _this.axisGraphicsContext.append("text").attr("class", isX ? "xAxisLabel" : "yAxisLabel").attr("transform", isX ? null : "rotate(-90)").attr("dy", isX ? null : "1em").attr("x", isX ? plotAreaWidth / 2 : -(viewportBottom - margin.bottom) / 2).attr("y", isX ? viewportBottom - baselineDelta : isY1 ? showY1OnRight ? yRightSide : yLeftSide : showY1OnRight ? yLeftSide : yRightSide).style("text-anchor", "middle").styles((0, 
                                common_fontProperties.E_)(titleFontProperties)).style("fill", null !== (_h = null === (_g = isX ? null === (_d = _this.axesData) || void 0 === _d ? void 0 : _d.x : isY1 ? null === (_e = _this.axesData) || void 0 === _e ? void 0 : _e.y : null === (_f = _this.axesData) || void 0 === _f ? void 0 : _f.y2) || void 0 === _g ? void 0 : _g.titleFontProperties.color) && void 0 !== _h ? _h : null).text(titleText).call(axisHelper.oq, isX ? plotAreaWidth : viewportBottom - margin.bottom, function(textElement, maxWidth) {
                                    return textMeasurementService.b.svgEllipsis(textElement, maxWidth, axisTextProperties);
                                }).call(tooltipUtils.Q, [ titleText ]).filter(function() {
                                    var _a;
                                    return null === (_a = _this.featureSwitches) || void 0 === _a ? void 0 : _a.onObject;
                                }).classed(htmlSubSelectionHelper.cy, !0).classed(htmlSubSelectionHelper.Qh.class, isPlaceholder).attr(htmlSubSelectionHelper.Ez, isX ? "x-axis-title" : isY1 ? "y1-axis-title" : "y2-axis-title").attr(htmlSubSelectionHelper.CK, "Visual_Axis_Title").attr(htmlSubSelectionHelper.QZ, 1).filter(function() {
                                    return Boolean(directEdit);
                                }).attr(htmlSubSelectionHelper.kv, JSON.stringify(directEdit));
                            }
                        }
                    };
                    renderAxisTitle(0), renderAxisTitle(1), renderAxisTitle(2);
                }
            }, SvgCartesianAxes.prototype.translateAxes = function(axesLayout) {
                var _a, _this = this, margin = axesLayout.margin, width = (_a = getAvailableViewport(axesLayout)).width, height = _a.height, seriesLabelWidth = this.axesData.showsSeriesLabels() ? (0, 
                seriesLabelViewModel.lr)(this.axesData.seriesLabelSettings, width) : 0, seriesOnRight = this.axesData.seriesLabelSettings.position === labelPosition2.M.right, seriesLabelContainerOffsetX = seriesOnRight ? margin.left : margin.left + seriesLabelWidth, scrollOffsetX = seriesOnRight ? 0 : seriesLabelWidth, showY1OnRight = this.axes.shouldShowY1OnRight();
                this.xAxisGraphicsContext.attr("transform", (0, svgUtil.Iu)(0, height)), this.y1AxisGraphicsContext.attr("transform", (0, 
                svgUtil.Iu)(showY1OnRight ? width : 0, 0)), this.y2AxisGraphicsContext.attr("transform", (0, 
                svgUtil.Iu)(showY1OnRight ? 0 : width, 0)), this.svgScrollable.attrs({
                    x: 0,
                    width: axesLayout.viewport.width,
                    height: axesLayout.viewport.height
                }), this.axisGraphicsContext.attr("transform", (0, svgUtil.Iu)(margin.left, margin.top));
                var applyTransform = function(x) {
                    _this.axisGraphicsContextScrollable.attr("transform", (0, svgUtil.Iu)(x, margin.top)), 
                    _this.labelRegion.attr("transform", (0, svgUtil.Iu)(x, margin.top)), _this.labelContainerRegion.attr("transform", (0, 
                    svgUtil.Iu)(x, margin.top)), _this.labelBackgroundRegion.attr("transform", (0, svgUtil.Iu)(x, margin.top)), 
                    _this.labelSeriesRegion.attr("transform", (0, svgUtil.Iu)(x, margin.top)), _this.labelSeriesBackgroundRegion.attr("transform", (0, 
                    svgUtil.Iu)(x, margin.top));
                };
                applyTransform(seriesLabelContainerOffsetX), axesLayout.isXScrollBarVisible ? (this.svgScrollable.attrs({
                    x: margin.left,
                    width
                }), applyTransform(scrollOffsetX)) : axesLayout.isYScrollBarVisible && this.svgScrollable.attr("height", height + margin.top), 
                this.valueGridlines.attr("transform", "translate(".concat(seriesOnRight ? showY1OnRight ? -seriesLabelWidth : 0 : showY1OnRight ? 0 : seriesLabelWidth, ")"));
            }, SvgCartesianAxes.centerHierarchyTicks = function(g, axisProps) {
                g.selectAll("g.tick").filter(function(d) {
                    return axisProps.adjustedValues[d] !== axisHelper.Pt;
                }).each(function(datum) {
                    var tick = d3.select(this), currentTransform = tick.attr("transform"), parsedTranslate = (0, 
                    svgUtil.nd)(currentTransform);
                    parsedTranslate && +parsedTranslate.x > 0 && tick.attr("transform", (0, svgUtil.Iu)(+parsedTranslate.x + axisProps.categoryLabelMaxWidths[datum] / 2 - axisProps.categoryThickness / 2 + cartesianHelper.Fv, +parsedTranslate.y)), 
                    parsedTranslate && +parsedTranslate.y > 0 && tick.attr("transform", (0, svgUtil.Iu)(+parsedTranslate.x, +parsedTranslate.y + axisProps.categoryLabelMaxWidths[datum] / 2 - axisProps.categoryThickness / 2 + cartesianHelper.Fv));
                });
            }, SvgCartesianAxes.xAxisWordBreak = function(xAxisTextNodes, options) {
                var _y = null;
                xAxisTextNodes.style("text-anchor", "middle").attrs({
                    dx: null,
                    dy: null,
                    transform: "rotate(0)",
                    y: function() {
                        if (null == _y) {
                            var properties = textMeasurementService.b.getSvgMeasurementProperties(this), fontHeight = textMeasurementService.b.estimateSvgTextHeight(properties), baselineDelta = textMeasurementService.b.estimateSvgTextBaselineDelta(properties);
                            _y = 10 + fontHeight - baselineDelta;
                        }
                        return "".concat(_y, "px");
                    }
                }).each(function(datum) {
                    (0, textUtil.lM)(this, (0, cartesianAxisHelper.getMaxWidth)(SvgCartesianAxes.getAxisProps(options), datum), options.height);
                });
            }, SvgCartesianAxes.orient = function(context, axis, orientation) {
                return delete context.node().__axis, (0, cartesianAxisHelper.axisFactory)(axis.scale(), axisHelper.Or[orientation]).tickArguments(axis.tickArguments()).tickValues(axis.tickValues()).tickFormat(axis.tickFormat()).tickSize(axis.tickSize()).tickSizeInner(axis.tickSizeInner()).tickSizeOuter(axis.tickSizeOuter()).tickPadding(axis.tickPadding());
            }, SvgCartesianAxes.styleHierarchyTicks = function(hierAxisContext, axisProps, gridlineOptions) {
                hierAxisContext.selectAll("g.tick").filter(function(d) {
                    return axisProps.adjustedValues[d] !== axisHelper.Pt;
                }).selectAll("line").data(function(d) {
                    return axisProps.lineStyleInfo[d];
                }).join(function(enter) {
                    return enter.append("line");
                }).attrs({
                    x1: function(line) {
                        return line.x1;
                    },
                    y1: function(line) {
                        return line.y1;
                    },
                    x2: function(line) {
                        return line.x2;
                    },
                    y2: function(line) {
                        return line.y2;
                    }
                }).styles((0, common_strokeStyle.bc)(gridlineOptions));
            }, SvgCartesianAxes.AxisGraphicsContext = (0, CssConstants.CH)("axisGraphicsContext"), 
            SvgCartesianAxes.HierarchicalStackCS = (0, CssConstants.CH)("stack"), SvgCartesianAxes.InteractivityGridlineClassSelector = (0, 
            CssConstants.CH)("interactivity-gridline"), SvgCartesianAxes.TickTextSelector = "g.tick > text", 
            SvgCartesianAxes.interactivityGridlinePadding = 10, SvgCartesianAxes.TickPaddingRotatedX = 5, 
            SvgCartesianAxes.Y2TickSize = -6, SvgCartesianAxes;
        }(), CartesianChartNavigationHelper = function() {
            function CartesianChartNavigationHelper() {
                this.navigationLayers = [], this.currentNavigationLayerIndex = 0;
            }
            return CartesianChartNavigationHelper.prototype.updateScrollCallbacks = function(scrollCallbacks) {
                this.scrollCallbacks = scrollCallbacks;
            }, CartesianChartNavigationHelper.prototype.clearNavigationLayers = function() {
                this.navigationLayers = [];
            }, CartesianChartNavigationHelper.prototype.addNavigationLayer = function(navigation) {
                this.navigationLayers.push(navigation);
            }, CartesianChartNavigationHelper.prototype.getFirstElement = function() {
                this.currentNavigationLayerIndex = 0;
                var element, firstElementInfo = this.navigationLayers[this.currentNavigationLayerIndex].getFirstElement();
                return firstElementInfo && (element = firstElementInfo.element ? firstElementInfo.element : this.getNextDataPoint(firstElementInfo.targetCategoryIndex, firstElementInfo.targetSeriesIndex, services_interactivityService.x0.NextSeries).element), 
                {
                    element
                };
            }, CartesianChartNavigationHelper.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var layerPointInfo = this.composeLayerPointInfo(categoryIndex, seriesIndex);
                return this.getNextDataPointWithStartData(layerPointInfo, direction, layerPointInfo);
            }, CartesianChartNavigationHelper.prototype.getNextDataPointWithStartData = function(currentLayerPointInfo, direction, startLayerPointInfo) {
                var _this = this, categoryIndex = currentLayerPointInfo.categoryIndex, seriesIndex = currentLayerPointInfo.seriesIndex, currentLayer = this.navigationLayers[this.currentNavigationLayerIndex], nextPoint = currentLayer.getNextDataPoint(categoryIndex, seriesIndex, direction), targetCategoryIndex = nextPoint.targetCategoryIndex, forward = direction === services_interactivityService.x0.NextSeries || direction === services_interactivityService.x0.NextCategory, numLayers = this.navigationLayers.length;
                if (numLayers > 1 && nextPoint.targetCategoryIndex !== categoryIndex) {
                    var currentCategoryIndex = categoryIndex, layerRollover = 0, layerIndexModifier = forward ? 1 : -1;
                    do {
                        switch (direction) {
                          case services_interactivityService.x0.NextSeries:
                          case services_interactivityService.x0.PreviousSeries:
                            this.currentNavigationLayerIndex += layerIndexModifier, this.layerRollOverCheck(this.currentNavigationLayerIndex, numLayers) ? (this.currentNavigationLayerIndex = this.currentNavigationLayerIndex < 0 ? numLayers - 1 : 0, 
                            nextPoint = (currentLayer = this.navigationLayers[this.currentNavigationLayerIndex]).getFirstElement(targetCategoryIndex, !forward), 
                            _.isFinite(nextPoint.targetCategoryIndex) && (targetCategoryIndex = nextPoint.targetCategoryIndex), 
                            currentCategoryIndex = targetCategoryIndex, layerRollover++) : nextPoint = (currentLayer = this.navigationLayers[this.currentNavigationLayerIndex]).getFirstElement(currentCategoryIndex, !forward);
                            break;

                          case services_interactivityService.x0.NextCategory:
                          case services_interactivityService.x0.PreviousCategory:
                            layerRollover = numLayers;
                            break;

                          default:
                            debug.fF.assertNever(direction);
                        }
                    } while (!nextPoint.element && layerRollover < numLayers && (!this.layerRollOverCheck(this.currentNavigationLayerIndex + layerIndexModifier, numLayers) || layerRollover < numLayers - 1));
                }
                if (!nextPoint.element && null != targetCategoryIndex && this.shouldScroll(targetCategoryIndex)) {
                    this.getPendingFocusElement = function() {
                        if (_this.getPendingFocusElement = void 0, direction === services_interactivityService.x0.NextSeries ? _this.currentNavigationLayerIndex = 0 : direction === services_interactivityService.x0.PreviousSeries && (_this.currentNavigationLayerIndex = numLayers - 1), 
                        !(nextPoint = (currentLayer = _this.navigationLayers[_this.currentNavigationLayerIndex]).getNextDataPoint(categoryIndex, seriesIndex, direction)).element) {
                            var endLayerIndex = _this.currentNavigationLayerIndex;
                            do {
                                _this.currentNavigationLayerIndex++, _this.currentNavigationLayerIndex >= _this.navigationLayers.length && (_this.currentNavigationLayerIndex = 0), 
                                nextPoint = _this.navigationLayers[_this.currentNavigationLayerIndex].getNextDataPoint(categoryIndex, seriesIndex, direction);
                            } while (!nextPoint.element && _this.currentNavigationLayerIndex !== endLayerIndex);
                        }
                        if (_this.shouldFindNextPoint(nextPoint, currentLayerPointInfo, startLayerPointInfo, forward)) {
                            var nextLayerPointInfo = _this.composeLayerPointInfo(nextPoint.targetCategoryIndex, nextPoint.targetSeriesIndex);
                            return _this.getNextDataPointWithStartData(nextLayerPointInfo, direction, startLayerPointInfo).element;
                        }
                        return nextPoint.element;
                    };
                    var stepsToScroll = targetCategoryIndex - categoryIndex;
                    stepsToScroll < 0 ? this.scrollCallbacks.scrollTo(targetCategoryIndex) : this.scrollCallbacks.scrollBy(stepsToScroll);
                } else if (this.shouldFindNextPoint(nextPoint, currentLayerPointInfo, startLayerPointInfo, forward)) {
                    var nextLayerPointInfo = this.composeLayerPointInfo(nextPoint.targetCategoryIndex, nextPoint.targetSeriesIndex);
                    return this.getNextDataPointWithStartData(nextLayerPointInfo, direction, startLayerPointInfo);
                }
                return nextPoint;
            }, CartesianChartNavigationHelper.prototype.shouldScroll = function(targetCategoryIndex) {
                return !!this.scrollCallbacks && this.scrollCallbacks.shouldScrollTo(targetCategoryIndex);
            }, CartesianChartNavigationHelper.prototype.layerRollOverCheck = function(navigationLayerIndex, numLayers) {
                return navigationLayerIndex >= numLayers || navigationLayerIndex < 0;
            }, CartesianChartNavigationHelper.prototype.composeLayerPointInfo = function(categoryIndex, seriesIndex) {
                return {
                    categoryIndex,
                    seriesIndex,
                    layerIndex: this.currentNavigationLayerIndex
                };
            }, CartesianChartNavigationHelper.prototype.shouldFindNextPoint = function(nextPoint, iterationStartLayerPointInfo, startLayerPointInfo, forward) {
                if ((!nextPoint.element || nextPoint.noShape) && null !== nextPoint.targetCategoryIndex && null !== nextPoint.targetSeriesIndex) {
                    var nextLayerPointInfo = this.composeLayerPointInfo(nextPoint.targetCategoryIndex, nextPoint.targetSeriesIndex);
                    switch (this.compareLayerPointInfo(startLayerPointInfo, nextLayerPointInfo, forward)) {
                      case 1:
                        if (this.compareLayerPointInfo(iterationStartLayerPointInfo, nextLayerPointInfo, forward) >= 0 && this.compareLayerPointInfo(startLayerPointInfo, iterationStartLayerPointInfo, forward) > 0) return !1;
                        break;

                      case 0:
                        return !1;

                      case -1:
                        if (this.compareLayerPointInfo(startLayerPointInfo, iterationStartLayerPointInfo, forward) > 0) return !1;
                        if (this.compareLayerPointInfo(iterationStartLayerPointInfo, nextLayerPointInfo, forward) >= 0) return !1;
                        break;

                      default:
                        debug.fF.assertFail("Unexpected result from compareLayerPointInfo");
                    }
                    return !0;
                }
                return !1;
            }, CartesianChartNavigationHelper.prototype.compareLayerPointInfo = function(firstInfo, secondInfo, forward) {
                return firstInfo.categoryIndex > secondInfo.categoryIndex ? forward ? 1 : -1 : firstInfo.categoryIndex < secondInfo.categoryIndex ? forward ? -1 : 1 : firstInfo.seriesIndex > secondInfo.seriesIndex ? forward ? 1 : -1 : firstInfo.seriesIndex < secondInfo.seriesIndex ? forward ? -1 : 1 : firstInfo.layerIndex > secondInfo.layerIndex ? forward ? 1 : -1 : firstInfo.layerIndex < secondInfo.layerIndex ? forward ? -1 : 1 : 0;
            }, CartesianChartNavigationHelper;
        }(), Utility = __webpack_require__(38078), ScrollableAxes = function() {
            function ScrollableAxes(options, scrollbar) {
                this.options = options, this.scrollbar = scrollbar;
            }
            return ScrollableAxes.filterDataToViewport = function(options) {
                var _a, scrollScale = (_a = options || {}).scrollScale, mainAxisScale = _a.mainAxisScale, layers = _a.layers, axesLayout = _a.axesLayout;
                if (options.scrollScale) {
                    var startIndex = (0, cartesianAxisHelper.invertOrdinalScale)(scrollScale, options.extent.start), endIndex = startIndex + options.visibleCategoryCount, selected = scrollScale.domain().slice(startIndex, endIndex);
                    if (!_.isEqual(selected, mainAxisScale.domain())) {
                        if (selected && selected.length > 0) {
                            for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) layers_1[_i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                            mainAxisScale.domain(selected);
                            var axisProperties = axesLayout.axes, axisPropsToUpdate = axesLayout.isXScrollBarVisible ? axisProperties.x : axisProperties.y1;
                            axisPropsToUpdate.d3Axis.scale(mainAxisScale), axisPropsToUpdate.scale(mainAxisScale), 
                            axisPropsToUpdate.d3Axis.ticks(selected.length), axisPropsToUpdate.d3Axis.tickValues(selected);
                            var tickFormat_1 = SvgCartesianAxes.getTickFormatter(axisPropsToUpdate.d3Axis);
                            axisPropsToUpdate.values = _.map(selected, function(d) {
                                return tickFormat_1(d);
                            });
                            var hierStack = (0, cartesianAxisHelper.getHierStack)(axisProperties);
                            if (!_.isEmpty(hierStack)) for (var orientation_1 = axisProperties.x.isCategoryAxis ? axisHelper.Or.bottom : axesLayout.axes.y1.orientation, leafHeight_1 = CartesianAxes.getLeafHeight(options.axesLayout.tickLabelMargins, orientation_1, hierStack.length), _loop_1 = function(stackIndex) {
                                var stack = hierStack[stackIndex], categoryWidth = (0, cartesianAxisHelper.getCategoryThickness)(stack.scale), stackValues = stack.values, adjustedSelected = ScrollableAxes.setLabelsAtEdges(selected, stackValues);
                                if (stack.d3Axis.ticks(selected.length).tickValues(selected).tickFormat(function(visibleItemIndex) {
                                    var tickValue = stackValues[adjustedSelected[selected.indexOf(visibleItemIndex)]];
                                    return tickValue === axisHelper.Pt ? "" : "".concat(tickValue);
                                }), 0 === stackIndex) return "continue";
                                for (var lastIndex, newMaxWidths = [], newStyleInfo = [], adjustedValues = [], updateNewWidthsAndStyleInfo = function(categorySpanCount) {
                                    null != lastIndex && (newMaxWidths[lastIndex] = CartesianAxes.getMaxCategoryWidth(categorySpanCount, categoryWidth), 
                                    newStyleInfo[lastIndex] = CartesianAxes.getHierarchyLineStyleInfo({
                                        levelIndex: stackIndex,
                                        stackHeight: axesLayout.tickLabelMargins.stackHeight,
                                        leafHeight: leafHeight_1,
                                        categorySpanCount,
                                        categoryWidth,
                                        orientation: orientation_1
                                    }));
                                }, currentIndex = 0; currentIndex < adjustedSelected.length; currentIndex++) {
                                    var categoryIndex = selected[currentIndex], valueIndex = adjustedSelected[currentIndex];
                                    stackValues[valueIndex] !== axisHelper.Pt ? (updateNewWidthsAndStyleInfo(categoryIndex - lastIndex), 
                                    adjustedValues[categoryIndex] = stackValues[valueIndex], lastIndex = categoryIndex) : adjustedValues[categoryIndex] = axisHelper.Pt;
                                }
                                null != lastIndex && updateNewWidthsAndStyleInfo(selected[adjustedSelected.length - 1] - lastIndex + 1), 
                                stack.categoryLabelMaxWidths = newMaxWidths, stack.lineStyleInfo = newStyleInfo, 
                                stack.adjustedValues = adjustedValues;
                            }, stackIndex = 0; stackIndex < hierStack.length; stackIndex++) _loop_1(stackIndex);
                        }
                        return {
                            startIndex,
                            endIndex: endIndex - 1
                        };
                    }
                }
            }, ScrollableAxes.prototype.destroy = function() {
                this.scrollbar.remove();
            }, ScrollableAxes.prototype.render = function(renderOptions, renderDelegate, preserveScrollPosition, categoryLoadMoreDataHandler, hasY2Role, formatMode, subSelectionHelper) {
                var _a, _b, _c, scrollbarX, scrollbarY, scrollbarLength, numVisibleCategories, categoryThickness, outerPaddingRatio, innerPaddingRatio, newAxisLength, _this = this, axesLayout = renderOptions.axesLayout, layers = renderOptions.layers;
                if (this.axisScale = null, categoryLoadMoreDataHandler || hasVisibleScrollbar(axesLayout)) if (this.options.axes.isYAxisCategorical) this.axisScale = axesLayout.axes.y1.scale, 
                scrollbarX = axesLayout.viewport.width, scrollbarY = axesLayout.margin.top, innerPaddingRatio = axesLayout.axes.y1.innerPaddingRatio, 
                outerPadding = (categoryThickness = axesLayout.axes.y1.categoryThickness) * (outerPaddingRatio = axesLayout.axes.y1.outerPaddingRatio), 
                newAxisLength = axesLayout.plotArea.height, numVisibleCategories = Math.max(1, (0, 
                Double.Uy)((newAxisLength - 2 * outerPadding) / categoryThickness)), scrollbarLength = newAxisLength; else {
                    this.axisScale = axesLayout.axes.x.scale, scrollbarX = axesLayout.margin.left;
                    var chartType = null === (_a = this.options.cartesianOptions) || void 0 === _a ? void 0 : _a.chartType, supportsSeriesLabels = !(0, 
                    cartesianHelper.LQ)(chartType) || hasY2Role, seriesLabelSettings = getSeriesLabelSettings(layers, chartType);
                    if (seriesLabelSettings.position === labelPosition2.M.left && supportsSeriesLabels) {
                        var width = getAvailableViewport(axesLayout).width;
                        scrollbarX += (0, seriesLabelViewModel.lr)(seriesLabelSettings, width);
                    }
                    scrollbarY = axesLayout.viewport.height, innerPaddingRatio = axesLayout.axes.x.innerPaddingRatio;
                    var outerPadding = (categoryThickness = axesLayout.axes.x.categoryThickness) * (outerPaddingRatio = axesLayout.axes.x.outerPaddingRatio);
                    newAxisLength = axesLayout.plotArea.width, numVisibleCategories = Math.max(1, (0, 
                    Double.Uy)((newAxisLength - 2 * outerPadding) / categoryThickness)), scrollbarLength = newAxisLength;
                }
                if (!hasVisibleScrollbar(axesLayout)) return categoryLoadMoreDataHandler && (categoryLoadMoreDataHandler.resetViewport(numVisibleCategories), 
                categoryLoadMoreDataHandler.shouldLoadMoreData() && categoryLoadMoreDataHandler.loadMoreData()), 
                this.scrollbar.remove(), void renderDelegate((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, renderOptions), {
                    cartesianOptions: this.options.cartesianOptions
                }));
                var scrollScale = this.axisScale.copy();
                scrollScale.range([ 0, scrollbarLength ]).paddingInner(.1).paddingOuter(0);
                var extentLength = scrollScale(numVisibleCategories - 1) + scrollScale.bandwidth();
                this.scrollHandler = new AxisScrollHandler({
                    visibleScale: this.axisScale,
                    fullScale: scrollScale,
                    onScroll: function(startIndex) {
                        var startPosition = scrollScale(startIndex);
                        _this.scrollbar.setExtent({
                            start: startPosition,
                            end: null
                        }), _this.scrollbar.refreshExtentAndVisual();
                    }
                }), this.axisScale.range([ 0, newAxisLength ]).paddingInner(innerPaddingRatio).paddingOuter(outerPaddingRatio), 
                this.scrollbar.setOrientation(axesLayout.isXScrollBarVisible), this.scrollbar.setScale(scrollScale, this.options.suppressBrush), 
                this.scrollbar.scrollBarLength = scrollbarLength, this.scrollbar.setExtentLength(extentLength), 
                preserveScrollPosition || this.scrollbar.setExtent({
                    start: 0,
                    end: null
                });
                var renderVisualOptions = {
                    axesLayout,
                    layers,
                    categoryLoadMoreDataHandler,
                    mainAxisScale: this.axisScale,
                    renderDelegate,
                    scrollScale,
                    visibleCategoryCount: numVisibleCategories,
                    cartesianOptions: this.options.cartesianOptions,
                    extent: this.scrollbar.getExtent()
                };
                this.scrollbar.render(scrollbarX, scrollbarY, function() {
                    ScrollableAxes.renderVisual((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, renderVisualOptions), {
                        suppressAnimations: !0,
                        extent: _this.scrollbar.getExtent()
                    })), null == subSelectionHelper || subSelectionHelper.addDirectEditPlaceholderOutlines(), 
                    null == subSelectionHelper || subSelectionHelper.refreshOutlines();
                }, formatMode, subSelectionHelper), preserveScrollPosition && categoryLoadMoreDataHandler ? this.scrollTo(null !== (_c = null === (_b = categoryLoadMoreDataHandler.viewportDataRange) || void 0 === _b ? void 0 : _b.startIndex) && void 0 !== _c ? _c : 0) : ScrollableAxes.renderVisual((0, 
                tslib_es6.__assign)((0, tslib_es6.__assign)({}, renderVisualOptions), {
                    extent: this.scrollbar.getExtent()
                }));
            }, ScrollableAxes.prototype.scrollDelta = function(delta) {
                this.scrollHandler.scrollDelta(delta);
            }, ScrollableAxes.prototype.scrollTo = function(index) {
                this.scrollHandler.scrollTo(index);
            }, ScrollableAxes.prototype.shouldScrollTo = function(index) {
                if (!this.scrollHandler) return !1;
                var domain = this.axisScale.domain();
                return !_.isEmpty(domain) && (index < domain[0] || index > domain[domain.length - 1]);
            }, ScrollableAxes.prototype.setExtent = function(extent) {
                this.scrollbar.setExtent(extent), this.scrollbar.refreshExtentAndVisual();
            }, ScrollableAxes.prototype.scrollBy = function(steps) {
                var domain = this.axisScale.domain();
                _.isEmpty(domain) || this.scrollHandler.scrollTo(domain[0] + steps);
            }, ScrollableAxes.prototype.clearRenderingTimeout = function() {
                this.scrollbar && this.scrollbar.clearRenderingTimeout();
            }, ScrollableAxes.setLabelsAtEdges = function(indices, stackedAxisValues) {
                if (indices.length <= 1 || stackedAxisValues[indices[0]] !== axisHelper.Pt) return indices;
                var firstIndex = indices[0], returnArr = indices.slice();
                if (firstIndex < stackedAxisValues.length && firstIndex >= 0) {
                    for (;stackedAxisValues[firstIndex] === axisHelper.Pt && firstIndex >= 0; firstIndex--) ;
                    returnArr[0] = firstIndex;
                }
                return returnArr;
            }, ScrollableAxes.renderVisual = function(options) {
                var dataRange = ScrollableAxes.filterDataToViewport(options);
                if (dataRange) {
                    if (options.categoryLoadMoreDataHandler) {
                        var categoryLoadMoreDataHandler = options.categoryLoadMoreDataHandler;
                        categoryLoadMoreDataHandler.viewportDataRange = dataRange, categoryLoadMoreDataHandler.shouldLoadMoreData() && categoryLoadMoreDataHandler.loadMoreData();
                    }
                    options.renderDelegate(options);
                }
            }, ScrollableAxes.ScrollbarWidth = 10, ScrollableAxes;
        }(), AxisScrollHandler = function() {
            function AxisScrollHandler(options) {
                debug.fF.assertValue(options, "options must be set"), debug.fF.assertValue(options.visibleScale, "options.visibleScale must be set"), 
                debug.fF.assertValue(options.fullScale, "options.fullScale must be set"), debug.fF.assertValue(options.onScroll, "options.onScroll must be set"), 
                this.visibleScale = options.visibleScale, this.fullScale = options.fullScale, this.onScroll = options.onScroll;
                var timeout = Utility.b$.valueOrDefault(options.timeout, AxisScrollHandler.defaultTimeoutMs);
                this.extendScrollTimeout = _.debounce(this.onTimeout, timeout), this.totalScrollDistance = 0;
            }
            return AxisScrollHandler.prototype.scrollDelta = function(delta) {
                if (!_.isEmpty(this.visibleScale.domain())) {
                    this.totalScrollDistance < 0 && delta > 0 || this.totalScrollDistance > 0 && delta < 0 ? this.totalScrollDistance = delta : this.totalScrollDistance += delta;
                    var stepSize = AxisScrollHandler.getStepSize(this.visibleScale);
                    if (Math.abs(this.totalScrollDistance) >= stepSize) {
                        this.extendScrollTimeout && this.extendScrollTimeout.cancel();
                        var newStartIndex = this.getNewStartIndex(this.totalScrollDistance);
                        this.scrollTo(newStartIndex), this.totalScrollDistance = 0;
                    } else this.extendScrollTimeout();
                }
            }, AxisScrollHandler.prototype.scrollTo = function(index) {
                var clampedIndex = this.clampIndex(index);
                this.onScroll(clampedIndex);
            }, AxisScrollHandler.getStepSize = function(scale) {
                var range = _.map(scale.domain(), scale);
                if (range.length > 1) return range[1] - range[0];
                var rangeExtent = scale.range();
                return rangeExtent[1] - rangeExtent[0];
            }, AxisScrollHandler.prototype.getNewStartIndex = function(scrollDistance) {
                var increasing = scrollDistance >= 0;
                scrollDistance = increasing ? scrollDistance : -scrollDistance;
                var visibleScale = this.visibleScale, range = _.map(visibleScale.domain(), visibleScale), domain = visibleScale.domain(), firstVisibleIndex = domain[0], newVisiblePosition = range[0] + scrollDistance;
                return (increasing ? 1 : -1) * (newVisiblePosition > visibleScale.range()[1] ? domain.length : (0, 
                cartesianAxisHelper.invertOrdinalScale)(visibleScale, newVisiblePosition) - firstVisibleIndex) + firstVisibleIndex;
            }, AxisScrollHandler.prototype.clampIndex = function(index) {
                var domain = this.fullScale.domain(), firstDataIndex = _.head(domain), lastDataIndex = _.last(domain);
                return Math.max(firstDataIndex, Math.min(lastDataIndex, index));
            }, AxisScrollHandler.prototype.onTimeout = function() {
                this.totalScrollDistance = 0;
            }, AxisScrollHandler.defaultTimeoutMs = 1e3, AxisScrollHandler;
        }(), CartesianAxesRenderer = function() {
            function CartesianAxesRenderer(settings) {
                this.settings = settings, this.svgAxes = new SvgCartesianAxes(settings), this.navigationHelper = new CartesianChartNavigationHelper;
            }
            return CartesianAxesRenderer.prototype.destroy = function() {
                var _a, _b;
                null === (_a = this.scrollableAxes) || void 0 === _a || _a.destroy(), null === (_b = this.svgScrollbar) || void 0 === _b || _b.remove(), 
                this.scrollableAxes = void 0, this.svgScrollbar = void 0;
            }, CartesianAxesRenderer.prototype.update = function(axesData, scrollbarOptions) {
                var _a;
                null === (_a = this.svgScrollbar) || void 0 === _a || _a.updateScrollbarOptions(scrollbarOptions), 
                this.svgAxes.update(axesData);
            }, CartesianAxesRenderer.prototype.render = function(axesData, axisZoom, layers, referenceLines, viewport, renderPlotArea, options, useManagedTabIndex, axesLayout) {
                var _this = this, _a = this.options = options, trimOrdinalDataOnOverflow = _a.trimOrdinalDataOnOverflow, categoryLoadMoreDataHandler = _a.categoryLoadMoreDataHandler, suppressAnimations = _a.suppressAnimations, isHierarchicalAxis = _a.isHierarchicalAxis, formatMode = _a.formatMode, isSelected = _a.isSelected, viewMode = _a.viewMode, subSelectionHelper = _a.subSelectionHelper, preserveScrollPosition = _a.preserveScrollPosition, navigationScrollCallbacks = _a.navigationScrollCallbacks, multipleId = this.options.multipleId || this.settings.multipleId;
                if (!axesLayout && ((axesLayout = build({
                    axesData,
                    rendererSettings: this.settings,
                    referenceLines,
                    layers,
                    viewport,
                    playAxesRect: _a.playAxesRect,
                    trimOrdinalDataOnOverflow,
                    axisZoom,
                    rotateXTickLabels90: void 0
                })).plotArea.width < 1 || axesLayout.plotArea.height < 1)) return axesLayout;
                if (!this.settings.suppressBrush || !(viewport.height < 1 || viewport.width < 1)) {
                    layers.forEach(function(layer, index) {
                        var _a, axisType;
                        0 !== index && axesLayout.axes.y2 ? axisType = 2 : (axisType = 1, 1 === layers.length && axesLayout.axes.y2 && (axisType |= 2)), 
                        null === (_a = layer.setAxesLayout) || void 0 === _a || _a.call(layer, {
                            layout: axesLayout,
                            trimOrdinalDataOnOverflow,
                            axisType
                        });
                    }), null == axisZoom || axisZoom.render({
                        axesLayout,
                        axesData,
                        showTitlePlaceholders: isSelected && 1 === viewMode
                    }), null == categoryLoadMoreDataHandler || categoryLoadMoreDataHandler.setScale((axesLayout.axes.x.isCategoryAxis ? axesLayout.axes.x : axesLayout.axes.y1).scale);
                    var renderAxes = function(renderOptions) {
                        return _this.renderAxes((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, renderOptions), {
                            isHierarchicalAxis
                        }), options.axesAnimationOptions, getAxesFontProperties(axesData), renderPlotArea, useManagedTabIndex, isSelected && 1 === viewMode, multipleId);
                    };
                    debug.fF.assert(function() {
                        return !_this.svgScrollbar && !_this.scrollableAxes || !(!_this.svgScrollbar || !_this.scrollableAxes);
                    }, "Expect `svgScrollbar` and `scrollableAxes` to have the same state");
                    var axisRenderOptions = {
                        axesLayout,
                        layers,
                        suppressAnimations,
                        isHierarchicalAxis
                    };
                    return options.supportsScrolling ? (this.svgScrollbar || (this.svgScrollbar = new svgScrollbar.x({
                        scrollbarWidth: ScrollableAxes.ScrollbarWidth,
                        onExtentUpdate: this.settings.onExtentUpdate
                    }), this.scrollableAxes = new ScrollableAxes(this.settings, this.svgScrollbar), 
                    this.svgScrollbar.init(this.settings.container)), this.scrollableAxes.render(axisRenderOptions, renderAxes, preserveScrollPosition, categoryLoadMoreDataHandler, axesData.hasY2Role, formatMode, subSelectionHelper)) : (this.destroy(), 
                    renderAxes((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axisRenderOptions), {
                        cartesianOptions: this.settings.cartesianOptions
                    }))), this.navigationHelper.updateScrollCallbacks(options.supportsScrolling ? navigationScrollCallbacks : void 0), 
                    this.eventsBoundForAxesLayout !== axesLayout && (this.bindScrollWheelEvents(axesLayout, this.settings.container, formatMode, subSelectionHelper), 
                    this.bindTouchEvents(axesLayout, this.settings.container, formatMode, subSelectionHelper), 
                    this.eventsBoundForAxesLayout = axesLayout), axesLayout;
                }
            }, CartesianAxesRenderer.prototype.renderAxes = function(renderOptions, axesAnimationOptions, axesFontProperties, renderPlotArea, useManagedTabIndex, showTitlePlaceholders, multipleId) {
                var _a, _b, result = this.svgAxes.renderAxes((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, renderOptions), {
                    axesAnimationOptions,
                    axesFontProperties,
                    shouldRenderGridLinesOnly: this.options.shouldRenderGridLinesOnly,
                    useManagedTabIndex,
                    showTitlePlaceholders,
                    multipleId
                }));
                if ((null == result ? void 0 : result.navigationOptions) && this.settings.behavior) {
                    this.navigationHelper.clearNavigationLayers(), this.navigationHelper.addNavigationLayer(result.navigationOptions.helper);
                    var interactivityServiceOptions = {
                        isAxis: !0,
                        navigationOptions: {
                            helper: this.navigationHelper,
                            navigationStrategy: result.navigationOptions.navigationStrategy,
                            focusElement: null === (_b = (_a = this.navigationHelper).getPendingFocusElement) || void 0 === _b ? void 0 : _b.call(_a)
                        },
                        pointSourceKey: "cartesian-axis".concat(this.settings.multipleId || ""),
                        isHierarchicalAxis: renderOptions.isHierarchicalAxis
                    };
                    this.settings.interactivityService.bind(result.dataPoints, this.settings.behavior, result.behaviorOptions, interactivityServiceOptions), 
                    this.settings.behavior.renderSelection(this.settings.interactivityService.hasSelection());
                }
                renderPlotArea(renderOptions);
            }, CartesianAxesRenderer.prototype.getLayerContainer = function() {
                return this.svgAxes.getScrollableRegion();
            }, CartesianAxesRenderer.prototype.getDataLabelContainers = function() {
                return this.svgAxes.getLabelsContainers();
            }, CartesianAxesRenderer.prototype.getLabelContainerRegion = function() {
                return this.svgAxes.getLabelContainerRegion();
            }, CartesianAxesRenderer.prototype.getSeriesLabelContainers = function() {
                return this.svgAxes.getSeriesLabelsContainers();
            }, CartesianAxesRenderer.prototype.setExtent = function(extent) {
                var _a;
                null === (_a = this.scrollableAxes) || void 0 === _a || _a.setExtent(extent);
            }, CartesianAxesRenderer.prototype.scrollDelta = function(delta) {
                var _a;
                null === (_a = this.scrollableAxes) || void 0 === _a || _a.scrollDelta(delta);
            }, CartesianAxesRenderer.prototype.scrollTo = function(position) {
                var _a;
                null === (_a = this.scrollableAxes) || void 0 === _a || _a.scrollTo(position);
            }, CartesianAxesRenderer.prototype.shouldScrollTo = function(position) {
                var _a;
                return null === (_a = this.scrollableAxes) || void 0 === _a ? void 0 : _a.shouldScrollTo(position);
            }, CartesianAxesRenderer.prototype.scrollBy = function(steps) {
                var _a;
                null === (_a = this.scrollableAxes) || void 0 === _a || _a.scrollBy(steps);
            }, CartesianAxesRenderer.prototype.clearRenderingTimeout = function() {
                var _a;
                null === (_a = this.scrollableAxes) || void 0 === _a || _a.clearRenderingTimeout();
            }, CartesianAxesRenderer.prototype.bindTouchEvents = function(axesLayout, chartAreaSvg, formatMode, subSelectionHelper) {
                var _this = this, previousTouchPosition = {
                    x: 0,
                    y: 0
                };
                this.settings.eventManager.on(chartAreaSvg.node(), "touchstart", function() {
                    if (0 === _this.options.viewMode && hasVisibleScrollbar(axesLayout)) {
                        var touch = d3.event.changedTouches[0];
                        previousTouchPosition.x = touch.pageX, previousTouchPosition.y = touch.pageY;
                    }
                }), this.settings.eventManager.on(chartAreaSvg.node(), "touchmove", function() {
                    var _a, _b, tooltips = null === (_a = _this.settings.hostServices) || void 0 === _a ? void 0 : _a.tooltips();
                    if (0 === _this.options.viewMode && hasVisibleScrollbar(axesLayout) && !(tooltips && tooltips.isTouchScreenOptimizedEnabled() && tooltips.visible())) {
                        formatMode && (null == subSelectionHelper || subSelectionHelper.onVisualScroll()), 
                        _this.settings.tooltipService.hide();
                        var touchEvent = d3.event, touch = touchEvent.changedTouches[0], delta = axesLayout.isXScrollBarVisible ? previousTouchPosition.x - touch.pageX : previousTouchPosition.y - touch.pageY;
                        _this.settings.onScroll ? _this.settings.onScroll(delta) : null === (_b = _this.scrollableAxes) || void 0 === _b || _b.scrollDelta(delta), 
                        previousTouchPosition.x = touch.pageX, previousTouchPosition.y = touch.pageY, touchEvent.preventDefault();
                    }
                });
            }, CartesianAxesRenderer.prototype.bindScrollWheelEvents = function(axesLayout, chartAreaSvg, formatMode, subSelectionHelper) {
                var _this = this;
                this.settings.eventManager.on(chartAreaSvg.node(), "wheel", function() {
                    var _a;
                    if (hasVisibleScrollbar(axesLayout)) {
                        formatMode && (null == subSelectionHelper || subSelectionHelper.onVisualScroll()), 
                        _this.settings.tooltipService.hide();
                        var wheelEvent = d3.event, dX = wheelEvent.deltaX, dY = wheelEvent.deltaY, delta = Math.abs(dX) > Math.abs(dY) ? dX : dY;
                        if (_this.settings.onScroll) {
                            if (_this.options.isSmallMultiples && !wheelEvent.shiftKey) return;
                            _this.settings.onScroll(delta);
                        } else null === (_a = _this.scrollableAxes) || void 0 === _a || _a.scrollDelta(delta);
                        wheelEvent.preventDefault();
                    }
                });
            }, CartesianAxesRenderer;
        }(), LabelsBehavior = __webpack_require__(58698), plotAreaLassoManager = __webpack_require__(11745), labelLayout1 = __webpack_require__(63972), labelOrientation = __webpack_require__(20624), dataLabelRendererEnhanced = __webpack_require__(5381), CartesianPlotAreaLayout = function() {
            function CartesianPlotAreaLayout(cartesianOptions, visibilityHelper, chartAreaSvg, axesRenderer, element, hostServices, behavior, interactivityService, clearCatcher, isSmallMultiples, initialViewportScale) {
                var _a;
                this.cartesianOptions = cartesianOptions, this.visibilityHelper = visibilityHelper, 
                this.chartAreaSvg = chartAreaSvg, this.axesRenderer = axesRenderer, this.element = element, 
                this.hostServices = hostServices, this.behavior = behavior, this.interactivityService = interactivityService, 
                this.clearCatcher = clearCatcher, this.initialViewportScale = initialViewportScale, 
                this.dataPointNavigationHelper = new CartesianChartNavigationHelper, (null === (_a = this.cartesianOptions) || void 0 === _a ? void 0 : _a.dataPointLassoSelect) && !isSmallMultiples && (this.plotLassoManager = new plotAreaLassoManager.oW(!1), 
                this.plotLassoManager.init([ axesRenderer.getLayerContainer(), clearCatcher ], chartAreaSvg, this.hostServices, this.featureSwitches), 
                this.lassoSelectionBehavior = new plotAreaLassoManager.lk(this.behavior), this.plotLassoManager.behaviors.push(this.lassoSelectionBehavior), 
                this.plotLassoManager.setUiScale(this.initialViewportScale));
            }
            return Object.defineProperty(CartesianPlotAreaLayout.prototype, "featureSwitches", {
                get: function() {
                    var _a;
                    return (null === (_a = this.cartesianOptions) || void 0 === _a ? void 0 : _a.featureSwitches) || {};
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianPlotAreaLayout.prototype, "chartType", {
                get: function() {
                    var _a;
                    return null === (_a = this.cartesianOptions) || void 0 === _a ? void 0 : _a.chartType;
                },
                enumerable: !1,
                configurable: !0
            }), CartesianPlotAreaLayout.prototype.attachToElement = function(element, viewport) {
                this.element = element;
                var d3SmallMultiplesArea = this.chartAreaSvg;
                d3SmallMultiplesArea.attrs({
                    width: viewport.width,
                    height: viewport.height
                }), d3SmallMultiplesArea.node().parentElement !== element.get(0) && element.append(d3SmallMultiplesArea.node());
            }, CartesianPlotAreaLayout.prototype.render = function(layers, data, renderedPlotArea, options, viewportScale) {
                var _a;
                this.options = options, this.renderedPlotArea = renderedPlotArea, this.cartesianData = data, 
                this.layers = layers, null === (_a = this.plotLassoManager) || void 0 === _a || _a.setUiScale(viewportScale), 
                this.cartesianData && (this.cartesianData.showIcon ? this.visibilityHelper.updateVisibility({
                    showIcon: this.cartesianData.showIcon,
                    viewport: this.options.viewport
                }) : (this.visibilityHelper.updateVisibility({
                    showIcon: this.cartesianData.showIcon
                }), this.renderCartesianChart()));
            }, CartesianPlotAreaLayout.prototype.destroy = function() {
                this.axesRenderer.destroy(), this.chartAreaSvg.html(null), (0, visualBackgroundHelper.q5)(this.element);
            }, CartesianPlotAreaLayout.prototype.renderCartesianChart = function() {
                var _this = this, options = this.options, plotAreaHasChanged = !this.renderedPlotArea || this.renderedPlotArea.height !== options.chartAreaViewport.height || this.renderedPlotArea.width !== options.chartAreaViewport.width;
                this.renderedPlotArea = options.chartAreaViewport, this.axesRenderer.render(this.cartesianData.axesData, this.options.axisZoom, this.layers, this.cartesianData.referenceLines, this.options.chartAreaViewport, function(renderOptions) {
                    return _this.renderPlotArea((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, renderOptions), {
                        resizeMode: options.resizeMode
                    }));
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    suppressAnimations: options.suppressAnimations || plotAreaHasChanged
                }), void 0, this.options.axesLayout), this.dataPointNavigationHelper.updateScrollCallbacks(options.supportsScrolling ? options.navigationScrollCallbacks : void 0);
            }, CartesianPlotAreaLayout.prototype.getPlotAreaRect = function(axesLayout) {
                return {
                    left: axesLayout.margin.left + this.options.chartAreaMargins.left,
                    top: axesLayout.margin.top + this.options.chartAreaMargins.top,
                    width: axesLayout.plotArea.width,
                    height: axesLayout.plotArea.height
                };
            }, CartesianPlotAreaLayout.prototype.renderPlotArea = function(renderOptions) {
                var axesLayout = renderOptions.axesLayout;
                (0, visualBackgroundHelper.Re)(this.options.background, this.element, this.getPlotAreaRect(axesLayout)), 
                (0, referenceLineHelper1.xw)({
                    graphicContext: this.axesRenderer.getLayerContainer(),
                    axes: axesLayout.axes,
                    viewport: axesLayout.plotArea,
                    referenceLines: this.cartesianData.referenceLines
                }), this.renderLayers(renderOptions), (0, trendLineHelper.Zb)(this.cartesianData.trendLines, this.axesRenderer.getLayerContainer(), axesLayout.axes, axesLayout.plotArea, this.featureSwitches.onObject);
            }, CartesianPlotAreaLayout.prototype.getReferenceLineLabels = function(axes, plotArea) {
                return (0, referenceLineHelper1.TY)({
                    axes,
                    viewport: plotArea,
                    referenceLines: this.cartesianData.referenceLines,
                    hostServices: this.hostServices,
                    style: this.options.layerStyle
                });
            }, CartesianPlotAreaLayout.prototype.getDataLabelLayoutOptions = function(labelDataPointGroups) {
                var layoutOptions = (0, dataLabelRendererEnhanced.n8)(this.chartType);
                return layoutOptions.allowLeaderLines = layoutOptions.allowLeaderLines || labelDataPointGroups.some(function(labelDataPointGroup) {
                    return labelDataPointGroup.enableLeaderLines;
                }), layoutOptions.shrinkLeaderLinesForBestFit = 11 !== this.chartType, layoutOptions.drawLeaderLinesIgnoreOffset = 11 !== this.chartType, 
                layoutOptions;
            }, CartesianPlotAreaLayout.prototype.renderDataLabels = function(options) {
                var labelInstances = this.behavior ? this.renderLabelsWithInteractiveBehavior(options) : this.renderLabelsWithoutInteractiveBehavior(options);
                return !_.isEmpty(labelInstances) || _.every(options.labelDataPointGroups, function(group) {
                    return _.isEmpty(group.labelDataPoints);
                });
            }, CartesianPlotAreaLayout.prototype.renderLabelsWithoutInteractiveBehavior = function(labelRendererOptions) {
                var _a, labelInstances = new labelLayout1.nu({
                    maximumOffset: dataLabelViewModel1Consts.wh,
                    startingOffset: dataLabelViewModel1Consts.ki,
                    attemptToMoveLabelsIntoViewport: !0
                }).layout(labelRendererOptions.labelDataPointGroups, labelRendererOptions.plotArea);
                return (null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.labelEnhancementsM0) ? this.renderEnhancedLabels(labelInstances, labelRendererOptions) : this.drawLegacyLabelsAndBackgrounds(labelInstances, labelRendererOptions), 
                labelInstances;
            }, CartesianPlotAreaLayout.prototype.drawLegacyLabelsAndBackgrounds = function(dataLabelsToDraw, labelRendererOptions) {
                var _a = this.axesRenderer.getDataLabelContainers();
                return (0, dataLabelRendererEnhanced.gm)({
                    labelContext: _a.foreground,
                    dataLabels: dataLabelsToDraw,
                    numeric: labelRendererOptions.labelsAreNumeric,
                    backgroundContext: _a.background,
                    formatMode: this.options.formatMode,
                    onObject: this.featureSwitches.onObject
                });
            }, CartesianPlotAreaLayout.prototype.drawLabelContainer = function(labelContainersToDraw, labelRendererOptions) {
                var labelsAreNumeric = labelRendererOptions.labelsAreNumeric, labelContainerRegion = this.axesRenderer.getLabelContainerRegion().foreground;
                return (0, dataLabelRendererEnhanced.AE)({
                    labelGroupContext: labelContainerRegion,
                    labelContainers: labelContainersToDraw,
                    numeric: labelsAreNumeric,
                    formatMode: this.options.formatMode,
                    onObject: this.featureSwitches.onObject
                });
            }, CartesianPlotAreaLayout.prototype.renderEnhancedLabels = function(labelsToRender, labelRendererOptions) {
                var svgLabels, _a = this.labelInstanceTypeSplitter(labelsToRender), labels = _a.labels, containers = _a.containers, labelContainerRegion = this.axesRenderer.getLabelContainerRegion().foreground;
                return _.isEmpty(containers) || (svgLabels = this.drawLabelContainer(containers, labelRendererOptions)), 
                svgLabels = this.drawLegacyLabelsAndBackgrounds(labels, labelRendererOptions), _.isEmpty(containers) && ((0, 
                dataLabelRendererEnhanced.in)(labelContainerRegion), (0, dataLabelRendererEnhanced.$J)(labelContainerRegion)), 
                svgLabels;
            }, CartesianPlotAreaLayout.prototype.renderLabelsWithInteractiveBehavior = function(labelRendererOptions) {
                var _a, svgLabels, labelDataPointGroups = labelRendererOptions.labelDataPointGroups, plotArea = labelRendererOptions.plotArea, suppressAnimations = labelRendererOptions.suppressAnimations, animateLabels = labelRendererOptions.animateLabels, labelsAreNumeric = labelRendererOptions.labelsAreNumeric, _b = this.options, formatMode = _b.formatMode, labelAnimationOptions = _b.labelAnimationOptions, labelLayoutOptions = this.getDataLabelLayoutOptions(labelDataPointGroups), labelInstances = new labelLayout1.nu(labelLayoutOptions).layout(labelDataPointGroups, plotArea), _c = this.axesRenderer.getDataLabelContainers(), labelRegion = _c.foreground, labelBackgroundRegion = _c.background, isArrayOfContainers = (0, 
                dataLabelUtil.ML)(labelInstances);
                if (this.renderLeaderLines(labelLayoutOptions, labelInstances), svgLabels = !isArrayOfContainers && (null === (_a = this.cartesianOptions) || void 0 === _a ? void 0 : _a.animator) && !suppressAnimations && animateLabels ? (0, 
                dataLabelRendererEnhanced.Bf)({
                    labelContext: labelRegion,
                    dataLabels: labelInstances,
                    duration: labelAnimationOptions.duration,
                    numeric: labelsAreNumeric,
                    easeType: labelAnimationOptions.ease,
                    backgroundContext: labelBackgroundRegion,
                    formatMode,
                    onObject: this.featureSwitches.onObject
                }) : this.featureSwitches.labelEnhancementsM0 ? this.renderEnhancedLabels(labelInstances, labelRendererOptions) : this.drawLegacyLabelsAndBackgrounds(labelInstances, labelRendererOptions), 
                this.interactivityService && (this.cartesianOptions.isLabelInteractivityEnabled || formatMode)) {
                    var labelsBehaviorOptions = {
                        labelItems: svgLabels
                    };
                    this.interactivityService.bind(labelInstances, new LabelsBehavior.c, labelsBehaviorOptions, {
                        isLabels: !0,
                        pointSourceKey: "data-labels",
                        formatMode
                    });
                }
                return labelInstances;
            }, CartesianPlotAreaLayout.prototype.labelInstanceTypeSplitter = function(labelInstances) {
                for (var labels = [], containers = [], _i = 0, labelInstances_1 = labelInstances; _i < labelInstances_1.length; _i++) {
                    var labelInstance = labelInstances_1[_i];
                    (0, dataLabelUtil.CC)(labelInstance) ? containers.push(labelInstance) : labels.push(labelInstance);
                }
                return {
                    labels,
                    containers
                };
            }, CartesianPlotAreaLayout.prototype.renderLeaderLines = function(labelLayoutOptions, dataLabels) {
                var labelRegion = this.axesRenderer.getDataLabelContainers().foreground, filteredLabels = labelLayoutOptions.allowLeaderLines ? dataLabels.filter(function(d) {
                    return !_.isEmpty(d.leaderLinePoints) && null != d.identity;
                }) : [];
                (0, dataLabelRendererEnhanced.z8)(labelRegion, filteredLabels, function(d) {
                    return d.identity.getKey();
                });
            }, CartesianPlotAreaLayout.prototype.renderSeriesLabels = function(labelDataPointGroups, plotArea, seriesLabelsSettings, availableChartWidth, formatMode) {
                var _a = this.axesRenderer.getSeriesLabelContainers(), labelSeriesRegion = _a.seriesForeground, labelSeriesBackgroundRegion = _a.seriesBackground, labelLayout = new labelLayout1.nu({
                    maximumOffset: dataLabelViewModel1Consts.wh,
                    startingOffset: dataLabelViewModel1Consts.ki,
                    attemptToMoveLabelsIntoViewport: !0
                });
                (0, dataLabelRendererEnhanced.Sw)({
                    labelContext: labelSeriesRegion,
                    dataLabels: labelLayout.layout(labelDataPointGroups, plotArea),
                    backgroundContext: labelSeriesBackgroundRegion,
                    availableChartWidth,
                    seriesLabelsSettings,
                    plotArea,
                    formatMode,
                    onObject: this.featureSwitches.onObject
                });
            }, CartesianPlotAreaLayout.prototype.renderLayers = function(renderOptions) {
                var layers = renderOptions.layers, axesLayout = renderOptions.axesLayout, suppressAnimations = renderOptions.suppressAnimations, resizeMode = renderOptions.resizeMode;
                debug.fF.assertValue(layers, "layers");
                var interactivityServiceOptions, categorySubRangeCount, verticalCategoryAxis, labelDataPointGroups = [], labelDataPointSeriesGroups = [], dataPoints = [], layerBehaviorOptions = [], labelsAreNumeric = !0, axes = axesLayout.axes, plotArea = axesLayout.plotArea;
                suppressAnimations = suppressAnimations || _.some(layers, function(layer) {
                    return layer.shouldSuppressAnimation && layer.shouldSuppressAnimation();
                });
                for (var animateLabels = !0, _loop_1 = function(layer) {
                    var result = layer.render(suppressAnimations, resizeMode, this_1.options.formatMode);
                    if (result) {
                        if (result.animateLabels || (animateLabels = !1), this_1.behavior && (dataPoints = dataPoints.concat(result.dataPoints), 
                        layerBehaviorOptions.push(result.behaviorOptions), result.navigationOptions && (interactivityServiceOptions ? interactivityServiceOptions.navigationOptions.navigationStrategy = services_interactivityService.jN.CategoryFirst : (interactivityServiceOptions = {
                            pointSourceKey: "cartesian-layer ".concat(this_1.options.multipleId || ""),
                            navigationOptions: {
                                navigationStrategy: result.navigationOptions.navigationStrategy,
                                helper: this_1.dataPointNavigationHelper
                            }
                        }, this_1.dataPointNavigationHelper.clearNavigationLayers()), interactivityServiceOptions.isHierarchicalAxis = this_1.options.isHierarchicalAxis, 
                        this_1.dataPointNavigationHelper.addNavigationLayer(result.navigationOptions.helper))), 
                        result.labelDataPointGroups) for (var _a = 0, resultLabelDataPointsGroups_1 = result.labelDataPointGroups; _a < resultLabelDataPointsGroups_1.length; _a++) (resultLabelDataPointsGroup = resultLabelDataPointsGroups_1[_a]) && labelDataPointGroups.push((0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, resultLabelDataPointsGroup), {
                            labelDataPoints: (0, dataLabelRendererEnhanced.R1)(resultLabelDataPointsGroup.labelDataPoints || []),
                            labelOrientation: resultLabelDataPointsGroup.isTotal ? labelOrientation.B.Horizontal : result.labelOrientation
                        })); else {
                            var resultsLabelDataPoints = result.labelDataPoints || [];
                            labelDataPointGroups.push((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, resultsLabelDataPoints), {
                                labelDataPoints: (0, dataLabelRendererEnhanced.R1)(resultsLabelDataPoints),
                                maxNumberOfLabels: resultsLabelDataPoints.length,
                                labelOrientation: result.labelOrientation
                            }));
                        }
                        if (result.labelDataPointSeriesGroups) for (var _b = 0, resultLabelDataPointsGroups_2 = result.labelDataPointSeriesGroups; _b < resultLabelDataPointsGroups_2.length; _b++) {
                            var resultLabelDataPointsGroup;
                            (resultLabelDataPointsGroup = resultLabelDataPointsGroups_2[_b]) && labelDataPointSeriesGroups.push((0, 
                            tslib_es6.__assign)((0, tslib_es6.__assign)({}, resultLabelDataPointsGroup), {
                                labelDataPoints: (0, dataLabelRendererEnhanced.R1)(resultLabelDataPointsGroup.labelDataPoints || []),
                                labelOrientation: resultLabelDataPointsGroup.isTotal ? labelOrientation.B.Horizontal : result.labelOrientation
                            }));
                        }
                        labelsAreNumeric = labelsAreNumeric && result.labelsAreNumeric, this_1.lassoSelectionBehavior && (void 0 !== result.categorySubRangeCount && (void 0 === categorySubRangeCount ? categorySubRangeCount = result.categorySubRangeCount : debug.fF.assert(function() {
                            return result.categorySubRangeCount === categorySubRangeCount;
                        }, "categorySubRangeCount should match between layers")), void 0 !== result.verticalCategoryAxis && (void 0 === verticalCategoryAxis ? verticalCategoryAxis = result.verticalCategoryAxis : debug.fF.assert(function() {
                            return result.verticalCategoryAxis === verticalCategoryAxis;
                        }, "verticalCategoryAxis should match between layers")));
                    }
                }, this_1 = this, _i = 0, layers_1 = layers; _i < layers_1.length; _i++) _loop_1(layers_1[_i]);
                var referenceLineLabels = this.getReferenceLineLabels(axes, plotArea);
                _.isEmpty(referenceLineLabels) || labelDataPointGroups.unshift({
                    labelDataPoints: referenceLineLabels,
                    maxNumberOfLabels: referenceLineLabels.length
                });
                var labelRendererOptions = {
                    labelDataPointGroups,
                    labelsAreNumeric,
                    plotArea,
                    suppressAnimations,
                    isCombo: (0, cartesianHelper.LQ)(this.chartType),
                    animateLabels
                };
                this.noLabelsCanBeRendered = !this.renderDataLabels(labelRendererOptions), this.renderSeriesLabels(labelDataPointSeriesGroups, plotArea, getSeriesLabelSettings(layers, this.chartType), getAvailableViewport(axesLayout).width, this.options.formatMode), 
                this.dataPointNavigationHelper.getPendingFocusElement && interactivityServiceOptions && (interactivityServiceOptions.navigationOptions.focusElement = this.dataPointNavigationHelper.getPendingFocusElement()), 
                this.interactivityService && this.interactivityService.bind(dataPoints, this.behavior, {
                    layerOptions: layerBehaviorOptions,
                    clearCatcher: this.clearCatcher,
                    root: this.chartAreaSvg,
                    axesLayout,
                    categorySubRangeCount,
                    verticalCategoryAxis
                }, interactivityServiceOptions);
            }, CartesianPlotAreaLayout;
        }(), dataViewObjectProperties = __webpack_require__(14599), smallMultiplesUtils = __webpack_require__(61297), gridLayout = __webpack_require__(32476), wordBreaker = __webpack_require__(66001), CartesianSharedAxisLayout = function() {
            function CartesianSharedAxisLayout() {
                var _a;
                this.unSyncedLayout = [], this.maxMargin = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }, this.axesRenderersByPosition = ((_a = {})[2] = [], _a[0] = [], _a[1] = [], _a);
            }
            return CartesianSharedAxisLayout.prototype.update = function(settings, multiples, renderOptions, viewport, columnCount, rowCount, coreMultiple) {
                this.settings = settings, this.coreMultiple = coreMultiple, this.renderOptions = renderOptions, 
                this.maxMargin = {
                    bottom: 0,
                    left: 0,
                    right: 0,
                    top: 0
                }, this.unSyncedLayout = [];
                var cartesianDataForSharedAxis = _.clone(this.getCoreMultipleData()), layersForShareAxis = this.coreMultiple.layers;
                if (!this.shouldShareAxis()) {
                    for (var _i = 0, multiples_1 = multiples; _i < multiples_1.length; _i++) {
                        var singleMultiple = multiples_1[_i], cartesianData = singleMultiple.getData(), layers = singleMultiple.layers;
                        cartesianData.axesData.x.showAxisTitle = !1, cartesianData.axesData.y.showAxisTitle = !1, 
                        cartesianData.axesData.y2.showAxisTitle = !1, cartesianDataForSharedAxis.axesData.y.sharedAxis || (cartesianData.axesData.x.show = !1), 
                        cartesianDataForSharedAxis.axesData.x.sharedAxis || (cartesianData.axesData.y.show = !1);
                        var layout = build({
                            axesData: cartesianData.axesData,
                            rendererSettings: this.settings,
                            referenceLines: cartesianData.referenceLines,
                            layers,
                            viewport,
                            playAxesRect: this.renderOptions.playAxesRect,
                            trimOrdinalDataOnOverflow: this.renderOptions.trimOrdinalDataOnOverflow,
                            axisZoom: void 0,
                            rotateXTickLabels90: !0
                        });
                        this.unSyncedLayout.push(layout), layout.margin.left >= this.maxMargin.left && (this.maxMargin.left = layout.margin.left), 
                        layout.margin.right >= this.maxMargin.right && (this.maxMargin.right = layout.margin.right), 
                        layout.margin.top >= this.maxMargin.top && (this.maxMargin.top = layout.margin.top), 
                        layout.margin.bottom >= this.maxMargin.bottom && (this.maxMargin.bottom = layout.margin.bottom);
                    }
                    (cartesianDataForSharedAxis = _.clone(multiples[0].getData())).axesData.x.showAxisTitle = this.getCoreMultipleData().axesData.x.showAxisTitle, 
                    cartesianDataForSharedAxis.axesData.y.showAxisTitle = this.getCoreMultipleData().axesData.y.showAxisTitle, 
                    cartesianDataForSharedAxis.axesData.y.sharedAxis || (cartesianDataForSharedAxis.axesData.x.show = this.getCoreMultipleData().axesData.x.show, 
                    cartesianDataForSharedAxis.axesData.y.show = !1, cartesianDataForSharedAxis.axesData.y2 && (cartesianDataForSharedAxis.axesData.y2.show = !1, 
                    cartesianDataForSharedAxis.axesData.y2.showAxisTitle = this.getCoreMultipleData().axesData.y.showAxisTitle)), 
                    cartesianDataForSharedAxis.axesData.x.sharedAxis || (cartesianDataForSharedAxis.axesData.x.show = !1, 
                    cartesianDataForSharedAxis.axesData.y.show = this.getCoreMultipleData().axesData.y.show);
                }
                return this.generateSharedAxisLayout(cartesianDataForSharedAxis, layersForShareAxis, viewport, columnCount, rowCount), 
                this.unSyncedLayout;
            }, CartesianSharedAxisLayout.prototype.generateSharedAxisLayout = function(cartesianData, layers, viewport, columnCount, rowCount) {
                this.layout = build({
                    axesData: cartesianData.axesData,
                    rendererSettings: this.settings,
                    referenceLines: cartesianData.referenceLines,
                    layers,
                    viewport,
                    playAxesRect: this.renderOptions.playAxesRect,
                    trimOrdinalDataOnOverflow: this.renderOptions.trimOrdinalDataOnOverflow,
                    axisZoom: void 0,
                    rotateXTickLabels90: !0,
                    forceMarginMin: this.shouldShareAxis() ? void 0 : (0, tslib_es6.__assign)({}, this.maxMargin)
                }), this.clearUnusedRenderers(columnCount, rowCount, this.layout.shouldRenderAxis, this.layout);
            }, CartesianSharedAxisLayout.prototype.getCoreMultipleData = function() {
                return this.coreMultiple.getData();
            }, CartesianSharedAxisLayout.prototype.shouldShareAxis = function() {
                return this.getCoreMultipleData().axesData.x.sharedAxis && this.getCoreMultipleData().axesData.y.sharedAxis;
            }, CartesianSharedAxisLayout.prototype.clearUnusedRenderers = function(columnCount, rowCount, shouldRenderAxis, layout) {
                this.destroyUnusedRenderers(columnCount = shouldRenderAxis.x || layout.isXScrollBarVisible ? columnCount : 0, 2);
                var yAxisRenderersCount = shouldRenderAxis.y || layout.isYScrollBarVisible ? rowCount : 0, gridYAxisPosition = this.shouldRenderYAxis(0, this.settings.data.y.switchAxisPosition) ? 0 : 1;
                this.destroyUnusedRenderers(yAxisRenderersCount, gridYAxisPosition), this.destroyUnusedRenderers(shouldRenderAxis.y2 || layout.isYScrollBarVisible ? rowCount : 0, 0 === gridYAxisPosition ? 1 : 0);
            }, CartesianSharedAxisLayout.prototype.destroyUnusedRenderers = function(start, position) {
                var renderers = this.axesRenderersByPosition[position];
                _.isEmpty(renderers) || renderers.length <= start || (renderers.slice(start, renderers.length).forEach(function(renderer) {
                    return renderer.destroy();
                }), this.axesRenderersByPosition[position] = renderers.slice(0, start));
            }, CartesianSharedAxisLayout.prototype.calculateAxesLayout = function(index) {
                return this.shouldShareAxis() || void 0 === index ? this.calculateSynchronizedAxesLayout() : void 0 !== index ? this.calculateUnSynchronizedAxesLayout(index) : this.layout;
            }, CartesianSharedAxisLayout.prototype.calculateSynchronizedAxesLayout = function() {
                var layout = _.cloneDeep(this.layout);
                return (0, Prototype.Zx)(this.layout, layout), layout.axes.x.scale = this.layout.axes.x.scale.copy(), 
                layout.axes.y1.scale = this.layout.axes.y1.scale.copy(), layout.axes.y2 && (layout.axes.y2.scale = this.layout.axes.y2.scale.copy()), 
                layout;
            }, CartesianSharedAxisLayout.prototype.calculateUnSynchronizedAxesLayout = function(index) {
                var _a, layout = _.cloneDeep(this.unSyncedLayout[index]);
                (0, Prototype.Zx)(this.unSyncedLayout[index], layout);
                var xAxis = layout.axes.x, yAxis = layout.axes.y1, plotArea = layout.plotArea = this.layout.plotArea, cartesianAxesData = this.getCoreMultipleData().axesData, thisOverflow = this.layout.tickLabelMargins.axesOverflow, unSynchedOverflow = layout.tickLabelMargins.axesOverflow;
                if (!cartesianAxesData.y.sharedAxis) {
                    xAxis.outerPadding = this.layout.axes.x.outerPadding, xAxis.outerPaddingRatio = this.layout.axes.x.outerPaddingRatio, 
                    xAxis.xLabelMaxWidth = this.layout.axes.x.xLabelMaxWidth, xAxis.categoryThickness = this.layout.axes.x.categoryThickness, 
                    layout.isXScrollBarVisible = this.layout.isXScrollBarVisible;
                    var yOverflowDiff = thisOverflow.bottom + thisOverflow.top - (unSynchedOverflow.bottom + unSynchedOverflow.top);
                    (y1Scale = yAxis.scale).range(yAxis.invertAxis ? [ 1, plotArea.height + yOverflowDiff - 1 ] : [ plotArea.height + yOverflowDiff - 1, 1 ]), 
                    xAxis.scale = this.layout.axes.x.scale.copy(), layout.axes.y2 && layout.axes.y2.scale.range(yAxis.invertAxis ? [ 1, plotArea.height + yOverflowDiff - 1 ] : [ plotArea.height + yOverflowDiff - 1, 1 ]), 
                    layout.margin.left = Math.max(this.maxMargin.left, layout.margin.left), layout.margin.right = Math.max(this.maxMargin.right, layout.margin.right);
                }
                if (!cartesianAxesData.x.sharedAxis) {
                    yAxis.outerPadding = this.layout.axes.y1.outerPadding, yAxis.outerPaddingRatio = this.layout.axes.y1.outerPaddingRatio, 
                    yAxis.xLabelMaxWidth = this.layout.axes.y1.xLabelMaxWidth, yAxis.categoryThickness = this.layout.axes.y1.categoryThickness, 
                    layout.isYScrollBarVisible = this.layout.isYScrollBarVisible;
                    var y1Scale, xOverflowDiff = thisOverflow.left + thisOverflow.right - (unSynchedOverflow.left + unSynchedOverflow.right);
                    if (xAxis.scale.range(xAxis.invertAxis ? [ plotArea.width + xOverflowDiff - 1, 1 ] : [ 1, plotArea.width + xOverflowDiff - 1 ]), 
                    !cartesianAxesData.x.show) if ((0, axisHelper._9)(y1Scale = yAxis.scale)) y1Scale.range([ 0, layout.plotArea.height ]), 
                    y1Scale.paddingOuter(yAxis.outerPaddingRatio); else {
                        var outerPadding = null !== (_a = yAxis.outerPadding) && void 0 !== _a ? _a : 0;
                        y1Scale.range([ layout.plotArea.height - outerPadding, outerPadding ]);
                    }
                    layout.margin.bottom = Math.max(this.maxMargin.bottom, layout.margin.bottom), layout.margin.top = Math.max(this.maxMargin.top, layout.margin.top);
                }
                return layout;
            }, CartesianSharedAxisLayout.prototype.renderAxes = function(data) {
                if (!(data.viewport.height < 1 || data.viewport.width < 1)) {
                    var container = (0, cartesianHelper.MI)(data.element, data.viewport), cartesianData = this.getCoreMultipleData();
                    this.getAxesRenderer(container.element, data.position, data.index, cartesianData).render(cartesianData.axesData, void 0, this.coreMultiple.layers, cartesianData.referenceLines, data.viewport, function() {}, (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, this.renderOptions), {
                        supportsScrolling: this.shouldSupportScrolling(cartesianData, data.position),
                        formatMode: this.settings.formatMode,
                        isSelected: this.settings.isSelected,
                        subSelectionHelper: void 0,
                        multipleId: void 0,
                        playAxesRect: void 0
                    }), this.renderOptions.isSmallMultiples, this.updateAxesLayoutByPosition(data));
                }
            }, CartesianSharedAxisLayout.prototype.scrollDelta = function(delta, visibleRows) {
                this.updateScrollState(function(renderer) {
                    return renderer.scrollDelta(delta);
                }, visibleRows);
            }, CartesianSharedAxisLayout.prototype.scrollTo = function(index, visibleRows) {
                this.updateScrollState(function(renderer) {
                    return renderer.scrollTo(index);
                }, visibleRows);
            }, CartesianSharedAxisLayout.prototype.scrollBy = function(steps, visibleRows) {
                this.updateScrollState(function(renderer) {
                    return renderer.scrollBy(steps);
                }, visibleRows);
            }, CartesianSharedAxisLayout.prototype.updateScrollbarExtent = function(extent, visibleRows) {
                this.updateScrollState(function(renderer) {
                    return renderer.setExtent(extent);
                }, visibleRows);
            }, CartesianSharedAxisLayout.prototype.updateScrollState = function(runScrollUpdate, visibleRows) {
                var cartesianData = this.getCoreMultipleData(), scrollablePosition = this.getScrollablePosition(cartesianData);
                debug.fF.assertValue(scrollablePosition, "scrollablePosition");
                var renderers = this.axesRenderersByPosition[scrollablePosition];
                2 !== scrollablePosition && _.isEmpty(visibleRows) || _.isEmpty(renderers) || renderers.forEach(function(renderer, index) {
                    2 !== scrollablePosition && (index < visibleRows.startIndex || index > visibleRows.endIndex) || runScrollUpdate(renderer);
                });
            }, CartesianSharedAxisLayout.prototype.updateAxesLayoutByPosition = function(_a) {
                var position = _a.position, viewport = _a.viewport, layout = this.calculateAxesLayout(), scrollHandleMargins = layout.scrollHandleMargins;
                layout.viewport = scrollHandleMargins ? {
                    width: viewport.width - (scrollHandleMargins.left + scrollHandleMargins.right),
                    height: viewport.height - (scrollHandleMargins.top + scrollHandleMargins.bottom),
                    scale: viewport.scale
                } : viewport, layout.preferredPlotArea = {
                    width: 0,
                    height: 0
                };
                var cartesianData = this.getCoreMultipleData();
                return 2 === position ? (layout.margin = this.getMarginByPosition(layout.margin, position, layout.tickLabelMargins.axesOverflow), 
                !cartesianData.axesData.y.sharedAxis && cartesianData.axesData.y.show && (layout.margin.left = this.layout.margin.left, 
                layout.shouldRenderAxis.y = !1), cartesianData.axesData.x.sharedAxis || (layout.margin.bottom = this.layout.margin.bottom), 
                this.shouldShareAxis() && (layout.shouldRenderAxis.y = !1), layout.shouldRenderAxis.y2 = !1, 
                layout.shouldRenderAxis.y = !1, layout.axisLabels.y = null, layout.axisLabels.y2 = null, 
                layout.plotArea.height = 0, layout) : (layout.plotArea.width = 0, layout.margin = this.getMarginByPosition(layout.margin, position, layout.tickLabelMargins.axesOverflow), 
                layout.shouldRenderAxis.x = !1, layout.axisLabels.x = null, this.shouldRenderYAxis(position, this.settings.data.y.switchAxisPosition) ? (layout.axisLabels.y2 = null, 
                layout.shouldRenderAxis.y2 = !1) : (layout.shouldRenderAxis.y = !1, layout.axisLabels.y = null), 
                layout);
            }, CartesianSharedAxisLayout.prototype.destroy = function() {
                var _this = this;
                this.executeActionByPosition(this.axesRenderersByPosition, function(renderers, position) {
                    _.isEmpty(renderers) || (renderers.forEach(function(renderer) {
                        return renderer.destroy();
                    }), _this.axesRenderersByPosition[position] = []);
                });
            }, CartesianSharedAxisLayout.prototype.executeActionByPosition = function(propertyByGridPosition, action) {
                for (var positionString in this.axesRenderersByPosition) action(propertyByGridPosition[positionString], positionString);
            }, CartesianSharedAxisLayout.prototype.clearRenderingTimeout = function() {
                this.executeActionByPosition(this.axesRenderersByPosition, function(renderers) {
                    _.isEmpty(renderers) || renderers.forEach(function(renderer) {
                        return renderer.clearRenderingTimeout();
                    });
                });
            }, CartesianSharedAxisLayout.prototype.shouldRenderYAxis = function(headerPosition, switchAxisPosition) {
                return 0 === headerPosition && !switchAxisPosition || 1 === headerPosition && switchAxisPosition;
            }, CartesianSharedAxisLayout.prototype.getMarginByPosition = function(margin, position, overflow) {
                var result = (0, Prototype.ED)(overflow);
                return 2 === position ? (result.bottom = margin.bottom, result.top = 0, result) : (result.left = 0, 
                result.right = 0, 0 === position ? result.left = margin.left : 1 === position && (result.right = margin.right), 
                result);
            }, CartesianSharedAxisLayout.prototype.getScrollablePosition = function(data) {
                var _a;
                return this.layout.isYScrollBarVisible ? (null === (_a = data.axesData.y) || void 0 === _a ? void 0 : _a.switchAxisPosition) ? 1 : 0 : this.layout.isXScrollBarVisible ? 2 : void 0;
            }, CartesianSharedAxisLayout.prototype.shouldSupportScrolling = function(data, position) {
                return this.getScrollablePosition(data) === position;
            }, CartesianSharedAxisLayout.prototype.getAxesRenderer = function(element, position, index, data) {
                var $element = $(element.node()), renderer = $element.data("CartesianAxesRenderer");
                if (renderer) renderer.update(data.axesData, data.scrollbarOptions); else {
                    var settings = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, this.settings), {
                        container: element,
                        multipleId: "".concat(index),
                        behavior: new CategoricalAxisBehavior
                    });
                    settings.data.useManagedTabIndex = !0, this.axesRenderersByPosition[position][index] = renderer = new CartesianAxesRenderer(settings), 
                    $element.data("CartesianAxesRenderer", renderer);
                }
                return renderer;
            }, CartesianSharedAxisLayout;
        }(), gridLayoutSelectors = __webpack_require__(39071), CartesianSmallMultipleLayout = function() {
            function CartesianSmallMultipleLayout(container, interactivityService, getLocalizedString, rowLoadMoreDataHandler, cartesianOptions, layerStyle, viewMode, buildPlotAreaLayout, renderMultiple, adapterFactory, visualInstanceId, eventManager) {
                var _a, _b;
                this.interactivityService = interactivityService, this.getLocalizedString = getLocalizedString, 
                this.cartesianOptions = cartesianOptions, this.layerStyle = layerStyle, this.viewMode = viewMode, 
                this.buildPlotAreaLayout = buildPlotAreaLayout, this.renderMultiple = renderMultiple, 
                this.adapterFactory = adapterFactory, this.visualInstanceId = visualInstanceId, 
                this.sharedAxisLayout = new CartesianSharedAxisLayout, this.gridLayout = new gridLayout.Me(container, function() {
                    return rowLoadMoreDataHandler.loadMoreData();
                }, null === (_a = this.cartesianOptions) || void 0 === _a ? void 0 : _a.isScrollable, interactivityService, eventManager, "multiple", null === (_b = this.cartesianOptions) || void 0 === _b ? void 0 : _b.featureSwitches), 
                this.visibilityHelper = (0, responsiveVisualUtil2.q)().visibilityHelper(container, CartesianSmallMultipleLayout.IconClassName);
            }
            return CartesianSmallMultipleLayout.prototype.render = function(options) {
                var _this = this;
                this.clearRenderingTimeout();
                var multiplesFactory = options.cartesianSmallMultipleFactory;
                this.options = options;
                var multiples = options.cartesianSmallMultipleFactory, smallMultipleAdapter = this.adapterFactory(), multiplesSubheader = smallMultipleAdapter.getMultiplesSubheader(options.warnings);
                debug.fF.assertValue(smallMultipleAdapter, "smallMultipleAdapter");
                var multiplesLayout = this.multiplesLayout = smallMultipleAdapter.getMultiplesLayout(options.warnings), showIcon = multiplesLayout.showIcon;
                if (this.visibilityHelper.updateVisibility({
                    showIcon,
                    viewport: options.viewport
                }), !showIcon) {
                    var gridCellRenderOptions = {
                        categoryLoadMoreDataHandler: options.categoryLoadMoreDataHandler,
                        playAxesRect: options.playAxesRect,
                        trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow,
                        suppressAnimations: options.suppressAnimations,
                        resizeMode: options.resizeMode,
                        rowCount: multiplesLayout.rowCount,
                        columnCount: multiplesLayout.columnCount,
                        getCellBackgroundColor: function(cellIndex) {
                            return _this.getColorFromMultipleObjects(cellIndex, dataViewObjectProperties.e0.smallMultiplesBackgroundColor, _this.multiplesLayout.backgroundColor);
                        },
                        backgroundTransparency: multiplesLayout.backgroundTransparency,
                        isHierarchicalAxis: options.isHierarchicalAxis,
                        gridline: multiplesLayout.gridline,
                        cellPadding: {
                            top: multiplesLayout.rowPaddingInner,
                            bottom: 0,
                            left: multiplesLayout.columnPaddingInner,
                            right: 0
                        },
                        outerPadding: {
                            top: multiplesLayout.rowPaddingOuter,
                            bottom: multiplesLayout.rowPaddingOuter,
                            left: multiplesLayout.columnPaddingOuter,
                            right: multiplesLayout.columnPaddingOuter
                        }
                    };
                    return this.cellDimensions && (this.cellDimensions.maxSubheaderHeight = void 0), 
                    this.renderGridLayout(multiplesFactory, options.viewport, function(data) {
                        return _this.renderGridCell(multiples, data, options.background, options.playAxesRect, options.suppressAnimations, options.resizeMode, options.trimOrdinalDataOnOverflow, options.categoryLoadMoreDataHandler, options.isHierarchicalAxis, !0, options.formatMode);
                    }, function(data) {
                        return _this.renderGridCellSubheader(data, multiples, multiplesSubheader);
                    }, multiplesSubheader, gridCellRenderOptions, options.axisRendererSettings.axes.isYAxisCategorical);
                }
            }, CartesianSmallMultipleLayout.prototype.clearRenderingTimeout = function() {
                this.sharedAxisLayout.clearRenderingTimeout(), this.gridLayout.clearRenderingTimeout();
            }, CartesianSmallMultipleLayout.prototype.destroy = function() {
                this.gridLayout.destroy(), this.sharedAxisLayout.destroy();
            }, CartesianSmallMultipleLayout.prototype.onScroll = function(delta) {
                this.sharedAxisLayout.scrollDelta(delta, this.gridLayout.getScrollPosition()), this.options.cartesianSmallMultipleFactory.scrollDelta(delta, this.getVisibleMultiples());
            }, CartesianSmallMultipleLayout.prototype.onExtentUpdate = function(extent) {
                this.sharedAxisLayout.updateScrollbarExtent(extent, this.gridLayout.getScrollPosition()), 
                this.options.cartesianSmallMultipleFactory.updateScrollbarExtent(extent, this.getVisibleMultiples());
            }, CartesianSmallMultipleLayout.prototype.scrollTo = function(index) {
                this.sharedAxisLayout.scrollTo(index, this.gridLayout.getScrollPosition()), this.options.cartesianSmallMultipleFactory.scrollTo(index, this.getVisibleMultiples());
            }, CartesianSmallMultipleLayout.prototype.shouldScrollTo = function(index) {
                return this.options.cartesianSmallMultipleFactory.shouldScrollTo(index, this.getVisibleMultiples());
            }, CartesianSmallMultipleLayout.prototype.scrollBy = function(steps) {
                this.sharedAxisLayout.scrollBy(steps, this.gridLayout.getScrollPosition()), this.options.cartesianSmallMultipleFactory.scrollBy(steps, this.getVisibleMultiples());
            }, CartesianSmallMultipleLayout.adjustAxesMarginsForShared = function(parameters, switchAxisPosition, showAxisTitles) {
                var _a, _b, _c, axesMargins = parameters.axesMargins, titleMargins = parameters.titleMargins, scrollHandleMargins = parameters.scrollHandleMargins, shouldRenderAxis = parameters.shouldRenderAxis, axes = parameters.axes;
                function shouldReserveAxisSpace(axis, isVisible, isLabelVisible) {
                    return isVisible || axis && null != axis.axisLabel && isLabelVisible;
                }
                var isYVisible = shouldReserveAxisSpace(null == axes ? void 0 : axes.y1, shouldRenderAxis.y, showAxisTitles.y), isY2Visible = shouldReserveAxisSpace(null == axes ? void 0 : axes.y2, shouldRenderAxis.y2, showAxisTitles.y2), margin = {
                    bottom: shouldReserveAxisSpace(null == axes ? void 0 : axes.x, shouldRenderAxis.x, showAxisTitles.x) ? axesMargins.bottom : 0,
                    top: 0,
                    left: 0,
                    right: 0
                };
                return switchAxisPosition ? (isYVisible && (margin.right = shouldRenderAxis.y ? axesMargins.right : titleMargins.right), 
                isY2Visible && (margin.left = shouldRenderAxis.y2 ? axesMargins.left : titleMargins.left)) : (isYVisible && (margin.left = shouldRenderAxis.y ? axesMargins.left : titleMargins.left), 
                isY2Visible && (margin.right = shouldRenderAxis.y2 ? axesMargins.right : titleMargins.right)), 
                {
                    left: margin.left + (null !== (_a = null == scrollHandleMargins ? void 0 : scrollHandleMargins.left) && void 0 !== _a ? _a : 0),
                    right: margin.right + (null !== (_b = null == scrollHandleMargins ? void 0 : scrollHandleMargins.right) && void 0 !== _b ? _b : 0),
                    bottom: margin.bottom + (null !== (_c = null == scrollHandleMargins ? void 0 : scrollHandleMargins.bottom) && void 0 !== _c ? _c : 0),
                    top: 0
                };
            }, CartesianSmallMultipleLayout.prototype.getVisibleMultiples = function() {
                var frameCount = this.options.cartesianSmallMultipleFactory.getFrameCount(), visibleRows = this.gridLayout.getScrollPosition();
                return visibleRows ? {
                    startIndex: visibleRows.startIndex * this.multiplesLayout.columnCount,
                    endIndex: Math.min(visibleRows.endIndex * this.multiplesLayout.columnCount, frameCount)
                } : {
                    startIndex: 0,
                    endIndex: 0
                };
            }, CartesianSmallMultipleLayout.prototype.calculatePlotArea = function(parameters) {
                var _a, _b, gridHeaders = CartesianSmallMultipleLayout.adjustAxesMarginsForShared(parameters, this.options.axesData.y.switchAxisPosition, calculateShowAxisTitles(this.options.axesData, void 0));
                this.gridLayout.updateHeaderMargins(gridHeaders);
                var multiplesSubheader = null !== (_b = null === (_a = this.adapterFactory()) || void 0 === _a ? void 0 : _a.getMultiplesSubheader(this.options.warnings)) && void 0 !== _b ? _b : (0, 
                cartesianHelper.yA)(this.options.cartesianSmallMultipleFactory.getObjects(), this.layerStyle), overflow = (0, 
                tslib_es6.__assign)({}, parameters.axesOverflow);
                if ((!this.options.axesData.y.sharedAxis || !this.options.axesData.x.sharedAxis) && this.sharedAxisLayout.getCoreMultipleData().axesData.valueAxis.show) {
                    var axesMargins = parameters.axesMargins;
                    this.options.axesData.y.sharedAxis || (overflow.left = Math.max(axesMargins.left, overflow.left), 
                    overflow.right = Math.max(axesMargins.right, overflow.right)), this.options.axesData.x.sharedAxis || (overflow.bottom = Math.max(axesMargins.bottom, overflow.bottom), 
                    overflow.top = Math.max(axesMargins.top, overflow.top));
                }
                return this.cellDimensions = this.gridLayout.calculateCellDimensions(overflow, {
                    titleWrap: multiplesSubheader.titleWrap,
                    subheaders: multiplesSubheader.titleWrap ? this.getFrameDisplayNames() : void 0,
                    subheaderFontProperties: multiplesSubheader.fontProperties,
                    subheaderLineHeight: multiplesSubheader.height,
                    subheaderMargin: multiplesSubheader.margins
                }, parameters), this.cellDimensions.plotAreaViewport;
            }, CartesianSmallMultipleLayout.prototype.scrollRowsTo = function(position) {
                debug.fF.assertValue(this.gridLayout, "grid layout"), this.gridLayout.scrollTo(position);
            }, CartesianSmallMultipleLayout.prototype.getFrameDisplayNames = function() {
                var listSeparator = this.getLocalizedString("ListJoin_Separator"), frameDisplayNames = this.options.cartesianSmallMultipleFactory.reader.getFrameDisplayNames();
                return frameDisplayNames && frameDisplayNames.map(function(values) {
                    return values.join(listSeparator);
                });
            }, CartesianSmallMultipleLayout.prototype.renderGridLayout = function(multiples, viewport, _renderCell, _renderCellSubheader, multiplesSubheader, gridCellRenderOptions, manageTabIndexOnRowHeaderFooter) {
                var _a, _b;
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var axesRenderOptions, frameCount, coreMultiple, shouldResetScrollPosition, rowCount, columnCount, getCellBackgroundColor, backgroundTransparency, cellPadding, outerPadding, subheaderMargins, subheaderShow, subheaderOneLineHeight, settings, totalRowsCount, dataToBind, _this = this;
                    return (0, tslib_es6.__generator)(this, function(_c) {
                        return axesRenderOptions = this.getAxesRenderOptions(gridCellRenderOptions), frameCount = multiples.getFrameCount(), 
                        coreMultiple = multiples.getCoreMultiple(), shouldResetScrollPosition = multiples.getShouldResetRowMultipleScrollPosition(), 
                        getCellBackgroundColor = gridCellRenderOptions.getCellBackgroundColor, backgroundTransparency = gridCellRenderOptions.backgroundTransparency, 
                        cellPadding = gridCellRenderOptions.cellPadding, outerPadding = gridCellRenderOptions.outerPadding, 
                        subheaderShow = multiplesSubheader.show, subheaderOneLineHeight = multiplesSubheader.height + (subheaderMargins = multiplesSubheader.margins).top + subheaderMargins.bottom, 
                        settings = {
                            rowCount: rowCount = gridCellRenderOptions.rowCount,
                            columnCount: columnCount = gridCellRenderOptions.columnCount,
                            viewport,
                            renderCell: function(data) {
                                return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                    return (0, tslib_es6.__generator)(this, function(_a) {
                                        return _renderCell(data), [ 2, new Promise(function(resolve) {
                                            return resolve();
                                        }) ];
                                    });
                                });
                            },
                            renderCellSubheader: function(data) {
                                return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                    return (0, tslib_es6.__generator)(this, function(_a) {
                                        return _renderCellSubheader(data), [ 2, new Promise(function(resolve) {
                                            return resolve();
                                        }) ];
                                    });
                                });
                            },
                            cellCount: frameCount,
                            headerMargins: (0, cartesianHelper.rX)(),
                            renderHeader: function() {},
                            subheaderShow,
                            subheaderHeight: (null === (_a = this.cellDimensions) || void 0 === _a ? void 0 : _a.maxSubheaderHeight) || subheaderOneLineHeight,
                            subheaderLineHeight: multiplesSubheader.height,
                            subheaderPosition: 1 !== multiplesSubheader.vertical ? 0 : 1,
                            shouldResetScrollPosition,
                            cellPadding,
                            outerPadding,
                            scrollPadding: 5,
                            getCellBackgroundColor,
                            backgroundTransparency,
                            gridLineSettings: gridCellRenderOptions.gridline,
                            getAllCells: function() {
                                return multiples.multiples;
                            },
                            manageTabIndexOnRowHeaderFooter,
                            boldedSubheaders: multiplesSubheader.labelBold
                        }, this.gridLayout.update(settings), totalRowsCount = Math.ceil(frameCount / columnCount), 
                        this.sharedAxisLayout.update(this.options.axisRendererSettings, multiples.multiples, axesRenderOptions, viewport, columnCount, Math.max(totalRowsCount, rowCount), coreMultiple), 
                        settings.renderHeader = function(data) {
                            return _this.sharedAxisLayout.renderAxes(data);
                        }, settings.headerMargins = this.cellDimensions.headerMargins, settings.subheaderHeight = (null === (_b = this.cellDimensions) || void 0 === _b ? void 0 : _b.maxSubheaderHeight) || subheaderOneLineHeight, 
                        this.gridLayout.update(settings), dataToBind = _.map(multiples.multiples, function(multiple) {
                            return multiple.getDataPoint();
                        }), [ 2, this.gridLayout.render({
                            calculatedCellDimensions: this.cellDimensions,
                            dataToBind,
                            pointSourceKey: "multiples",
                            visualInstanceId: this.visualInstanceId,
                            formatMode: this.options.formatMode,
                            subSelectionHelper: this.options.subSelectionHelper
                        }) ];
                    });
                });
            }, CartesianSmallMultipleLayout.prototype.renderGridCellSubheader = function(data, multiples, multiplesSubheader) {
                var _a, $subheader = data.element, index = data.index, viewport = data.viewport;
                if (!_.isUndefined(index)) {
                    var textAlign = 1 === multiplesSubheader.horizontal ? "center" : 2 === multiplesSubheader.horizontal ? "right" : "left", subheaderFontProperties = this.getSubheaderFontProperties(index, multiplesSubheader.fontProperties);
                    $subheader.css((0, common_fontProperties.wB)(subheaderFontProperties)), $subheader.css({
                        padding: "".concat(multiplesSubheader.margins.top, "px ").concat(multiplesSubheader.margins.right, "px ").concat(multiplesSubheader.margins.bottom, "px ").concat(multiplesSubheader.margins.left, "px "),
                        "text-align": textAlign
                    });
                    var listSeparator = this.getLocalizedString("ListJoin_Separator"), frameDisplayNames = this.options.cartesianSmallMultipleFactory.reader.getDisplayNameForFrame(index), subheader = frameDisplayNames && frameDisplayNames.join("".concat(listSeparator));
                    if ($subheader.attr("title", subheader), $subheader.attr("id", "".concat(this.visualInstanceId, "-").concat(index)), 
                    $subheader.empty(), multiplesSubheader.titleWrap && (null === (_a = this.cellDimensions) || void 0 === _a ? void 0 : _a.maxSubheaderHeight) > multiplesSubheader.height + multiplesSubheader.margins.top + multiplesSubheader.margins.bottom) for (var textProperties = (0, 
                    common_fontProperties.qk)(subheaderFontProperties), linesBroken = (0, wordBreaker.ql)(subheader, textProperties, textMeasurementService.b.measureSvgTextWidth, viewport.width, gridLayout.ji, null, !0), i = 0; i < linesBroken.length; i++) {
                        var line = linesBroken[i], $line = $("<div/>").text(line);
                        i === linesBroken.length - 1 && $line.addClass("truncate"), $subheader.append($line);
                    } else $subheader.text(subheader);
                    if (this.interactivityService) {
                        var multiple = multiples.get(index), $cell = $subheader.closest(gridLayoutSelectors.bL.selector);
                        data.styleSubheader($cell, multiple, multiplesSubheader.labelBold);
                    }
                }
            }, CartesianSmallMultipleLayout.prototype.getSubheaderFontProperties = function(index, defaultFontProperties) {
                var subheaderDynamicFontColor = this.getColorFromMultipleObjects(index, {
                    objectName: smallMultiplesUtils.XG,
                    propertyName: "fontColor"
                });
                return null == subheaderDynamicFontColor ? defaultFontProperties : (0, common_fontProperties.ED)(defaultFontProperties, {
                    color: subheaderDynamicFontColor
                });
            }, CartesianSmallMultipleLayout.prototype.getColorFromMultipleObjects = function(frameIndex, propertyId, fallbackColor) {
                var _a;
                if (null != frameIndex) {
                    var frameObjects = null === (_a = this.options.cartesianSmallMultipleFactory.reader.getFrameNode(frameIndex)) || void 0 === _a ? void 0 : _a.objects;
                    if (frameObjects) {
                        var multipleDynamicBackColor = (0, dataViewObject2.W7)(frameObjects, propertyId);
                        if (multipleDynamicBackColor) return multipleDynamicBackColor;
                    }
                }
                return fallbackColor;
            }, CartesianSmallMultipleLayout.prototype.getAxesRenderOptions = function(options) {
                var _this = this;
                return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    axesAnimationOptions: this.options.animationSettings,
                    viewMode: this.viewMode,
                    isSmallMultiples: !0,
                    preserveScrollPosition: !0,
                    navigationScrollCallbacks: {
                        scrollTo: function(index) {
                            return _this.scrollTo(index);
                        },
                        shouldScrollTo: function(index) {
                            return _this.shouldScrollTo(index);
                        },
                        scrollBy: function(steps) {
                            return _this.scrollBy(steps);
                        }
                    }
                });
            }, CartesianSmallMultipleLayout.prototype.renderGridCell = function(multiples, data, background, playAxesRect, suppressAnimations, resizeMode, trimOrdinalDataOnOverflow, categoryLoadMoreDataHandler, isHierarchicalAxis, preserveScrollPosition, formatMode) {
                var _a, viewport = data.viewport, multiple = multiples.get(data.index);
                if (2 & multiple.getState()) multiple.getRenderer().attachToElement(data.element, data.viewport); else {
                    var d3Container = (0, cartesianHelper.MI)(data.element, viewport), d3SmallMultiplesArea = d3Container.element, multipleBehavior = null === (_a = this.cartesianOptions.behaviorFactory) || void 0 === _a ? void 0 : _a.create();
                    multiple.initRenderer(this.buildPlotAreaLayout(!0, d3SmallMultiplesArea, d3Container.clearCatcher, data.element, multipleBehavior));
                }
                if (this.interactivityService) {
                    var $cell = data.element.closest(gridLayoutSelectors.bL.selector);
                    data.bindDataToGridCell($cell, multiple, "multiple");
                }
                this.renderMultiple({
                    multiple,
                    viewport,
                    background,
                    axisZoom: void 0,
                    chartAreaViewport: viewport,
                    chartAreaMargins: (0, cartesianHelper.rX)(),
                    renderedViewport: viewport,
                    playAxesRect,
                    suppressAnimations,
                    resizeMode,
                    trimOrdinalDataOnOverflow,
                    categoryLoadMoreDataHandler,
                    isSharedAxis: !0,
                    isHierarchicalAxis,
                    preserveScrollPosition,
                    supportsScrolling: !0,
                    axesLayout: this.sharedAxisLayout.calculateAxesLayout(multiple.index),
                    formatMode
                });
            }, CartesianSmallMultipleLayout.IconClassName = "cartesianChartResponsiveIcon", 
            CartesianSmallMultipleLayout;
        }(), playChart = __webpack_require__(67174), CartesianChartLayoutBuilder = function() {
            function CartesianChartLayoutBuilder(options, axes, isPlayAxis, adapterFactory) {
                this.options = options, this.axes = axes, this.isPlayAxis = isPlayAxis, this.adapterFactory = adapterFactory;
            }
            return CartesianChartLayoutBuilder.prototype.init = function(options, tooltipService, legend, axesData, interactivityService, layerStyle, rowLoadMoreDataHandler, eventManager) {
                this.initOptions = options, this.tooltipService = tooltipService, this.legend = legend, 
                this.axesData = axesData, this.interactivityService = interactivityService, this.layerStyle = layerStyle, 
                this.rowLoadMoreDataHandler = rowLoadMoreDataHandler, this.eventManager = eventManager;
            }, CartesianChartLayoutBuilder.prototype.create = function(container) {
                var layout = new CartesianChartLayout(this.options, this.axes, this.isPlayAxis, this.axesData, this.adapterFactory);
                return layout.init(container, this.initOptions, this.tooltipService, this.legend, this.interactivityService, this.layerStyle, this.rowLoadMoreDataHandler, this.eventManager), 
                layout;
            }, CartesianChartLayoutBuilder;
        }(), CartesianLegendRender = function() {
            function CartesianLegendRender(legend, data, viewport, interactivity, showTitlePlaceholder) {
                this.legend = legend, this.data = data, this.viewport = viewport, this.interactivity = interactivity, 
                this.showTitlePlaceholder = showTitlePlaceholder;
            }
            return CartesianLegendRender.prototype.render = function(isHierarchicalAxis, formatMode, onObject) {
                if (this.shouldRender()) {
                    var data = this.data;
                    this.legend.setPosition(data.position), 1 !== data.dataPoints.length || data.grouped || ((data = (0, 
                    Prototype.ED)(data)).dataPoints = []), this.legend.drawLegend({
                        data,
                        parentViewport: this.viewport,
                        isHierarchicalAxis,
                        formatMode,
                        onObject,
                        titleSliceUid: "".concat("legend", "-").concat("title", "-titleText"),
                        showTitlePlaceholder: this.showTitlePlaceholder
                    });
                }
            }, CartesianLegendRender.prototype.shouldRender = function() {
                var _a;
                return !(null === (_a = this.interactivity) || void 0 === _a ? void 0 : _a.mobileTileInteractive);
            }, CartesianLegendRender.prototype.getMargin = function() {
                return this.legend.getMargins();
            }, CartesianLegendRender.prototype.getPosition = function() {
                return this.legend.getPosition();
            }, CartesianLegendRender.prototype.adjustChartArea = function(chartArea) {
                (0, legend_util.xz)(chartArea, this.legend);
            }, CartesianLegendRender.prototype.isRenderedLeftOrRight = function() {
                return this.legend.isVisible() && (0, legend_util.cB)(this.legend.getPosition());
            }, CartesianLegendRender;
        }(), CartesianChartLayout = function() {
            function CartesianChartLayout(cartesianOptions, axes, isPlayAxis, axesData, adapterFactory) {
                this.cartesianOptions = cartesianOptions, this.axes = axes, this.isPlayAxis = isPlayAxis, 
                this.axesData = axesData, this.adapterFactory = adapterFactory, this.viewMode = 0, 
                debug.fF.assertValue(cartesianOptions, "CartesianChartLayout.cartesianOptions");
            }
            return Object.defineProperty(CartesianChartLayout.prototype, "featureSwitches", {
                get: function() {
                    return this.cartesianOptions.featureSwitches || {};
                },
                enumerable: !1,
                configurable: !0
            }), CartesianChartLayout.prototype.init = function(element, options, tooltipService, legend, interactivityService, layerStyle, rowLoadMoreDataHandler, eventManager) {
                var _a, _b;
                this.options = options, this.tooltipService = tooltipService, this.legend = legend, 
                this.interactivityService = interactivityService, this.layerStyle = layerStyle, 
                this.element = element, this.rowLoadMoreDataHandler = rowLoadMoreDataHandler, this.eventManager = eventManager, 
                this.hostServices = options.host, this.gridContainer = $(document.createElement("div")).appendTo(this.element), 
                this.gridContainer.addClass(CartesianChartLayout.GridContainerClassName), this.behavior = null === (_a = this.cartesianOptions.behaviorFactory) || void 0 === _a ? void 0 : _a.create(), 
                this.visibilityHelper = (0, responsiveVisualUtil2.q)().visibilityHelper(this.element, CartesianChartLayout.IconClassName);
                var root = d3.select(this.element.get(0)), chartAreaSvg = this.chartAreaSvg = root.append("svg");
                chartAreaSvg.classed(cartesianHelper.Sq, !0), chartAreaSvg.attr("name", this.getCartesianChartName()), 
                chartAreaSvg.style("position", "absolute"), (null === (_b = options.featureSwitches) || void 0 === _b ? void 0 : _b.onObject) && chartAreaSvg.attr(htmlSubSelectionHelper.oy, 0), 
                this.behavior && (this.clearCatcher = (0, services_interactivityService.EX)(chartAreaSvg), 
                this.categoricalAxisBehavior = new CategoricalAxisBehavior), this.viewMode = this.hostServices.getViewMode();
            }, CartesianChartLayout.prototype.getCartesianChartName = function() {
                var str;
                switch (this.cartesianOptions.chartType) {
                  case 0:
                  case 15:
                    str = "LineChart_ToolTip";
                    break;

                  case 1:
                    str = "AreaChart_ToolTip";
                    break;

                  case 2:
                    str = "StackedAreaChart_ToolTip";
                    break;

                  case 3:
                    str = "HundredPercentStackedAreaChart_ToolTip";
                    break;

                  case 4:
                    str = "ClusteredColumnChart_ToolTip";
                    break;

                  case 5:
                    str = "ColumnChart_ToolTip";
                    break;

                  case 6:
                    str = "ClusteredBarChart_ToolTip";
                    break;

                  case 7:
                    str = "BarChart_ToolTip";
                    break;

                  case 8:
                    str = "HundredPercentStackedBarChart_ToolTip";
                    break;

                  case 9:
                    str = "HundredPercentStackedColumnChart_ToolTip";
                    break;

                  case 10:
                    str = "RibbonChart_ToolTip";
                    break;

                  case 11:
                    str = "ScatterChart_ToolTip";
                    break;

                  case 12:
                    str = "WaterfallChart_ToolTip";
                    break;

                  case 13:
                    str = "LineClusteredColumnComboChart_ToolTip";
                    break;

                  case 14:
                    str = "LineStackedColumnComboChart_ToolTip";
                    break;

                  default:
                    str = "Chart";
                }
                return this.hostServices.getLocalizedString(str);
            }, CartesianChartLayout.prototype.render = function(multiples, currentViewport, categoryLoadMoreDataHandler, background, axisZoom, trimOrdinalDataOnOverflow, suppressAnimations, isHierarchicalAxis, preserveScrollPosition, formatMode, subSelectionHelper, isSelected, resizeMode) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var coreMultiple, cartesianData, legendViewport, legendPosition, zoomMargins, playAxesRect, _a;
                    return (0, tslib_es6.__generator)(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return this.cartesianSmallMultipleFactory = multiples, this.viewportScale = currentViewport.scale, 
                            multiples.clearRenderingTimeout(), coreMultiple = multiples.getCoreMultiple(), (cartesianData = coreMultiple.getData()) ? (this.axesData = cartesianData.axesData, 
                            this.formatMode = formatMode, this.isSelected = isSelected, _a = this.renderLegend(cartesianData.legendData, currentViewport, isHierarchicalAxis, formatMode, this.featureSwitches.onObject), 
                            legendPosition = _a[1], this.chartAreaViewport = {
                                height: currentViewport.height - (legendViewport = _a[0]).height,
                                width: currentViewport.width - legendViewport.width,
                                scale: currentViewport.scale
                            }, zoomMargins = axisZoom.renderContainers(this.chartAreaViewport, this.axesData, this.isPlayAxis() ? CartesianChartLayout.PlayAxisBottomMargin : 0, this.featureSwitches), 
                            this.legendRenderer.adjustChartArea(axisZoom.context), this.positionChartArea(legendViewport, legendPosition, this.isPlayAxis(), zoomMargins), 
                            playAxesRect = this.calculatePlayAxisControlLayout(this.chartAreaViewport, legendViewport, this.legendRenderer.getPosition(), zoomMargins), 
                            multiples.isSmallMultiples() ? [ 3, 1 ] : (this.cartesianSmallMultiplesLayout && (this.cartesianSmallMultiplesLayout.destroy(), 
                            this.cartesianSmallMultiplesLayout = void 0), this.setGridContainerVisibility(!1), 
                            2 & coreMultiple.getState() || coreMultiple.initRenderer(this.buildPlotAreaLayout(!1)), 
                            this.renderMultiple({
                                multiple: coreMultiple,
                                viewport: currentViewport,
                                background,
                                axisZoom,
                                chartAreaViewport: this.chartAreaViewport,
                                chartAreaMargins: this.chartAreaMargins,
                                renderedViewport: this.renderedPlotArea,
                                playAxesRect,
                                suppressAnimations,
                                resizeMode,
                                trimOrdinalDataOnOverflow,
                                categoryLoadMoreDataHandler,
                                isSharedAxis: !1,
                                isHierarchicalAxis,
                                preserveScrollPosition,
                                supportsScrolling: !0,
                                formatMode,
                                isSelected,
                                subSelectionHelper
                            }), [ 3, 3 ])) : [ 2 ];

                          case 1:
                            return this.setGridContainerVisibility(!0), this.adjustGridContainer(this.chartAreaViewport), 
                            this.cartesianSmallMultiplesLayout = this.cartesianSmallMultiplesLayout || this.createSmallMultiplesLayout(), 
                            [ 4, this.cartesianSmallMultiplesLayout.render({
                                viewport: this.chartAreaViewport,
                                axisRendererSettings: this.getAxisRendererSettings(this.chartAreaSvg, !0, !1),
                                cartesianSmallMultipleFactory: multiples,
                                axesData: this.axesData,
                                animationSettings: this.getAnimationOptions(!0),
                                background,
                                playAxesRect,
                                suppressAnimations: !0,
                                resizeMode,
                                isHierarchicalAxis,
                                trimOrdinalDataOnOverflow,
                                categoryLoadMoreDataHandler,
                                warnings: cartesianData.warningObjectCollection,
                                formatMode,
                                subSelectionHelper
                            }) ];

                          case 2:
                            _b.sent(), _b.label = 3;

                          case 3:
                            return this.featureSwitches.onObject && subSelectionHelper.addDirectEditPlaceholderOutlines(), 
                            [ 2 ];
                        }
                    });
                });
            }, CartesianChartLayout.prototype.setGridContainerVisibility = function(show) {
                this.gridContainer.css("display", show ? "" : "none");
            }, CartesianChartLayout.prototype.scrollRowsTo = function(position) {
                debug.fF.assertValue(this.cartesianSmallMultiplesLayout, "multiple layout"), this.cartesianSmallMultiplesLayout.scrollRowsTo(position);
            }, CartesianChartLayout.prototype.destroy = function() {
                this.cartesianSmallMultiplesLayout && this.cartesianSmallMultiplesLayout.destroy();
            }, CartesianChartLayout.prototype.positionChartArea = function(legendViewport, legendPosition, hasPlayAxis, zoomMargins) {
                this.chartAreaMargins = (0, cartesianHelper.rX)(), (0, legend_util.nM)(legendPosition) && (this.chartAreaMargins.left = legendViewport.width), 
                (0, legend_util.RB)(legendPosition) && (this.chartAreaMargins.top = legendViewport.height), 
                hasPlayAxis && (this.chartAreaViewport.height -= CartesianChartLayout.PlayAxisBottomMargin), 
                zoomMargins && (this.chartAreaViewport.height -= zoomMargins.top + zoomMargins.bottom, 
                this.chartAreaViewport.width -= zoomMargins.left + zoomMargins.right, this.chartAreaMargins.left = (this.chartAreaMargins.left || 0) + zoomMargins.left, 
                this.chartAreaMargins.top = (this.chartAreaMargins.top || 0) + zoomMargins.top), 
                this.chartAreaSvg.attrs({
                    width: this.chartAreaViewport.width,
                    height: this.chartAreaViewport.height
                }).styles({
                    "margin-top": this.chartAreaMargins.top ? "".concat(this.chartAreaMargins.top, "px") : null,
                    "margin-left": this.chartAreaMargins.left ? "".concat(this.chartAreaMargins.left, "px") : null
                });
            }, CartesianChartLayout.prototype.createSmallMultiplesLayout = function() {
                var _this = this;
                return new CartesianSmallMultipleLayout(this.gridContainer, this.interactivityService, function(id) {
                    return _this.hostServices.getLocalizedString(id);
                }, this.rowLoadMoreDataHandler, this.cartesianOptions, this.layerStyle, this.viewMode, this.buildPlotAreaLayout.bind(this), this.renderMultiple.bind(this), this.adapterFactory, this.hostServices.instanceId, this.eventManager);
            }, CartesianChartLayout.prototype.adjustGridContainer = function(viewport) {
                this.gridContainer.css({
                    width: viewport.width,
                    height: viewport.height
                }), this.legendRenderer.adjustChartArea(d3.select(this.gridContainer.get(0)));
            }, CartesianChartLayout.prototype.getVisibleMultiples = function() {
                return this.cartesianSmallMultiplesLayout ? this.cartesianSmallMultiplesLayout.getVisibleMultiples() : {
                    startIndex: 0,
                    endIndex: 1
                };
            }, CartesianChartLayout.prototype.isSmallMultiples = function() {
                var _a, _b;
                return null !== (_b = null === (_a = this.cartesianSmallMultipleFactory) || void 0 === _a ? void 0 : _a.isSmallMultiples()) && void 0 !== _b && _b;
            }, CartesianChartLayout.prototype.renderMultiple = function(options) {
                var _this = this, layoutOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    axesLayout: void 0,
                    labelAnimationOptions: this.getLabelAnimationOptions(options.suppressAnimations),
                    axesAnimationOptions: this.getAnimationOptions(options.suppressAnimations),
                    layerStyle: this.layerStyle,
                    viewMode: this.viewMode,
                    shouldRenderGridLinesOnly: !1,
                    isSmallMultiples: this.isSmallMultiples(),
                    multipleId: options.multiple.getIndex().toString(),
                    navigationScrollCallbacks: {
                        scrollTo: function(index) {
                            return _this.scrollTo(index);
                        },
                        shouldScrollTo: function(index) {
                            return _this.shouldScrollTo(index);
                        },
                        scrollBy: function(steps) {
                            return _this.scrollBy(steps);
                        }
                    }
                }), data = options.multiple.getData();
                options.isSharedAxis && this.adjustOptionsForSharedAxis(layoutOptions, options.viewport, options.axesLayout, data);
                var renderer = options.multiple.getRenderer();
                renderer.axesRenderer.update(data.axesData, data.scrollbarOptions), renderer.render(options.multiple.layers, data, options.renderedViewport, layoutOptions, this.viewportScale), 
                this.renderedPlotArea = renderer.renderedPlotArea;
            }, CartesianChartLayout.prototype.scrollTo = function(index) {
                this.isSmallMultiples() ? this.cartesianSmallMultiplesLayout.scrollTo(index) : this.cartesianSmallMultipleFactory.scrollTo(index, this.getVisibleMultiples());
            }, CartesianChartLayout.prototype.shouldScrollTo = function(index) {
                return this.isSmallMultiples() ? this.cartesianSmallMultiplesLayout.shouldScrollTo(index) : this.cartesianSmallMultipleFactory.shouldScrollTo(index, this.getVisibleMultiples());
            }, CartesianChartLayout.prototype.scrollBy = function(steps) {
                this.isSmallMultiples() ? this.cartesianSmallMultiplesLayout.scrollBy(steps) : this.cartesianSmallMultipleFactory.scrollBy(steps, this.getVisibleMultiples());
            }, CartesianChartLayout.prototype.getLabelAnimationOptions = function(suppressAnimations) {
                return this.isPlayAxis() ? playChart.Je : this.getAnimationOptions(suppressAnimations);
            }, CartesianChartLayout.prototype.getAnimationOptions = function(suppressAnimations) {
                var _a;
                return {
                    ease: null === (_a = this.cartesianOptions.animator) || void 0 === _a ? void 0 : _a.getEasing(),
                    duration: (0, animatorCommon.Mb)(this.cartesianOptions.animator, suppressAnimations)
                };
            }, CartesianChartLayout.prototype.calculatePlotArea = function(parameters) {
                if (this.isSmallMultiples()) {
                    var plotArea = this.cartesianSmallMultiplesLayout.calculatePlotArea(parameters);
                    return {
                        width: plotArea.width,
                        height: plotArea.height,
                        scale: parameters.viewport.scale
                    };
                }
                var viewport = parameters.viewport, axesMargins = parameters.axesMargins, plotWidth = viewport.width - (axesMargins.left + axesMargins.right);
                return {
                    width: plotWidth - (parameters.showSeriesLabels ? (0, seriesLabelViewModel.lr)(parameters.seriesLabelSettings, plotWidth) : 0),
                    height: viewport.height - (axesMargins.top + axesMargins.bottom),
                    scale: viewport.scale
                };
            }, CartesianChartLayout.prototype.adjustOptionsForSharedAxis = function(options, viewport, axesLayout, data) {
                data.axesData.y.sharedAxis && data.axesData.x.sharedAxis ? (axesLayout.shouldRenderAxis.x = !1, 
                axesLayout.shouldRenderAxis.y = !1, axesLayout.shouldRenderAxis.y2 = !1, axesLayout.margin = axesLayout.tickLabelMargins.axesOverflow, 
                options.shouldRenderGridLinesOnly = !0) : options.shouldRenderGridLinesOnly = !this.axesData.valueAxis.show, 
                axesLayout.viewport = viewport, options.axesLayout = axesLayout;
            }, CartesianChartLayout.prototype.getAxisRendererSettings = function(element, isSmallMultiples, suppressBrush) {
                var _this = this;
                return this.axesData.useManagedTabIndex = !1, {
                    axes: this.axes,
                    container: element,
                    cartesianOptions: this.cartesianOptions,
                    data: this.axesData,
                    interactivity: this.options.interactivity,
                    interactivityService: this.interactivityService,
                    behavior: this.categoricalAxisBehavior,
                    calculatePlotArea: function(parameters) {
                        return _this.calculatePlotArea(parameters);
                    },
                    hostServices: this.hostServices,
                    tooltipService: this.tooltipService,
                    eventManager: this.eventManager,
                    formatMode: this.formatMode,
                    isSelected: this.isSelected,
                    onScroll: isSmallMultiples ? function(delta) {
                        return _this.cartesianSmallMultiplesLayout.onScroll(delta);
                    } : void 0,
                    onExtentUpdate: isSmallMultiples ? function(extent) {
                        return _this.cartesianSmallMultiplesLayout.onExtentUpdate(extent);
                    } : void 0,
                    suppressBrush: isSmallMultiples ? suppressBrush : void 0
                };
            }, CartesianChartLayout.prototype.calculatePlayAxisControlLayout = function(chartAreaViewport, legendViewport, legendPosition, zoomMargins) {
                var layout;
                if (this.isPlayAxis()) {
                    var leftZoomMargin = (null == zoomMargins ? void 0 : zoomMargins.left) || 0, bottomZoomMargin = (null == zoomMargins ? void 0 : zoomMargins.bottom) || 0;
                    layout = {
                        left: (0, legend_util.nM)(legendPosition) ? legendViewport.width : 0,
                        top: (0, legend_util.RB)(legendPosition) ? legendViewport.height + chartAreaViewport.height + bottomZoomMargin : chartAreaViewport.height + bottomZoomMargin,
                        height: CartesianChartLayout.PlayAxisBottomMargin,
                        width: chartAreaViewport.width + leftZoomMargin
                    };
                }
                return layout;
            }, CartesianChartLayout.prototype.renderLegend = function(data, currentViewport, isHierarchicalAxis, formatMode, onObject) {
                return this.legendRenderer = new CartesianLegendRender(this.legend, data, currentViewport, this.options.interactivity, onObject && 1 === this.viewMode && this.isSelected), 
                this.legendRenderer.render(isHierarchicalAxis, formatMode, onObject), [ this.legendRenderer.getMargin(), this.legendRenderer.getPosition() ];
            }, CartesianChartLayout.prototype.buildPlotAreaLayout = function(isSmallMultiples, container, clearCatcher, backgroundContainer, behavior) {
                return container || (container = this.chartAreaSvg), new CartesianPlotAreaLayout(this.cartesianOptions, this.visibilityHelper, container, new CartesianAxesRenderer(this.getAxisRendererSettings(container, isSmallMultiples, isSmallMultiples)), backgroundContainer || this.element, this.hostServices, behavior || this.behavior, this.interactivityService, clearCatcher || this.clearCatcher, isSmallMultiples, this.viewportScale);
            }, CartesianChartLayout.IconClassName = "cartesianChartResponsiveIcon", CartesianChartLayout.GridContainerClassName = "cartesian-grid-container", 
            CartesianChartLayout.PlayAxisBottomMargin = 80, CartesianChartLayout;
        }(), columnChart_capabilities = __webpack_require__(47287), uncertainty_renderer = __webpack_require__(58691), d3Helper = __webpack_require__(34644), CartesianLayer = function() {
            function CartesianLayer(options) {
                var _a;
                this.options = options, debug.fF.assertValue(options, "options:CartesianVisualConstructorOptions"), 
                this._tooltipsEnabled = null !== (_a = options.tooltipsEnabled) && void 0 !== _a && _a;
            }
            return Object.defineProperty(CartesianLayer.prototype, "activeData", {
                get: function() {
                    var _a;
                    return null !== (_a = this.clippedData) && void 0 !== _a ? _a : this.data;
                },
                enumerable: !1,
                configurable: !0
            }), CartesianLayer.prototype.hasData = function() {
                return !!this.data;
            }, Object.defineProperty(CartesianLayer.prototype, "featureSwitches", {
                get: function() {
                    return this.options.featureSwitches || {};
                },
                enumerable: !1,
                configurable: !0
            }), CartesianLayer.prototype.initData = function(options) {
                debug.fF.assertValue(options, "options:CartesianVisualInitDataOptions"), this._currentViewport = options.viewport, 
                this.dataInitOptions = options;
            }, CartesianLayer.prototype.initRenderer = function(options) {
                debug.fF.assertValue(null == options ? void 0 : options.svg, "options:CartesianVisualInitRendererOptions"), 
                this.renderOptions = options;
            }, Object.defineProperty(CartesianLayer.prototype, "tooltipsEnabledSafe", {
                get: function() {
                    var _a, hostTooltips = null === (_a = this.hostService) || void 0 === _a ? void 0 : _a.tooltips();
                    return this.tooltipsEnabled && (!hostTooltips || (null == hostTooltips ? void 0 : hostTooltips.enabled()));
                },
                enumerable: !1,
                configurable: !0
            }), CartesianLayer.prototype.updateCurrentViewport = function(options) {
                this._currentViewport = options.viewport, this._margin = options.margin;
            }, CartesianLayer.prototype.getLegendData = function() {
                var _a;
                return null === (_a = this.data) || void 0 === _a ? void 0 : _a.legendData;
            }, Object.defineProperty(CartesianLayer.prototype, "margin", {
                get: function() {
                    return this._margin;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "style", {
                get: function() {
                    return this.dataInitOptions.style;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "animationOptions", {
                get: function() {
                    return this.dataInitOptions.animation;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "currentViewport", {
                get: function() {
                    return this._currentViewport;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "hostService", {
                get: function() {
                    return this.dataInitOptions.host;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "tooltipService", {
                get: function() {
                    var _a;
                    return null === (_a = this.dataInitOptions.services) || void 0 === _a ? void 0 : _a.tooltips;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "tooltipsEnabled", {
                get: function() {
                    return this._tooltipsEnabled;
                },
                set: function(v) {
                    this._tooltipsEnabled = v;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "element", {
                get: function() {
                    return this.dataInitOptions.element;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "cartesianVisualHost", {
                get: function() {
                    return this.renderOptions.cartesianHost;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "animator", {
                get: function() {
                    return this.renderOptions.animator;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "svg", {
                get: function() {
                    return this.renderOptions.svg;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "availableWidth", {
                get: function() {
                    return Math.max(0, this.currentViewport.width - (this.margin.left + this.margin.right));
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "availableHeight", {
                get: function() {
                    return Math.max(0, this.currentViewport.height - (this.margin.top + this.margin.bottom));
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "interactivityService", {
                get: function() {
                    return this.options.interactivityService;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "mobileTileInteractive", {
                get: function() {
                    var _a, _b;
                    return null !== (_b = null === (_a = this.dataInitOptions.interactivity) || void 0 === _a ? void 0 : _a.mobileTileInteractive) && void 0 !== _b && _b;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "isVisualInteractive", {
                get: function() {
                    var _a, _b;
                    return null !== (_b = null === (_a = this.dataInitOptions.interactivity) || void 0 === _a ? void 0 : _a.isVisualInteractive) && void 0 !== _b && _b;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "dragDataPoint", {
                get: function() {
                    var _a;
                    return null === (_a = this.dataInitOptions.interactivity) || void 0 === _a ? void 0 : _a.dragDataPoint;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianLayer.prototype, "isComboChart", {
                get: function() {
                    return this.options.isComboChart;
                },
                enumerable: !1,
                configurable: !0
            }), CartesianLayer.prototype.isYCategorical = function() {
                return !1;
            }, CartesianLayer.prototype.overrideXAxis = function(xProperties) {
                this.xAxisProperties = xProperties;
            }, CartesianLayer.prototype.onClearSelection = function() {
                var _a;
                null === (_a = this.interactivityService) || void 0 === _a || _a.clearSelection();
            }, Object.defineProperty(CartesianLayer.prototype, "localizer", {
                get: function() {
                    var _this = this;
                    return function(key) {
                        return _this.hostService.getLocalizedString(key);
                    };
                },
                enumerable: !1,
                configurable: !0
            }), CartesianLayer.prototype.getPreferredPlotArea = function(layout) {
                var _a = layout.outerPaddingRatio, plotArea = {
                    height: this.availableHeight,
                    width: this.availableWidth
                };
                if (this.options.isScrollable && !layout.isScalar) {
                    var preferredCategorySpan = layout.categoryThickness * (layout.categoryCount + 2 * (void 0 === _a ? 0 : _a));
                    this.isYCategorical() ? plotArea.height = Math.max(preferredCategorySpan, plotArea.height) : plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            }, CartesianLayer;
        }(), ResponsiveCartesianLayer = function(_super) {
            function ResponsiveCartesianLayer(options) {
                var _this = _super.call(this, options) || this;
                return _this.options = options, _this.viewModelAdapterFactory = options.viewModelAdapterFactory, 
                _this;
            }
            return (0, tslib_es6.__extends)(ResponsiveCartesianLayer, _super), ResponsiveCartesianLayer.prototype.updateCurrentViewport = function(options) {
                _super.prototype.updateCurrentViewport.call(this, options), this.updateViewModelAdapterAndData();
            }, ResponsiveCartesianLayer.prototype.updateViewModelAdapterAndData = function() {
                this.viewModelAdapterFactory && this.originalData && (this.viewModelAdapter = this.viewModelAdapterFactory.create({
                    data: this.originalData,
                    dataView: this.dataView,
                    viewport: this.currentViewport
                }), this.data = this.viewModelAdapter.getData());
            }, ResponsiveCartesianLayer.prototype.addWarnings = function(warningObjectCollection) {
                var _a;
                null === (_a = this.viewModelAdapter) || void 0 === _a || _a.addWarnings(warningObjectCollection);
            }, ResponsiveCartesianLayer;
        }(CartesianLayer), gradientUtils = __webpack_require__(52083), uncertainty_converter = __webpack_require__(7176), uncertainty_util = __webpack_require__(44196), formattingStrategy = __webpack_require__(43906), errorFormat = __webpack_require__(77558), labelPosition1 = __webpack_require__(382), dateWithEpochValue = __webpack_require__(6444), columnChart_util = __webpack_require__(38859), ColumnChartConverter = function() {
            function ColumnChartConverter(options) {
                var _a;
                this.options = options, this.categories = [], this.existingTooltips = [], this.fillTransparency = columnChart_util.fl, 
                debug.fF.assertValue(options.dataView, "dataView"), debug.fF.assertValue(options.style, "style"), 
                this.reader = (0, dataViewCategoricalReader.G)(options.dataView, {
                    staticSeriesRoleNames: [ cartesian_capabilities.x.y ],
                    colorOptions: {
                        valueRole: cartesian_capabilities.x.y,
                        visualStyle: options.style
                    },
                    formatStringProp: cartesian_capabilities.p.general.formatString,
                    errorRangeProp: dataViewObjectProperties.Qx.errorRange
                }), this.seriesCount = this.reader.data.hasValues(ColumnChartConverter.valueRoleName) ? this.reader.data.getSeriesCount() : void 0, 
                this.isStacked = columnChart_util.C3(options.chartType, this.seriesCount);
                var categories = (_a = (0, converterHelper.xh)(options.dataView.categorical, columnChart_capabilities.gE.general.formatString, void 0)).categories, categoryFormatter = _a.categoryFormatter;
                this.categories = categories, this.categoryFormatter = categoryFormatter;
            }
            return Object.defineProperty(ColumnChartConverter.prototype, "displayNames", {
                get: function() {
                    if (!this._displayNames) {
                        var hostServices = this.options.hostServices;
                        this._displayNames = {
                            negative: hostServices.getLocalizedString("Visual_TotalTooltipNegative"),
                            positive: hostServices.getLocalizedString("Visual_TotalTooltipPositive"),
                            net: hostServices.getLocalizedString("Visual_TotalTooltipNet"),
                            simple: hostServices.getLocalizedString("Visual_Total")
                        };
                    }
                    return this._displayNames;
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChartConverter.create = function(options) {
                return new ColumnChartConverter(options);
            }, ColumnChartConverter.convert = function(options) {
                return new ColumnChartConverter(options).convert();
            }, Object.defineProperty(ColumnChartConverter.prototype, "staticObjects", {
                get: function() {
                    return this.reader.objects.getStaticObjects();
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChartConverter.prototype.convert = function() {
                var _a, _b, _c, _d, dataView = (_a = this.options).dataView, style = _a.style, multipleInfo = _a.multipleInfo, chartType = _a.chartType, interactivityService = _a.interactivityService, hostServices = _a.hostServices, isCombo = _a.isComboChart, supportsTotalLabels = _a.supportsTotalLabels, dataViewMetadata = null !== (_c = dataView.metadata) && void 0 !== _c ? _c : null, ribbonChart = 84 === chartType, is100PercentStacked = columnChart_util.Ds(chartType), xAxisCardProperties = (0, 
                cartesianHelper.Vk)(dataViewMetadata, !1), preferredCategoryWidth = (0, cartesianHelper.$K)(xAxisCardProperties), isScalar = (0, 
                cartesianHelper.qU)(null !== (_d = this.options.isScalar) && void 0 !== _d && _d, xAxisCardProperties), categoryMetadata = (0, 
                cartesianHelper.Zo)(dataView.categorical, isScalar).category.source, dataLabelsSettings = columnChart_util.L2(style, is100PercentStacked, isCombo, chartType, this.seriesCount);
                this.staticObjects && (0, dataLabelViewModel1.AR)(this.staticObjects.labels, dataLabelsSettings, !columnChart_util.hg(chartType), style, isCombo);
                var totalLabelsSettings = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataLabelsSettings), {
                    show: !1
                });
                supportsTotalLabels && this.staticObjects && (0, dataLabelViewModel1.ww)(this.staticObjects.totals, totalLabelsSettings, !1, style, isCombo), 
                this.totalLabelsSettings = totalLabelsSettings, this.color = (0, dataViewObject2.W7)(this.staticObjects, columnChart_capabilities.gE.dataPoint.fill, style.colorPalette.dataColors.getColorByIndex(0).value), 
                this.fillTransparency = (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.dataPoint.fillTransparency, columnChart_util.fl), 
                this.borderSettings = this.readBorderSettings(this.staticObjects, (0, columnChart_util.nO)(style), this.color), 
                this.ribbonBandSettings = (0, tslib_es6.__assign)({
                    show: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.ribbonBands.show, ribbonChart)
                }, this.readRibbonSettings(void 0, this.color));
                var defaultSeriesSettings = getDefaultSeriesLabelSettings(style);
                this.staticObjects && ((0, dataLabelViewModel1.FJ)(this.staticObjects.seriesLabels, defaultSeriesSettings, style, isCombo), 
                defaultSeriesSettings.defaultSeriesWidth = defaultSeriesSettings.defaultSeriesWidth ? -1 : null, 
                defaultSeriesSettings.maxWidthPercentage = defaultSeriesSettings.defaultSeriesWidth ? -1 : defaultSeriesSettings.maxWidthPercentage), 
                this.layout = {
                    seriesOrderReversed: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.seriesOrderReversed, columnChart_util.HQ.seriesOrderReversed),
                    seriesOrderSorted: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.seriesOrderSorted, !!ribbonChart || columnChart_util.HQ.seriesOrderSorted),
                    stackedGapSize: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.stackedGapSize, columnChart_util.HQ.stackedGapSize),
                    stackedGapExplodes: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.stackedGapExplodes, columnChart_util.HQ.stackedGapExplodes),
                    clusteredGapSize: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.clusteredGapSize, columnChart_util.HQ.clusteredGapSize),
                    clusteredGapOverlaps: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.clusteredGapOverlaps, columnChart_util.HQ.clusteredGapOverlaps),
                    clusteredGapOverlapReverse: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.clusteredGapOverlapReverse, columnChart_util.HQ.clusteredGapOverlapReverse),
                    ribbonGapSize: (0, dataViewObject2.NA)(this.staticObjects, columnChart_capabilities.gE.layout.ribbonGapSize, columnChart_util.HQ.ribbonGapSize)
                }, (isCombo || is100PercentStacked) && (this.layout.stackedGapExplodes = !1), this.isStacked && (this.layout.stackedGapSize = Math.min(this.layout.stackedGapSize, this.layout.stackedGapExplodes ? columnChart_util._f : columnChart_util.nD)), 
                this.isStacked || (this.layout.clusteredGapSize = Math.min(this.layout.clusteredGapSize, this.layout.clusteredGapOverlaps ? columnChart_util.jL : columnChart_util.E5)), 
                (!this.isStacked || this.layout.stackedGapSize > 0) && (this.borderSettings.outlineOnly = !1);
                var legendData = (_b = this.getLegend()).legendData, seriesSources = _b.seriesSources, legend = legendData.dataPoints, partialResult = this.createDataPoints({
                    legend,
                    defaultDataLabelsSettings: dataLabelsSettings,
                    defaultSeriesSettings,
                    totalLabelsSettings,
                    isScalar,
                    isCombo: !!isCombo,
                    categoryMetadata,
                    multipleInfo
                }), series = partialResult.series, hasHighlights = partialResult.hasHighlights, hasDynamicSeries = partialResult.hasDynamicSeries, labelPositions = columnChart_util.e3(chartType, series.length);
                null != dataLabelsSettings.position && _.includes(labelPositions, dataLabelsSettings.position) || (dataLabelsSettings.position = labelPosition1.h.auto);
                for (var valuesMetadata = [], j = 0, jLen = legend.length; j < jLen; j++) valuesMetadata.push(seriesSources[j]);
                if ((this.layout.seriesOrderSorted || this.isStacked && this.layout.stackedGapSize > 0 || this.borderSettings.outlineOnly) && function(options) {
                    for (var valuesPerCategory_Pos = Array.from({
                        length: options.categoryCount
                    }, function() {
                        return [];
                    }), valuesPerCategory_Neg = Array.from({
                        length: options.categoryCount
                    }, function() {
                        return [];
                    }), countPerCategory = Array.from({
                        length: options.categoryCount
                    }, function() {
                        return 0;
                    }), onlyUpdateIndexFromZero = options.isStacked && options.layout.stackedGapSize > 0 && !options.layout.seriesOrderSorted, _loop_3 = function(series) {
                        for (var _loop_5 = function(dataPointIndex) {
                            var data = series[dataPointIndex];
                            if (data.highlight) return "continue";
                            options.hasHighlights && debug.fF.assert(function() {
                                return series[dataPointIndex + 1].highlight;
                            }, "next item must be a highlight data point"), (data.value >= 0 ? valuesPerCategory_Pos : valuesPerCategory_Neg)[data.categoryIndex].push({
                                data,
                                dataHighlight: options.hasHighlights ? series[dataPointIndex + 1] : void 0
                            }), data.value && countPerCategory[data.categoryIndex]++;
                        }, dataPointIndex = 0; dataPointIndex < series.length; dataPointIndex++) _loop_5(dataPointIndex);
                    }, _i = 0, _a = options.series; _i < _a.length; _i++) _loop_3(_a[_i].data);
                    function sortDataPointsPerCategory(dataPoints, altPointsCount) {
                        var _a;
                        if (!(dataPoints.length < 1)) {
                            dataPoints.sort(function(a, b) {
                                var _a, _b;
                                return Math.abs(null !== (_a = a.data.value) && void 0 !== _a ? _a : 0) - Math.abs(null !== (_b = b.data.value) && void 0 !== _b ? _b : 0);
                            }), options.layout.seriesOrderReversed && dataPoints.reverse();
                            for (var totalCategoryValue = 0, index = 0, indexFromZeroValue = 0; index < dataPoints.length; index++) {
                                var _b = dataPoints[index], mutable = _b.data, mutableHighlight = _b.dataHighlight, preTotalCategoryHeight = totalCategoryValue, value = null !== (_a = mutable.value) && void 0 !== _a ? _a : 0;
                                mutable.indexFromZeroValue = indexFromZeroValue, mutableHighlight && (mutableHighlight.indexFromZeroValue = indexFromZeroValue), 
                                value && indexFromZeroValue++, value > 0 ? (mutable.position = totalCategoryValue += value, 
                                mutable.rank = dataPoints.length - index, mutable.seriesPosition = options.layout.seriesOrderReversed ? altPointsCount + index : dataPoints.length - index - 1) : (mutable.position = totalCategoryValue, 
                                totalCategoryValue += value, mutable.rank = altPointsCount + index + 1, mutable.seriesPosition = options.layout.seriesOrderReversed ? dataPoints.length - index : altPointsCount + index), 
                                mutable.originalPosition = mutable.position, mutableHighlight && (mutableHighlight.rank = mutable.rank, 
                                mutableHighlight.seriesPosition = mutable.seriesPosition, mutableHighlight.position = value > 0 ? preTotalCategoryHeight + mutableHighlight.value : preTotalCategoryHeight, 
                                mutableHighlight.originalPosition = mutable.position);
                            }
                        }
                    }
                    function updateDataPointsPerCategory(dataPoints) {
                        if (!(dataPoints.length < 1)) for (var index = 0, indexFromZeroValue = 0; index < dataPoints.length; index++) {
                            var _a = dataPoints[index], mutableData = _a.data, dataHighlight = _a.dataHighlight;
                            mutableData.indexFromZeroValue = indexFromZeroValue, dataHighlight && (dataHighlight.indexFromZeroValue = indexFromZeroValue), 
                            mutableData.value && indexFromZeroValue++;
                        }
                    }
                    for (var categoryIndex = 0; categoryIndex < options.categoryCount; categoryIndex++) onlyUpdateIndexFromZero ? (updateDataPointsPerCategory(valuesPerCategory_Pos[categoryIndex]), 
                    updateDataPointsPerCategory(valuesPerCategory_Neg[categoryIndex])) : options.layout.seriesOrderSorted && (sortDataPointsPerCategory(valuesPerCategory_Pos[categoryIndex], valuesPerCategory_Neg[categoryIndex].length), 
                    sortDataPointsPerCategory(valuesPerCategory_Neg[categoryIndex], valuesPerCategory_Pos[categoryIndex].length));
                    var _loop_4 = function(categoryIndex) {
                        for (var countOfPointsInCategory = countPerCategory[categoryIndex], indexFromBottom = 0, updateDataIndexFromBottom = function(data) {
                            data.countOfPointsInCategory = countOfPointsInCategory, data.value && (data.indexFromBottom = indexFromBottom, 
                            indexFromBottom++);
                        }, index = valuesPerCategory_Neg[categoryIndex].length - 1; index >= 0; index--) updateDataIndexFromBottom(valuesPerCategory_Neg[categoryIndex][index].data);
                        for (var _b = 0, _c = valuesPerCategory_Pos[categoryIndex]; _b < _c.length; _b++) updateDataIndexFromBottom(_c[_b].data);
                    };
                    for (categoryIndex = 0; categoryIndex < options.categoryCount; categoryIndex++) _loop_4(categoryIndex);
                }({
                    series,
                    hasHighlights,
                    categoryCount: this.categories.length,
                    layout: this.layout,
                    isStacked: this.isStacked
                }), this.isStacked && this.layout.stackedGapSize > 0 && this.layout.stackedGapExplodes) {
                    for (var maxValueAbsolute = 0, _i = 0, series_1 = series; _i < series_1.length; _i++) for (var _e = 0, _f = (aSeries = series_1[_i]).data; _e < _f.length; _e++) (dataPoint = _f[_e]).highlight || (maxValueAbsolute = Math.max(dataPoint.valueAbsolute, maxValueAbsolute));
                    this.layout.stackedGapExplodeStepSize = maxValueAbsolute * this.layout.stackedGapSize / 100;
                    for (var _g = 0, series_2 = series; _g < series_2.length; _g++) for (var _h = 0, _j = (aSeries = series_2[_g]).data; _h < _j.length; _h++) {
                        var dataPoint;
                        columnChart_util.o9(dataPoint = _j[_h], this.layout);
                    }
                }
                for (var positionInSet = 1, categoryIndex = 0; categoryIndex < this.categories.length; categoryIndex++) for (var _k = 0, series_3 = series; _k < series_3.length; _k++) (null == (aSeries = series_3[_k]) ? void 0 : aSeries.data[categoryIndex]) && (aSeries.data[categoryIndex].posinset = positionInSet++);
                if (this.ribbonBandSettings.show && this.categories.length >= 2 && function(options) {
                    for (var formatStringProp = cartesian_capabilities.p.general.formatString, dataViewCategories = options.dataView.categorical.categories, swapPoints = columnChart_util.hg(options.chartType) && !options.isScalar, _loop_6 = function(series) {
                        var seriesData = options.hasHighlights ? _.filter(series.data, function(columnChartDataPoint) {
                            return columnChartDataPoint.highlight;
                        }) : series.data;
                        debug.fF.assert(function() {
                            return null !== series.ribbonBands;
                        }, "ribbonBands must be created per each series in advance");
                        for (var _loop_7 = function(categoryIndex) {
                            var d1 = seriesData[categoryIndex], d2 = seriesData[categoryIndex + 1];
                            if (!d1.value || !d2.value || d1.categoryIndex !== d2.categoryIndex - 1) return "continue";
                            if (swapPoints) {
                                var d = d1;
                                d1 = d2, d2 = d;
                            }
                            var tooltipInfo = [], valueColumnMetadata = options.reader.columns.getValueMetadataColumn(columnChart_capabilities.au.y, series.index), categoryDisplayNameD1 = (0, 
                            concatenateUtils.BJ)((0, concatenateUtils.AD)(dataViewCategories, d1.categoryIndex, formatStringProp)), categoryDisplayNameD2 = (0, 
                            concatenateUtils.BJ)((0, concatenateUtils.AD)(dataViewCategories, d2.categoryIndex, formatStringProp)), getDisplayName = function(categoryDisplayName) {
                                return "".concat(categoryDisplayName, " ").concat(series.displayName).concat(options.hasDynamicSeries ? " ".concat(valueColumnMetadata.displayName) : "");
                            };
                            tooltipInfo.push({
                                displayName: getDisplayName(categoryDisplayNameD1),
                                value: (0, converterHelper.xq)(d1.value, valueColumnMetadata, formatStringProp, !1)
                            }), tooltipInfo.push({
                                displayName: getDisplayName(categoryDisplayNameD2),
                                value: (0, converterHelper.xq)(d2.value, valueColumnMetadata, formatStringProp, !1)
                            });
                            var valueDiff = d2.value - d1.value, formattedValueDiff = (0, converterHelper.xq)(valueDiff, valueColumnMetadata, formatStringProp, !1), formatString = (0, 
                            valueFormatter.Z)("Percentage"), formattedPercentChange = (0, valueFormatter.WU)(valueDiff / d1.value, formatString);
                            if (tooltipInfo.push({
                                displayName: "".concat(valueColumnMetadata.displayName, " ").concat(options.hostServices.getLocalizedString("Change")),
                                value: "".concat(formattedValueDiff, " (").concat(formattedPercentChange, ")")
                            }), null != d1.rank && null != d2.rank) {
                                tooltipInfo.push({
                                    displayName: "".concat(categoryDisplayNameD1, " ").concat(series.displayName, " ").concat(options.hostServices.getLocalizedString("RibbonChart_TooltipRank")),
                                    value: "".concat(d1.rank)
                                }), tooltipInfo.push({
                                    displayName: "".concat(categoryDisplayNameD2, " ").concat(series.displayName, " ").concat(options.hostServices.getLocalizedString("RibbonChart_TooltipRank")),
                                    value: "".concat(d2.rank)
                                });
                                var rankDiff = d2.rank - d1.rank;
                                if (0 !== rankDiff) {
                                    var formattedRankDiff = rankDiff > 0 ? "\u25bc".concat(rankDiff) : "\u25b2".concat(-rankDiff);
                                    tooltipInfo.push({
                                        displayName: "".concat(options.hostServices.getLocalizedString("RibbonChart_TooltipRank"), " ").concat(options.hostServices.getLocalizedString("Change")),
                                        value: formattedRankDiff
                                    });
                                }
                            }
                            series.ribbonBands.dataPoints.push({
                                d1,
                                d2,
                                tooltipInfo
                            });
                        }, categoryIndex = 0; categoryIndex < seriesData.length - 1; categoryIndex++) _loop_7(categoryIndex);
                    }, _i = 0, _a = options.series; _i < _a.length; _i++) _loop_6(_a[_i]);
                }({
                    dataView,
                    isScalar,
                    chartType,
                    series,
                    hasHighlights,
                    hasDynamicSeries,
                    reader: this.reader,
                    hostServices
                }), interactivityService) {
                    for (var _l = 0, series_4 = series; _l < series_4.length; _l++) {
                        var aSeries;
                        interactivityService.applySelectionStateToData((aSeries = series_4[_l]).data);
                    }
                    interactivityService.applySelectionStateToData(legendData.dataPoints);
                }
                return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, partialResult), {
                    categories: this.categories,
                    categoryFormatter: this.categoryFormatter,
                    preferredCategoryWidth,
                    hasY2Role: (0, dataRoleHelper.c5)(dataView, "Y2"),
                    valuesMetadata,
                    legendData,
                    categoryMetadata,
                    isScalar,
                    dataLabelsSettings,
                    seriesLabelSettings: defaultSeriesSettings,
                    totalLabelsSettings,
                    columnStyle: {
                        fillColor: this.color,
                        fillTransparency: this.fillTransparency,
                        border: this.borderSettings
                    },
                    layout: this.layout,
                    ribbonBands: this.ribbonBandSettings,
                    strokeSettings: (0, visualBorderUtil.kG)(style),
                    dataPointsCount: positionInSet
                });
            }, ColumnChartConverter.prototype.createDataPoints = function(options) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _this = this, dataView = (_a = this.options).dataView, chartType = _a.chartType, style = _a.style, hostServices = _a.hostServices, is100PercentStacked = columnChart_util.Ds(chartType), multipleInfo = options.multipleInfo, isCombo = options.isCombo, defaultDataLabelsSettings = options.defaultDataLabelsSettings, defaultSeriesSettings = options.defaultSeriesSettings, isScalar = options.isScalar, seriesCount = this.seriesCount, dataViewCat = dataView.categorical, formatStringProp = cartesian_capabilities.p.general.formatString, grouped = null !== (_c = null === (_b = null == dataViewCat ? void 0 : dataViewCat.values) || void 0 === _b ? void 0 : _b.grouped()) && void 0 !== _c ? _c : void 0, categoryCount = this.categories.length, columnSeries = [], totals = [], categoryData = [];
                if (seriesCount < 1 || categoryCount < 1) return {
                    series: columnSeries,
                    totals,
                    hasPositive: !1,
                    hasNegative: !1,
                    hasNetPositive: !1,
                    hasNetNegative: !1,
                    valuesMetadataBySeries: [],
                    categoryIdentities: [],
                    hasHighlights: !1,
                    hasDynamicSeries: !1,
                    multipleIdentity: void 0,
                    categoryData
                };
                var categoryMetadata, dvCategories = dataViewCat.categories;
                categoryMetadata = _.isEmpty(dvCategories) ? null : _.last(dvCategories).source;
                var multipleIdentity, multipleQueryName, multipleValueDetails, categoryType = (0, 
                cartesianAxisHelper.getCategoryValueType)(categoryMetadata), isCategoryDateTimeType = (0, 
                axisHelper.v9)(categoryType), rawValues = [], rawHighlightValues = [], categoryIdentities = [], valueMetadataColumns = [], valuesMetadataBySeries = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source);
                multipleInfo && (multipleQueryName = _.first(multipleInfo.sources).metadata.queryName, 
                multipleValueDetails = multipleInfo.sources.map(function(source) {
                    return (0, selection_selectionId.Y)(source.metadata, source.value, multipleInfo.identity);
                }), multipleIdentity = (new selection_selectionId.dw).withColumnIdentity(multipleInfo.identity, multipleQueryName, multipleValueDetails).createSelectionId());
                for (var highlightsOverflow = !1, hasHighlights = this.reader.data.hasHighlights(), seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        var value = this.getValueBySeriesAndCategory(seriesIndex, categoryIndex), formatString = this.getFormatStringBySeriesAndCategory(seriesIndex, categoryIndex);
                        if (seriesValues[categoryIndex] = {
                            value,
                            formatString
                        }, hasHighlights) {
                            var highlightValue = this.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex), highlightFormatString = this.getHighlightFormatStringBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesHighlightValues[categoryIndex] = {
                                value: highlightValue,
                                formatString: highlightFormatString
                            }, null == value || null == highlightValue || value >= 0 && highlightValue >= 0 && (0, 
                            Double.bA)(value, highlightValue) || value <= 0 && highlightValue <= 0 && (0, Double.bl)(value, highlightValue) || (highlightsOverflow = !0);
                        }
                    }
                    rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                }
                highlightsOverflow && !columnChart_util.G1(chartType, seriesCount) && (highlightsOverflow = !1, 
                hasHighlights = !1, rawValues = rawHighlightValues);
                for (var multipliers = is100PercentStacked ? generate100StackedMultipliers(categoryCount, seriesCount, function(seriesIndex, categoryIndex) {
                    return rawValues[seriesIndex][categoryIndex].value;
                }) : [], defaultLabelColor = defaultDataLabelsSettings.fontProperties.color, defaultTotalLabelColor = this.totalLabelsSettings.fontProperties.color, _loop_1 = function(s) {
                    var seriesIndex = s, positioningIndex = this_1.layout.seriesOrderReversed ? seriesCount - s - 1 : s, dynamicLabelsEnabledForSeries = this_1.reader.labels.dynamicLabelReader.areDynamicValueLabelsEnabled(null === (_d = this_1.options.featureSwitches) || void 0 === _d ? void 0 : _d.labelEnhancementsM0, positioningIndex, hasHighlights), seriesDataPoints = [], legendItem = options.legend[positioningIndex], columnChartDataLabelsSettings = void 0, seriesLabelSettings = (0, 
                    Prototype.ED)(defaultSeriesSettings);
                    if (this_1.reader.data.hasSeries() || isCombo) {
                        var seriesObjects, labelObjects = (seriesObjects = isCombo && !this_1.reader.data.hasSeries() ? this_1.reader.objects.getValueMetadataObjects(ColumnChartConverter.valueRoleName, positioningIndex) : this_1.reader.objects.getSeriesDataObjects(positioningIndex)) && seriesObjects.labels, labelSeriesObjects = seriesObjects && seriesObjects.seriesLabels;
                        (columnChartDataLabelsSettings = (0, Prototype.ED)(defaultDataLabelsSettings)).show = defaultDataLabelsSettings.show && (null === (_e = defaultDataLabelsSettings.showByDefault) || void 0 === _e || _e), 
                        labelObjects && (0, dataLabelViewModel1.AR)(labelObjects, columnChartDataLabelsSettings, void 0, style, isCombo), 
                        seriesLabelSettings.show = defaultSeriesSettings.show && (null === (_f = defaultSeriesSettings.showByDefault) || void 0 === _f || _f), 
                        labelSeriesObjects && (0, dataLabelViewModel1.FJ)(labelSeriesObjects, seriesLabelSettings, style, isCombo);
                    }
                    var valueColumn = this_1.reader.columns.getValueColumnBySeries(positioningIndex), valueColumnMetadata = valueMetadataColumns[positioningIndex] = this_1.reader.columns.getValueMetadataColumn(ColumnChartConverter.valueRoleName, positioningIndex), valueColumnIndex = _.findIndex(valueMetadataColumns, valueColumnMetadata);
                    -1 !== valueColumnIndex && (valuesMetadataBySeries[valueColumnIndex] ? valuesMetadataBySeries[valueColumnIndex].usedInSeriesIndices.push(positioningIndex) : valuesMetadataBySeries[valueColumnIndex] = {
                        metadataColumn: valueColumnMetadata,
                        usedInSeriesIndices: [ positioningIndex ],
                        valueSelector: (new selection_selectionId.dw).withMeasure(valueColumnMetadata.queryName, valueColumn).createSelectionId()
                    });
                    var measureUncertainty = (0, uncertainty_converter.nC)(this_1.isStacked ? {} : valueColumnMetadata.objects, style, legendItem.marker.color, positioningIndex, (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, defaultDataLabelsSettings), {
                        show: !1
                    }), {
                        isCombo,
                        hideBand: !0,
                        valueAxisHorizontal: columnChart_util.hg(chartType),
                        staticObjects: this_1.staticObjects
                    }), hasUncertainty = measureUncertainty.hasUncertainty, seriesData = (0, tslib_es6.__assign)((0, 
                    tslib_es6.__assign)({
                        displayName: legendItem.label,
                        key: "series".concat(positioningIndex),
                        index: positioningIndex,
                        data: seriesDataPoints,
                        identity: legendItem.identity,
                        columnStyle: {
                            fillColor: legendItem.marker.color,
                            fillTransparency: legendItem.marker.transparency,
                            border: legendItem.marker.stroke
                        }
                    }, this_1.ribbonBandSettings.show && {
                        ribbonBands: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, this_1.readRibbonSettings(positioningIndex, legendItem.marker.color)), {
                            dataPoints: []
                        })
                    }), {
                        labelSettings: columnChartDataLabelsSettings,
                        uncertainty: measureUncertainty,
                        measureDisplayName: valueColumnMetadata.displayName,
                        type: valueColumnMetadata.type,
                        seriesLabelSettings
                    });
                    columnSeries.push(seriesData);
                    for (var gradientMeasureIndex = (0, gradientUtils.yj)(dataViewCat), gradientValueColumn = (0, 
                    gradientUtils.Rr)(dataViewCat), pctFormatString = (0, valueFormatter.Z)("Percentage"), hasCheckedLabelModificationForSeries = !1, _loop_2 = function(categoryIndex) {
                        var _r, _s, rawValue = (_r = rawValues[positioningIndex][categoryIndex]).value, formatString = _r.formatString, originalValue = (0, 
                        axisHelper.eT)(rawValue);
                        if (null == originalValue && seriesIndex > 0) return "continue";
                        var originalCategoryValue = this_1.categories[categoryIndex];
                        if (isCategoryDateTimeType && null != originalCategoryValue && !(originalCategoryValue instanceof Date)) return "continue";
                        var dataPointUncertainty, categoryValue = void 0;
                        if (originalCategoryValue instanceof Date ? (debug.fF.assert(function() {
                            return isCategoryDateTimeType;
                        }, "Metadata type and value type must match"), debug.fF.assert(function() {
                            return (0, dateWithEpochValue.M4)(originalCategoryValue);
                        }, "originalCategoryValue"), categoryValue = originalCategoryValue.epochTimeStamp) : categoryValue = originalCategoryValue, 
                        isScalar && (null == categoryValue || isNaN(categoryValue))) return "continue";
                        hasUncertainty && (dataPointUncertainty = (0, uncertainty_converter.PT)(this_1.reader.data, categoryIndex, positioningIndex, originalValue));
                        var isNegative = originalValue < 0;
                        null !== (_g = totals[categoryIndex]) && void 0 !== _g || (totals[categoryIndex] = {
                            positive: 0,
                            positiveCount: 0,
                            negative: 0,
                            negativeCount: 0,
                            net: 0,
                            categoryValue,
                            categoryIndex,
                            dynamicFormatString: formatString
                        }), null !== (_h = (_p = totals[categoryIndex]).dynamicFormatString) && void 0 !== _h || (_p.dynamicFormatString = formatString);
                        var totalLabelFill = (0, dataLabelUtil.AO)({
                            defaultColor: defaultTotalLabelColor,
                            categoricalDataReader: this_1.reader,
                            categoryIndex,
                            seriesIndex
                        }), fontPropTotalColor = (0, dataLabelUtil.B8)(totalLabelFill) ? totalLabelFill.color : defaultLabelColor;
                        this_1.totalLabelsSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropTotalColor, this_1.totalLabelsSettings.fontProperties), 
                        totals[categoryIndex].labelFill = totalLabelFill.color;
                        var value = null == originalValue ? null : originalValue * (is100PercentStacked ? multipliers[categoryIndex][isNegative ? "neg" : "pos"] : 1), valueAbsolute = Math.abs(value), position = void 0;
                        isNegative ? (position = totals[categoryIndex].negative, isNaN(valueAbsolute) || (totals[categoryIndex].negative -= valueAbsolute, 
                        totals[categoryIndex].negativeCount++, totals[categoryIndex].net -= valueAbsolute)) : (isNaN(valueAbsolute) || (totals[categoryIndex].positive += valueAbsolute, 
                        totals[categoryIndex].positiveCount++, totals[categoryIndex].net += valueAbsolute), 
                        position = totals[categoryIndex].positive);
                        var seriesGroup = grouped && grouped.length > positioningIndex && grouped[positioningIndex].values ? grouped[positioningIndex] : null, category = _.isEmpty(dataViewCat.categories) ? null : dataViewCat.categories[0], identity = (_s = ColumnChartConverter.createIdentities(dataViewCat, category, categoryIndex, seriesGroup, this_1.reader.columns.getValueColumn(ColumnChartConverter.valueRoleName, positioningIndex), valueColumnMetadata, multipleInfo, multipleQueryName, multipleValueDetails)).identity, identityKey = _s.identityKey;
                        null !== (_j = categoryIdentities[categoryIndex]) && void 0 !== _j || (categoryIdentities[categoryIndex] = function() {
                            return (0, cartesianHelper.MH)(categoryIndex, category);
                        });
                        var valueHighlight, highlightFormatString, uncertaintyHighlight, unadjustedValueHighlight, gradientColumnForTooltip = 0 === gradientMeasureIndex ? null : gradientValueColumn;
                        hasHighlights && (valueHighlight = this_1.reader.data.getHighlight(ColumnChartConverter.valueRoleName, categoryIndex, positioningIndex), 
                        highlightFormatString = this_1.reader.data.getHighlightFormatString(ColumnChartConverter.valueRoleName, categoryIndex, positioningIndex), 
                        unadjustedValueHighlight = valueHighlight, null !== valueHighlight && (hasUncertainty && (uncertaintyHighlight = (0, 
                        uncertainty_converter.PT)(this_1.reader.data, categoryIndex, positioningIndex, valueHighlight, !0)), 
                        is100PercentStacked && (valueHighlight *= multipliers[categoryIndex][isNegative ? "neg" : "pos"])));
                        var tooltipBuilder, hierarchyCategoryLevels = category ? (0, concatenateUtils.AD)(dataView.categorical.categories, categoryIndex, formatStringProp) : void 0;
                        this_1.options.tooltipsEnabled && (tooltipBuilder = new Visuals_tooltip.E4).withLazyValues(function() {
                            var _a, tooltipInfo = [];
                            if (multipleInfo) {
                                var getMultipleTooltip = (0, Visuals_tooltip.Q6)(multipleInfo.sources.map(function(source) {
                                    return source.metadata;
                                }), multipleInfo.sources.map(function(source) {
                                    return source.value;
                                }), !0, (0, formattingStrategy.F)(formatStringProp));
                                getMultipleTooltip && tooltipInfo.push(getMultipleTooltip());
                            }
                            category && tooltipInfo.push((0, concatenateUtils.bR)(hierarchyCategoryLevels)), 
                            hasDynamicSeries && (category && category.source === dataViewCat.values.source || tooltipInfo.push({
                                displayName: dataViewCat.values.source.displayName,
                                value: (0, converterHelper.xq)(grouped[positioningIndex].name, dataViewCat.values.source, formatStringProp)
                            }));
                            var valueFormatterFunc = function(givenValue) {
                                return (0, converterHelper.xq)(givenValue, valueColumnMetadata, formatStringProp, !1, formatString);
                            };
                            if (null != originalValue) {
                                var formattedOriginalValue = valueFormatterFunc(originalValue), valueString = is100PercentStacked ? "".concat(formattedOriginalValue, " (").concat((0, 
                                valueFormatter.WU)(valueAbsolute, pctFormatString), ")") : formattedOriginalValue, tooltip = {
                                    displayName: valueColumnMetadata.displayName,
                                    value: valueString
                                }, tooltipProperties = measureUncertainty.tooltips;
                                if (hasUncertainty && !hasHighlights && tooltipProperties.show && tooltipProperties.format === errorFormat.K.range) {
                                    var tooltipItems_1 = (0, uncertainty_util.kS)(dataPointUncertainty, value, measureUncertainty, valueFormatterFunc, hostServices, {
                                        overrideDisplayName: valueColumnMetadata.displayName
                                    });
                                    debug.fF.assert(function() {
                                        return void 0 === tooltipItems_1 || 1 === tooltipItems_1.length;
                                    }, "getUncertaintyTooltipItems() with 'range' format should return exactly one item"), 
                                    _.isEmpty(tooltipItems_1) || (tooltip = tooltipItems_1[0]);
                                }
                                tooltipInfo.push(tooltip);
                            }
                            if (hasHighlights) {
                                var tooltipValue = void 0;
                                if (null !== unadjustedValueHighlight && null !== valueHighlight) {
                                    var highlightedPct = (0, valueFormatter.WU)(valueHighlight, pctFormatString), highlightedValueFormat = (0, 
                                    converterHelper.xq)(unadjustedValueHighlight, valueColumnMetadata, formatStringProp, !1, highlightFormatString);
                                    tooltipValue = is100PercentStacked ? "".concat(highlightedValueFormat, " (").concat(highlightedPct, ")") : highlightedValueFormat;
                                }
                                if (valueFormatterFunc = function(givenValue) {
                                    return (0, converterHelper.xq)(givenValue, valueColumnMetadata, formatStringProp, !1, highlightFormatString);
                                }, tooltipValue) if (tooltipProperties = measureUncertainty.tooltips, hasUncertainty && tooltipProperties.show && tooltipProperties.format === errorFormat.K.range) {
                                    var tooltipItems_2 = (0, uncertainty_util.kS)(dataPointUncertainty, value, measureUncertainty, valueFormatterFunc, hostServices, {
                                        overrideDisplayName: Visuals_tooltip.I6.localizationOptions.highlightedValueDisplayName
                                    });
                                    debug.fF.assert(function() {
                                        return void 0 === tooltipItems_2 || 1 === tooltipItems_2.length;
                                    }, "getUncertaintyTooltipItems() with 'range' format should return exactly one item"), 
                                    _.isEmpty(tooltipItems_2) ? tooltipInfo.push({
                                        displayName: Visuals_tooltip.I6.localizationOptions.highlightedValueDisplayName,
                                        value: tooltipValue
                                    }) : tooltipInfo.push(tooltipItems_2[0]);
                                } else tooltipInfo.push({
                                    displayName: Visuals_tooltip.I6.localizationOptions.highlightedValueDisplayName,
                                    value: tooltipValue
                                });
                            }
                            if (hasUncertainty && measureUncertainty.tooltips.format !== errorFormat.K.range) {
                                var uncertainty = hasHighlights ? uncertaintyHighlight : dataPointUncertainty;
                                uncertainty && tooltipInfo.push.apply(tooltipInfo, (0, uncertainty_util.kS)(uncertainty, originalValue, measureUncertainty, valueFormatterFunc, hostServices, {
                                    hideMarker: !0
                                }));
                            }
                            gradientColumnForTooltip && null != gradientColumnForTooltip.values[categoryIndex] && tooltipInfo.push({
                                displayName: gradientColumnForTooltip.source.displayName,
                                value: (0, converterHelper.xq)(gradientColumnForTooltip.values[categoryIndex], gradientColumnForTooltip.source, formatStringProp, !1, (0, 
                                dataViewObject2.NA)(null === (_a = gradientColumnForTooltip.objects) || void 0 === _a ? void 0 : _a[categoryIndex], formatStringProp))
                            }), (0, Visuals_tooltip.VT)(_this.reader, tooltipInfo, categoryIndex, hasDynamicSeries ? positioningIndex : void 0, formatStringProp);
                            var tooltipTotal = _this.getTotalTooltip(positioningIndex, categoryIndex, isNegative, totals, valueMetadataColumns, formatStringProp);
                            return tooltipTotal && tooltipInfo.push(tooltipTotal), tooltipInfo;
                        });
                        var dataPointLabelSettings = null !== (_k = columnSeries[seriesIndex].labelSettings) && void 0 !== _k ? _k : defaultDataLabelsSettings, dataLabelFillColorOptions = {
                            defaultColor: defaultLabelColor,
                            seriesColor: null == columnChartDataLabelsSettings ? void 0 : columnChartDataLabelsSettings.fontProperties.color,
                            categoricalDataReader: this_1.reader,
                            categoryIndex,
                            seriesIndex: positioningIndex
                        }, dataLabelValueColor = (0, dataLabelUtil.t$)(dataLabelFillColorOptions), labelCreatorSettings = {
                            dataPointLabelSettings,
                            defaultLabelSettings: defaultDataLabelsSettings,
                            categoricalDataReader: this_1.reader,
                            categoryIndex,
                            seriesIndex: positioningIndex,
                            hasHighlights,
                            dynamicLabelsEnabledForSeries,
                            featureSwitches: this_1.options.featureSwitches
                        }, appendedLabelContents = (0, dataLabelUtil.Xc)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labelCreatorSettings), {
                            dataLabelFillColorOptions,
                            detailPropertyId: columnChart_capabilities.mi.labels.dynamicLabelDetail,
                            titlePropertyId: columnChart_capabilities.mi.labels.dynamicLabelTitle
                        })), dynamicLabelValue = (0, dataLabelUtil.tI)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labelCreatorSettings), {
                            valuePropertyId: columnChart_capabilities.mi.labels.dynamicLabelValue
                        }));
                        if (!hasCheckedLabelModificationForSeries && (null === (_l = this_1.options.featureSwitches) || void 0 === _l ? void 0 : _l.labelEnhancementsM0) && !_.isEmpty(appendedLabelContents)) {
                            var detailLabel = appendedLabelContents && (null === (_m = appendedLabelContents.find(function(label) {
                                return "Detail" === label.role;
                            })) || void 0 === _m ? void 0 : _m.dynamicLabel), isDetailLabelEnabled = (null == detailLabel ? void 0 : detailLabel.enabled) && null != (null == detailLabel ? void 0 : detailLabel.value);
                            if (isDetailLabelEnabled) {
                                var isStacked100 = columnChart_util.Ds(chartType);
                                (0, dataLabelUtil.hY)(hostServices, isStacked100, null == dynamicLabelValue ? void 0 : dynamicLabelValue.enabled, isDetailLabelEnabled, dataPointLabelSettings);
                            }
                            hasCheckedLabelModificationForSeries = !0;
                        }
                        var columnChartDataPoint = (0, tslib_es6.__assign)({
                            categoryValue,
                            position,
                            categoryIndex,
                            seriesIndex,
                            seriesPosition: positioningIndex,
                            labelSettings: dataPointLabelSettings,
                            columnStyle: function() {
                                if (_this.reader.columns.hasDynamicSeries() || _this.reader.columns.hasStaticSeries() || !_this.reader.columns.hasCategories() || null == categoryIndex) return seriesData.columnStyle;
                                var fillColor = _this.reader.colors.createBySeries(positioningIndex, categoryIndex), categoryObjects = _this.reader.objects.getCategoryDataObjects(categoryIndex);
                                return {
                                    fillColor,
                                    fillTransparency: (0, dataViewObject2.NA)(categoryObjects, columnChart_capabilities.gE.dataPoint.fillTransparency, _this.fillTransparency),
                                    border: _this.readBorderSettings(categoryObjects, _this.borderSettings, fillColor)
                                };
                            }(),
                            selected: !1,
                            originalValue,
                            originalPosition: position,
                            labelFill: dataLabelValueColor.color,
                            dynamicLabelValue,
                            value,
                            valueAbsolute,
                            indexFromZeroValue: this_1.isStacked ? seriesIndex : 0,
                            uncertainty: dataPointUncertainty,
                            identity,
                            key: identityKey,
                            labelFormatString: formatString || valueColumnMetadata.format
                        }, this_1.options.featureSwitches.labelEnhancementsM0 && {
                            appendedLabelContents,
                            labelDataPointContainerEnabled: !0
                        });
                        if (null !== (_o = categoryData[categoryIndex]) && void 0 !== _o || (categoryData[categoryIndex] = extractCategoryFromDataPoint(columnChartDataPoint, hierarchyCategoryLevels)), 
                        categoryData[categoryIndex] && ((_q = categoryData[categoryIndex]).hasData || (_q.hasData = null != columnChartDataPoint.value)), 
                        seriesDataPoints.push((0, tslib_es6.__assign)({
                            get tooltipInfo() {
                                return null == tooltipBuilder ? void 0 : tooltipBuilder.getTooltipItems();
                            },
                            get formattedTooltip() {
                                return null == tooltipBuilder ? void 0 : tooltipBuilder.getFormattedTooltipItems();
                            }
                        }, columnChartDataPoint)), hasHighlights) {
                            var absoluteValueHighlight = null !== valueHighlight ? Math.abs(valueHighlight) : 0, highlightIdentity = selection_selectionId.l0.createWithHighlight(identity);
                            seriesDataPoints.push((0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                                get tooltipInfo() {
                                    return null == tooltipBuilder ? void 0 : tooltipBuilder.getTooltipItems();
                                },
                                get formattedTooltip() {
                                    return tooltipBuilder && tooltipBuilder.getFormattedTooltipItems();
                                }
                            }, columnChartDataPoint), {
                                value: valueHighlight,
                                position: getHighlightPosition(position, value, valueHighlight, valueAbsolute, absoluteValueHighlight),
                                valueAbsolute: absoluteValueHighlight,
                                uncertainty: uncertaintyHighlight,
                                highlight: !0,
                                drawThinner: highlightsOverflow,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                pairKey: identityKey,
                                labelFormatString: highlightFormatString || valueColumnMetadata.format
                            }));
                        }
                    }, categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) _loop_2(categoryIndex);
                }, this_1 = this, s = 0; s < seriesCount; s++) _loop_1(s);
                for (var hasPositive = !1, hasNegative = !1, hasNetPositive = !1, hasNetNegative = !1, _i = 0, totals_1 = totals; _i < totals_1.length; _i++) {
                    var total = totals_1[_i];
                    total && (hasPositive || (hasPositive = total.positive > 0), hasNegative || (hasNegative = total.negative < 0), 
                    hasNetPositive || (hasNetPositive = total.net > 0), hasNetNegative || (hasNetNegative = total.net < 0));
                }
                return this.hasNetPositive = hasNetPositive, this.hasNetNegative = hasNetNegative, 
                {
                    series: columnSeries,
                    totals,
                    hasPositive,
                    hasNegative,
                    hasNetPositive,
                    hasNetNegative,
                    valuesMetadataBySeries,
                    categoryIdentities,
                    hasHighlights,
                    hasDynamicSeries,
                    multipleIdentity,
                    categoryData
                };
            }, ColumnChartConverter.createIdentities = function(dataViewCat, category, categoryIndex, seriesGroup, valueColumn, valueColumnMetadata, multipleInfo, multipleQueryName, multipleValueDetails) {
                var _a, withCategory = dataViewCat.originalCategories || [ category ], idBuilder = selection_selectionId.dw.builder().withCategory(withCategory, categoryIndex, null === (_a = null == category ? void 0 : category.source) || void 0 === _a ? void 0 : _a.queryName, !0).withSeries(dataViewCat.values, seriesGroup, !0).withMeasure(valueColumnMetadata.queryName, valueColumn, categoryIndex);
                multipleInfo && (idBuilder = idBuilder.withColumnIdentity(multipleInfo.identity, multipleQueryName, multipleValueDetails));
                var identity = idBuilder.createSelectionId();
                return {
                    identity,
                    identityKey: identity.getKey()
                };
            }, ColumnChartConverter.prototype.getTotalTooltip = function(seriesIndex, categoryIndex, isNegative, totals, valueMetadataColumns, formatStringProp) {
                var _a, _b, _c, _d, _e, _f;
                if (this.options.tooltipsEnabled && this.options.supportsTotalLabels && this.totalLabelsSettings.show) {
                    if (null !== (_a = (_d = this.existingTooltips)[categoryIndex]) && void 0 !== _a || (_d[categoryIndex] = {}), 
                    this.totalLabelsSettings.showPositiveAndNegative) {
                        var signKey = isNegative ? "negative" : "positive";
                        return null !== (_b = (_e = this.existingTooltips[categoryIndex])[signKey]) && void 0 !== _b || (_e[signKey] = {
                            displayName: this.displayNames[signKey],
                            value: (0, converterHelper.xq)(totals[categoryIndex][signKey], valueMetadataColumns[seriesIndex], formatStringProp, !1)
                        }), this.existingTooltips[categoryIndex][signKey];
                    }
                    return null !== (_c = (_f = this.existingTooltips[categoryIndex]).net) && void 0 !== _c || (_f.net = {
                        displayName: this.hasNetPositive && this.hasNetNegative ? this.displayNames.net : this.displayNames.simple,
                        value: (0, converterHelper.xq)(totals[categoryIndex].net, valueMetadataColumns[seriesIndex], formatStringProp, !1, totals[categoryIndex].dynamicFormatString)
                    }), this.existingTooltips[categoryIndex].net;
                }
            }, ColumnChartConverter.prototype.readRibbonSettings = function(seriesIndex, columnFillColor) {
                var generalSettings = void 0 === seriesIndex, dataViewObjects = generalSettings ? this.staticObjects : this.reader.objects.getSeriesDataObjects(seriesIndex), defaults = generalSettings ? columnChart_util.bS(this.options.style) : this.ribbonBandSettings, fillColor = (0, 
                dataViewObject2.W7)(dataViewObjects, columnChart_capabilities.gE.ribbonBands.fillColor, defaults.fillColor), fillMatchColor = (0, 
                dataViewObject2.NA)(dataViewObjects, columnChart_capabilities.gE.ribbonBands.fillMatchColor, defaults.fillMatchColor);
                return fillMatchColor && columnFillColor && (fillColor = columnFillColor), {
                    fillColor,
                    fillMatchColor,
                    fillTransparency: (0, dataViewObject2.NA)(dataViewObjects, columnChart_capabilities.gE.ribbonBands.fillTransparency, defaults.fillTransparency),
                    border: (0, common_strokeStyle.QI)(dataViewObjects, {
                        strokeShow: columnChart_capabilities.gE.ribbonBands.borderShow,
                        strokeWidth: columnChart_capabilities.gE.ribbonBands.borderSize,
                        strokeColor: columnChart_capabilities.gE.ribbonBands.borderColor,
                        strokeColorMatch: columnChart_capabilities.gE.ribbonBands.borderColorMatchFill,
                        strokeTransparency: columnChart_capabilities.gE.ribbonBands.borderTransparency
                    }, defaults.border, fillColor)
                };
            }, ColumnChartConverter.prototype.readBorderSettings = function(objects, defaults, matchColor) {
                var strokeStyle = (0, common_strokeStyle.QI)(objects, {
                    strokeShow: columnChart_capabilities.gE.dataPoint.borderShow,
                    strokeWidth: columnChart_capabilities.gE.dataPoint.borderSize,
                    strokeColor: columnChart_capabilities.gE.dataPoint.borderColor,
                    strokeColorMatch: columnChart_capabilities.gE.dataPoint.borderColorMatchFill,
                    strokeTransparency: columnChart_capabilities.gE.dataPoint.borderTransparency
                }, defaults, matchColor);
                return strokeStyle.outlineOnly = (0, dataViewObject2.NA)(objects, columnChart_capabilities.gE.dataPoint.borderOutlineOnly, null == defaults ? void 0 : defaults.outlineOnly), 
                strokeStyle;
            }, ColumnChartConverter.prototype.getLegend = function() {
                var _a, _b, _c, _d, _e, title, dataPoints = [], seriesSources = [], seriesObjects = [], grouped = !1, dataView = null === (_a = this.options.dataView) || void 0 === _a ? void 0 : _a.categorical;
                if (null == dataView ? void 0 : dataView.values) {
                    for (var seriesLength = this.reader.columns.getSeriesCount(cartesian_capabilities.x.y), seriesIndex = 0; seriesIndex < seriesLength; seriesIndex++) {
                        var source = this.reader.columns.getValueMetadataColumnBySeries(seriesIndex), objects = this.reader.objects.getSeriesDataObjects(seriesIndex);
                        seriesSources.push(source), seriesObjects.push(objects);
                        var fillColor = null !== (_b = this.reader.colors.createBySeries(seriesIndex)) && void 0 !== _b ? _b : this.color;
                        dataPoints.push({
                            marker: {
                                show: !0,
                                shape: markerShape.ZO.circle,
                                color: fillColor,
                                transparency: (0, dataViewObject2.NA)(objects, columnChart_capabilities.gE.dataPoint.fillTransparency, this.fillTransparency),
                                stroke: this.readBorderSettings(objects, this.borderSettings, fillColor)
                            },
                            label: this.reader.data.hasSeries() ? (0, valueFormatter.WU)(this.reader.data.getSeriesName(seriesIndex), this.reader.objects.getSeriesFormatString(seriesIndex)) : (0, 
                            converterHelper.TO)(source, dataView.values, cartesian_capabilities.p.general.formatString),
                            identity: this.reader.data.hasSeries() ? this.reader.identities.createForSeries(seriesIndex) : this.reader.identities.createForValue(0),
                            selected: !1,
                            index: seriesIndex
                        }), void 0 !== source.groupName && (grouped = !0);
                    }
                    title = null !== (_e = null === (_d = null === (_c = dataView.values) || void 0 === _c ? void 0 : _c.source) || void 0 === _d ? void 0 : _d.displayName) && void 0 !== _e ? _e : "";
                }
                return {
                    legendData: (0, legend_converter.RS)(this.staticObjects, dataPoints, !0, title, grouped, this.options.style, void 0),
                    seriesSources,
                    seriesObjects
                };
            }, ColumnChartConverter.prototype.getValueBySeriesAndCategory = function(series, category) {
                return this.reader.data.getValue("Y", category, series);
            }, ColumnChartConverter.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                return this.reader.data.getHighlight("Y", category, series);
            }, ColumnChartConverter.prototype.getFormatStringBySeriesAndCategory = function(series, category) {
                return this.reader.data.getFormatString("Y", category, series);
            }, ColumnChartConverter.prototype.getHighlightFormatStringBySeriesAndCategory = function(series, category) {
                return this.reader.data.getHighlightFormatString("Y", category, series);
            }, ColumnChartConverter.valueRoleName = cartesian_capabilities.x.y, ColumnChartConverter;
        }();
        function getHighlightPosition(position, value, valueHighlight, valueAbsolute, absoluteValueHighlight) {
            return valueHighlight > 0 ? position - (valueAbsolute - absoluteValueHighlight) : (null === valueHighlight || 0 === valueHighlight) && value > 0 ? position - valueAbsolute : position;
        }
        function generate100StackedMultipliers(categoryCount, seriesCount, getRawValue) {
            for (var multipliers = [], categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                for (var absPos = 0, absNeg = 0, seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var value = (0, axisHelper.eT)(getRawValue(seriesIndex, categoryIndex));
                    value > 0 ? absPos += value : absNeg -= value;
                }
                var grandTotal = absNeg + absPos;
                multipliers[categoryIndex] = {
                    pos: absPos ? absPos / grandTotal / absPos : 1,
                    neg: absNeg ? absNeg / grandTotal / absNeg : 1
                };
            }
            return multipliers;
        }
        var comboChart_capabilities = __webpack_require__(84741), seriesLevelToggleBehavior = __webpack_require__(3665), topLevelToggleBehavior = __webpack_require__(23465), addDataViewObjectChange = __webpack_require__(57622), formattingModelUtil = __webpack_require__(61617), visualLocKeys = __webpack_require__(33024), uncertainty_formatter = __webpack_require__(16122), dataViewWildcard = __webpack_require__(96915), dataViewRoleWildcard = __webpack_require__(91059), ribbonGapSizeMin = 0, ribbonGapSizeMax = 25;
        function getFormattingCards(formattingCardOptions) {
            return {
                type: 4,
                card: [ getColumnsBarsCard.call(this, formattingCardOptions.categoryAxisData), getRibbonCard.call(this, formattingCardOptions.categoryAxisData), getLabelsCard.call(this), getTotalsCard.call(this), getErrorBarsCard.call(this) ].filter(function(card) {
                    return card;
                })
            };
        }
        function addColumnsLayoutFormatters(containerItemBuilder, categoryAxisData, panelGroupType, disabled) {
            var _this = this, data = this.originalData;
            if (data && this.dataView) {
                var seriesCount = data.series.length, hasClusteredSettings = this.isClustered && seriesCount > 1, layoutProps = columnChart_capabilities.gE.layout;
                containerItemBuilder.addGroup("layout", function(layoutBuilder) {
                    layoutBuilder.withDisplayName("Layout"), disabled ? layoutBuilder.withDisabled(disabled, "perCategory" === panelGroupType ? "Visual_DisabledReason_AllCategoriesOnly_Plural" : "Visual_DisabledReason_AllSeriesOnly_Plural") : layoutBuilder.addSimpleSlice("seriesOrderReversed", new build_control_util.bd({
                        descriptor: layoutProps.seriesOrderReversed,
                        value: data.layout.seriesOrderReversed
                    }).build(), function(builder) {
                        return builder.withDisabled(seriesCount < 2, "Visual_DisabledReason_MultiSeriesOnly_Singular");
                    }).addSimpleSlice("seriesOrderSorted", new build_control_util.bd({
                        descriptor: layoutProps.seriesOrderSorted,
                        value: data.layout.seriesOrderSorted
                    }).build(), function(builder) {
                        return builder.withDisabled(seriesCount < 2, "Visual_DisabledReason_MultiSeriesOnly_Singular");
                    }).addSimpleSlice("innerPadding", (0, cartesianChart_formatter.Gf)(categoryAxisData, _this.localizer)).addSimpleSlice("stackedGapSize", new build_control_util.JN({
                        descriptor: layoutProps.stackedGapSize,
                        value: data.layout.stackedGapSize,
                        options: {
                            minValue: {
                                type: 0,
                                value: columnChart_util.fX
                            },
                            maxValue: {
                                type: 1,
                                value: data.layout.stackedGapExplodes ? columnChart_util._f : columnChart_util.nD
                            },
                            unitSymbol: data.layout.stackedGapExplodes ? visualLocKeys.t2 : visualLocKeys.e_
                        },
                        localize: _this.localizer
                    }).build(), function(builder) {
                        return builder.withHidden(_this.isClustered).withDisabled(seriesCount < 2, "Visual_DisabledReason_MultiSeriesOnly_Singular");
                    }).addSimpleSlice("stackedGapExplodes", new build_control_util.bd({
                        descriptor: layoutProps.stackedGapExplodes,
                        value: data.layout.stackedGapExplodes
                    }).build(), function(builder) {
                        return builder.withHidden(!_this.supportsStackedGapExplode()).withCustomDescription("Visual_Spacing_Explode_Description_".concat(_this.isColumn ? "Columns" : "Bars"));
                    }).addSimpleSlice("clusteredGapSize", new build_control_util.JN({
                        descriptor: layoutProps.clusteredGapSize,
                        value: data.layout.clusteredGapSize,
                        options: {
                            minValue: {
                                type: 0,
                                value: 0
                            },
                            maxValue: {
                                type: 1,
                                value: data.layout.clusteredGapOverlaps ? columnChart_util.jL : columnChart_util.E5
                            },
                            unitSymbol: visualLocKeys.t2
                        },
                        localize: _this.localizer
                    }).build(), function(builder) {
                        return builder.withHidden(!hasClusteredSettings);
                    }).addSimpleSlice("clusteredGapOverlaps", new build_control_util.bd({
                        descriptor: layoutProps.clusteredGapOverlaps,
                        value: data.layout.clusteredGapOverlaps
                    }).build(), function(builder) {
                        return builder.withHidden(!hasClusteredSettings);
                    }).addSimpleSlice("clusteredGapOverlapReverse", new build_control_util.bd({
                        descriptor: layoutProps.clusteredGapOverlapReverse,
                        value: data.layout.clusteredGapOverlapReverse
                    }).build(), function(builder) {
                        return builder.withHidden(!hasClusteredSettings).withDisabled(!data.layout.clusteredGapOverlaps);
                    });
                }).build();
            }
        }
        function getRibbonCard() {
            var _this = this;
            if (this.dataView && !this.isClustered && !this.isComboChart) {
                var data = this.originalData;
                if (data && 0 !== data.series.length) {
                    var ribbonBandsProps = columnChart_capabilities.gE.ribbonBands, cardBuilder = new build_control_util.CQ(new build_control_util.lg("ribbonChart"), "RibbonChart", [ ribbonBandsProps.show, ribbonBandsProps.fillMatchColor, ribbonBandsProps.fillColor, ribbonBandsProps.fillTransparency, ribbonBandsProps.borderShow, ribbonBandsProps.borderColor, ribbonBandsProps.borderColorMatchFill, ribbonBandsProps.borderTransparency, ribbonBandsProps.borderSize, columnChart_capabilities.gE.layout.ribbonGapSize ], this.localizer), addRibbonLayoutGroup = function(builder, disabled) {
                        builder.addGroup("layout", function(layoutBuilder) {
                            layoutBuilder.withDisplayName("Layout"), disabled ? layoutBuilder.withDisabled(!0, "Visual_DisabledReason_AllSeriesOnly_Plural") : layoutBuilder.addSimpleSlice("ribbonGapSize", new build_control_util.JN({
                                descriptor: columnChart_capabilities.gE.layout.ribbonGapSize,
                                value: data.layout.ribbonGapSize,
                                options: {
                                    minValue: {
                                        type: 0,
                                        value: ribbonGapSizeMin
                                    },
                                    maxValue: {
                                        type: 1,
                                        value: ribbonGapSizeMax
                                    },
                                    unitSymbol: visualLocKeys.t2
                                },
                                localize: _this.localizer
                            }).build());
                        });
                    };
                    return cardBuilder.withDescription("RibbonChart_Description").addTopLevelToggle("show", function() {
                        var _a;
                        return new build_control_util.bd({
                            descriptor: ribbonBandsProps.show,
                            value: null === (_a = data.ribbonBands) || void 0 === _a ? void 0 : _a.show
                        }).build();
                    }), this.hasRibbonBands && data.ribbonBands && cardBuilder.addGroup("applySettingsTo", function(groupBuilder) {
                        groupBuilder.withContainerDisabled(!1).withDisplayName("Apply_Settings_To").withCollapsible(!1), 
                        groupBuilder.addContainer("series", function(containerBuilder) {
                            containerBuilder.withDisplayName("Series"), containerBuilder.addContainerItem("all", _this.localizer("All"), function(builder) {
                                var options = {
                                    containerBuilder: builder,
                                    props: ribbonBandsProps,
                                    selector: null,
                                    panelGroupType: "allSeries"
                                };
                                addFillStyleFormatters.call(_this, options, data.ribbonBands), addBorderStyleFormatters.call(_this, options, data.ribbonBands.border, "Visual_MatchRibbonColor", !0), 
                                addRibbonLayoutGroup(builder);
                            });
                            for (var _loop_1 = function(series) {
                                debug.fF.assert(function() {
                                    return null != series.ribbonBands;
                                }, "series must have ribbonBands for ribbon charts"), containerBuilder.addContainerItem(series.displayName, series.displayName, function(builder) {
                                    var options = {
                                        containerBuilder: builder,
                                        props: ribbonBandsProps,
                                        selector: (0, contracts_selector.fd)(series.identity.getSelector()),
                                        panelGroupType: "perSeries"
                                    };
                                    addFillStyleFormatters.call(_this, options, series.ribbonBands), addBorderStyleFormatters.call(_this, options, series.ribbonBands.border, "Visual_MatchRibbonColor", !0), 
                                    addRibbonLayoutGroup(builder, !0);
                                });
                            }, _i = 0, _a = data.series; _i < _a.length; _i++) _loop_1(_a[_i]);
                        });
                    }), cardBuilder.build();
                }
            }
        }
        function getColumnsBarsCard(categoryAxisData) {
            var _this = this, data = this.originalData;
            if (data && this.dataView) {
                var seriesCount = data.series.length;
                if (0 !== seriesCount) {
                    var dataPointProps = columnChart_capabilities.gE.dataPoint, layoutProps = columnChart_capabilities.gE.layout;
                    return new build_control_util.CQ(new build_control_util.lg("bars"), this.isColumn ? "Role_DisplayName_Columns" : "Visual_Bars_Title", [ dataPointProps.fill, dataPointProps.fillTransparency, dataPointProps.borderShow, dataPointProps.borderColor, dataPointProps.borderColorMatchFill, dataPointProps.borderTransparency, dataPointProps.borderSize, dataPointProps.borderOutlineOnly, layoutProps.seriesOrderReversed, layoutProps.seriesOrderSorted, layoutProps.stackedGapSize, layoutProps.stackedGapExplodes, layoutProps.clusteredGapSize, layoutProps.clusteredGapOverlaps, layoutProps.clusteredGapOverlapReverse, cartesian_capabilities.p.categoryAxis.innerPadding ], this.localizer).addGroup("applySettingsTo", function(groupBuilder) {
                        return groupBuilder.withContainerDisabled(!1).withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                            containerBuilder.withDisplayName(seriesCount > 1 ? "Series" : "Visual_Categories");
                            var borderColorMatchFillDisplayName = _this.isColumn ? "Visual_MatchColumnColor" : "Visual_MatchBarColor";
                            containerBuilder.addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                                var options = {
                                    containerBuilder: containerItemBuilder,
                                    props: dataPointProps,
                                    selector: null,
                                    panelGroupType: 1 === data.series.length ? "allCategories" : "allSeries"
                                };
                                addFillStyleFormatters.call(_this, options, _this.data.columnStyle), addBorderStyleFormatters.call(_this, options, data.columnStyle.border, borderColorMatchFillDisplayName), 
                                addColumnsLayoutFormatters.call(_this, containerItemBuilder, categoryAxisData, options.panelGroupType, !1);
                            });
                            var allSeries = data.series, panelGroupType = "perSeries";
                            if (1 === allSeries.length) {
                                var onlySeries_1 = data.series[0], topNCategories = onlySeries_1.data.slice(0, cartesianChart_formatter.Rl);
                                if (topNCategories.length < 2) return;
                                var concatenatedCategoryNames_1 = generateConcatenatedNames(topNCategories, data);
                                allSeries = _.map(topNCategories, function(category, categoryIndex) {
                                    var _a, _b;
                                    return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, onlySeries_1), {
                                        identity: (null === (_b = null === (_a = data.categoryIdentities) || void 0 === _a ? void 0 : _a[category.categoryIndex]) || void 0 === _b ? void 0 : _b.call(_a)) || category.identity,
                                        columnStyle: category.columnStyle,
                                        displayName: concatenatedCategoryNames_1[categoryIndex]
                                    });
                                }), panelGroupType = "perCategory";
                            }
                            for (var _loop_2 = function(series) {
                                containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                                    var selector = (0, contracts_selector.fd)(series.identity.getSelector());
                                    if (selector) {
                                        "perCategory" === panelGroupType && data.multipleIdentity && (selector = (0, contracts_selector.d9)(selector), 
                                        debug.fF.assert(function() {
                                            return !!selector.data;
                                        }, "expect categories to have some data identity"), selector.data.unshift((0, dataViewRoleWildcard.Yp)([ columnChart_capabilities.au.rows ])));
                                        var options = {
                                            containerBuilder: containerItemBuilder,
                                            props: dataPointProps,
                                            selector,
                                            panelGroupType
                                        };
                                        addFillStyleFormatters.call(_this, options, series.columnStyle), addBorderStyleFormatters.call(_this, options, series.columnStyle.border, borderColorMatchFillDisplayName), 
                                        addColumnsLayoutFormatters.call(_this, containerItemBuilder, categoryAxisData, panelGroupType, !0);
                                    }
                                });
                            }, _i = 0, allSeries_1 = allSeries; _i < allSeries_1.length; _i++) _loop_2(allSeries_1[_i]);
                        });
                    }).build();
                }
            }
        }
        function addFillStyleFormatters(_a, data) {
            var _this = this, props = _a.props, selector = _a.selector, panelGroupType = _a.panelGroupType, noFillMatchColor = null == data.fillMatchColor || null == props.fillMatchColor, supportsRules = "allCategories" === panelGroupType && noFillMatchColor, colorPickerDisabled = "allSeries" === panelGroupType && noFillMatchColor;
            _a.containerBuilder.addGroup("colors", function(colorGroupBuilder) {
                return colorGroupBuilder.withDisplayName("Generic_Color").addSimpleSlice("fillMatchColor", new build_control_util.bd({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, props.fillMatchColor), {
                        selector
                    }),
                    value: data.fillMatchColor
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withHidden(noFillMatchColor);
                }).addSimpleSlice("fillColor", new build_control_util.BT({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)((0, tslib_es6.__assign)((0, 
                    tslib_es6.__assign)({}, props.fill || props.fillColor), {
                        selector: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, selector), supportsRules && {
                            data: [ (0, dataViewWildcard.Ue)(1) ]
                        })
                    }), supportsRules && {
                        altConstantValueSelector: null
                    }), {
                        instanceKind: supportsRules ? 3 : 1
                    }),
                    value: {
                        value: data.fillColor
                    }
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled(colorPickerDisabled || data.fillMatchColor, colorPickerDisabled ? "Visual_Color_AllSeries_DisabledReason" : "");
                }).addSimpleSlice("fillTransparency", build_control_util.JN.getTransparencySliderBuilder({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, props.fillTransparency), {
                        selector
                    }),
                    value: data.fillTransparency,
                    localize: _this.localizer
                }).build());
            });
        }
        function addBorderStyleFormatters(_a, data, borderColorMatchFillDisplayName, isRibbon) {
            var _this = this, props = _a.props, selector = _a.selector;
            void 0 === isRibbon && (isRibbon = !1), _a.containerBuilder.addGroup("border", function(borderGroupBuilder) {
                borderGroupBuilder.withDisplayName("Visual_Border").addSlices((0, common_strokeStyle.Iq)({
                    containerItemBuilder: borderGroupBuilder,
                    descriptors: {
                        strokeShow: props.borderShow,
                        strokeColorMatch: props.borderColorMatchFill,
                        strokeColor: props.borderColor,
                        strokeTransparency: props.borderTransparency,
                        strokeWidth: props.borderSize
                    },
                    selector,
                    strokeData: data,
                    featureSwitches: _this.featureSwitches,
                    localize: _this.localizer
                }).map(function(slice) {
                    return (0, formattingModelUtil.cd)(slice.getSimpleControlDescriptor(), props.borderColorMatchFill) && slice.withCustomDisplayName(borderColorMatchFillDisplayName), 
                    slice.build();
                })), isRibbon || borderGroupBuilder.addSimpleSlice("borderOutlineOnly", new build_control_util.bd({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, props.borderOutlineOnly), {
                        selector
                    }),
                    value: data.outlineOnly
                }).build(), function(builder) {
                    var _a;
                    return builder.withHidden(_this.isClustered || null !== selector).withDisabled((null === (_a = _this.originalData) || void 0 === _a ? void 0 : _a.layout.stackedGapSize) > 0, "Visual_Border_OutlineOnly_DisabledReason");
                });
            }).build();
        }
        function getLabelsCard() {
            var _a, _this = this, data = this.originalData, labelSettings = data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = seriesCount > 1 || !data.categoryMetadata || this.isComboChart, showOverflow = data.dataLabelsSettings.position !== labelPosition1.h.outsideEnd, labelPositions = columnChart_util.e3(this.columnChartType, seriesCount);
            labelSettings.position && labelPositions.indexOf(labelSettings.position) < 0 && (labelSettings.position = labelPosition1.h.auto);
            var columnChartDataLabelProps = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, columnChart_capabilities.mi.labels), {
                position: columnChart_capabilities.mi.labels.labelPosition,
                precision: columnChart_capabilities.mi.labels.labelPrecision,
                displayUnits: columnChart_capabilities.mi.labels.labelDisplayUnits,
                labelBackgroundColor: columnChart_capabilities.mi.labels.backgroundColor,
                labelBackgroundTransparency: columnChart_capabilities.mi.labels.backgroundTransparency,
                showDynamicLabels: columnChart_capabilities.mi.labels.showDynamicLabels,
                dynamicLabelValue: columnChart_capabilities.mi.labels.dynamicLabelValue
            });
            this.isColumn || delete columnChartDataLabelProps.labelOrientation;
            var reader, cardBuilder = new build_control_util.CQ(new build_control_util.lg("labels"), "Visual_DataPointsLabels", columnChartDataLabelProps, this.localizer), isFieldPickerDisabled = (0, 
            dataLabelUtil.DU)(this.featureSwitches, data.hasDynamicSeries, showLabelPerSeries, seriesCount, this.isComboChart, !0), labelSettingsOptions = getLabelSettingsOptions.call(this, void 0, labelSettings, null, showLabelPerSeries, labelPositions, showOverflow, isFieldPickerDisabled), individualSelector = getLabelIndividualSelector.call(this, !1), formatCardOptions = {
                cardBuilder,
                dataLabelsProps: columnChartDataLabelProps,
                featureSwitches: this.featureSwitches,
                includeAltConstantValueSelector: !0,
                hostServices: this.hostService,
                options: labelSettingsOptions,
                individualSelector,
                showEnhancedLabelsFormattingOptions: !0,
                instanceId: "all"
            };
            if ((null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.labelEnhancementsM0) && this.dataView) {
                var _b = (reader = (0, dataViewCategoricalReader.y)(this.dataView)).labels.dynamicLabelReader.getLabelFieldSourceTypes();
                Object.assign(formatCardOptions, {
                    valueFieldSourceType: _b.valueFieldSourceType,
                    detailFieldSourceType: _b.detailFieldSourceType,
                    titleFieldSourceType: _b.titleFieldSourceType,
                    valueLabelPickerFallbackExpr: (0, dataLabelUtil.WA)(data.valuesMetadataBySeries, seriesCount, data.hasDynamicSeries),
                    dataLabelPickerSeriesType: (0, dataLabelUtil.Nb)(seriesCount, data.hasDynamicSeries, this.isComboChart)
                });
            }
            return columnChartDataLabelProps.show && cardBuilder.addTopLevelToggle("show", function() {
                return new build_control_util.bd({
                    descriptor: columnChartDataLabelProps.show,
                    value: labelSettingsOptions.dataLabelsSettings.show
                }).build();
            }), cardBuilder.addGroup("applySettingsTo", function(groupBuilder) {
                groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                    var _a, _b;
                    if (containerBuilder.withDisplayName("Series"), containerBuilder.addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                        return (0, dataLabelViewModel1.WW)(formatCardOptions, containerItemBuilder);
                    }), showLabelPerSeries) for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i], seriesLabelSettings = series.labelSettings ? series.labelSettings : data.dataLabelsSettings;
                        seriesLabelSettings.position && labelPositions.indexOf(seriesLabelSettings.position) < 0 && (seriesLabelSettings.position = labelPosition1.h.auto);
                        var selector = series.identity.getSelector();
                        if (Object.assign(formatCardOptions, {
                            includeAltConstantValueSelector: !1,
                            selector: data.hasDynamicSeries ? (0, contracts_selector.fd)(selector) : selector,
                            individualSelector: getLabelIndividualSelector.call(_this, !0),
                            options: getLabelSettingsOptions.call(_this, void 0, seriesLabelSettings, selector, void 0, labelPositions, showOverflow, data.hasDynamicSeries),
                            displayDisabledSlices: (_a = {}, _a.labelOverflow = !0, _a),
                            instanceId: "sn-".concat(i)
                        }), null === (_b = _this.featureSwitches) || void 0 === _b ? void 0 : _b.labelEnhancementsM0) {
                            var labelFieldSourceTypes = reader ? reader.labels.dynamicLabelReader.getLabelFieldSourceTypes(i) : null;
                            Object.assign(formatCardOptions, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labelFieldSourceTypes ? {
                                valueFieldSourceType: labelFieldSourceTypes.valueFieldSourceType,
                                detailFieldSourceType: labelFieldSourceTypes.detailFieldSourceType,
                                titleFieldSourceType: labelFieldSourceTypes.titleFieldSourceType
                            } : {}), {
                                valueLabelPickerFallbackExpr: (0, dataLabelUtil.CH)(data.valuesMetadataBySeries, i),
                                dataLabelPickerSeriesType: (0, dataLabelUtil.aC)(seriesCount, data.hasDynamicSeries, _this.isComboChart)
                            }));
                        }
                        containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                            return (0, dataLabelViewModel1.WW)(formatCardOptions, containerItemBuilder);
                        });
                    }
                });
            }), cardBuilder.build();
        }
        function getLabelIndividualSelector(hasSeriesSelector) {
            return (0, dataLabelViewModel1.WD)({
                featureSwitches: this.featureSwitches,
                hasCategories: null != _.first(this.originalData.categories),
                hasDynamicSeries: this.originalData.hasDynamicSeries,
                hasSeriesSelector
            });
        }
        function getTotalsCard() {
            var _a, labelSettings = this.originalData.totalLabelsSettings;
            if (labelSettings && !this.isClustered && !this.isStacked100) {
                var columnChartDataLabelProps = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, columnChart_capabilities.mi.totals), {
                    precision: columnChart_capabilities.mi.totals.labelPrecision,
                    displayUnits: columnChart_capabilities.mi.totals.labelDisplayUnits
                }), cardBuilder = new build_control_util.CQ(new build_control_util.lg("totals"), "Visual_DataTotalLabels", columnChartDataLabelProps, this.localizer);
                if (!this.supportsTotalLabels()) {
                    var hasMultipleInfo = !!(null === (_a = this.data) || void 0 === _a ? void 0 : _a.multipleIdentity);
                    return cardBuilder.withDisabled(!0, hasMultipleInfo ? "Visual_Totals_DisabledReason_SmallMultiples" : "Visual_Totals_DisabledReason"), 
                    cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: columnChartDataLabelProps.show,
                            value: !1
                        }).build();
                    }), cardBuilder.build();
                }
                return (0, dataLabelViewModel1.XQ)({
                    cardBuilder,
                    dataLabelsProps: columnChartDataLabelProps,
                    featureSwitches: this.featureSwitches,
                    hostServices: this.hostService,
                    options: getTotalLabelSettingsOptions.call(this, void 0, labelSettings),
                    individualSelector: getLabelIndividualSelector.call(this, !1),
                    showEnhancedLabelsFormattingOptions: !1,
                    instanceId: "all"
                });
            }
        }
        function getErrorBarsCard() {
            var _this = this;
            if (!this.isStacked) {
                var data = this.originalData;
                if (data && data.series && 0 !== data.series.length) return new build_control_util.CQ(new build_control_util.lg("errorBars"), "Visual_Error_Bars", dataViewObjectProperties.Qx, this.localizer, !0, !0).addGroup("applySettingsTo", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("measure", function(containerBuilder) {
                        containerBuilder.withDisplayName("Series");
                        for (var _loop_3 = function(valueMetadata) {
                            var seriesIndex = _.first(valueMetadata.usedInSeriesIndices);
                            if (debug.fF.assertValue(seriesIndex, "lineChart - measure is not associated with any series"), 
                            null != seriesIndex && null !== data.series[seriesIndex]) {
                                var measureSelector_1 = valueMetadata.valueSelector.getSelector();
                                containerBuilder.addContainerItem(valueMetadata.metadataColumn.queryName, valueMetadata.metadataColumn.displayName, function(containerItemBuilder) {
                                    return (0, uncertainty_formatter.f)({
                                        localize: _this.localizer,
                                        uncertainty: data.series[seriesIndex].uncertainty,
                                        targetMeasure: valueMetadata.metadataColumn.expr,
                                        measureSelector: measureSelector_1,
                                        dataPointSelector: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, measureSelector_1), {
                                            data: [ (0, dataViewWildcard.Ue)() ],
                                            highlightMatching: 1
                                        }),
                                        featureSwitches: _this.featureSwitches,
                                        uncertaintyOptions: {
                                            isCombo: _this.isComboChart,
                                            hideBand: !0
                                        }
                                    }, containerItemBuilder);
                                });
                            }
                        }, _i = 0, _a = data.valuesMetadataBySeries; _i < _a.length; _i++) _loop_3(_a[_i]);
                    });
                }).build();
            }
        }
        function getLabelSettingsOptions(enumeration, dataLabelsSettings, selector, showAll, positionObject, showOverflow, isFieldPickerDisabled) {
            var _a, isSubSlice = !!selector;
            return {
                enumeration,
                dataLabelsSettings,
                show: !0,
                position: !_.isEmpty(positionObject),
                positionObject,
                labelOrientation: !this.isBar && !isSubSlice,
                displayUnits: !this.isStacked100,
                precision: !0,
                selector,
                showAll,
                fontSize: !0,
                fontFamily: !0,
                labelDensity: null === (_a = this.data) || void 0 === _a ? void 0 : _a.isScalar,
                labelOverflow: !isSubSlice && showOverflow,
                enableBackground: dataLabelsSettings.enableBackground,
                backgroundColor: dataLabelsSettings.backgroundColor,
                backgroundTransparency: dataLabelsSettings.backgroundTransparency,
                style: this.style,
                bold: !0,
                italic: !0,
                underline: !0,
                enableDynamicLabelPickers: !isFieldPickerDisabled,
                isStacked100: this.isStacked100
            };
        }
        function getTotalLabelSettingsOptions(enumeration, dataLabelsSettings) {
            return {
                enumeration,
                dataLabelsSettings,
                show: !0,
                displayUnits: !0,
                precision: !0,
                fontSize: !0,
                fontFamily: !0,
                showPositiveAndNegative: !0,
                enableBackground: dataLabelsSettings.enableBackground,
                backgroundColor: dataLabelsSettings.backgroundColor,
                backgroundTransparency: dataLabelsSettings.backgroundTransparency,
                style: this.style,
                bold: !0,
                italic: !0,
                underline: !0
            };
        }
        function getSubSelectionStyles(subSelections) {
            var visualObject, selector, visualObjects = _.first(subSelections).visualObjects;
            if (visualObjects.length > 0) {
                (null == (visualObject = visualObjects[0]) ? void 0 : visualObject.selectorsByColumn) && (selector = (0, 
                contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn)));
                var omitForSingleSeries = 1 === this.data.series.length;
                switch (visualObject.objectName) {
                  case "columns":
                    return omitForSingleSeries && this.data.categoryMetadata && !this.data.hasDynamicSeries && (selector = {
                        data: [ (0, dataViewWildcard.Ue)(1) ]
                    }), (0, onObjectUtil.w3)(this.hostService, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, columnChart_capabilities.gE.dataPoint.borderColor), {
                        selector
                    }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, columnChart_capabilities.gE.dataPoint.fill), {
                        selector
                    }), this.hostService.getLocalizedString("Visual_Border"));

                  case "ribbon":
                    return omitForSingleSeries && this.data.categoryMetadata && !this.data.hasDynamicSeries && (selector = {
                        data: [ (0, dataViewWildcard.Ue)(1) ]
                    }), (0, onObjectUtil.w3)(this.hostService, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, columnChart_capabilities.gE.ribbonBands.borderColor), {
                        selector
                    }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, columnChart_capabilities.gE.ribbonBands.fillColor), {
                        selector
                    }), this.hostService.getLocalizedString("Visual_Border"));

                  case "data-labels":
                    var currentSeries = this.data.series.find(function(series) {
                        var _a;
                        return (0, contracts_selector.Ic)(null === (_a = null == series ? void 0 : series.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn(), visualObject.selectorsByColumn);
                    });
                    if (!currentSeries) return;
                    var labels = columnChart_capabilities.mi.labels, refSelector = omitForSingleSeries ? void 0 : selector, dataLabelsModelReferences = {
                        fontFamilyReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.fontFamily), {
                            selector: refSelector
                        }),
                        fontSizeReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.fontSize), {
                            selector: refSelector
                        }),
                        boldReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.bold), {
                            selector: refSelector
                        }),
                        italicReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.italic), {
                            selector: refSelector
                        }),
                        underlineReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.underline), {
                            selector: refSelector
                        }),
                        fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.color), {
                            selector: refSelector
                        }),
                        displayUnitsReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.labelDisplayUnits), {
                            selector: refSelector
                        }),
                        precisionReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.labelPrecision), {
                            selector: refSelector
                        }),
                        backgroundReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.backgroundColor), {
                            selector: refSelector
                        })
                    };
                    return (0, onObjectUtil.Jf)({
                        hostServices: this.hostService,
                        omitSelectorForSingleSeries: omitForSingleSeries,
                        individualSelector: getLabelIndividualSelector.call(this, !omitForSingleSeries),
                        selector,
                        repetitionSelector: void 0,
                        subSelectionStylesOptions: {
                            precision: {
                                defaultPrecision: this.getLabelUnitsAndPrecision().getPrecision(!1, currentSeries.type)
                            }
                        }
                    }, dataLabelsModelReferences);

                  case "total-labels":
                    var totals = columnChart_capabilities.mi.totals;
                    return (0, onObjectUtil.Jf)({
                        hostServices: this.hostService,
                        omitSelectorForSingleSeries: omitForSingleSeries,
                        individualSelector: getLabelIndividualSelector.call(this, !omitForSingleSeries),
                        selector,
                        repetitionSelector: void 0
                    }, {
                        fontFamilyReference: totals.fontFamily,
                        fontSizeReference: totals.fontSize,
                        boldReference: totals.bold,
                        italicReference: totals.italic,
                        underlineReference: totals.underline,
                        fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, totals.color), {
                            selector: (0, dataLabelUtil.hm)(getLabelIndividualSelector.call(this, !1), void 0, void 0)
                        }),
                        displayUnitsReference: totals.labelDisplayUnits,
                        precisionReference: totals.labelPrecision,
                        backgroundReference: totals.backgroundColor
                    });

                  default:
                    return;
                }
            }
        }
        function getSubSelectionShortcuts(subSelections, filter) {
            if (!filter) {
                var visualObject, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0) {
                    visualObject = visualObjects[0];
                    var selector, useTopLevelToggle = !this.showLabelPerSeries();
                    useTopLevelToggle || _.isEmpty(visualObject.selectorsByColumn) || (selector = (0, 
                    contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn)));
                    var addDataLabelToggleFormattingId = useTopLevelToggle ? columnChart_capabilities.mi.labels.show : columnChart_capabilities.mi.labels.showSeries;
                    switch (visualObject.objectName) {
                      case "columns":
                      case "ribbon":
                        var forRibbons = "ribbon" === visualObject.objectName, destination = (0, tslib_es6.__assign)({}, forRibbons ? columnChart_capabilities.gE.ribbonBands.fillColor : columnChart_capabilities.gE.dataPoint.fill), shortcuts = [ {
                            type: 1,
                            destinationInfo: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, destination), {
                                selector: this.data.series.length > 1 ? selector : void 0
                            }),
                            label: this.localizer(forRibbons ? "Format_Ribbon" : this.isBar ? "Format_Bars" : "Format_Columns")
                        } ];
                        return this.supportsTotalLabels() && shortcuts.unshift((0, tslib_es6.__assign)((0, 
                        tslib_es6.__assign)({
                            type: 2
                        }, columnChart_capabilities.mi.totals.show), {
                            enabledLabel: this.localizer("Format_AddTotalLabels")
                        })), shortcuts.unshift({
                            type: 0,
                            excludedResetFormattingIds: [ columnChart_capabilities.mi.totals.show, (0, tslib_es6.__assign)((0, 
                            tslib_es6.__assign)({}, addDataLabelToggleFormattingId), {
                                selector
                            }) ]
                        }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, addDataLabelToggleFormattingId), {
                            enabledLabel: this.localizer("Format_AddDataLabels"),
                            selector
                        })), shortcuts;

                      default:
                        return;
                    }
                }
            }
        }
        function getSelectorsByColumnFromSubselectedElement(e) {
            switch (d3.select(e).attr(htmlSubSelectionHelper.Ez)) {
              case "columns":
                var dataPointDatum = d3.select(e).datum();
                return getSelectorsByColumnForDataPointWithSeriesIndex.call(this, dataPointDatum.seriesIndex);

              case "ribbon":
                return dataPointDatum = d3.select(e).datum(), getSelectorsByColumnForDataPointWithSeriesIndex.call(this, dataPointDatum.d1.seriesIndex);

              case "data-labels":
              case "series-labels":
                var labelSelectorsByColumn = (0, dataLabelUtil.wT)(e, this.data.series);
                if (labelSelectorsByColumn) return labelSelectorsByColumn;

              default:
                return;
            }
        }
        function getSelectorsByColumnForDataPointWithSeriesIndex(dataPointSeriesIndex) {
            var _a, seriesList = this.data.series;
            if (!_.isEmpty(seriesList) && dataPointSeriesIndex >= 0) {
                var series = seriesList[dataPointSeriesIndex];
                return null === (_a = null == series ? void 0 : series.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn();
            }
        }
        function getDataViewObjectLayerChanges(propertySaveObjects, sourceType) {
            var changes = [];
            if (this.featureSwitches.onObject && 1 === sourceType) {
                var chartProps = this.isComboChart ? comboChart_capabilities.OA : columnChart_capabilities.mi, dataLabelsValues = this.data.series.map(function(s) {
                    var _a;
                    return {
                        selector: s.identity.getSelector(),
                        value: null === (_a = s.labelSettings) || void 0 === _a ? void 0 : _a.show
                    };
                }), behaviors = [ seriesLevelToggleBehavior.v.create(chartProps.labels.backgroundColor, this.data.dataLabelsSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.enableBackground, !0, {
                    inheritSelector: !0
                })), topLevelToggleBehavior.$.create(chartProps.labels.backgroundColor, this.data.dataLabelsSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.enableBackground, !0)), seriesLevelToggleBehavior.v.create(chartProps.labels.showSeries, this.data.dataLabelsSettings.show, dataLabelsValues).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.showByDefault, !1), addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.show, !0)).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("labels")), topLevelToggleBehavior.$.create(chartProps.labels.show, this.data.dataLabelsSettings.show).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("labels")), topLevelToggleBehavior.$.create(chartProps.totals.backgroundColor, this.data.totalLabelsSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.totals.enableBackground, !0)).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("totals")), seriesLevelToggleBehavior.v.create(columnChart_capabilities.gE.dataPoint.borderColor, this.data.columnStyle.border.strokeShow).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(columnChart_capabilities.gE.dataPoint.borderShow, !0, {
                    inheritSelector: !0,
                    required: !0
                })) ];
                changes = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], changes, !0), dataViewObjectChangeHelper.o.getDataViewObjectsBehaviorChanges(propertySaveObjects, behaviors), !0);
            }
            return changes;
        }
        var columnChart_renderer = __webpack_require__(3406), ColumnChart = function(_super) {
            function ColumnChart(options) {
                var _this = _super.call(this, options) || this;
                return _this.options = options, debug.fF.assertValue(options.columnChartType, "columnChartType"), 
                _this;
            }
            return (0, tslib_es6.__extends)(ColumnChart, _super), Object.defineProperty(ColumnChart.prototype, "columnChartType", {
                get: function() {
                    return this.options.columnChartType;
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChart.prototype.initRenderer = function(options) {
                _super.prototype.initRenderer.call(this, options), this.svg.classed(ColumnChart.ClassName, !0), 
                this.unclippedGraphicsContext = this.svg.append("g").classed("columnChartUnclippedGraphicsContext", !0), 
                this.mainGraphicsContext = this.unclippedGraphicsContext.append("svg").classed("mainGraphicsContext", !0), 
                this.useManagedTabIndex = options.useManagedTabIndex, this.interactivityService && (this.mainGraphicsContext.attrs({
                    "aria-label": this.localizer("Visual_Plot"),
                    "data-automation-type": "mainGraphicsContext",
                    role: "group"
                }).classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()), options.useManagedTabIndex ? (this.mainGraphicsContext.classed(gridLayoutBehaviors.rG.class, !0), 
                this.mainGraphicsContext.attr(DOMConstants.Rh, !0)) : this.mainGraphicsContext.attrs({
                    tabindex: 0,
                    focusable: !0
                }));
            }, Object.defineProperty(ColumnChart.prototype, "isBar", {
                get: function() {
                    return columnChart_util.hg(this.columnChartType);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "isColumn", {
                get: function() {
                    return columnChart_util.t3(this.columnChartType);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "isStacked", {
                get: function() {
                    var _a;
                    return columnChart_util.C3(this.columnChartType, null === (_a = this.data) || void 0 === _a ? void 0 : _a.series.length);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "isStacked100", {
                get: function() {
                    return columnChart_util.Ds(this.columnChartType);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "isClustered", {
                get: function() {
                    return columnChart_util.V5(this.columnChartType);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "hasRibbonBands", {
                get: function() {
                    var _a;
                    return (null === (_a = this.data.ribbonBands) || void 0 === _a ? void 0 : _a.show) && !this.isComboChart;
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChart.prototype.isYCategorical = function() {
                return this.isBar;
            }, ColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                void 0 === startIndex && (startIndex = 0);
                var newSeries = [];
                if (series && series.length > 0) for (var i = 0, len = series.length; i < len; i++) newSeries[i] = (0, 
                Prototype.ED)(series[i]), newSeries[i].data = series[i].data.filter(function(d) {
                    return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                });
                return newSeries;
            }, ColumnChart.getInteractiveColumnChartDomElement = function(element) {
                return element.children("svg").get(0);
            }, ColumnChart.prototype.setData = function(dataViews, multipleInfo) {
                debug.fF.assertValue(dataViews, "dataViews");
                var labelSettings = columnChart_util.L2(this.style, this.isStacked100);
                if (this.data = this.originalData = {
                    categories: [],
                    categoryFormatter: null,
                    series: [],
                    totals: [],
                    valuesMetadata: [],
                    categoryData: [],
                    legendData: null,
                    hasHighlights: !1,
                    categoryMetadata: null,
                    isScalar: !1,
                    dataLabelsSettings: labelSettings,
                    titleDataLabelsSettings: labelSettings,
                    detailDataLabelsSettings: labelSettings,
                    seriesLabelSettings: getDefaultSeriesLabelSettings(this.style),
                    hasDynamicSeries: !1,
                    columnStyle: {
                        fillColor: void 0,
                        fillTransparency: columnChart_util.fl,
                        border: columnChart_util.nO(this.style)
                    },
                    layout: columnChart_util.HQ,
                    ribbonBands: (0, tslib_es6.__assign)({
                        show: !1
                    }, columnChart_util.bS(this.style))
                }, dataViews.length > 0) {
                    var dataView = this.dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dvCategories = dataView.categorical.categories, categoryType = cartesianAxisHelper.getCategoryValueType(dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null), hasHierarchy = (0, 
                        dataViewHelper.n$)(dataView), isScalar = (0, scalarUtils.PX)(dataView.metadata ? dataView.metadata.objects : null, cartesian_capabilities.p.categoryAxis.axisType, categoryType, void 0, hasHierarchy);
                        this.converter = ColumnChartConverter.create({
                            dataView,
                            style: this.style,
                            isScalar,
                            multipleInfo,
                            chartType: this.columnChartType,
                            interactivityService: this.interactivityService,
                            tooltipsEnabled: this.tooltipsEnabled,
                            hostServices: this.hostService,
                            isComboChart: this.isComboChart,
                            supportsTotalLabels: !multipleInfo && this.supportsTotalLabels(),
                            featureSwitches: this.featureSwitches
                        }), this.data = this.originalData = this.converter.convert();
                    }
                }
            }, ColumnChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
            }, ColumnChart.prototype.getSeriesLabelsSettings = function() {
                return (0, Prototype.ED)(this.data).seriesLabelSettings;
            }, ColumnChart.prototype.getFormattingCards = function(formattingCardOptions) {
                return getFormattingCards.call(this, formattingCardOptions);
            }, ColumnChart.prototype.getSubSelectionStyles = function(subSelections) {
                return getSubSelectionStyles.call(this, subSelections);
            }, ColumnChart.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                return getSubSelectionShortcuts.call(this, subSelections, filter);
            }, ColumnChart.prototype.getSelectorsByColumnFromSubselectedElement = function(e) {
                return getSelectorsByColumnFromSubselectedElement.call(this, e);
            }, ColumnChart.prototype.getDataViewObjectLayerChanges = function(propertySaveObjects, sourceType) {
                return getDataViewObjectLayerChanges.call(this, propertySaveObjects, sourceType);
            }, ColumnChart.prototype.showSeriesCard = function() {
                return !(this.isComboChart && !this.data.hasY2Role);
            }, ColumnChart.prototype.showLabelPerSeries = function() {
                var data = this.originalData;
                return data.series.length > 1 || !data.categoryMetadata || this.isComboChart;
            }, ColumnChart.prototype.calculateAxesProperties = function(options) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                this.updateCurrentViewport(options);
                var initialCategoryCount = null !== (_c = null === (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.categories) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0, categoryLayout = this.data ? (0, 
                cartesianHelper.is)({
                    data: this.data,
                    availableWidth: Math.max(0, this.isBar ? this.availableHeight : this.availableWidth),
                    categoryCount: initialCategoryCount,
                    preferredCategoryWidth: null !== (_e = null === (_d = this.data) || void 0 === _d ? void 0 : _d.preferredCategoryWidth) && void 0 !== _e ? _e : null,
                    domain: null === (_g = cartesianAxisHelper.createDomain(this.data.series, cartesianAxisHelper.getCategoryValueType(null === (_f = this.data) || void 0 === _f ? void 0 : _f.categoryMetadata), this.getVisualCategoryAxisIsScalar(), [ options.categoryAxisOptions.includeDomain ])) || void 0 === _g ? void 0 : _g.domain,
                    isScalar: this.getVisualCategoryAxisIsScalar(),
                    cartesianOptions: this.options,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow,
                    outerPaddingRatio: options.outerPaddingRatio,
                    innerPaddingRatio: options.innerPaddingRatio,
                    axisZoom: options.axisZoom
                }) : (0, cartesianHelper.u8)(), data = this.adjustLayoutForScroll(this.data, initialCategoryCount, options.trimOrdinalDataOnOverflow, categoryLayout);
                this.updateCategoryLayout(categoryLayout);
                var categoryAxisProps = this.createCategoryAxis(options), valueAxisProps = this.createValueAxis(options), shouldAdjustForStackedTotals = (null === (_h = data.totalLabelsSettings) || void 0 === _h ? void 0 : _h.show) && this.supportsTotalLabels(), shouldAdjustForClusterLabels = (null === (_j = data.dataLabelsSettings) || void 0 === _j ? void 0 : _j.show) && this.isClusteredOptimized;
                if (shouldAdjustForStackedTotals || shouldAdjustForClusterLabels) {
                    var adjustedDomain = cartesianAxisHelper.mergeScalarAxisDomains(cartesianAxisHelper.createScalarDomainOptions(this.adjustDomainForLabels(valueAxisProps), 0, [ !0, !0 ]), options.valueAxisOptions.includeDomain, cartesianAxisHelper.createScalarDomainOptions(valueAxisProps.scale.domain(), 0));
                    valueAxisProps = this.createValueAxis(options, adjustedDomain, !0);
                }
                return [ this.isBar ? valueAxisProps : categoryAxisProps, this.isBar ? categoryAxisProps : valueAxisProps ];
            }, ColumnChart.prototype.setAxesLayout = function(options) {
                var _a, _b, _c;
                this.updateCurrentViewport(options.layout), this.xAxisProperties = options.layout.axes.x, 
                this.yAxisProperties = options.layout.axes.y1;
                var categoryLayout = this.data ? {
                    categoryCount: _.isEmpty(this.categoryAxis.categoryIdentities) ? 0 : this.categoryAxis.categoryIdentities.length,
                    categoryThickness: this.categoryAxis.categoryThickness,
                    outerPaddingRatio: this.categoryAxis.outerPaddingRatio,
                    innerPaddingRatio: this.categoryAxis.innerPaddingRatio,
                    isScalar: this.getVisualCategoryAxisIsScalar()
                } : (0, cartesianHelper.u8)();
                this.data = this.adjustLayoutForScroll(this.data, null !== (_c = null === (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.categories) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0, options.trimOrdinalDataOnOverflow, categoryLayout), 
                this.updateCategoryLayout(categoryLayout);
            }, ColumnChart.prototype.getAxesDomains = function(includeZero, requestedDomains) {
                var _a, _b, axesDomains = {};
                if (!this.data) return axesDomains;
                if (requestedDomains.categoryAxis && this.data.isScalar) {
                    var categoryDomain = cartesianAxisHelper.createDomain(this.data.series, null !== (_b = null === (_a = this.data.categoryMetadata) || void 0 === _a ? void 0 : _a.type) && void 0 !== _b ? _b : valueType.Ge.fromDescriptor({
                        text: !0
                    }), this.data.isScalar, void 0);
                    categoryDomain && (cartesianAxisHelper.assertScalarDomain(categoryDomain.domain), 
                    axesDomains.categoryAxis = [ categoryDomain.domain[0], categoryDomain.domain[1] ]);
                }
                if (requestedDomains.valueAxis) {
                    var valueDomain = void 0;
                    if (this.isStacked) {
                        var valueDomainRange = columnChart_util.VY(this.data.series, this.isStacked100);
                        valueDomain = [ valueDomainRange.min, valueDomainRange.max ];
                    } else valueDomain = cartesianAxisHelper.createUncertaintyAwareValueDomain(this.data.series, includeZero) || cartesianAxisHelper.emptyDomain;
                    var valueDomainMin = valueDomain[0], valueDomainMax = valueDomain[1];
                    void 0 !== valueDomainMin && void 0 !== valueDomainMax && (axesDomains.valueAxis = [ valueDomainMin, valueDomainMax ]);
                }
                return axesDomains;
            }, ColumnChart.prototype.updateCategoryLayout = function(chartLayout) {
                var _a;
                _a = this.getPreferredPlotArea(chartLayout), this.height = _a.height, this.width = _a.width, 
                this.categoryLayout = chartLayout, this.applyInteractivity(), this.categoryBandScale = d3.scaleBand().range([ 0, this.categoryWidth ]), 
                this.isClusteredOptimized ? (this.activeData.layout.clusteredGapSize && (this.activeData.layout.clusteredGapOverlaps ? this.categoryBandScale = d3.scaleBand().range([ 0, this.categoryWidth * (1 - this.activeData.layout.clusteredGapSize / 100) ]) : this.categoryBandScale.paddingInner(this.activeData.layout.clusteredGapSize / 100)), 
                this.categoryBandScale.domain(this.activeData.series.map(function(s) {
                    return s.index.toString();
                }))) : this.categoryBandScale.domain([ "0" ]);
            }, ColumnChart.prototype.adjustLayoutForScroll = function(data, initialCategoryCount, trimOrdinalDataOnOverflow, chartLayout) {
                if (this.clippedData = void 0, data && !chartLayout.isScalar && !this.options.isScrollable && trimOrdinalDataOnOverflow) {
                    var categoryCount = Math.min(initialCategoryCount, chartLayout.categoryCount);
                    if (categoryCount !== initialCategoryCount) {
                        var newData = (0, Prototype.ED)(data);
                        newData.series = ColumnChart.sliceSeries(newData.series, categoryCount), newData.categories = newData.categories.slice(0, categoryCount), 
                        newData.categoryIdentities && (newData.categoryIdentities = newData.categoryIdentities.slice(0, categoryCount)), 
                        this.clippedData = newData;
                    }
                }
                return data;
            }, ColumnChart.prototype.getLabelUnitsAndPrecision = function() {
                return (0, dataLabelRendererEnhanced.d6)(this.xAxisProperties, this.data.dataLabelsSettings);
            }, ColumnChart.prototype.adjustDomainForLabels = function(valueAxis) {
                var data = this.activeData, domain = valueAxis.dataDomain;
                if (domain && null != domain[0] && null != domain[1]) {
                    var minSampleString = domain[0].toString(), maxSampleString = domain[1].toString(), formatString = "";
                    data.series.length > 0 && data.series[0].data.length > 0 && (formatString = data.series[0].data[0].labelFormatString);
                    var formattersCache = (0, dataLabelViewModel1.fI)(), labelUnitsAndPrecision = (0, 
                    dataLabelRendererEnhanced.d6)(valueAxis, data.totalLabelsSettings), formatter = formattersCache.getOrCreate(formatString, data.totalLabelsSettings, labelUnitsAndPrecision.units, data.totalLabelsSettings.precision), minText = (0, 
                    dataLabelRendererEnhanced.Bw)(formatter.format(minSampleString)), maxText = (0, 
                    dataLabelRendererEnhanced.Bw)(formatter.format(maxSampleString)), minProperties = (0, 
                    common_fontProperties.qk)(data.totalLabelsSettings.fontProperties, minText), maxProperties = (0, 
                    common_fontProperties.qk)(data.totalLabelsSettings.fontProperties, maxText), minTextPrimaryDimension = void 0, maxTextPrimaryDimension = void 0, offsetSign = void 0;
                    this.isBar ? (minTextPrimaryDimension = textMeasurementService.b.measureSvgTextWidth(minProperties), 
                    maxTextPrimaryDimension = textMeasurementService.b.measureSvgTextWidth(maxProperties), 
                    offsetSign = valueAxis.invertAxis ? -1 : 1) : (minTextPrimaryDimension = textMeasurementService.b.estimateSvgTextHeight(minProperties), 
                    maxTextPrimaryDimension = textMeasurementService.b.estimateSvgTextHeight(maxProperties), 
                    offsetSign = valueAxis.invertAxis ? 1 : -1);
                    var scale = valueAxis.scale, newPixelMin = scale(domain[0]) - offsetSign * (minTextPrimaryDimension + dataLabelViewModel1Consts.FJ), newPixelMax = scale(domain[1]) + offsetSign * (maxTextPrimaryDimension + dataLabelViewModel1Consts.FJ), adjustMax = !1, adjustMin = !1;
                    return data.totalLabelsSettings.showPositiveAndNegative ? (adjustMax = data.hasPositive, 
                    adjustMin = data.hasNegative) : (adjustMax = data.hasNetPositive, adjustMin = data.hasNetNegative), 
                    [ adjustMin ? scale.invert(newPixelMin) : void 0, adjustMax ? scale.invert(newPixelMax) : void 0 ];
                }
            }, ColumnChart.prototype.isMobileInteractiveLegend = function() {
                return this.mobileTileInteractive && !(this.data && this.data.multipleIdentity);
            }, ColumnChart.prototype.getClosestColumnIndex = function(coordinate) {
                for (var currentIndex = 0, distance = Number.MAX_VALUE, columnsCenters = this.getGlyphCenters(), i = 0; i < columnsCenters.length; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    currentDistance < distance && (distance = currentDistance, currentIndex = i);
                }
                return currentIndex;
            }, ColumnChart.prototype.applyInteractivity = function() {
                var _this = this;
                if (this.isMobileInteractiveLegend()) {
                    var dragMove = function() {
                        var mousePoint = d3.mouse(_this.mainGraphicsContext.node()), index = _this.getClosestColumnIndex(_this.isColumn ? mousePoint[0] : mousePoint[1]);
                        _this.selectColumn(index);
                    }, ColumnChartSvg = ColumnChart.getInteractiveColumnChartDomElement(this.element);
                    this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove).style("touch-action", "none");
                    var drag = d3.drag().on("drag", dragMove);
                    this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                }
            }, ColumnChart.prototype.selectColumn = function(columnIndexToSelect, forceDimAll) {
                void 0 === forceDimAll && (forceDimAll = !1), (forceDimAll || this.lastInteractiveSelectedColumnIndex !== columnIndexToSelect) && (columnChart_renderer.rT(this.mainGraphicsContext, this.CS.selector, columnIndexToSelect, this.lastInteractiveSelectedColumnIndex, forceDimAll), 
                this.moveHandle(columnIndexToSelect), this.cartesianVisualHost.updateLegend(this.createInteractiveLegendDataPoints(columnIndexToSelect)), 
                this.lastInteractiveSelectedColumnIndex = columnIndexToSelect);
            }, ColumnChart.prototype.createInteractiveLegendDataPoints = function(columnIndexToSelect) {
                var _a, _b, _c, _d, _this = this, data = this.data;
                if (!data || _.isEmpty(data.series)) return (0, legend_converter.Fe)(this.style);
                var formatStringProp = cartesian_capabilities.p.general.formatString, category = null === (_a = data.categories) || void 0 === _a ? void 0 : _a[columnIndexToSelect], formattedCategory = null !== (_c = null === (_b = data.categoryFormatter) || void 0 === _b ? void 0 : _b.format(category)) && void 0 !== _c ? _c : category, dataPoints = null === (_d = data.legendData) || void 0 === _d ? void 0 : _d.dataPoints, legendDataPoints = data.series.map(function(series, i) {
                    var _a, measure = null === (_a = _this.converter) || void 0 === _a ? void 0 : _a.getValueBySeriesAndCategory(i, columnIndexToSelect), valueMetadata = data.valuesMetadata[i], dataPoint = dataPoints[i];
                    return {
                        marker: {
                            show: !0,
                            shape: markerShape.ZO.circle,
                            color: 1 === data.series.length ? series.data.length > columnIndexToSelect && series.data[columnIndexToSelect].columnStyle.fillColor : dataPoints.length > i && dataPoint.marker.color,
                            transparency: dataPoint.marker.transparency,
                            stroke: dataPoint.marker.stroke
                        },
                        label: (0, converterHelper.TO)(valueMetadata, _this.dataView.categorical.values, formatStringProp),
                        category: formattedCategory,
                        measure: (0, valueFormatter.WU)(measure, (0, valueFormatter.EO)(valueMetadata, formatStringProp)),
                        identity: selection_selectionId.l0.createNull(),
                        selected: !1,
                        index: i
                    };
                });
                return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, (0, legend_converter.Fe)(this.style)), {
                    dataPoints: legendDataPoints
                });
            }, ColumnChart.prototype.render = function(suppressAnimations, _resizeMode, formatMode) {
                return columnChart_renderer.sY.call(this, suppressAnimations, formatMode);
            }, ColumnChart.prototype.usesUngroupedRenderer = function() {
                return this.data.layout.clusteredGapOverlaps && this.data.layout.clusteredGapSize > 0;
            }, ColumnChart.prototype.getFirstElement = function(categoryIndex, reverse) {
                void 0 === reverse && (reverse = !1);
                var series = this.activeData.series;
                if (_.isEmpty(series)) return null;
                var nextDataPoint, element, firstCategoryIndex = null != categoryIndex ? categoryIndex : series[0].data[0].categoryIndex, seriesIndex = reverse ? this.findSeriesIndex(series.length - 1, firstCategoryIndex, !1) : this.findSeriesIndex(0, firstCategoryIndex, !0);
                return seriesIndex >= 0 ? (nextDataPoint = this.data.series[seriesIndex].data[firstCategoryIndex], 
                element = this.getDataPointElement(seriesIndex, firstCategoryIndex)) : seriesIndex = reverse ? series.length - 1 : 0, 
                {
                    element,
                    targetCategoryIndex: firstCategoryIndex,
                    targetSeriesIndex: seriesIndex,
                    noShape: nextDataPoint && 0 === nextDataPoint.valueAbsolute
                };
            }, ColumnChart.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                switch (direction) {
                  case services_interactivityService.x0.NextCategory:
                    categoryIndex = ColumnChart.findCategoryIndex(this.data.series[seriesIndex].data, categoryIndex, !0);
                    break;

                  case services_interactivityService.x0.PreviousCategory:
                    categoryIndex = ColumnChart.findCategoryIndex(this.data.series[seriesIndex].data, categoryIndex, !1);
                    break;

                  case services_interactivityService.x0.NextSeries:
                    (seriesIndex = this.findSeriesIndex(seriesIndex + 1, categoryIndex, !0)) < 0 && (categoryIndex = ColumnChart.loopIndex(categoryIndex + 1, this.data.categories.length), 
                    seriesIndex = this.findSeriesIndex(0, categoryIndex, !0));
                    break;

                  case services_interactivityService.x0.PreviousSeries:
                    (seriesIndex = seriesIndex > 0 ? this.findSeriesIndex(seriesIndex - 1, categoryIndex, !1) : -1) < 0 && (categoryIndex = ColumnChart.loopIndex(categoryIndex - 1, this.data.categories.length), 
                    seriesIndex = this.findSeriesIndex(this.data.series.length - 1, categoryIndex, !1));
                }
                var nextDataPoint, element;
                if (debug.fF.assert(function() {
                    return seriesIndex >= 0 || categoryIndex >= 0;
                }, "We expect that categoryIndex or seriesIndex will always be valid."), seriesIndex >= 0 && categoryIndex >= 0) {
                    var data = this.data.series[seriesIndex].data;
                    this.data.hasHighlights && (data = data.filter(function(d) {
                        return !d.highlight;
                    })), nextDataPoint = data[categoryIndex], element = this.getDataPointElement(seriesIndex, categoryIndex);
                } else if (categoryIndex < 0) switch (direction) {
                  case services_interactivityService.x0.NextCategory:
                    categoryIndex = ColumnChart.loopIndex(categoryIndex + 1, this.data.categories.length);
                    break;

                  case services_interactivityService.x0.PreviousCategory:
                    categoryIndex = ColumnChart.loopIndex(categoryIndex - 1, this.data.categories.length);
                    break;

                  default:
                    debug.fF.assertFail("categoryIndex should not be less than 0 unless we are navigating on categories.");
                } else switch (direction) {
                  case services_interactivityService.x0.NextSeries:
                    seriesIndex = 0;
                    break;

                  case services_interactivityService.x0.PreviousSeries:
                    seriesIndex = this.data.series.length - 1;
                    break;

                  default:
                    debug.fF.assertFail("seriesIndex should be less than 0 unless we are navigating on series");
                }
                return this.isInViewport(element) ? {
                    element,
                    targetCategoryIndex: categoryIndex,
                    targetSeriesIndex: seriesIndex,
                    noShape: nextDataPoint && 0 === nextDataPoint.valueAbsolute
                } : this.getNextDataPoint(categoryIndex, seriesIndex, direction);
            }, ColumnChart.prototype.validateDirection = function(direction) {
                return !this.isBar || this.getVisualCategoryAxisIsScalar() || direction !== services_interactivityService.x0.NextSeries && direction !== services_interactivityService.x0.PreviousSeries || (direction = direction === services_interactivityService.x0.NextSeries ? services_interactivityService.x0.PreviousSeries : services_interactivityService.x0.NextSeries), 
                direction;
            }, ColumnChart.prototype.isInViewport = function(element) {
                if (!element) return !0;
                var bounding = element.getBBox(), viewport = this.currentViewport;
                return bounding.y + bounding.height > 0 && bounding.y < viewport.height && bounding.x + bounding.width > 0 && bounding.x < viewport.width;
            }, ColumnChart.prototype.getDataPointElement = function(seriesIndex, categoryIndex) {
                return this.mainGraphicsContext.selectAll(this.CS.selector).filter(function(d) {
                    return d.categoryIndex === categoryIndex && d.seriesIndex === seriesIndex;
                }).node();
            }, ColumnChart.prototype.findSeriesIndex = function(startSeriesIndex, targetCategoryIndex, forward) {
                return (forward ? _.findIndex : _.findLastIndex)(this.data.series, function(series) {
                    return _.some(series.data, function(d) {
                        return d.categoryIndex === targetCategoryIndex && null != d.value;
                    });
                }, startSeriesIndex);
            }, ColumnChart.findCategoryIndex = function(seriesData, currentCategoryIndex, forward) {
                var indexModifier = forward ? 1 : -1, dataCategoryIndex = _.findIndex(seriesData, function(d) {
                    return d.categoryIndex === currentCategoryIndex;
                });
                return dataCategoryIndex < 0 ? dataCategoryIndex : seriesData[dataCategoryIndex = ColumnChart.loopIndex(dataCategoryIndex + indexModifier, seriesData.length)].categoryIndex;
            }, ColumnChart.loopIndex = function(index, listLength) {
                return index >= listLength ? 0 : index < 0 ? listLength - 1 : index;
            }, ColumnChart.prototype.getCategoryValueType = function() {
                return cartesianAxisHelper.getCategoryValueType(this.data.categoryMetadata);
            }, ColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return !!this.data && this.data.isScalar;
            }, ColumnChart.prototype.getSupportedCategoryAxisType = function() {
                var _a, valueType = cartesianAxisHelper.getCategoryValueType(null === (_a = this.data) || void 0 === _a ? void 0 : _a.categoryMetadata);
                return (0, axisHelper.c$)(valueType) ? axisType.w.categorical : axisType.w.both;
            }, ColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = (0, Prototype.ED)(this.data);
                data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex), data.categories = data.categories.slice(startIndex, endIndex), 
                this.clippedData = data;
            }, ColumnChart.prototype.supportsTotalLabels = function() {
                return !(this.data && this.data.multipleIdentity) && this.isStacked && !this.isStacked100;
            }, ColumnChart.prototype.supportsTrendLine = function() {
                if (this.data.multipleIdentity) return !1;
                var reader = (0, dataViewCategoricalReader.y)(this.dataView), isScalar = this.getVisualCategoryAxisIsScalar();
                return 12 === this.columnChartType && isScalar && reader.data.hasValues("Y");
            }, ColumnChart.prototype.supportsStaticReferenceLines = function() {
                return this.data && !this.isValueAxisIrregular();
            }, ColumnChart.prototype.isValueAxisIrregular = function() {
                var _a, _b;
                return (null === (_a = this.data) || void 0 === _a ? void 0 : _a.layout.stackedGapSize) > 0 && (null === (_b = this.data) || void 0 === _b ? void 0 : _b.layout.stackedGapExplodes) && this.isStacked;
            }, ColumnChart.prototype.supportsStackedGapExplode = function() {
                return this.isStacked && !this.isStacked100 && !this.isComboChart;
            }, ColumnChart.prototype.getCartesianVisualCapabilities = function() {
                var _a;
                return {
                    supportsHierarchicalCategoryAxis: !0,
                    isValueAxisIrregular: this.isValueAxisIrregular(),
                    axesCapabilities: {
                        categoryAxis: {
                            domainAggregateRole: columnChart_capabilities.au.category,
                            supportedDomainAggregates: (null === (_a = this.data) || void 0 === _a ? void 0 : _a.isScalar) ? 3 : 0
                        },
                        valueAxis: {
                            domainAggregateRole: columnChart_capabilities.au.y,
                            supportedDomainAggregates: 84 === this.columnChartType || this.isStacked ? 1 : 3
                        }
                    }
                };
            }, ColumnChart.prototype.getStaticSeriesRole = function() {
                return "Y";
            }, Object.defineProperty(ColumnChart.prototype, "CS", {
                get: function() {
                    return columnChart_util.t3(this.columnChartType) ? {
                        class: "column",
                        selector: ".column"
                    } : {
                        class: "bar",
                        selector: ".bar"
                    };
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "chartTypeOptimized", {
                get: function() {
                    var _a, chartType = this.columnChartType, isStackedOriginalChart = columnChart_util.C3(chartType, null === (_a = this.data) || void 0 === _a ? void 0 : _a.series.length);
                    return 18 !== chartType || isStackedOriginalChart ? 20 !== chartType || isStackedOriginalChart ? chartType : 12 : 10;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "isStackedOptimized", {
                get: function() {
                    return columnChart_util.C3(this.chartTypeOptimized, 2) || this.hasRibbonBands;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "isClusteredOptimized", {
                get: function() {
                    return columnChart_util.V5(this.chartTypeOptimized);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "valueAxis", {
                get: function() {
                    return this.isColumn ? this.yAxisProperties : this.xAxisProperties;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "categoryAxis", {
                get: function() {
                    return this.isColumn ? this.xAxisProperties : this.yAxisProperties;
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChart.prototype.createCategoryAxis = function(options, includeDomainPreferred) {
                var _a, _b, _c, _d, data = this.activeData, isScalar = (_a = this.categoryLayout).isScalar, outerPaddingRatio = _a.outerPaddingRatio, categoryThickness = _a.categoryThickness, axisZoom = options.axisZoom, innerPaddingRatio = options.innerPaddingRatio, axis = (_b = options.categoryAxisOptions).axis, includeDomain = _b.includeDomain, props = cartesianAxisHelper.createAxis({
                    pixelSpan: this.isColumn ? this.width : this.height,
                    domainOptions: cartesianAxisHelper.createDomain(data.series, null !== (_d = null === (_c = data.categoryMetadata) || void 0 === _c ? void 0 : _c.type) && void 0 !== _d ? _d : valueType.Ge.fromDescriptor({
                        text: !0
                    }), isScalar, [ null != includeDomainPreferred ? includeDomainPreferred : includeDomain ]),
                    axisZoom,
                    metaDataColumn: data.categoryMetadata,
                    formatString: (0, valueFormatter.EO)(data.categoryMetadata, cartesian_capabilities.p.general.formatString),
                    outerPadding: categoryThickness * outerPaddingRatio,
                    outerPaddingRatio,
                    isCategoryAxis: !0,
                    isScalar,
                    isVertical: this.isBar,
                    categoryThickness,
                    useTickIntervalForDisplayUnits: !0,
                    getValueFn: function(index, type) {
                        return (0, cartesianHelper.dZ)(data, index, type, isScalar);
                    },
                    axis: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axis), {
                        invertAxis: axis.invertAxis && isScalar
                    }),
                    margin: this.margin,
                    allowSingleScalarTick: isScalar,
                    preventNice: cartesianAxisHelper.hasForcedDomain(includeDomain),
                    innerPaddingRatio,
                    orientation: this.isColumn ? axisHelper.Or.bottom : axis.switchAxisPosition ? axisHelper.Or.right : axisHelper.Or.left
                });
                return props.categoryIdentities = data.categoryIdentities, this.categoryLayout.categoryThickness = props.categoryThickness, 
                props;
            }, ColumnChart.prototype.createValueAxis = function(options, includeDomain, skipAxisZoomUpdate) {
                var _a, valueDomain, _this = this, axisZoom = options.axisZoom, forcedTickCount = options.forcedTickCount, valueAxisOptions = options.valueAxisOptions, axis = valueAxisOptions.axis;
                if (debug.fF.assert(function() {
                    return !(_this.isBar && void 0 !== forcedTickCount);
                }, "Cannot have bar chart as combo chart."), debug.fF.assert(function() {
                    return !(_this.isClusteredOptimized && _this.isStacked100);
                }, "Cannot have 100% clustered chart."), null != includeDomain || (includeDomain = valueAxisOptions.includeDomain), 
                this.isClusteredOptimized) valueDomain = cartesianAxisHelper.createUncertaintyAwareValueDomain(this.activeData.series) || cartesianAxisHelper.emptyDomain; else {
                    var valueDomainSrc = columnChart_util.VY(this.activeData.series, this.isStacked100);
                    valueDomain = [ valueDomainSrc.min, valueDomainSrc.max ];
                }
                var domainOptions = cartesianAxisHelper.mergeScalarAxisDomains(includeDomain, cartesianAxisHelper.createScalarDomainOptions(valueDomain, 0)), props = cartesianAxisHelper.createAxis({
                    pixelSpan: this.isColumn ? this.availableHeight : this.width,
                    domainOptions,
                    zeroScalarDomain: columnChart_util.iR,
                    metaDataColumn: this.activeData.valuesMetadata,
                    formatString: this.isStackedOptimized && this.isStacked100 ? this.hostService.getLocalizedString("Percentage") : null !== (_a = cartesianAxisHelper.getAxisFormatString(this.activeData.series)) && void 0 !== _a ? _a : (0, 
                    valueFormatter.EO)(this.activeData.valuesMetadata[0], cartesian_capabilities.p.general.formatString),
                    outerPadding: 0,
                    isScalar: !0,
                    isVertical: this.isColumn,
                    useTickIntervalForDisplayUnits: !0,
                    isCategoryAxis: !1,
                    shouldClamp: cartesianAxisHelper.scaleShouldClamp(null == domainOptions ? void 0 : domainOptions.domain, valueDomain),
                    preventNice: cartesianAxisHelper.hasForcedDomain(domainOptions) || this.isValueAxisIrregular(),
                    includeZero: cartesianAxisHelper.shouldIncludeZero(domainOptions),
                    axisZoom,
                    forcedTickCount,
                    axis,
                    margin: this.margin,
                    skipAxisZoomUpdate,
                    is100Pct: this.isStackedOptimized && this.isStacked100,
                    orientation: this.isColumn ? axis.switchAxisPosition ? axisHelper.Or.right : axisHelper.Or.left : axisHelper.Or.bottom
                });
                return props.isIrregular = this.isValueAxisIrregular(), this.isBar && props.d3Axis.tickSizeInner(-this.availableHeight).tickSizeOuter(0), 
                props;
            }, Object.defineProperty(ColumnChart.prototype, "categoryWidth", {
                get: function() {
                    return this.categoryLayout.categoryThickness * (1 - this.categoryLayout.innerPaddingRatio);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(ColumnChart.prototype, "columnWidth", {
                get: function() {
                    var seriesCount = this.activeData.series.length;
                    return seriesCount >= 2 && this.activeData.layout.clusteredGapSize > 0 && this.activeData.layout.clusteredGapOverlaps ? this.categoryWidth * (1 + (seriesCount - 1) * this.activeData.layout.clusteredGapSize / 100) / seriesCount : this.categoryBandScale.bandwidth();
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChart.prototype.createLabelDataPoints = function(style) {
                return columnChart_util.Q4.call(this, style);
            }, ColumnChart.prototype.createTotalLabelDataPoints = function(style) {
                return columnChart_util.$3.call(this, style);
            }, ColumnChart.prototype.createUncertaintyLabels = function(style) {
                return columnChart_util.EX.call(this, style);
            }, Object.defineProperty(ColumnChart.prototype, "ribbonGapSize", {
                get: function() {
                    var _a;
                    return this.categoryLayout.categoryThickness * this.categoryLayout.innerPaddingRatio * (null !== (_a = this.data.layout.ribbonGapSize) && void 0 !== _a ? _a : 0) / 100;
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChart.prototype.drawColumns = function(useAnimation) {
                var _a, _this = this;
                debug.fF.assertValue(this.activeData, "data should be defined"), this.glyphsCenters = null, 
                this.layout = this.getColumnLayout();
                var shapes, uncertaintyShapes, onDragStart, renderWithoutAnimation = !0, series = columnChart_renderer.kC.call(this);
                return this.animator && useAnimation && (shapes = (_a = this.animator.animate({
                    chart: this,
                    series,
                    valueAxisProps: this.isClusteredOptimized ? this.valueAxis : void 0,
                    isBar: this.isClusteredOptimized ? this.isBar : void 0,
                    columnWidth: this.isClusteredOptimized ? this.columnWidth : void 0,
                    layout: this.layout,
                    interactivityService: this.interactivityService
                })).shapes, uncertaintyShapes = _a.uncertaintyShapes, renderWithoutAnimation = _a.failed), 
                renderWithoutAnimation && (uncertaintyShapes = columnChart_renderer.WR.call(this, {
                    isBar: this.isBar,
                    valueAxisProps: this.isStackedOptimized ? void 0 : this.valueAxis,
                    layout: this.isStackedOptimized ? void 0 : this.layout,
                    columnWidth: this.isStackedOptimized ? void 0 : this.columnWidth,
                    interactivityService: this.isStackedOptimized ? void 0 : this.interactivityService
                }), shapes = columnChart_renderer.Wv.call(this, series), this.isClusteredOptimized && (0, 
                d3Helper.LL)(this.mainGraphicsContext, [ columnChart_util.L0, uncertainty_renderer.jx ])), 
                columnChart_renderer.hJ.call(this, useAnimation, this.animator), this.dragDataPoint && (onDragStart = function(datum) {
                    datum.identity && _this.hostService.onDragStart({
                        event: d3.event,
                        data: {
                            data: datum.identity.getSelector()
                        }
                    });
                }), columnChart_renderer.bk(shapes, onDragStart), {
                    eventGroup: this.mainGraphicsContext,
                    shapesSelection: shapes,
                    uncertaintyShapes: this.isClusteredOptimized ? uncertaintyShapes : void 0,
                    labelDataPointGroups: (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)((0, 
                    tslib_es6.__spreadArray)([], this.createLabelDataPoints(this.style), !0), this.createUncertaintyLabels(this.style), !0), this.createTotalLabelDataPoints(this.style), !0),
                    animateLabels: !renderWithoutAnimation
                };
            }, Object.defineProperty(ColumnChart.prototype, "scaledMargin", {
                get: function() {
                    var _a, scale = null !== (_a = this.currentViewport.scale) && void 0 !== _a ? _a : 1;
                    return {
                        top: this.margin.top * scale,
                        right: this.margin.right * scale,
                        bottom: this.margin.bottom * scale,
                        left: this.margin.left * scale
                    };
                },
                enumerable: !1,
                configurable: !0
            }), ColumnChart.prototype.getGlyphCenters = function() {
                var _this = this;
                if (!this.glyphsCenters && this.activeData.series.length > 0) {
                    var scaleOffset_1 = 0;
                    this.categoryLayout.isScalar || (scaleOffset_1 = this.categoryWidth / 2), this.glyphsCenters = this.activeData.series[0].data.map(function(d) {
                        return _this.categoryAxis.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + scaleOffset_1;
                    });
                }
                return this.glyphsCenters;
            }, ColumnChart.prototype.moveHandle = function(selectedColumnIndex) {
                var _a, glyphCenters = this.getGlyphCenters(), hoverLine = d3.select(".interactive-hover-line");
                if (hoverLine.empty() || this.columnSelectionLineHandle || (this.columnSelectionLineHandle = d3.select(hoverLine.node().parentElement)), 
                !glyphCenters || glyphCenters.length <= 1) null === (_a = this.columnSelectionLineHandle) || void 0 === _a || _a.remove(); else {
                    var c = glyphCenters[selectedColumnIndex];
                    this.columnSelectionLineHandle ? (this.columnSelectionLineHandle.select("line").attrs(this.isColumn ? {
                        x1: c,
                        x2: c
                    } : {
                        y1: c,
                        y2: c
                    }), this.columnSelectionLineHandle.select("circle").attrs(this.isColumn ? {
                        cx: c
                    } : {
                        cy: c
                    })) : (this.columnSelectionLineHandle = this.unclippedGraphicsContext.append("g"), 
                    this.columnSelectionLineHandle.append("line").classed("interactive-hover-line", !0).attrs(this.isColumn ? {
                        x1: c,
                        x2: c,
                        y1: 0,
                        y2: this.height
                    } : {
                        y1: c,
                        y2: c,
                        x1: 0,
                        x2: this.width
                    }), this.columnSelectionLineHandle.append("circle").classed("drag-handle", !0).attrs(this.isColumn ? {
                        cx: c,
                        cy: this.height
                    } : {
                        cy: c,
                        cx: 0
                    }).attr("r", "6px"));
                }
            }, ColumnChart.prototype.getColumnLayout = function() {
                var _this = this, columnWidth = this.columnWidth, isCategoryScalar = this.categoryLayout.isScalar, invertAxis = this.valueAxis.invertAxis, valueScale = this.valueAxis.scale, categoryScale = this.categoryAxis.scale, scaleOffset = isCategoryScalar ? this.categoryWidth / 2 : 0, convertToXY = function(_a) {
                    var catSize = _a.catSize, catBase = _a.catBase, valueSize = _a.valueSize, valueBase = _a.valueBase;
                    return _this.isColumn ? {
                        width: catSize,
                        x: catBase,
                        height: valueSize,
                        y: valueBase
                    } : {
                        height: catSize,
                        y: catBase,
                        width: valueSize,
                        x: valueBase
                    };
                };
                if (this.isStackedOptimized) {
                    var categoryLayout = {
                        catSize: function(_) {
                            return columnWidth;
                        },
                        catBase: function(d) {
                            return categoryScale(isCategoryScalar ? d.categoryValue : d.categoryIndex) - scaleOffset;
                        }
                    }, eitherOr_1 = function(a, b) {
                        return a !== b;
                    }, swapsPositiveDirection_1 = function(isNegative) {
                        return eitherOr_1(eitherOr_1(isNegative, _this.isBar), invertAxis);
                    }, erodeGap_1 = this.data.layout.stackedGapExplodes ? 0 : this.data.layout.stackedGapSize, pointErodeSize_1 = function(d) {
                        return d.indexFromZeroValue > 0 ? erodeGap_1 : 0;
                    }, getOriginalSize_1 = function(d) {
                        return Math.abs(valueScale(d.originalPosition - Math.abs(d.originalValue)) - valueScale(d.originalPosition));
                    }, valueSizeWithErode_1 = function(d, useOriginal) {
                        void 0 === useOriginal && (useOriginal = !1);
                        var position = useOriginal ? d.originalPosition : d.position, size = Math.abs(valueScale(position - Math.abs(useOriginal ? d.originalValue : d.value)) - valueScale(position)), pointErode = pointErodeSize_1(d);
                        return 0 === pointErode ? size : d.highlight ? size * (1 - Math.min(1, pointErode / getOriginalSize_1(d))) : Math.min(Math.max(1, size - pointErode), size);
                    }, valueBaseWithErode_1 = function(d, useOriginal) {
                        void 0 === useOriginal && (useOriginal = !1);
                        var position = useOriginal ? d.originalPosition : d.position, value = useOriginal ? d.originalValue : d.value, base = valueScale(eitherOr_1(invertAxis, _this.isColumn) ? position : position - Math.abs(value)), pointErode = pointErodeSize_1(d);
                        if (0 === pointErode) return base;
                        if (!d.highlight || useOriginal || swapsPositiveDirection_1(value < 0)) {
                            if (!swapsPositiveDirection_1(value < 0)) return base;
                            base += pointErode;
                        } else {
                            var hSize = function(d) {
                                return Math.abs(valueScale(d.position - Math.abs(d.value)) - valueScale(d.position));
                            }(d), orgSize = getOriginalSize_1(d);
                            base -= pointErode * ((orgSize - hSize) / orgSize);
                        }
                        var ceiling = valueScale(eitherOr_1(invertAxis, _this.isColumn) ? d.originalPosition - Math.abs(d.originalValue) : d.originalPosition);
                        return Math.min(base, ceiling);
                    };
                    return {
                        shapeLayout: convertToXY((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryLayout), {
                            valueSize: function(d) {
                                return valueSizeWithErode_1(d);
                            },
                            valueBase: function(d) {
                                return valueBaseWithErode_1(d);
                            }
                        })),
                        shapeLayoutWithoutHighlights: convertToXY((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryLayout), {
                            valueSize: function(d) {
                                return valueSizeWithErode_1(d, !0);
                            },
                            valueBase: function(d) {
                                return valueBaseWithErode_1(d, !0);
                            }
                        })),
                        zeroShapeLayout: convertToXY((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryLayout), {
                            valueSize: function(_) {
                                return 0;
                            },
                            valueBase: function(d) {
                                return valueScale(d.value >= 0 ? d.position - d.valueAbsolute : d.position);
                            }
                        }))
                    };
                }
                var halfColumnWidth = .5 * columnWidth, quarterColumnWidth = halfColumnWidth / 2, scaledValueZero = valueScale(0), valuePos = function(clampedValue) {
                    return scaledValueZero + (0, axisHelper.sc)(valueScale, clampedValue, 0);
                }, categoryPos = function(d) {
                    return categoryScale(isCategoryScalar ? d.categoryValue : d.categoryIndex) + _this.categoryBandScale("".concat(d.seriesPosition)) - scaleOffset;
                };
                return {
                    shapeLayout: convertToXY({
                        catSize: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        },
                        catBase: function(d) {
                            return categoryPos(d) + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        valueSize: function(d) {
                            return Math.abs((0, axisHelper.sc)(valueScale, 0, d.value));
                        },
                        valueBase: this.isColumn ? function(d) {
                            return valuePos(invertAxis ? Math.min(0, d.value) : Math.max(0, d.value));
                        } : function(d) {
                            return valuePos(invertAxis ? Math.max(0, d.value) : Math.min(0, d.value));
                        }
                    }),
                    shapeLayoutWithoutHighlights: convertToXY({
                        catSize: function(_) {
                            return columnWidth;
                        },
                        catBase: function(d) {
                            return categoryPos(d);
                        },
                        valueSize: function(d) {
                            return Math.abs((0, axisHelper.sc)(valueScale, 0, d.originalValue));
                        },
                        valueBase: this.isColumn ? function(d) {
                            return valuePos(invertAxis ? Math.min(0, d.originalValue) : Math.max(0, d.originalValue));
                        } : function(d) {
                            return valuePos(invertAxis ? Math.max(0, d.originalValue) : Math.min(0, d.originalValue));
                        }
                    }),
                    zeroShapeLayout: convertToXY({
                        catSize: function(d) {
                            return d.drawThinner ? halfColumnWidth : columnWidth;
                        },
                        catBase: function(d) {
                            return categoryPos(d) + (d.drawThinner ? quarterColumnWidth : 0);
                        },
                        valueSize: function(_) {
                            return 0;
                        },
                        valueBase: this.isColumn ? function(_) {
                            return scaledValueZero;
                        } : function(d) {
                            return valuePos(invertAxis ? Math.max(0, d.value) : Math.min(0, d.value));
                        }
                    }),
                    uncertaintyLayout: {
                        lower: function(d) {
                            var _a, _b;
                            if (null != (null === (_a = d.uncertainty) || void 0 === _a ? void 0 : _a.lower)) return valueScale(null === (_b = d.uncertainty) || void 0 === _b ? void 0 : _b.lower);
                        },
                        upper: function(d) {
                            var _a, _b;
                            if (null != (null === (_a = d.uncertainty) || void 0 === _a ? void 0 : _a.upper)) return valueScale(null === (_b = d.uncertainty) || void 0 === _b ? void 0 : _b.upper);
                        }
                    }
                };
            }, ColumnChart.ClassName = "columnChart", ColumnChart;
        }(ResponsiveCartesianLayer), lineChart_capabilities = __webpack_require__(69871), anomalyDetectionCartesianRenderer = __webpack_require__(42589), anomalyDetectionKeyboardNavigationHelper = __webpack_require__(40006), anomalyDetectionVisualPlugin = __webpack_require__(80822), marker_renderer = __webpack_require__(51995), marker_converter = __webpack_require__(94038), types_legendMarkerRendering = __webpack_require__(37865), formattingService = __webpack_require__(28326), lineChartRoles = __webpack_require__(6714), lineInterpolation = __webpack_require__(17772), dataLabelContainerTruncation = __webpack_require__(45028), marker = __webpack_require__(66123), horizontalPosition = __webpack_require__(92374), labelContentLayout = __webpack_require__(63892), detailContentType = __webpack_require__(93907), TooltipOverlaySelector = (0, 
        CssConstants.CH)("tooltip-overlay"), MarkerShapeSizeRange = {
            min: 1,
            max: 20
        };
        function getDefaultLineStyle(isAreaChart) {
            return void 0 === isAreaChart && (isAreaChart = !1), (0, tslib_es6.__assign)({
                strokeShow: !0,
                strokeColor: void 0,
                strokeTransparency: 0,
                strokeWidth: 2,
                strokeLineJoin: strokeLineJoin.t.round,
                strokePattern: strokePattern.Dv.solid,
                strokeDashArray: strokePattern.YU,
                strokeDashCap: strokePattern.xm,
                strokeAutoScale: !1,
                markerProperties: {
                    show: !1,
                    showMarkerByDefault: !0,
                    shape: markerShape.ZO.circle,
                    size: marker.$V,
                    color: void 0,
                    transparency: 0,
                    rotation: 0,
                    stroke: {
                        strokeShow: !0,
                        strokePattern: strokePattern.Dv.solid,
                        strokeColor: void 0,
                        strokeTransparency: 0,
                        strokeWidth: void 0
                    }
                },
                areaShow: isAreaChart,
                areaColor: void 0,
                areaTransparency: 60,
                areaMatchStrokeColor: !0
            }, (0, lineInterpolation.aQ)());
        }
        function getFocusOnlyMarkerRadius(lineStyle) {
            return lineStyle.strokeWidth / 2 + 3;
        }
        function getDefaultLineChartLabelSettings(style, isCombo, isStacked100) {
            void 0 === isCombo && (isCombo = !1), void 0 === isStacked100 && (isStacked100 = !1);
            var defaultFontProperties = (0, dataLabelViewModel1.bT)({
                style,
                labelColor: common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ),
                textClassName: "smallLightLabel"
            }).fontProperties;
            return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                show: !1,
                showByDefault: !0
            }, defaultFontProperties), {
                bold: !1,
                italic: !1,
                underline: !1,
                position: labelPosition1.h.auto,
                horizontalAlignment: horizontalPosition.D.center,
                minimumOffset: void 0,
                maximumOffset: void 0,
                labelDensity: dataLabelViewModel1Consts.go,
                labelContainerMaxWidth: dataLabelContainerTruncation.w9,
                labelContentLayout: labelContentLayout.v.SingleLine,
                optimizeLabelDisplay: !1,
                enableValueDataLabel: !isStacked100,
                fontProperties: defaultFontProperties,
                displayUnits: 0,
                precision: dataLabelViewModel1Consts.NZ,
                valueCustomFormatString: dataLabelViewModel1Consts.M3,
                enableTitleDataLabel: !1,
                titleFontProperties: defaultFontProperties,
                titleLabelDisplayUnits: 0,
                titleLabelPrecision: dataLabelViewModel1Consts.NZ,
                titleCustomFormatString: dataLabelViewModel1Consts.M3,
                enableDetailDataLabel: isStacked100,
                detailFontProperties: defaultFontProperties,
                detailLabelDisplayUnits: 0,
                detailLabelPrecision: dataLabelViewModel1Consts.NZ,
                detailCustomFormatString: dataLabelViewModel1Consts.M3,
                detailContentType: isStacked100 ? detailContentType.W.Percent : void 0,
                leaderLine: (0, dataLabelUtil.sW)(style),
                enableBackground: isCombo,
                backgroundColor: isCombo ? common_colorHelper.v.getThemeColor(style, colorHelper.U) : void 0,
                backgroundTransparency: isCombo ? dataLabelViewModel1Consts.r_ : void 0
            });
        }
        function hasAnomalies(data) {
            return _.some(data.anomalyDetections, function(anomalyDetection) {
                return !_.isEmpty(anomalyDetection.anomaliesCategoryIndex);
            });
        }
        function isAnomaly(data) {
            return data.isAnomaly;
        }
        function isForecastPoint(data) {
            return data && null != data.points;
        }
        function getMarkerXPositionCalc(chart, dataPoint, mainGraphicsSVGLeft) {
            return Mockable.convertSvgXToClientX(getXPositionWithOffset(chart, dataPoint), chart.currentViewport.scale, mainGraphicsSVGLeft);
        }
        var Mockable = {
            convertSvgXToClientX: function(svgX, xScale, left) {
                return svgX * xScale + left;
            },
            convertSvgYToClientY: function(svgY, yScale, top) {
                return svgY * yScale + top;
            }
        };
        function getXValue(chart, d) {
            return chart.activeData.isScalar ? d.categoryValue : d.categoryIndex;
        }
        function getXPositionWithOffset(chart, d) {
            return chart.xAxisProperties.scale(getXValue(chart, d)) + chart.horizontalOffset;
        }
        function getYPosition(chart, d) {
            var _a;
            return d.isY2 ? null === (_a = chart.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale(d.value) : chart.yAxisProperties.scale(chart.isStackedArea ? d.stackedValue : d.value);
        }
        function getUncertaintyLowerYPosition(chart, d) {
            var _a, _b;
            return d.isY2 ? null === (_a = chart.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale(d.uncertainty.lower) : null === (_b = chart.yAxisProperties) || void 0 === _b ? void 0 : _b.scale(d.uncertainty.lower);
        }
        function getUncertaintyUpperYPosition(chart, d) {
            var _a, _b;
            return d.isY2 ? null === (_a = chart.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale(d.uncertainty.upper) : null === (_b = chart.yAxisProperties) || void 0 === _b ? void 0 : _b.scale(d.uncertainty.upper);
        }
        var LineChartConverter = function() {
            function LineChartConverter(options) {
                this.options = options, debug.fF.assertValue(options.dataView, "dataView"), debug.fF.assertValue(options.style, "style");
                var dataView = options.dataView, xAxisCardProperties = (0, cartesianHelper.Vk)(dataView.metadata);
                this.isScalar = (0, cartesianHelper.qU)(this.options.isScalar, xAxisCardProperties);
                var category = (0, cartesianHelper.Zo)(dataView.categorical, this.isScalar).category;
                this.isDateTime = (0, axisHelper.v9)((0, cartesianAxisHelper.getCategoryValueType)(category.source, this.isScalar)), 
                this.reader = (0, dataViewCategoricalReader.G)(dataView, {
                    staticSeriesRoleNames: this.valueRoleNames,
                    colorOptions: {
                        visualStyle: options.style,
                        valueRole: this.primaryValueRole,
                        ignoreDefaultColor: options.isComboChart,
                        ignoreDefaultCategoryColor: !0
                    },
                    formatStringProp: lineChart_capabilities.zK.general.formatString,
                    errorRangeProp: dataViewObjectProperties.Qx.errorRange
                });
            }
            return Object.defineProperty(LineChartConverter.prototype, "primaryValueRole", {
                get: function() {
                    return this.options.isComboChart ? lineChartRoles.R.Y2 : lineChartRoles.R.Y;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChartConverter.prototype, "secondaryValueRole", {
                get: function() {
                    return this.options.isComboChart ? void 0 : lineChartRoles.R.Y2;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChartConverter.prototype, "valueRoleNames", {
                get: function() {
                    return [ this.primaryValueRole, this.secondaryValueRole ].filter(function(role) {
                        return role;
                    });
                },
                enumerable: !1,
                configurable: !0
            }), LineChartConverter.convert = function(options) {
                return new LineChartConverter(options).convert();
            }, Object.defineProperty(LineChartConverter.prototype, "staticObjects", {
                get: function() {
                    return this.reader.objects.getStaticObjects();
                },
                enumerable: !1,
                configurable: !0
            }), LineChartConverter.prototype.convert = function() {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, scalarMetadataColumn, _0 = this.options, dataView = _0.dataView, style = _0.style, interactivityService = _0.interactivityService, isStacked = _0.isStacked, isStacked100 = _0.isStacked100, isComboChart = _0.isComboChart, anomalyDetectionDataView = _0.anomalyDetectionDataView, _1 = _0.tooltipsEnabled, tooltipsEnabled = void 0 === _1 || _1, multipleInfo = _0.multipleInfo, hostServices = _0.hostServices, xAxisCardProperties = (0, 
                cartesianHelper.Vk)(dataView.metadata), _2 = (0, cartesianHelper.Zo)(dataView.categorical, this.isScalar), category = _2.category, useScalarKeys = _2.useScalarKeys, scalarKeys = _2.scalarKeys;
                useScalarKeys && ((scalarMetadataColumn = (0, Prototype.ED)(category.source)).type = {
                    dateTime: !0
                });
                var multipleQueryName, multipleIdentity, multipleDisplayName, multipleValueDetails, formatStringProp = lineChart_capabilities.zK.general.formatString, categoryData = [], categoryIdentities = [], multiplesCategoryIdentities = [], series = [], values = dataView.categorical.values, hasDynamicSeries = !(!values || !values.source), defaultLabelSettings = getDefaultLineChartLabelSettings(style, isComboChart, isStacked100), colorHelper = common_colorHelper.v.create(style);
                if (multipleInfo) {
                    multipleQueryName = _.first(multipleInfo.sources).metadata.queryName, multipleValueDetails = multipleInfo.sources.map(function(source) {
                        return (0, selection_selectionId.Y)(source.metadata, source.value, multipleInfo.identity);
                    }), multipleIdentity = (new selection_selectionId.dw).withColumnIdentity(multipleInfo.identity, multipleQueryName, multipleValueDetails).createSelectionId();
                    var formatter_1 = (0, formattingStrategy.F)(formatStringProp);
                    multipleDisplayName = (0, concatenateUtils.ML)(_.map(multipleInfo.sources, function(source) {
                        return formatter_1(source.value, source.metadata);
                    }));
                }
                this.staticObjects && (0, dataLabelViewModel1.AR)(this.staticObjects.labels, defaultLabelSettings, void 0, style, isComboChart);
                var totalLabelsSettings = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, defaultLabelSettings), {
                    show: !1
                });
                this.options.supportsTotalLabels && this.staticObjects && (0, dataLabelViewModel1.ww)(this.staticObjects.totals, totalLabelsSettings, !1, style, isComboChart);
                var grouped = null !== (_a = null == values ? void 0 : values.grouped()) && void 0 !== _a ? _a : void 0, stackedValues = isStacked && (null == values ? void 0 : values.length) > 0 ? _.times(values[0].values.length, function() {
                    return 0;
                }) : [], dataReader = this.reader.data, columnReader = this.reader.columns, categoryCount = dataReader.hasCategories() ? dataReader.getCategoryCount() : 1, seriesCount = dataReader.getSeriesCount();
                this.seriesColors = this.allocateSeriesColors(), this.staticLineStyle = this.readLineStyleFromObjects(null, style);
                var valuesMetadataArray = columnReader.getAllValueMetadataColumnsForRole(this.primaryValueRole);
                this.secondaryValueRole && (valuesMetadataArray = (0, tslib_es6.__spreadArray)((0, 
                tslib_es6.__spreadArray)([], valuesMetadataArray || [], !0), columnReader.getAllValueMetadataColumnsForRole(this.secondaryValueRole) || [], !0));
                var anomalyDetections, valuesMetadataBySeries = [], totals = [];
                anomalyDetectionDataView && this.isScalar && !isStacked && !isComboChart && (anomalyDetections = (0, 
                anomalyDetection_converter.Eb)(anomalyDetectionDataView, dataView, style, formatStringProp), 
                debug.fF.assert(function() {
                    return anomalyDetections.length === seriesCount;
                }, "anomalyDetections length should be the same as series count"));
                var seriesDisplayName, seriesOrderReversed = (0, dataViewObject2.NA)(this.staticObjects, lineChart_capabilities.zK.layout.seriesOrderReversed, columnChart_util.HQ.seriesOrderReversed), seriesNames = this.getSeriesNames(), defaultSeriesSettings = getDefaultSeriesLabelSettings(style), hasValues = !1;
                if (_.some(this.valueRoleNames, function(name) {
                    return dataReader.hasValues(name);
                })) {
                    var firstRoleSeriesLength = this.reader.columns.getSeriesCount(this.primaryValueRole);
                    if (hasValues = !0, seriesDisplayName = hasDynamicSeries ? (0, converterHelper.xq)(dataReader.getSeriesDisplayName(), columnReader.getSeriesMetadataColumn(), formatStringProp) : void 0, 
                    this.staticObjects) {
                        (0, dataLabelViewModel1.FJ)(this.staticObjects.seriesLabels, defaultSeriesSettings, style, isComboChart);
                        var maximumWidth = function(fontProperties, seriesNames) {
                            var maximumWidth = 1;
                            if (seriesNames) for (var seriesCount = seriesNames.length, seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var labelTextProperties = dataLabelViewModel1Consts.bN, properties = {
                                    text: seriesNames[seriesIndex],
                                    fontFamily: fontProperties.family,
                                    fontSize: StandaloneUtility1.FP.fromPoint(fontProperties.size.pt),
                                    fontWeight: labelTextProperties.fontWeight
                                }, seriesWidth = textMeasurementService.b.measureSvgTextWidth(properties) + 2 * dataLabelViewModel1Consts.Bo;
                                maximumWidth = seriesWidth > maximumWidth ? seriesWidth : maximumWidth;
                            }
                            return maximumWidth;
                        }(defaultSeriesSettings.fontProperties, seriesNames);
                        defaultSeriesSettings.defaultSeriesWidth = defaultSeriesSettings.defaultSeriesWidth ? maximumWidth : null, 
                        defaultSeriesSettings.maxWidthPercentage = defaultSeriesSettings.defaultSeriesWidth ? maximumWidth : defaultSeriesSettings.maxWidthPercentage;
                    }
                    for (var valueMetadataColumns = [], defaultLabelColor = defaultLabelSettings.fontProperties.color, multipliers = isStacked100 ? generate100StackedMultipliers(categoryCount, seriesCount, function(seriesIndex, categoryIndex) {
                        return dataReader.getValueBySeries(categoryIndex, seriesIndex);
                    }) : [], _loop_1 = function(s) {
                        var seriesIndex = seriesOrderReversed ? seriesCount - s - 1 : s, dynamicLabelsEnabledForSeries = this_1.reader.labels.dynamicLabelReader.areDynamicValueLabelsEnabled(null === (_b = this_1.options.featureSwitches) || void 0 === _b ? void 0 : _b.labelEnhancementsM0, seriesIndex), isY2 = seriesIndex >= firstRoleSeriesLength, column = columnReader.getValueColumnBySeries(seriesIndex), seriesValueColumn = grouped && grouped[seriesIndex], valuesMetadata = valueMetadataColumns[seriesIndex] = column.source, dataPoints = [], seriesIdentity = selection_selectionId.dw.builder().withSeries(values, seriesValueColumn, !0).withMeasure(valuesMetadata.queryName).createSelectionId(), seriesKey = seriesIdentity.getKey(), lineChartDataLabelsSettings = void 0, seriesLabelSettings = (0, 
                        Prototype.ED)(defaultSeriesSettings);
                        if (this_1.reader.data.hasSeries() || isComboChart) {
                            var seriesObjects = isComboChart && !this_1.reader.data.hasSeries() ? this_1.reader.objects.getValueMetadataObjectsBySeries(seriesIndex) : this_1.reader.objects.getSeriesDataObjects(seriesIndex), labelObjects = null == seriesObjects ? void 0 : seriesObjects.labels, labelSeriesObjects = null == seriesObjects ? void 0 : seriesObjects.seriesLabels;
                            (lineChartDataLabelsSettings = (0, Prototype.ED)(defaultLabelSettings)).show = defaultLabelSettings.show && (null === (_c = defaultLabelSettings.showByDefault) || void 0 === _c || _c), 
                            labelObjects && (0, dataLabelViewModel1.AR)(labelObjects, lineChartDataLabelsSettings, void 0, style, isComboChart), 
                            seriesLabelSettings.show = defaultSeriesSettings.show && (null === (_d = defaultSeriesSettings.showByDefault) || void 0 === _d || _d), 
                            labelSeriesObjects && (0, dataLabelViewModel1.FJ)(labelSeriesObjects, seriesLabelSettings, style, isComboChart);
                        }
                        for (var out_dataPointsIndex_1, measureUncertainty = (0, uncertainty_converter.nC)(valuesMetadata.objects, style, this_1.seriesColors[seriesIndex], seriesIndex, (0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, defaultLabelSettings), {
                            show: !1
                        }), {
                            isCombo: isComboChart,
                            staticObjects: this_1.staticObjects
                        }), hasUncertainty = measureUncertainty.hasUncertainty, dataPointLabelSettings = null != lineChartDataLabelsSettings ? lineChartDataLabelsSettings : defaultLabelSettings, useHighlightValues = (null === (_e = column.highlights) || void 0 === _e ? void 0 : _e.length) > 0, lineStyle = this_1.readLineStyleFromObjects(seriesIndex, style), anomalyDetection = _.get(anomalyDetections, seriesIndex), anomalyTooltipBuilder = anomalyDetection ? new anomalyDetection_converter.LO(hostServices, anomalyDetection, valuesMetadata, formatStringProp) : void 0, hasCheckedLabelModificationForSeries = !1, _loop_2 = function(categoryIndex, dataPointsIndex) {
                            var categoryValue = category.values[categoryIndex], xAxisValue = useScalarKeys ? null === (_f = scalarKeys.values[categoryIndex]) || void 0 === _f ? void 0 : _f.min : categoryValue, originalValue = (0, 
                            axisHelper.eT)(useHighlightValues ? dataReader.getHighlightBySeries(categoryIndex, seriesIndex) : dataReader.getValueBySeries(categoryIndex, seriesIndex)), isNegative = originalValue < 0, value = isStacked100 ? originalValue * multipliers[categoryIndex][isNegative ? "neg" : "pos"] : originalValue;
                            if (this_1.isScalar && (null == xAxisValue || null == value)) return out_dataPointsIndex_1 = dataPointsIndex, 
                            "continue";
                            if (this_1.isDateTime && null != categoryValue && !(categoryValue instanceof Date)) return out_dataPointsIndex_1 = dataPointsIndex, 
                            "continue";
                            if (dataPointsIndex++, null == value && (seriesOrderReversed ? seriesIndex < seriesCount - 1 : seriesIndex > 0)) return out_dataPointsIndex_1 = dataPointsIndex, 
                            "continue";
                            var formatString = useHighlightValues ? dataReader.getHighlightFormatStringBySeries(categoryIndex, seriesIndex) : dataReader.getFormatStringBySeries(categoryIndex, seriesIndex), dataPointUncertainty = hasUncertainty ? (0, 
                            uncertainty_converter.PT)(dataReader, categoryIndex, seriesIndex, value) : void 0, tooltipInfo = void 0, additionalTooltipItems = void 0, hierarchyCategoryLevels = category.source ? (0, 
                            concatenateUtils.AD)(dataView.categorical.categories, categoryIndex, formatStringProp) : void 0;
                            if (tooltipsEnabled) {
                                if (tooltipInfo = [], multipleInfo) {
                                    var tooltipBuilder = new Visuals_tooltip.E4;
                                    tooltipBuilder.withMultipleColumnAndValues(multipleInfo.sources.map(function(source) {
                                        return source.metadata;
                                    }), multipleInfo.sources.map(function(source) {
                                        return source.value;
                                    }), !0, (0, formattingStrategy.F)(formatStringProp)), tooltipInfo.push.apply(tooltipInfo, tooltipBuilder.getTooltipItems());
                                }
                                category.source && tooltipInfo.push((0, concatenateUtils.bR)(hierarchyCategoryLevels));
                                var valueFormatterFunc = function(givenValue) {
                                    return (0, converterHelper.xq)(givenValue, valuesMetadata, formatStringProp, !1, formatString);
                                };
                                if (hasDynamicSeries && (category.source && category.source === values.source || tooltipInfo.push({
                                    displayName: values.source.displayName,
                                    value: (0, converterHelper.xq)(grouped[seriesIndex].name, values.source, formatStringProp)
                                })), null != value) {
                                    var tooltipToAdd = {
                                        displayName: valuesMetadata.displayName,
                                        value: this_1.options.isStacked100 ? "".concat(valueFormatterFunc(originalValue), " (").concat((0, 
                                        valueFormatter.WU)(value, (0, valueFormatter.Z)("Percentage")), ")") : valueFormatterFunc(originalValue)
                                    }, uncertaintyTooltips = measureUncertainty.tooltips;
                                    if (hasUncertainty && uncertaintyTooltips.show && uncertaintyTooltips.format === errorFormat.K.range) {
                                        var tooltipItems_1 = (0, uncertainty_util.kS)(dataPointUncertainty, value, measureUncertainty, valueFormatterFunc, hostServices, {
                                            overrideDisplayName: valuesMetadata.displayName
                                        });
                                        debug.fF.assert(function() {
                                            return void 0 === tooltipItems_1 || 1 === tooltipItems_1.length;
                                        }, "getUncertaintyTooltipItems() with 'range' format should return exactly one item or undefined when when bounds have not been set yet"), 
                                        _.isEmpty(tooltipItems_1) || (tooltipToAdd = tooltipItems_1[0]);
                                    }
                                    tooltipInfo.push(tooltipToAdd);
                                }
                                hasUncertainty && (isComboChart && measureUncertainty.tooltips.format !== errorFormat.K.range ? tooltipInfo.push.apply(tooltipInfo, null !== (_g = (0, 
                                uncertainty_util.kS)(dataPointUncertainty, value, measureUncertainty, valueFormatterFunc, hostServices, {
                                    hideMarker: !0
                                })) && void 0 !== _g ? _g : []) : (0, uncertainty_util.$w)(dataPointUncertainty, value, measureUncertainty, valueFormatterFunc, hostServices)), 
                                (0, Visuals_tooltip.VT)(this_1.reader, additionalTooltipItems = [], categoryIndex, hasDynamicSeries ? seriesIndex : void 0, formatStringProp);
                                var anomalyTooltipItems = null == anomalyTooltipBuilder ? void 0 : anomalyTooltipBuilder.getTooltipItems(categoryIndex, formatString);
                                anomalyTooltipItems && additionalTooltipItems.push.apply(additionalTooltipItems, anomalyTooltipItems), 
                                additionalTooltipItems = _.isEmpty(additionalTooltipItems) ? void 0 : additionalTooltipItems;
                            }
                            var idBuilder = new selection_selectionId.dw, withCategory = null !== (_h = dataView.categorical.originalCategories) && void 0 !== _h ? _h : [ category ];
                            dataReader.hasCategories() && (idBuilder = idBuilder.withCategory(withCategory, categoryIndex, null === (_k = null === (_j = columnReader.getCategoryColumn("Category")) || void 0 === _j ? void 0 : _j.source) || void 0 === _k ? void 0 : _k.queryName, !0)), 
                            hasDynamicSeries && (idBuilder = idBuilder.withSeries(values, seriesValueColumn, !0)), 
                            multipleInfo && (idBuilder = idBuilder.withColumnIdentity(multipleInfo.identity, multipleQueryName, multipleValueDetails)), 
                            null !== (_l = totals[categoryIndex]) && void 0 !== _l || (totals[categoryIndex] = {
                                positive: 0,
                                positiveCount: 0,
                                negative: 0,
                                negativeCount: 0,
                                net: 0,
                                categoryValue: this_1.convertCategoryValue(xAxisValue, this_1.isDateTime, useScalarKeys),
                                categoryIndex,
                                dynamicFormatString: formatString
                            });
                            var valueAbsolute = Math.abs(value);
                            isNaN(valueAbsolute) || (isNegative ? (totals[categoryIndex].net -= valueAbsolute, 
                            totals[categoryIndex].net < totals[categoryIndex].negative && (totals[categoryIndex].negative = totals[categoryIndex].net, 
                            totals[categoryIndex].negativeCount++)) : (totals[categoryIndex].net += valueAbsolute, 
                            totals[categoryIndex].net > totals[categoryIndex].positive && (totals[categoryIndex].positive = totals[categoryIndex].net, 
                            totals[categoryIndex].positiveCount++)));
                            var dataLabelFillColorOptions = {
                                defaultColor: defaultLabelColor,
                                seriesColor: null == lineChartDataLabelsSettings ? void 0 : lineChartDataLabelsSettings.fontProperties.color,
                                categoricalDataReader: this_1.reader,
                                categoryIndex,
                                seriesIndex
                            }, dataLabelColor = (0, dataLabelUtil.t$)(dataLabelFillColorOptions), labelCreatorSettings = {
                                dataPointLabelSettings,
                                defaultLabelSettings,
                                categoricalDataReader: this_1.reader,
                                categoryIndex,
                                seriesIndex,
                                dynamicLabelsEnabledForSeries,
                                featureSwitches: this_1.options.featureSwitches
                            }, appendedLabelContents = (0, dataLabelUtil.Xc)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labelCreatorSettings), {
                                detailPropertyId: lineChart_capabilities.zK.labels.dynamicLabelDetail,
                                titlePropertyId: lineChart_capabilities.zK.labels.dynamicLabelTitle,
                                dataLabelFillColorOptions
                            })), dynamicLabelValue = (0, dataLabelUtil.tI)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labelCreatorSettings), {
                                valuePropertyId: lineChart_capabilities.zK.labels.dynamicLabelValue
                            }));
                            if (!hasCheckedLabelModificationForSeries && (null === (_m = this_1.options.featureSwitches) || void 0 === _m ? void 0 : _m.labelEnhancementsM0)) {
                                var dynamicLabelDetailEnabled = appendedLabelContents && (null === (_o = _.first(appendedLabelContents.filter(function(label) {
                                    return "Detail" === label.role;
                                }))) || void 0 === _o ? void 0 : _o.dynamicLabel.enabled);
                                (0, dataLabelUtil.hY)(hostServices, !1, null == dynamicLabelValue ? void 0 : dynamicLabelValue.enabled, dynamicLabelDetailEnabled, dataPointLabelSettings), 
                                hasCheckedLabelModificationForSeries = !0;
                            }
                            isStacked && (stackedValues[categoryIndex] += value);
                            var dataPoint = (0, tslib_es6.__assign)({
                                categoryValue: this_1.convertCategoryValue(xAxisValue, this_1.isDateTime, useScalarKeys),
                                value,
                                originalValue,
                                categoryIndex,
                                seriesIndex,
                                tooltipInfo,
                                selected: !1,
                                identity: idBuilder.withMeasure(valuesMetadata.queryName, columnReader.getValueColumn(isY2 ? lineChartRoles.R.Y2 : lineChartRoles.R.Y, seriesIndex), categoryIndex).createSelectionId(),
                                key: JSON.stringify({
                                    series: seriesKey,
                                    category: category && !_.isEmpty(category.identity) && category.identity[categoryIndex] ? category.identity[categoryIndex].key : categoryIndex
                                }),
                                labelFill: dataLabelColor.color,
                                leaderLineColor: (0, dataLabelUtil.Zj)(defaultLabelSettings.leaderLine.strokeColor, lineChartDataLabelsSettings, dataLabelFillColorOptions, dataLabelColor),
                                labelFormatString: formatString || valuesMetadata.format,
                                labelSettings: dataPointLabelSettings,
                                uncertainty: dataPointUncertainty,
                                additionalTooltipItems,
                                marker: function() {
                                    var _a, fillIdentifier = lineChart_capabilities.zK.lineStyles.strokeColor, currentCategoryObjects = null === (_a = category.objects) || void 0 === _a ? void 0 : _a[categoryIndex], perCategoryMarker = currentCategoryObjects && colorHelper.hasColorForProperty(currentCategoryObjects, fillIdentifier), marker = Object.create(lineStyle.markerProperties);
                                    return marker.perCategoryStyle = Boolean(perCategoryMarker), marker.transparency = lineStyle.strokeTransparency, 
                                    marker.color = perCategoryMarker ? colorHelper.getColorForProperty(currentCategoryObjects, fillIdentifier, void 0) : lineStyle.strokeColor, 
                                    marker.show = !!perCategoryMarker || Boolean(marker.show), marker.focusOnlySize = getFocusOnlyMarkerRadius(lineStyle), 
                                    marker.focusOnlyColor = lineStyle.strokeColor, marker;
                                }(),
                                isY2,
                                dynamicLabelValue,
                                stackedValue: isStacked ? stackedValues[categoryIndex] : void 0
                            }, (null === (_p = this_1.options.featureSwitches) || void 0 === _p ? void 0 : _p.labelEnhancementsM0) && {
                                appendedLabelContents,
                                labelDataPointContainerEnabled: !0
                            });
                            dataPoints[dataPointsIndex] = dataPoint, null !== (_q = categoryData[categoryIndex]) && void 0 !== _q || (categoryData[categoryIndex] = extractCategoryFromDataPoint(dataPoint, hierarchyCategoryLevels)), 
                            categoryData[categoryIndex] && ((_z = categoryData[categoryIndex]).hasData || (_z.hasData = null != dataPoint.value));
                            var getCategoryIdentityBuilder = function(isMultiples) {
                                var _a, categoryIdBuilder = (new selection_selectionId.dw).withCategory(withCategory, categoryIndex, null === (_a = null == category ? void 0 : category.source) || void 0 === _a ? void 0 : _a.queryName, !0);
                                return hasDynamicSeries || 1 !== seriesCount || categoryIdBuilder.withMeasure(valuesMetadata.queryName), 
                                isMultiples && multipleInfo && categoryIdBuilder.withColumnIdentity(multipleInfo.identity, multipleQueryName, multipleValueDetails), 
                                categoryIdBuilder;
                            };
                            dataReader.hasCategories() && (null !== (_r = categoryIdentities[categoryIndex]) && void 0 !== _r || (categoryIdentities[categoryIndex] = getCategoryIdentityBuilder(!1).createSelectionId()), 
                            null !== (_s = multiplesCategoryIdentities[categoryIndex]) && void 0 !== _s || (multiplesCategoryIdentities[categoryIndex] = getCategoryIdentityBuilder(!0).createSelectionId())), 
                            out_dataPointsIndex_1 = dataPointsIndex;
                        }, categoryIndex = 0, dataPointsIndex = -1; categoryIndex < categoryCount; categoryIndex++) _loop_2(categoryIndex, dataPointsIndex), 
                        dataPointsIndex = out_dataPointsIndex_1;
                        var valueColumnIndex = _.findIndex(valuesMetadataArray, valuesMetadata);
                        -1 !== valueColumnIndex && (null !== (_t = valuesMetadataBySeries[valueColumnIndex]) && void 0 !== _t || (valuesMetadataBySeries[valueColumnIndex] = {
                            metadataColumn: valuesMetadata,
                            usedInSeriesIndices: [],
                            valueSelector: (new selection_selectionId.dw).withMeasure(valuesMetadata.queryName, column).createSelectionId()
                        }), valuesMetadataBySeries[valueColumnIndex].usedInSeriesIndices.push(seriesIndex)), 
                        null == interactivityService || interactivityService.applySelectionStateToData(_.filter(dataPoints, function(dataPoint) {
                            return null != dataPoint;
                        })), (dataPoints.length > 0 || (null == multipleInfo ? void 0 : multipleInfo.isCoreMultiple)) && series.push({
                            displayName: seriesNames[seriesIndex],
                            key: seriesKey,
                            index: seriesIndex,
                            xCol: useScalarKeys ? scalarMetadataColumn : category.source,
                            yCol: valuesMetadata,
                            data: dataPoints,
                            identity: seriesIdentity,
                            selected: !1,
                            uncertainty: measureUncertainty,
                            labelSettings: lineChartDataLabelsSettings,
                            seriesLabelSettings,
                            type: valuesMetadata.type,
                            measureDisplayName: valuesMetadata.displayName,
                            lineStyle,
                            isY2
                        });
                    }, this_1 = this, s = 0; s < seriesCount; s++) _loop_1(s);
                    this.addTotalTooltips(seriesOrderReversed, series, totalLabelsSettings, totals, valueMetadataColumns);
                }
                var reductionMetadata = null === (_v = null === (_u = dataView.metadata) || void 0 === _u ? void 0 : _u.dataReduction) || void 0 === _v ? void 0 : _v.categorical;
                null == interactivityService || interactivityService.applySelectionStateToData(series);
                var legendMarkerRendering = (0, dataViewObject2.NA)(this.staticObjects, lineChart_capabilities.zK.legend.legendMarkerRendering, types_legendMarkerRendering._.markerCircleDefault), matchLineColor = (0, 
                dataViewObject2.NA)(this.staticObjects, lineChart_capabilities.zK.legend.matchLineColor, !0);
                return {
                    series,
                    totals,
                    legendData: (0, legend_converter.pq)({
                        dataView,
                        allowLegendWithNoSeries: isComboChart,
                        showByDefault: !0,
                        staticSeriesRoleNames: isComboChart ? [ "Y2" ] : [ "Y", "Y2" ],
                        style,
                        ignoreDefaultColor: isComboChart,
                        ignoreDefaultCategoryColor: !0,
                        lineAndMarkerOptions: {
                            renderLineStyle: !0,
                            legendMarkerRendering,
                            matchSeriesColor: matchLineColor,
                            defaultMarkerShape: markerShape.ZO.longDash
                        },
                        featureSwitches: this.options.featureSwitches
                    }),
                    forecastLines: this.convertForecastLines(categoryData, useScalarKeys, categoryIdentities, multiplesCategoryIdentities),
                    anomalyDetections,
                    isScalar: this.isScalar,
                    dataLabelsSettings: defaultLabelSettings,
                    totalLabelsSettings,
                    seriesLabelSettings: defaultSeriesSettings,
                    hasDynamicSeries,
                    hasHighlights: !1,
                    hasY2Role: (0, dataRoleHelper.c5)(dataView, "Y2"),
                    categoryMetadata: category.source,
                    valuesMetadata: valuesMetadataArray,
                    valuesMetadataBySeries,
                    preferredCategoryWidth: (0, cartesianHelper.$K)(xAxisCardProperties),
                    scalarMetadata: scalarMetadataColumn,
                    scalarKeyCount: useScalarKeys ? scalarKeys.values.length : void 0,
                    categories: category.values,
                    categoryData,
                    seriesDisplayName,
                    hasValues,
                    categoryIdentities,
                    multiplesCategoryIdentities,
                    lineStyle: this.staticLineStyle,
                    binnedLineSamplingApplied: Boolean((null === (_w = null == reductionMetadata ? void 0 : reductionMetadata.metadata) || void 0 === _w ? void 0 : _w.binnedLineSample) || (null === (_x = null == reductionMetadata ? void 0 : reductionMetadata.categories) || void 0 === _x ? void 0 : _x.binnedLineSample) || (null === (_y = null == reductionMetadata ? void 0 : reductionMetadata.values) || void 0 === _y ? void 0 : _y.binnedLineSample)),
                    legendMarkerRendering,
                    matchLineColor,
                    multipleIdentity,
                    multipleDisplayName,
                    layout: {
                        seriesOrderReversed
                    }
                };
            }, LineChartConverter.prototype.addTotalTooltips = function(seriesOrderReversed, series, totalLabelsSettings, totals, valueMetadataColumns) {
                var _a, _b, _c, _d, _e = this.options, hostServices = _e.hostServices, _f = _e.tooltipsEnabled;
                if (_e.isStacked && hostServices && (void 0 === _f || _f) && totalLabelsSettings.show) for (var seriesCount = this.reader.data.getSeriesCount(), defaultTotalLabelColor = totalLabelsSettings.fontProperties.color, existingTooltips = [], s = 0; s < seriesCount; s++) {
                    var seriesIndex = seriesOrderReversed ? seriesCount - s - 1 : s;
                    if (series[seriesIndex]) for (var _i = 0, _g = series[seriesIndex].data; _i < _g.length; _i++) {
                        var dataPoint = _g[_i];
                        if (dataPoint) {
                            var categoryIndex = dataPoint.categoryIndex, totalLabelFill = (0, dataLabelUtil.AO)({
                                defaultColor: defaultTotalLabelColor,
                                categoricalDataReader: this.reader,
                                categoryIndex,
                                seriesIndex
                            });
                            totals[categoryIndex].labelFill = totalLabelFill.color;
                            var fontPropColor = (0, dataLabelUtil.B8)(totalLabelFill) ? totalLabelFill.color : defaultTotalLabelColor;
                            totalLabelsSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropColor, totalLabelsSettings.fontProperties), 
                            null !== (_a = existingTooltips[categoryIndex]) && void 0 !== _a || (existingTooltips[categoryIndex] = {
                                net: {
                                    displayName: hostServices.getLocalizedString("Visual_Total"),
                                    value: (0, converterHelper.xq)(totals[categoryIndex].net, valueMetadataColumns[seriesIndex], lineChart_capabilities.zK.general.formatString, !1)
                                }
                            });
                            var tooltipTotal = existingTooltips[categoryIndex].net;
                            null !== (_b = dataPoint.tooltipInfo) && void 0 !== _b || (dataPoint.tooltipInfo = []), 
                            dataPoint.tooltipInfo.push(tooltipTotal), null !== (_c = (_d = dataPoint).additionalTooltipItems) && void 0 !== _c || (_d.additionalTooltipItems = []), 
                            dataPoint.additionalTooltipItems.push(tooltipTotal);
                        }
                    }
                }
            }, LineChartConverter.prototype.convertForecastLines = function(categoryData, useScalarKeys, categoryIdentities, multiplesCategoryIdentities) {
                var _a, _b, _c, _d = this.options, dataView = _d.dataView, forecastDataView = _d.forecastDataView;
                if (forecastDataView && this.isScalar && !_d.isStacked && !_d.isComboChart) {
                    for (var forecastLines = (0, forecastHelper1.XB)(forecastDataView, dataView, _d.style, this.staticLineStyle), lastDataPoint = _.last(categoryData), _i = 0, forecastLines_1 = forecastLines; _i < forecastLines_1.length; _i++) for (var categoryIndex = lastDataPoint.categoryIndex, _e = 0, _f = forecastLines_1[_i].points; _e < _f.length; _e++) {
                        var point = _f[_e];
                        point.point.x = this.convertCategoryValue(point.point.x, this.isDateTime, useScalarKeys), 
                        point.upperBound.x = this.convertCategoryValue(point.upperBound.x, this.isDateTime, useScalarKeys), 
                        point.lowerBound.x = this.convertCategoryValue(point.lowerBound.x, this.isDateTime, useScalarKeys);
                        var categoryValue = point.point.x;
                        categoryValue <= lastDataPoint.categoryValue || (null !== (_a = categoryData[++categoryIndex]) && void 0 !== _a || (categoryData[categoryIndex] = {
                            categoryIndex,
                            categoryValue,
                            hasData: null != point.point.y,
                            hierarchyCategoryLevels: (0, concatenateUtils.AD)(dataView.categorical.categories, categoryIndex, lineChart_capabilities.zK.general.formatString)
                        }), null !== (_b = categoryIdentities[categoryIndex]) && void 0 !== _b || (categoryIdentities[categoryIndex] = null), 
                        null !== (_c = multiplesCategoryIdentities[categoryIndex]) && void 0 !== _c || (multiplesCategoryIdentities[categoryIndex] = null));
                    }
                    return forecastLines;
                }
            }, LineChartConverter.prototype.allocateSeriesColors = function() {
                for (var seriesCount = this.reader.data.getSeriesCount(), seriesColors = [], seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) seriesColors.push(this.reader.colors.createBySeries(seriesIndex, void 0, colorHelper.fA));
                return seriesColors;
            }, LineChartConverter.prototype.getSeriesNames = function() {
                var _this = this, seriesCount = this.reader.data.getSeriesCount();
                return _.range(seriesCount).map(function(s) {
                    return _this.reader.columns.hasDynamicSeries() ? (0, valueFormatter.WU)(_this.reader.data.getSeriesName(s), _this.reader.objects.getSeriesFormatString(s)) : _this.reader.columns.hasStaticSeries() ? _this.reader.data.getSeriesName(s) : _this.reader.data.getValueDisplayName(_this.primaryValueRole);
                });
            }, LineChartConverter.prototype.convertCategoryValue = function(value, isDate, useScalarKeys) {
                if (value && (isDate || useScalarKeys)) {
                    var dateValue_1 = value;
                    return debug.fF.assert(function() {
                        return (0, dateWithEpochValue.M4)(dateValue_1);
                    }, "dateValue"), dateValue_1.epochTimeStamp;
                }
                return value;
            }, LineChartConverter.prototype.readLineStyleFromObjects = function(seriesIndex, style) {
                var props = lineChart_capabilities.zK.lineStyles, showAllSeries = (0, dataViewObject2.NA)(this.staticObjects, lineChart_capabilities.zK.lineStyles.showSeries, !0), objects = null != seriesIndex && showAllSeries ? this.reader.objects.getSeriesDataObjects(seriesIndex) : this.staticObjects, staticStyle = this.staticLineStyle, defaultStyle = null != staticStyle ? staticStyle : getDefaultLineStyle(this.options.isAreaChart);
                null != seriesIndex ? debug.fF.assert(function() {
                    return null != staticStyle;
                }, "If converting per-series line style, staticStyle must be defined") : debug.fF.assert(function() {
                    return null == staticStyle;
                }, "If converting static line style, staticStyle must be not-defined");
                var computedStyle = (0, tslib_es6.__assign)((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, (0, 
                common_strokeStyle.QI)(objects, props, defaultStyle)), {
                    markerProperties: null == seriesIndex ? (0, marker_converter.RZ)(objects, style) : (0, 
                    marker_converter.Yh)(this.reader, staticStyle.markerProperties, seriesIndex, style, !showAllSeries),
                    areaShow: (0, dataViewObject2.NA)(objects, props.areaShow, defaultStyle.areaShow),
                    areaColor: (0, dataViewObject2.W7)(objects, props.areaColor, defaultStyle.areaColor),
                    areaTransparency: (0, dataViewObject2.NA)(objects, props.areaTransparency, defaultStyle.areaTransparency),
                    areaMatchStrokeColor: (0, dataViewObject2.NA)(objects, props.areaMatchStrokeColor, defaultStyle.areaMatchStrokeColor)
                }), (0, lineInterpolation.RN)(objects, props, defaultStyle));
                return null !== seriesIndex && (computedStyle.strokeColor = this.seriesColors[seriesIndex]), 
                null != seriesIndex && computedStyle.areaShow && (computedStyle.areaShow = staticStyle.areaShow), 
                computedStyle.areaMatchStrokeColor && (computedStyle.areaColor = computedStyle.strokeColor), 
                computedStyle;
            }, LineChartConverter;
        }(), anomalyDetection_formatter = __webpack_require__(67918), lineInterp = __webpack_require__(72250);
        function lineChart_formatter_getFormattingCards() {
            return {
                type: 0,
                card: [ getLinesCard.call(this), getShadeAreaCard.call(this), getMarkersCard.call(this), getDataLabelsCard.call(this), getSeriesLabelsCard.call(this), lineChart_formatter_getTotalsCard.call(this), lineChart_formatter_getErrorBarsCard.call(this) ].filter(function(card) {
                    return card;
                })
            };
        }
        function getMarkersCard() {
            var _a, _b, _this = this, data = this.originalData;
            if (data && this.dataView) {
                var seriesCount = data.series.length;
                if (0 !== seriesCount) {
                    var showSeriesValue = (0, dataViewObject2.NA)(null === (_b = null === (_a = this.dataView) || void 0 === _a ? void 0 : _a.metadata) || void 0 === _b ? void 0 : _b.objects, lineChart_capabilities.qn.lineStyles.showSeries, !0);
                    return new build_control_util.CQ(new build_control_util.lg("markers"), "Visual_Markers", Object.values(lineChart_capabilities.zK.markers).concat([ lineChart_capabilities.zK.dataPoint.fill, lineChart_capabilities.zK.dataPoint.showAllDataPoints, lineChart_capabilities.zK.lineStyles.showSeries ]), this.localizer).addTopLevelToggle("showMarkerTopLevel", function() {
                        return new build_control_util.bd({
                            descriptor: lineChart_capabilities.qn.lineStyles.showMarker,
                            value: data.lineStyle.markerProperties.show
                        }).build();
                    }).addGroup("applySettingsTo", function(groupBuilder) {
                        return groupBuilder.withContainerDisabled(!showSeriesValue).withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                            if (containerBuilder.withDisplayName(seriesCount > 1 ? "Series" : "Visual_Categories").addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                                var _a, _b, _c;
                                if (addMarkersFormattingContainers.call(_this, {
                                    containerItemBuilder,
                                    listType: seriesCount > 1 ? "staticPerSeries" : "staticPerCategories",
                                    markerStyle: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, data.lineStyle.markerProperties), {
                                        color: null !== (_b = null !== (_a = data.lineStyle.markerProperties.color) && void 0 !== _a ? _a : data.lineStyle.strokeColor) && void 0 !== _b ? _b : null === (_c = data.series[0]) || void 0 === _c ? void 0 : _c.lineStyle.strokeColor
                                    })
                                }), !showSeriesValue) {
                                    var resetToDefaultDescriptors_1 = [ lineChart_capabilities.qn.lineStyles.lineChartType, lineChart_capabilities.qn.lineStyles.lineStyle, lineChart_capabilities.qn.lineStyles.strokeWidth, lineChart_capabilities.qn.lineStyles.strokeLineJoin, lineChart_capabilities.qn.lineStyles.showMarker, lineChart_capabilities.qn.lineStyles.showMarkerByDefault, lineChart_capabilities.qn.lineStyles.markerShape, lineChart_capabilities.qn.lineStyles.markerSize, lineChart_capabilities.qn.lineStyles.markerColor, lineChart_capabilities.qn.dataPoint.showAllDataPoints, lineChart_capabilities.qn.dataPoint.fill ];
                                    containerItemBuilder.addSimpleSlice("showSeriesLink", function() {
                                        return new build_control_util.ob({
                                            descriptor: lineChart_capabilities.qn.lineStyles.showSeries,
                                            value: function() {},
                                            ariaLabel: "Enable_This_Setting",
                                            type: "SeriesDialogLink",
                                            resetToDefaultDescriptors: resetToDefaultDescriptors_1,
                                            warningIcon: !0
                                        }).build();
                                    }, function(sliceBuilder) {
                                        return sliceBuilder.withCustomDisplayName("Enable_This_Setting").withSuppressDisplayName(!0);
                                    });
                                }
                            }), 1 === seriesCount && _this.supportsPerCategoryMarker()) {
                                var validDataPointIndices = function(data) {
                                    for (var validDataPointIndices = [], _loop_5 = function(categoryData) {
                                        if (categoryData && data.categoryIdentities[categoryData.categoryIndex]) for (var seriesIndex = 0; seriesIndex < data.series.length; seriesIndex++) {
                                            var validDataPointIndex = _.findIndex(data.series[seriesIndex].data, function(d) {
                                                return d.categoryIndex === categoryData.categoryIndex;
                                            });
                                            if (validDataPointIndex >= 0) {
                                                validDataPointIndices.push({
                                                    categoryIndex: categoryData.categoryIndex,
                                                    seriesIndex,
                                                    dataPointIndex: validDataPointIndex
                                                });
                                                break;
                                            }
                                        }
                                    }, _i = 0, _a = data.categoryData; _i < _a.length; _i++) _loop_5(_a[_i]);
                                    return validDataPointIndices;
                                }(data), topNCategories = validDataPointIndices.slice(0, cartesianChart_formatter.Rl);
                                if (topNCategories.length < 2) return;
                                var displayNames_1 = generateConcatenatedNames(topNCategories, data);
                                topNCategories.forEach(function(_a, i) {
                                    var _b, categoryIndex = _a.categoryIndex, seriesIndex = _a.seriesIndex, dataPointIndex = _a.dataPointIndex, markerStyle = (0, 
                                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, _.cloneDeep(data.lineStyle.markerProperties)), {
                                        color: null !== (_b = data.series[seriesIndex].data[dataPointIndex].marker.color) && void 0 !== _b ? _b : data.series[seriesIndex].lineStyle.strokeColor
                                    }), selector = (0, contracts_selector.fd)(data.categoryIdentities[categoryIndex].getSelector());
                                    data.multipleIdentity && (selector = (0, contracts_selector.d9)(selector), debug.fF.assert(function() {
                                        return !!selector.data;
                                    }, "expect categories to have some data identity"), selector.data.unshift((0, dataViewRoleWildcard.Yp)([ lineChartRoles.R.Rows ]))), 
                                    containerBuilder.addContainerItem(displayNames_1[i], displayNames_1[i], function(containerItemBuilder) {
                                        return addMarkersFormattingContainers.call(_this, {
                                            containerItemBuilder,
                                            listType: "perCategory",
                                            markerStyle,
                                            selector
                                        });
                                    });
                                });
                            }
                            if (seriesCount > 1) for (var _loop_1 = function(series) {
                                var selector = (0, contracts_selector.fd)(series.identity.getSelector());
                                if (!selector) return "continue";
                                containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                                    return addMarkersFormattingContainers.call(_this, {
                                        containerItemBuilder,
                                        listType: "perSeries",
                                        markerStyle: series.lineStyle.markerProperties,
                                        selector
                                    });
                                });
                            }, _i = 0, _a = data.series; _i < _a.length; _i++) _loop_1(_a[_i]);
                        });
                    }).build();
                }
            }
        }
        function getDataLabelsCard() {
            var _a, _this = this, data = this.originalData, labelSettings = data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = seriesCount > 1 || !data.categoryMetadata || this.isComboChart, labelPositions = this.isStacked ? [ labelPosition1.h.auto, labelPosition1.h.insideCenter, labelPosition1.h.insideEnd ] : [ labelPosition1.h.auto, labelPosition1.h.above, labelPosition1.h.under ];
            labelSettings.position && labelPositions.indexOf(labelSettings.position) < 0 && (labelSettings.position = labelPosition1.h.auto);
            var reader, lineChartDataLabelProps = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.labels), {
                position: lineChart_capabilities.qn.labels.labelPosition,
                precision: lineChart_capabilities.qn.labels.labelPrecision,
                displayUnits: lineChart_capabilities.qn.labels.labelDisplayUnits,
                labelBackgroundColor: lineChart_capabilities.qn.labels.backgroundColor,
                labelBackgroundTransparency: lineChart_capabilities.qn.labels.backgroundTransparency,
                showDynamicLabels: lineChart_capabilities.qn.labels.showDynamicLabels,
                dynamicLabelValue: lineChart_capabilities.qn.labels.dynamicLabelValue,
                leaderLines: lineChart_capabilities.qn.labels.leaderLines,
                maximumOffset: lineChart_capabilities.qn.labels.maximumOffset,
                minimumOffset: lineChart_capabilities.qn.labels.minimumOffset
            }), cardBuilder = new build_control_util.CQ(new build_control_util.lg("labels"), "Visual_DataPointsLabels", lineChartDataLabelProps, this.localizer), isFieldPickerDisabled = (0, 
            dataLabelUtil.DU)(this.featureSwitches, data.hasDynamicSeries, showLabelPerSeries, seriesCount, this.isComboChart, !0), labelSettingsOptions = lineChart_formatter_getLabelSettingsOptions.call(this, void 0, labelSettings, null, showLabelPerSeries, labelPositions, isFieldPickerDisabled), individualSelector = this.isComboChart ? void 0 : lineChart_formatter_getLabelIndividualSelector.call(this, !1), formatCardOptions = {
                cardBuilder,
                dataLabelsProps: lineChartDataLabelProps,
                featureSwitches: this.featureSwitches,
                hostServices: this.hostService,
                options: labelSettingsOptions,
                includeAltConstantValueSelector: !0,
                individualSelector,
                showEnhancedLabelsFormattingOptions: !0,
                instanceId: "all"
            };
            if ((null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.labelEnhancementsM0) && this.dataView) {
                var _b = (reader = (0, dataViewCategoricalReader.y)(this.dataView)).labels.dynamicLabelReader.getLabelFieldSourceTypes();
                Object.assign(formatCardOptions, {
                    valueFieldSourceType: _b.valueFieldSourceType,
                    detailFieldSourceType: _b.detailFieldSourceType,
                    titleFieldSourceType: _b.titleFieldSourceType,
                    valueLabelPickerFallbackExpr: (0, dataLabelUtil.WA)(data.valuesMetadataBySeries, seriesCount, data.hasDynamicSeries),
                    dataLabelPickerSeriesType: (0, dataLabelUtil.Nb)(seriesCount, data.hasDynamicSeries, this.isComboChart)
                });
            }
            return cardBuilder.withDescription("Visual_DataPointsLabelsDescription"), lineChartDataLabelProps.show && cardBuilder.addTopLevelToggle("show", function() {
                return new build_control_util.bd({
                    descriptor: lineChartDataLabelProps.show,
                    value: labelSettingsOptions.dataLabelsSettings.show
                }).build();
            }), cardBuilder.addGroup("applySettingsTo", function(groupBuilder) {
                return groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                    var _a, _b;
                    if (containerBuilder.withDisplayName("Series"), containerBuilder.addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                        return (0, dataLabelViewModel1.WW)(formatCardOptions, containerItemBuilder);
                    }), showLabelPerSeries) for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i], seriesLabelSettings = null !== (_a = series.labelSettings) && void 0 !== _a ? _a : data.dataLabelsSettings;
                        seriesLabelSettings.position && labelPositions.indexOf(seriesLabelSettings.position) < 0 && (seriesLabelSettings.position = labelPosition1.h.auto);
                        var selector = series.identity.getSelector();
                        if (Object.assign(formatCardOptions, {
                            includeAltConstantValueSelector: !1,
                            selector: data.hasDynamicSeries ? (0, contracts_selector.fd)(selector) : selector,
                            individualSelector: lineChart_formatter_getLabelIndividualSelector.call(_this, !0),
                            options: lineChart_formatter_getLabelSettingsOptions.call(_this, void 0, seriesLabelSettings, selector, void 0, labelPositions, data.hasDynamicSeries),
                            instanceId: "sn-".concat(i)
                        }), null === (_b = _this.featureSwitches) || void 0 === _b ? void 0 : _b.labelEnhancementsM0) {
                            var labelFieldSourceTypes = null == reader ? void 0 : reader.labels.dynamicLabelReader.getLabelFieldSourceTypes(i);
                            Object.assign(formatCardOptions, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labelFieldSourceTypes ? {
                                valueFieldSourceType: labelFieldSourceTypes.valueFieldSourceType,
                                detailFieldSourceType: labelFieldSourceTypes.detailFieldSourceType,
                                titleFieldSourceType: labelFieldSourceTypes.titleFieldSourceType
                            } : {}), {
                                valueLabelPickerFallbackExpr: (0, dataLabelUtil.CH)(data.valuesMetadataBySeries, i),
                                dataLabelPickerSeriesType: (0, dataLabelUtil.aC)(seriesCount, data.hasDynamicSeries, _this.isComboChart)
                            }));
                        }
                        containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                            return (0, dataLabelViewModel1.WW)(formatCardOptions, containerItemBuilder);
                        });
                    }
                });
            }), cardBuilder.build();
        }
        function getSeriesLabelsCard() {
            var _this = this;
            if (this.showSeriesCard()) {
                var data = this.originalData, labelSettings = data.seriesLabelSettings, showLabelPerSeries = this.showLabelPerSeries(), lineChartSeriesLabelProps = (0, 
                tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.seriesLabels), {
                    show: {
                        objectName: "seriesLabels",
                        propertyName: "show"
                    }
                }), cardBuilder = new build_control_util.CQ(new build_control_util.lg("seriesLabels"), "Visual_SeriesLabels", lineChartSeriesLabelProps, this.localizer), formatCardOptions = {
                    cardBuilder,
                    seriesLabelsProps: lineChartSeriesLabelProps,
                    featureSwitches: this.featureSwitches,
                    hostServices: this.hostService,
                    seriesOptions: {
                        enumeration: void 0,
                        seriesLabelsSettings: labelSettings,
                        selector: null,
                        style: this.style,
                        showAll: showLabelPerSeries
                    }
                };
                return cardBuilder.withDescription("Visual_SeriesDescription"), lineChartSeriesLabelProps.show && cardBuilder.addTopLevelToggle("show", function() {
                    return new build_control_util.bd({
                        descriptor: lineChartSeriesLabelProps.show,
                        value: formatCardOptions.seriesOptions.seriesLabelsSettings.show
                    }).build();
                }), cardBuilder.addGroup("applySettingsTo", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                        var _a;
                        if (containerBuilder.withDisplayName("Series").addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                            return (0, seriesLabelViewModel.eR)(formatCardOptions, containerItemBuilder);
                        }), _this.showLabelPerSeries()) for (var _i = 0, _b = data.series; _i < _b.length; _i++) {
                            var series = _b[_i], selector = series.identity.getSelector();
                            formatCardOptions.selector = data.hasDynamicSeries ? (0, contracts_selector.fd)(selector) : selector, 
                            formatCardOptions.seriesOptions = {
                                enumeration: void 0,
                                seriesLabelsSettings: null !== (_a = series.seriesLabelSettings) && void 0 !== _a ? _a : data.seriesLabelSettings,
                                selector,
                                style: _this.style,
                                showAll: void 0
                            }, containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                                return (0, seriesLabelViewModel.eR)(formatCardOptions, containerItemBuilder);
                            });
                        }
                    });
                }).build();
            }
        }
        function getShadeAreaCard() {
            var _this = this, data = this.originalData;
            if (data && data.series && 0 !== data.series.length) {
                var addShadeAreaGroup = function(lineStyleFormatOptions) {
                    var lineStyle = lineStyleFormatOptions.lineStyle, selector = lineStyleFormatOptions.selector;
                    lineStyleFormatOptions.containerItemBuilder.addSimpleSlice("showSeries", new build_control_util.bd({
                        descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.areaShow), {
                            selector
                        }),
                        value: lineStyle.areaShow
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(!selector).withCustomDisplayName("Visual_Show_Data_Labels_PerSeries");
                    }).addGroup("colors", function(groupBuilder) {
                        return groupBuilder.withDisplayName("Generic_Color").addSimpleSlice("shadeAreaMatchStrokeColor", new build_control_util.bd({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.areaMatchStrokeColor), {
                                selector
                            }),
                            value: lineStyle.areaMatchStrokeColor
                        }).build()).addSimpleSlice("shadeAreaColor", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.areaColor), {
                                selector
                            }),
                            value: {
                                value: lineStyle.areaColor
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withDisabled(lineStyle.areaMatchStrokeColor);
                        }).addSimpleSlice("shadeAreaTransparency", build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.dataPoint.transparency), {
                                selector
                            }),
                            value: lineStyle.areaTransparency,
                            localize: _this.localizer
                        }).build());
                    });
                };
                return new build_control_util.CQ(new build_control_util.lg("shadeArea"), "Visual_Shapes_ShadeArea", [ lineChart_capabilities.qn.lineStyles.areaShow, lineChart_capabilities.qn.dataPoint.transparency, lineChart_capabilities.qn.lineStyles.areaColor, lineChart_capabilities.qn.lineStyles.areaMatchStrokeColor ], this.localizer).addTopLevelToggle("shadeAreaShow", function() {
                    return new build_control_util.bd({
                        descriptor: lineChart_capabilities.qn.lineStyles.areaShow,
                        value: _this.data.lineStyle.areaShow
                    }).build();
                }).addGroup("applySettingsTo", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                        if (containerBuilder.withDisplayName("Series"), containerBuilder.addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                            addShadeAreaGroup.call(_this, {
                                containerItemBuilder,
                                lineStyle: data.lineStyle
                            });
                        }), data.series.length > 1) for (var _loop_2 = function(series) {
                            containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                                return addShadeAreaGroup.call(_this, {
                                    containerItemBuilder,
                                    lineStyle: series.lineStyle,
                                    selector: (0, contracts_selector.fd)(series.identity.getSelector())
                                });
                            });
                        }, _i = 0, _a = data.series; _i < _a.length; _i++) _loop_2(_a[_i]);
                    });
                }).build();
            }
        }
        function getLinesCard() {
            var _a, _b, _this = this, data = this.originalData;
            if (data && data.series && 0 !== data.series.length) {
                var showSeriesValue = (0, dataViewObject2.NA)(null === (_b = null === (_a = this.dataView) || void 0 === _a ? void 0 : _a.metadata) || void 0 === _b ? void 0 : _b.objects, lineChart_capabilities.qn.lineStyles.showSeries, !0);
                return new build_control_util.CQ(new build_control_util.lg("lines"), "Visual_Lines", [ lineChart_capabilities.qn.lineStyles.lineChartType, lineChart_capabilities.qn.lineStyles.interpolationStep, lineChart_capabilities.qn.lineStyles.interpolationSmooth, lineChart_capabilities.qn.lineStyles.interpolationSmoothParam, lineChart_capabilities.qn.lineStyles.strokeShow, lineChart_capabilities.qn.dataPoint.fill, lineChart_capabilities.qn.dataPoint.defaultColor, lineChart_capabilities.qn.lineStyles.lineStyle, lineChart_capabilities.qn.lineStyles.strokeWidth, lineChart_capabilities.qn.lineStyles.strokeLineJoin, lineChart_capabilities.qn.lineStyles.strokeTransparency, lineChart_capabilities.qn.lineStyles.strokeAutoScale, lineChart_capabilities.qn.lineStyles.strokeDashArray, lineChart_capabilities.qn.lineStyles.strokeDashCap, lineChart_capabilities.qn.layout.seriesOrderReversed ], this.localizer).addGroup("applySettingsTo", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).withContainerDisabled(!showSeriesValue).addContainer("series", function(containerBuilder) {
                        if (containerBuilder.withDisplayName("Series").addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                            return addLinesCardPerSeriesToContainer.call(_this, {
                                containerItemBuilder,
                                lineStyle: data.lineStyle
                            });
                        }), data.series.length > 1) for (var _loop_3 = function(series) {
                            containerBuilder.addContainerItem(series.displayName, series.displayName, function(containerItemBuilder) {
                                return addLinesCardPerSeriesToContainer.call(_this, {
                                    containerItemBuilder,
                                    lineStyle: series.lineStyle,
                                    selector: (0, contracts_selector.fd)(series.identity.getSelector())
                                });
                            });
                        }, _i = 0, _a = data.series; _i < _a.length; _i++) _loop_3(_a[_i]);
                    });
                }).build();
            }
        }
        function lineChart_formatter_getTotalsCard() {
            if (this.supportsTotalLabels()) {
                var labelSettings = this.originalData.totalLabelsSettings;
                if (labelSettings) {
                    var lineChartDataLabelProps = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.totals), {
                        precision: lineChart_capabilities.qn.totals.labelPrecision,
                        displayUnits: lineChart_capabilities.qn.totals.labelDisplayUnits
                    }), cardBuilder = new build_control_util.CQ(new build_control_util.lg("totals"), "Visual_DataTotalLabels", lineChartDataLabelProps, this.localizer).withDescription("Visual_DataTotalLabelsDescription");
                    return (0, dataLabelViewModel1.XQ)({
                        cardBuilder,
                        dataLabelsProps: lineChartDataLabelProps,
                        featureSwitches: this.featureSwitches,
                        hostServices: this.hostService,
                        options: lineChart_formatter_getTotalLabelSettingsOptions.call(this, void 0, labelSettings),
                        individualSelector: lineChart_formatter_getLabelIndividualSelector.call(this, !1),
                        showEnhancedLabelsFormattingOptions: !1
                    });
                }
            }
        }
        function lineChart_formatter_getErrorBarsCard() {
            var _this = this;
            if (!this.isAreaChart) {
                var data = this.originalData;
                if (data && data.series && 0 !== data.series.length) {
                    var allErrorProps = dataViewObjectProperties.N_.error;
                    return new build_control_util.CQ(new build_control_util.lg("errorBars"), "Visual_Error_Bars", [ allErrorProps.enabled, allErrorProps.errorRange, allErrorProps.barShow, allErrorProps.barMatchSeriesColor, allErrorProps.barColor, allErrorProps.barWidth, allErrorProps.barBorderColor, allErrorProps.barBorderSize, allErrorProps.shadeShow, allErrorProps.shadeBandStyle, allErrorProps.shadeColor, allErrorProps.shadeMatchSeriesColor, allErrorProps.shadeTransparency, allErrorProps.labelShow, allErrorProps.labelFontFamily, allErrorProps.labelFontSize, allErrorProps.labelBold, allErrorProps.labelItalic, allErrorProps.labelUnderline, allErrorProps.labelColor, allErrorProps.labelMatchSeriesColor, allErrorProps.labelFormat, allErrorProps.labelBackground, allErrorProps.labelBackgroundColor, allErrorProps.labelBackgroundTransparency, allErrorProps.markerShape, allErrorProps.markerShow, allErrorProps.markerSize, allErrorProps.showMarkerByDefault, allErrorProps.tooltipShow, allErrorProps.tooltipFormat ], this.localizer, !0, !0).addGroup("applySettingsTo", function(groupBuilder) {
                        return groupBuilder.withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("measure", function(containerBuilder) {
                            containerBuilder.withDisplayName("Series");
                            for (var _loop_4 = function(valueMetadata) {
                                var seriesIndex = _.first(valueMetadata.usedInSeriesIndices);
                                if (debug.fF.assertValue(seriesIndex, "lineChart - measure is not associated with any series"), 
                                null != seriesIndex) {
                                    var measure = valueMetadata.metadataColumn, series_1 = data.series[seriesIndex];
                                    if (null == series_1) return "continue";
                                    var measureSelector_1 = valueMetadata.valueSelector.getSelector(), dataPointRepetition = _this.isComboChart ? (0, 
                                    dataViewRoleWildcard.Yp)([ lineChartRoles.R.Rows, lineChartRoles.R.Category ]) : (0, 
                                    dataViewWildcard.Ue)(), dataPointSelector_1 = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, measureSelector_1), {
                                        data: [ dataPointRepetition ],
                                        highlightMatching: 1
                                    });
                                    containerBuilder.addContainerItem(measure.queryName, measure.displayName, function(containerItemBuilder) {
                                        return (0, uncertainty_formatter.f)({
                                            localize: _this.localizer,
                                            uncertainty: series_1.uncertainty,
                                            targetMeasure: valueMetadata.metadataColumn.expr,
                                            measureSelector: measureSelector_1,
                                            dataPointSelector: dataPointSelector_1,
                                            featureSwitches: _this.featureSwitches
                                        }, containerItemBuilder);
                                    });
                                }
                            }, _i = 0, _a = data.valuesMetadataBySeries; _i < _a.length; _i++) _loop_4(_a[_i]);
                        });
                    }).build();
                }
            }
        }
        function enumerateObjectInstances(enumeration, options) {
            var data = this.originalData;
            if (data) switch (options.objectName) {
              case forecastHelper1.Po:
                if (this.supportsForecast()) {
                    var disabledReason = void 0;
                    _.isEmpty(data.anomalyDetections) || (disabledReason = this.localizer("Visual_AnomalyDetection_WarningMessage_NoWithForecast")), 
                    (0, forecastHelper1.$I)(enumeration, data.forecastLines, this.style, disabledReason);
                }
                break;

              case anomalyDetectionVisualPlugin.xn:
                this.supportsAnomalyDetection() && (0, anomalyDetection_formatter.HL)(this.hostService, this.data, this.dataView, enumeration, data.anomalyDetections, this.style, data.isScalar, options.selectors);
            }
        }
        function lineChart_formatter_getLabelSettingsOptions(enumeration, labelSettings, selector, showAll, labelPositions, isFieldPickerDisabled) {
            return {
                enumeration,
                dataLabelsSettings: labelSettings,
                show: !0,
                position: !0,
                positionObject: labelPositions,
                displayUnits: !this.isStacked100,
                precision: !0,
                selector,
                showAll,
                fontSize: !0,
                fontFamily: !0,
                labelDensity: this.data.isScalar,
                enableBackground: labelSettings.enableBackground,
                backgroundColor: labelSettings.backgroundColor,
                backgroundTransparency: labelSettings.backgroundTransparency,
                style: this.style,
                bold: !0,
                italic: !0,
                underline: !0,
                enableDynamicLabelPickers: !isFieldPickerDisabled,
                isStacked100: this.isStacked100,
                leaderLines: !this.isStacked && !this.isComboChart
            };
        }
        function lineChart_formatter_getTotalLabelSettingsOptions(enumeration, labelSettings) {
            return {
                enumeration,
                dataLabelsSettings: labelSettings,
                show: !0,
                displayUnits: !0,
                precision: !0,
                fontSize: !0,
                fontFamily: !0,
                enableBackground: labelSettings.enableBackground,
                backgroundColor: labelSettings.backgroundColor,
                backgroundTransparency: labelSettings.backgroundTransparency,
                style: this.style,
                bold: !0,
                italic: !0,
                underline: !0
            };
        }
        function getDisambiguationSubSelectables(subSelectionHelper, filterType) {
            var _a;
            if (!this.data) return [];
            var customSubSelectables = [];
            if (void 0 === filterType || 3 === filterType) for (var _i = 0, seriesData_1 = this.data.series; _i < seriesData_1.length; _i++) {
                var series = seriesData_1[_i];
                if (series.lineStyle.markerProperties.show) {
                    var selectorsByColumn = null === (_a = null == series ? void 0 : series.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn(), displayName = this.hostService.getLocalizedString("MiniToolbar_Markers", series.displayName);
                    customSubSelectables.push(subSelectionHelper.createVisualSubSelectionForSingleObject({
                        objectName: "markers",
                        subSelectionType: 3,
                        displayName,
                        showUI: !0,
                        selectorsByColumn
                    }));
                }
            }
            return customSubSelectables;
        }
        function lineChart_formatter_getSelectorsByColumnFromSubselectedElement(e) {
            var _a;
            switch (d3.select(e).attr(htmlSubSelectionHelper.Ez)) {
              case "area":
              case "lines":
                var lineChartSeriesDatum = d3.select(e).datum(), selectorsByColumn = null === (_a = null == lineChartSeriesDatum ? void 0 : lineChartSeriesDatum.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn();
                if (selectorsByColumn) return selectorsByColumn;
                break;

              case "data-labels":
              case "series-labels":
                var labelSelectorsByColumn = (0, dataLabelUtil.wT)(e, this.data.series);
                if (labelSelectorsByColumn) return labelSelectorsByColumn;
                break;

              default:
                return;
            }
        }
        function getSubSelectionCustomOutlines(subSelection) {
            var _a, _b, subSelectionSelectorsByColumn = subSelection.visualObjects[0].selectorsByColumn;
            if ("markers" === subSelection.visualObjects[0].objectName) {
                var lineSeries = null === (_a = this.activeData) || void 0 === _a ? void 0 : _a.series;
                if (lineSeries) for (var _i = 0, lineSeries_1 = lineSeries; _i < lineSeries_1.length; _i++) {
                    var lineData = lineSeries_1[_i], lineSelectorsByColumn = null === (_b = lineData.identity) || void 0 === _b ? void 0 : _b.getSelectorsByColumn();
                    if ((0, contracts_selector.Ic)(lineSelectorsByColumn, subSelectionSelectorsByColumn)) return getMarkerOutlinesForSeries(lineData, this.viewModel);
                }
            }
        }
        function getMarkerOutlinesForSeries(series, viewModel) {
            var _a, mainGraphicsPositionOverlay = viewModel.renderContext.mainGraphicsPositionOverlay;
            if (mainGraphicsPositionOverlay) {
                var mainSvgElement = mainGraphicsPositionOverlay.node();
                if (mainSvgElement) {
                    var _b = mainSvgElement.getBoundingClientRect(), left = _b.left, top_1 = _b.top, currentViewport = viewModel.currentViewport, data = series.data, yScale = (null === (_a = _.first(data)) || void 0 === _a ? void 0 : _a.isY2) ? viewModel.y2AxisProperties.scale : viewModel.yAxisProperties.scale, currentViewportScale = currentViewport.scale, markerSize = viewModel.data.lineStyle.markerProperties.size * currentViewportScale, rectSize = Math.max(markerSize + 1.2 * markerSize, 10) * currentViewportScale;
                    rectSize % 2 == 0 && ++rectSize;
                    var step = 1;
                    if (data.length * rectSize > currentViewport.width) {
                        var maxOutlines = (0, dataLabelRendererEnhanced.SS)(currentViewport.width, 50, 4, rectSize);
                        step = Math.floor(data.length / maxOutlines);
                    }
                    for (var rects = [], i = 0; i < data.length; i += step) {
                        var point = data[i];
                        point && rects.push({
                            x: Math.floor(getMarkerXPositionCalc(viewModel, point, left) - rectSize / 2),
                            y: Math.floor(Mockable.convertSvgYToClientY(yScale(point.value), currentViewportScale, top_1) - rectSize / 2),
                            width: rectSize,
                            height: rectSize,
                            type: 1
                        });
                    }
                    var multipleDisplayName = viewModel.data.multipleDisplayName;
                    return [ {
                        id: multipleDisplayName ? "".concat(series.key).concat(multipleDisplayName) : series.key,
                        outline: {
                            type: 0,
                            outlines: rects,
                            clipPath: {
                                type: 1,
                                x: left,
                                y: top_1,
                                height: viewModel.availableHeight * currentViewportScale,
                                width: viewModel.availableWidth * currentViewportScale
                            }
                        }
                    } ];
                }
            }
            return [];
        }
        function getSubSelectionCustomElements(subSelection) {
            if ("area" === subSelection.visualObjects[0].objectName) {
                var areaElement = this.findSubSelectedAreaElement({
                    x: d3.event.clientX,
                    y: d3.event.clientY
                });
                return areaElement ? [ areaElement ] : void 0;
            }
        }
        function lineChart_formatter_getSubSelectionStyles(subSelections) {
            var visualObject, selector, visualObjects = _.first(subSelections).visualObjects;
            if (visualObjects.length > 0) {
                (visualObject = visualObjects[0]) && visualObject.selectorsByColumn && (selector = (0, 
                contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn)));
                var omitForSingleSeries = 1 === this.data.series.length;
                switch (visualObject.objectName) {
                  case "lines":
                    return selector ? (0, onObjectUtil.w3)(this.hostService, (0, tslib_es6.__assign)((0, 
                    tslib_es6.__assign)({}, lineChart_capabilities.zK.lineStyles.strokeColor), {
                        selector
                    }), null) : void debug.fF.assertFail("LineChart - line subselection should never have no selector");

                  case "area":
                    return selector ? (0, onObjectUtil.w3)(this.hostService, void 0, (0, tslib_es6.__assign)((0, 
                    tslib_es6.__assign)({}, lineChart_capabilities.zK.lineStyles.strokeColor), {
                        selector
                    })) : void debug.fF.assertFail("AreaChart - area subselection should never have no selector");

                  case "markers":
                    return selector ? (selector = omitForSingleSeries ? void 0 : selector, (0, onObjectUtil.w3)(this.hostService, void 0, (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.markers.color), {
                        selector
                    }))) : void debug.fF.assertFail("LineChart - marker subselection should never have no selector");

                  case "data-labels":
                    var currentSeries = this.data.series.find(function(series) {
                        var _a;
                        return (0, contracts_selector.Ic)(null === (_a = null == series ? void 0 : series.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn(), visualObject.selectorsByColumn);
                    });
                    if (!currentSeries) return;
                    var refSelector = omitForSingleSeries ? void 0 : selector, currentAxisProperties = this.getSeriesAxisProperties(currentSeries), labelUnitsAndPrecision = (0, 
                    dataLabelRendererEnhanced.d6)(currentAxisProperties, this.data.dataLabelsSettings), labels = lineChart_capabilities.qn.labels, dataLabelsModelReferences = {
                        fontFamilyReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.fontFamily), {
                            selector: refSelector
                        }),
                        fontSizeReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.fontSize), {
                            selector: refSelector
                        }),
                        boldReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.bold), {
                            selector: refSelector
                        }),
                        italicReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.italic), {
                            selector: refSelector
                        }),
                        underlineReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.underline), {
                            selector: refSelector
                        }),
                        fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.color), {
                            selector: refSelector
                        }),
                        displayUnitsReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.labelDisplayUnits), {
                            selector: refSelector
                        }),
                        precisionReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.labelPrecision), {
                            selector: refSelector
                        }),
                        backgroundReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, labels.backgroundColor), {
                            selector: refSelector
                        })
                    };
                    return (0, onObjectUtil.Jf)({
                        hostServices: this.hostService,
                        omitSelectorForSingleSeries: omitForSingleSeries,
                        individualSelector: lineChart_formatter_getLabelIndividualSelector.call(this, !omitForSingleSeries),
                        selector,
                        repetitionSelector: void 0,
                        subSelectionStylesOptions: {
                            precision: {
                                defaultPrecision: labelUnitsAndPrecision.getPrecision(!1, currentSeries.type)
                            }
                        }
                    }, dataLabelsModelReferences);

                  case "total-labels":
                    var totals = lineChart_capabilities.qn.totals;
                    return (0, onObjectUtil.Jf)({
                        hostServices: this.hostService,
                        omitSelectorForSingleSeries: omitForSingleSeries,
                        individualSelector: lineChart_formatter_getLabelIndividualSelector.call(this, !omitForSingleSeries),
                        selector,
                        repetitionSelector: void 0
                    }, {
                        fontFamilyReference: totals.fontFamily,
                        fontSizeReference: totals.fontSize,
                        boldReference: totals.bold,
                        italicReference: totals.italic,
                        underlineReference: totals.underline,
                        fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, totals.color), {
                            selector: (0, dataLabelUtil.hm)(lineChart_formatter_getLabelIndividualSelector.call(this, !1), void 0, void 0)
                        }),
                        displayUnitsReference: totals.labelDisplayUnits,
                        precisionReference: totals.labelPrecision,
                        backgroundReference: totals.backgroundColor
                    });

                  default:
                    return;
                }
            }
        }
        function lineChart_formatter_getLabelIndividualSelector(hasSeriesSelector) {
            return (0, dataLabelViewModel1.WD)({
                featureSwitches: this.featureSwitches,
                hasCategories: null != _.first(this.originalData.categories),
                hasDynamicSeries: this.originalData.hasDynamicSeries,
                hasSeriesSelector
            });
        }
        function lineChart_formatter_getSubSelectionShortcuts(subSelections, filter) {
            if (!filter) {
                var visualObject, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0) {
                    var selector;
                    visualObject = visualObjects[0], _.isEmpty(visualObject.selectorsByColumn) || (selector = (0, 
                    contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn)));
                    var deleteKeyboardShortcut = {
                        key: "Delete",
                        nextValue: !1
                    };
                    switch (visualObject.objectName) {
                      case "lines":
                      case "area":
                        return selector ? [ {
                            type: 0,
                            excludedResetFormattingIds: [ lineChart_capabilities.qn.labels.show, (0, tslib_es6.__assign)((0, 
                            tslib_es6.__assign)({}, lineChart_capabilities.qn.labels.showSeries), {
                                selector
                            }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.showMarker), {
                                selector
                            }), {
                                objectName: "seriesLabels",
                                propertyName: "show",
                                selector
                            } ]
                        }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, lineChart_capabilities.qn.labels.showSeries), {
                            enabledLabel: this.localizer("Format_AddDataLabels"),
                            selector
                        }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, lineChart_capabilities.qn.lineStyles.showMarker), {
                            enabledLabel: this.localizer("Format_AddMarkers"),
                            selector,
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, {
                            objectName: "seriesLabels",
                            propertyName: "show"
                        }), {
                            enabledLabel: this.localizer("Format_AddSeriesLabel"),
                            selector
                        }), {
                            type: 1,
                            destinationInfo: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.lineStyle), {
                                selector: this.data.series.length > 1 ? selector : void 0
                            }),
                            label: this.localizer("Format_Line")
                        } ] : void debug.fF.assertFail("LineChart - line subselection should never have no selector");

                      case "markers":
                        return selector ? [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, lineChart_capabilities.qn.lineStyles.showMarker), {
                            disabledLabel: this.localizer("Delete"),
                            selector,
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            excludedResetFormattingIds: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.showMarker), {
                                selector
                            }) ]
                        }, {
                            type: 1,
                            destinationInfo: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.markerShape), {
                                selector: this.data.series.length > 1 ? selector : void 0
                            }),
                            label: this.localizer("Format_Markers")
                        } ] : void debug.fF.assertFail("LineChart - marker subselection should never have no selector");

                      default:
                        return;
                    }
                }
            }
        }
        function addLineStrokeFormattingGroup(lineStyleFormatOptions) {
            var _a, _this = this, lineStyle = lineStyleFormatOptions.lineStyle, selector = lineStyleFormatOptions.selector, containerItemBuilder = lineStyleFormatOptions.containerItemBuilder, strokeSlices = (0, 
            common_strokeStyle.Iq)({
                containerItemBuilder,
                descriptors: {
                    strokePattern: lineChart_capabilities.qn.lineStyles.lineStyle,
                    strokeDashArray: lineChart_capabilities.qn.lineStyles.strokeDashArray,
                    strokeAutoScale: lineChart_capabilities.qn.lineStyles.strokeAutoScale,
                    strokeDashCap: lineChart_capabilities.qn.lineStyles.strokeDashCap,
                    strokeLineJoin: lineChart_capabilities.qn.lineStyles.strokeLineJoin,
                    strokeWidth: lineChart_capabilities.qn.lineStyles.strokeWidth
                },
                strokeData: lineStyle,
                selector,
                isSVGStroke: !0,
                featureSwitches: this.featureSwitches,
                localize: this.localizer
            });
            null === (_a = strokeSlices.find(function(slice) {
                return (0, formattingModelUtil.cd)(slice.getSimpleControlDescriptor(), lineChart_capabilities.zK.lineStyles.strokeLineJoin);
            })) || void 0 === _a || _a.withDisabled(!lineStyle.strokeShow || lineStyle.interpolation === lineInterp.Fu.smooth, "Visual_StrokeLineJoinDisabledReason"), 
            containerItemBuilder.addGroup("shape", function(groupBuilder) {
                return groupBuilder.withDisplayName("Visual_Shape_Line").addSlices(strokeSlices.map(function(slice) {
                    return slice.build();
                })).addSlices((0, lineInterpolation.Ie)({
                    containerItemBuilder,
                    descriptors: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles), {
                        interpolation: lineChart_capabilities.qn.lineStyles.lineChartType
                    }),
                    interpData: lineStyle,
                    selector,
                    localize: _this.localizer,
                    featureSwitches: _this.featureSwitches,
                    disabledIfHasSelector: !0
                }).map(function(slice) {
                    return slice.build();
                }));
            });
        }
        function addLineColorFormattingGroup(lineStyleFormatOptions) {
            var _a, _b, _c, selector = lineStyleFormatOptions.selector, lineStyle = lineStyleFormatOptions.lineStyle, containerItemBuilder = lineStyleFormatOptions.containerItemBuilder, formatSingleStaticSeries = !selector && this.hasSingleStaticSeries, strokeSlices = (0, 
            common_strokeStyle.Iq)({
                containerItemBuilder,
                descriptors: {
                    strokeColor: lineChart_capabilities.qn.dataPoint.fill,
                    strokeTransparency: lineChart_capabilities.qn.lineStyles.strokeTransparency
                },
                strokeData: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineStyle), {
                    strokeColor: formatSingleStaticSeries ? null === (_a = this.data.series[0]) || void 0 === _a ? void 0 : _a.lineStyle.strokeColor : lineStyle.strokeColor
                }),
                selector,
                colorSelector: formatSingleStaticSeries ? (0, contracts_selector.fd)(null === (_b = this.data.series[0]) || void 0 === _b ? void 0 : _b.identity.getSelector()) : selector,
                featureSwitches: this.featureSwitches,
                localize: this.localizer
            });
            null === (_c = strokeSlices.find(function(slice) {
                return (0, formattingModelUtil.cd)(slice.getSimpleControlDescriptor(), lineChart_capabilities.zK.lineStyles.strokeColor);
            })) || void 0 === _c || _c.withDisabled(!this.hasSingleStaticSeries && !selector, "Visual_Color_AllSeries_DisabledReason"), 
            containerItemBuilder.addGroup("colors", function(colorGroupBuilder) {
                return colorGroupBuilder.withDisplayName("Generic_Color").addSlices(strokeSlices.map(function(slice) {
                    return slice.build();
                }));
            });
        }
        function addLineLayoutFormattingGroup(lineStyleFormatOptions) {
            var _this = this;
            this.isStacked && null == lineStyleFormatOptions.selector && (this.originalData.hasDynamicSeries || this.originalData.series.length > 1) && lineStyleFormatOptions.containerItemBuilder.addGroup("layout", function(layoutBuilder) {
                return layoutBuilder.withDisplayName("Layout").addSimpleSlice("seriesOrderReversed", new build_control_util.bd({
                    descriptor: lineChart_capabilities.qn.layout.seriesOrderReversed,
                    value: _this.data.layout.seriesOrderReversed
                }).build());
            });
        }
        function addLinesCardPerSeriesToContainer(lineStyleFormatOptions) {
            var selector = lineStyleFormatOptions.selector, lineStyle = lineStyleFormatOptions.lineStyle;
            lineStyleFormatOptions.containerItemBuilder.addSimpleSlice("showSeries", new build_control_util.bd({
                descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.qn.lineStyles.strokeShow), {
                    selector
                }),
                value: lineStyle.strokeShow
            }).build(), function(sliceBuilder) {
                return sliceBuilder.withCustomDisplayName(selector ? "Visual_Show_Data_Labels_PerSeries" : "Visual_ShowForAllSeries");
            }), addLineStrokeFormattingGroup.call(this, lineStyleFormatOptions), addLineColorFormattingGroup.call(this, lineStyleFormatOptions), 
            addLineLayoutFormattingGroup.call(this, lineStyleFormatOptions);
        }
        function addMarkersFormattingContainers(formatCardOptions) {
            var _this = this, markerStyle = formatCardOptions.markerStyle, selector = formatCardOptions.selector, listType = formatCardOptions.listType;
            formatCardOptions.containerItemBuilder.addSimpleSlice("showMarker", new build_control_util.bd({
                descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.markers.show), {
                    selector
                }),
                value: markerStyle.show
            }).build(), function(sliceBuilder) {
                return sliceBuilder.withDisabled(!selector).withHidden("perCategory" === listType || "staticPerCategories" === listType);
            }).addGroup("markers", function(groupBuilder) {
                return groupBuilder.withDisplayName("Visual_Shape").withDisabled(!markerStyle.show || "perCategory" === listType).addSimpleSlice("markerShape", new build_control_util.uY({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.markers.shape), {
                        selector
                    }),
                    value: markerStyle.shape
                }).build()).addSimpleSlice("markerSize", new build_control_util.mu({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.markers.size), {
                        selector
                    }),
                    value: markerStyle.size,
                    options: {
                        minValue: {
                            type: 0,
                            value: MarkerShapeSizeRange.min
                        },
                        maxValue: {
                            type: 1,
                            value: MarkerShapeSizeRange.max
                        },
                        unitSymbol: visualLocKeys.e_
                    }
                }).build()).addSimpleSlice("markerRotation", build_control_util.JN.getRotationSliderBuilder({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.markers.rotation), {
                        selector
                    }),
                    value: markerStyle.rotation,
                    localize: _this.localizer
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withHidden(!_this.featureSwitches.newMarkerProperties || !(0, 
                    markerShape.Cd)(markerStyle.shape));
                });
            }).addGroup("colors", function(groupBuilder) {
                return groupBuilder.withDisplayName("Generic_Color").withDisabled(!markerStyle.show).addSimpleSlice("markerColor", new build_control_util.BT({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, "perCategory" === listType ? (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.dataPoint.fill), {
                        instanceKind: 1
                    }) : lineChart_capabilities.zK.markers.color), {
                        selector
                    }),
                    value: {
                        value: markerStyle.color
                    }
                }).build()).addSimpleSlice("markerTransparency", build_control_util.JN.getTransparencySliderBuilder({
                    descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, lineChart_capabilities.zK.markers.transparency), {
                        selector
                    }),
                    value: markerStyle.transparency,
                    localize: _this.localizer
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withHidden(!_this.featureSwitches.newMarkerProperties);
                });
            }), this.featureSwitches.newMarkerProperties && formatCardOptions.containerItemBuilder.addGroup("border", function(groupBuilder) {
                return groupBuilder.withDisplayName("Visual_Border").withDisabled(!(0, markerShape.nK)(markerStyle.shape) || !markerStyle.show || "perCategory" === listType).addSlices((0, 
                common_strokeStyle.Iq)({
                    containerItemBuilder: groupBuilder,
                    descriptors: dataViewObjectProperties.$9,
                    strokeData: markerStyle.stroke,
                    selector,
                    featureSwitches: _this.featureSwitches,
                    localize: _this.localizer
                }).map(function(slice) {
                    return slice.build();
                }));
            });
        }
        function lineChart_formatter_getDataViewObjectLayerChanges(propertySaveObjects, sourceType) {
            if (!this.featureSwitches.onObject || 1 !== sourceType) return [];
            var chartProps = this.isComboChart ? comboChart_capabilities.OA : lineChart_capabilities.qn, seriesMarkerValues = this.data.series.map(function(s) {
                return {
                    selector: s.identity.getSelector(),
                    value: s.lineStyle.markerProperties.show
                };
            }), seriesLabelsValues = this.data.series.map(function(s) {
                var _a;
                return {
                    selector: s.identity.getSelector(),
                    value: null === (_a = s.seriesLabelSettings) || void 0 === _a ? void 0 : _a.show
                };
            }), dataLabelsValues = this.data.series.map(function(s) {
                var _a;
                return {
                    selector: s.identity.getSelector(),
                    value: null === (_a = s.labelSettings) || void 0 === _a ? void 0 : _a.show
                };
            }), behaviorObjects = [ seriesLevelToggleBehavior.v.create(chartProps.lineStyles.showMarker, this.data.lineStyle.markerProperties.show, seriesMarkerValues).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.lineStyles.showMarkerByDefault, !1, {
                required: !0
            }), addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.lineStyles.showMarker, !0, {
                required: !0
            })).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("lineStyles", {
                required: !0
            })), topLevelToggleBehavior.$.create(chartProps.lineStyles.showMarker, this.data.lineStyle.markerProperties.show).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("lineStyles", {
                required: !0
            })), seriesLevelToggleBehavior.v.create(lineChart_capabilities.qn.seriesLabels.backgroundColor, this.data.seriesLabelSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(lineChart_capabilities.qn.seriesLabels.enableBackground, !0, {
                required: !0,
                inheritSelector: !0
            })), topLevelToggleBehavior.$.create(lineChart_capabilities.qn.seriesLabels.backgroundColor, this.data.seriesLabelSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(lineChart_capabilities.qn.seriesLabels.enableBackground, !0, {
                required: !0
            })), seriesLevelToggleBehavior.v.create(lineChart_capabilities.qn.seriesLabels.show, this.data.seriesLabelSettings.show, seriesLabelsValues).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(lineChart_capabilities.qn.seriesLabels.showByDefault, !1, {
                required: !0
            }), addDataViewObjectChange.W.createBooleanDataViewObjectChange(lineChart_capabilities.qn.seriesLabels.show, !0, {
                required: !0
            })).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("seriesLabels", {
                required: !0
            })), topLevelToggleBehavior.$.create(lineChart_capabilities.qn.seriesLabels.show, this.data.seriesLabelSettings.show).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("seriesLabels", {
                required: !0
            })), seriesLevelToggleBehavior.v.create(chartProps.labels.backgroundColor, this.data.dataLabelsSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.enableBackground, !0, {
                inheritSelector: !0
            })), topLevelToggleBehavior.$.create(chartProps.labels.backgroundColor, this.data.dataLabelsSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.enableBackground, !0)), seriesLevelToggleBehavior.v.create(chartProps.labels.showSeries, this.data.dataLabelsSettings.show, dataLabelsValues).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.showByDefault, !1), addDataViewObjectChange.W.createBooleanDataViewObjectChange(chartProps.labels.show, !0)).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("labels")), topLevelToggleBehavior.$.create(chartProps.labels.show, this.data.dataLabelsSettings.show).onToggleDisabled(addDataViewObjectChange.W.createRevertToDefaultDataViewObjectChange("labels")) ];
            return dataViewObjectChangeHelper.o.getDataViewObjectsBehaviorChanges(propertySaveObjects, behaviorObjects);
        }
        var dataLabelContainerUtils = __webpack_require__(34519), labelDataPointSorter = __webpack_require__(12198), color = __webpack_require__(64067), LineChartHitTester = function() {
            function LineChartHitTester(options) {
                this.dataPoints = options.dataPoints, this.isComboChart = options.isComboChart, 
                this.isScalar = options.isScalar, this.hasCategories = options.hasCategories;
            }
            return LineChartHitTester.prototype.queryRegion = function(rect) {
                var _this = this, selectedPoints = [], dataSpaceRect = rect.dataSpace;
                return (this.isScalar || this.hasCategories && void 0 !== dataSpaceRect.left && void 0 !== dataSpaceRect.right) && (selectedPoints = _.filter(this.dataPoints, function(point) {
                    return (0, Double.bl)(dataSpaceRect.left.value, _this.isScalar ? point.categoryValue : point.categoryIndex) && (0, 
                    Double.bl)(_this.isScalar ? point.categoryValue : point.categoryIndex, dataSpaceRect.right.value) && (0, 
                    Double.bl)(_this.getBottom(dataSpaceRect, point), point.value) && (0, Double.bl)(point.value, _this.getTop(dataSpaceRect, point));
                })), selectedPoints;
            }, LineChartHitTester.prototype.getBottom = function(rect, point) {
                return point.isY2 || this.isComboChart && rect.bottom2 ? rect.bottom2.value : rect.bottom.value;
            }, LineChartHitTester.prototype.getTop = function(rect, point) {
                return point.isY2 || this.isComboChart && rect.top2 ? rect.top2.value : rect.top.value;
            }, LineChartHitTester;
        }(), LineClassSelector = (0, CssConstants.CH)("line"), FocusElementSelector = (0, 
        CssConstants.CH)("focus-element"), PositionRectSelector = (0, CssConstants.CH)("position-rect"), CategorySelector = (0, 
        CssConstants.CH)("cat"), CategoryAreaSelector = (0, CssConstants.CH)("catArea"), CategoryValuePoint = (0, 
        CssConstants.CH)("dot"), CategoryPointSelector = (0, CssConstants.CH)("point"), HoverLineCircleDot = (0, 
        CssConstants.CH)("circle-item"), MarkerLineClassSelector = (0, CssConstants.CH)("marker-line"), InteractivityLineClassSelector = (0, 
        CssConstants.CH)("interactivity-line"), SelectedMarkerLineClassSelector = (0, CssConstants.CH)("selected-markers"), SelectionCircleClassSelector = (0, 
        CssConstants.CH)("selection-circle"), selectionCirclesClassSelector = (0, CssConstants.CH)("selection-circles");
        function setHoverlineAndDotsForTooltip(categoryIndex, dataPoints) {
            var _this = this, chartX = this.getChartX(categoryIndex);
            dataPoints.length > 0 && setHoverLineForTooltip.call(this, chartX), this.hoverLineContext.selectAll(HoverLineCircleDot.selector).data(_.filter(dataPoints, function(dataPoint) {
                return dataPoint.showHoverlineDots && null != dataPoint.value;
            })).join(function(enter) {
                return enter.append("circle").classed(HoverLineCircleDot.class, !0);
            }).attr("fill", function(d) {
                return d.marker.color;
            }).attr("r", getFocusOnlyMarkerRadius(this.data.lineStyle)).attr("cx", chartX).attr("cy", function(d) {
                return getYPosition(_this.viewModel, d);
            });
        }
        function clearHoverLine() {
            this.hoverLine.style("opacity", svgUtil.OH), this.hoverLineContext.selectAll(HoverLineCircleDot.selector).remove();
        }
        function initHoverLine() {
            this.hoverLineContext = this.mainGraphicsSVG.append("g").classed("hover-line", !0), 
            this.hoverLine = this.hoverLineContext.append("line").classed("interactive", this.mobileTileInteractive).attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0).style("opacity", svgUtil.OH).style("stroke", common_colorHelper.v.getThemeColor(this.style, "foregroundNeutralSecondary")), 
            this.mobileTileInteractive && (this.dragHandle = this.hoverLineContext.append("circle").attr("cx", 0).attr("r", "6px").classed("drag-handle", !0), 
            this.hoverLineContext.append("g").classed(selectionCirclesClassSelector.class, !0));
        }
        function setHoverLineForTooltip(chartX) {
            this.hoverLine.attr("x1", chartX = chartX || 0).attr("x2", chartX).attr("y1", 0).attr("y2", this.availableHeight).style("opacity", 1);
        }
        function setHoverLine(chartX, columnIndex) {
            var _this = this;
            setHoverLineForTooltip.call(this, chartX), this.mobileTileInteractive && (this.dragHandle.attr("cx", chartX).attr("cy", this.availableHeight), 
            this.hoverLineContext.select(selectionCirclesClassSelector.selector).selectAll(SelectionCircleClassSelector.selector).data(this.activeData.series, function(d) {
                return d.identity.getKey();
            }).join(function(enter) {
                return enter.append("circle").classed(SelectionCircleClassSelector.class, !0);
            }).attr("r", getFocusOnlyMarkerRadius(this.activeData.lineStyle)).attr("cx", chartX).attr("cy", function(series) {
                return series.data[columnIndex] ? getYPosition(_this.viewModel, series.data[columnIndex]) : 0;
            }).style("opacity", function(series) {
                return _.some(series.data, function(value) {
                    return !!value && value.categoryIndex === columnIndex;
                }) ? 1 : 0;
            }).style("fill", function(series) {
                return series.lineStyle.strokeColor;
            }));
        }
        function isDataPointDefined(d) {
            return d && null !== d.value;
        }
        function getLeftmostPathPointFromSeriesData(seriesData, invertSearch) {
            return (invertSearch ? _.findLast : _.find)(seriesData.data, function(dataPoint, index, dataPoints) {
                var nextDataPoint = invertSearch ? dataPoints[index - 1] : dataPoints[index + 1];
                return null != dataPoint && null != dataPoint.value && null != nextDataPoint && null != nextDataPoint.value;
            });
        }
        var lineChart_renderer_Mockable_findSubSelectedAreaElement = function(viewModel, clientPoint) {
            if (null != viewModel.renderContext.mainGraphicsSVG) {
                var linePathElements = viewModel.renderContext.mainGraphicsSVG.selectAll(LineClassSelector.selector).filter(function(d) {
                    return d.data.some(function(dataPoint) {
                        return isDataPointDefined(dataPoint);
                    });
                }).nodes(), subSelectedAreaIndex = function(viewModel, clientPoint, pathElements) {
                    for (var nearestLineIndex, minAbsDiff = Number.MAX_VALUE, _a = viewModel.renderContext.mainGraphicsSVG.node().getBoundingClientRect(), left = _a.left, top = _a.top, i = 0; i < pathElements.length; i++) {
                        var svgPointClientY = getPosition(clientPoint.x, pathElements[i], function(svgX) {
                            return Mockable.convertSvgXToClientX(svgX, viewModel.currentViewport.scale, left);
                        }, function(svgY) {
                            return Mockable.convertSvgYToClientY(svgY, viewModel.currentViewport.scale, top);
                        }).y, diff = clientPoint.y - svgPointClientY;
                        diff >= -4 && minAbsDiff > (diff = Math.abs(diff)) && (minAbsDiff = diff, nearestLineIndex = i);
                    }
                    return nearestLineIndex;
                }(viewModel, clientPoint, linePathElements);
                if (null != subSelectedAreaIndex) return viewModel.renderContext.mainGraphicsSVG.selectAll(CategoryAreaSelector.selector).filter(function(d) {
                    return d.index === subSelectedAreaIndex;
                }).node();
            }
        };
        function getPosition(x, pathElement, convertSvgXToClientX, convertSvgYToClientY) {
            for (var pos, target, beginning = 0, end = pathElement.getTotalLength(); pos = pathElement.getPointAtLength(target = beginning + end >> 1), 
            (0, svgUtil.lO)(pos), convertSvgXToClientX && (pos.x = convertSvgXToClientX(pos.x)), 
            convertSvgYToClientY && (pos.y = convertSvgYToClientY(pos.y)), target !== end && target !== beginning || pos.x === x; ) if (pos.x > x) end = target; else {
                if (!(pos.x < x)) break;
                beginning = target;
            }
            return pos;
        }
        function updateFocusElement(viewModel, elementToFocus) {
            return viewModel.renderContext.mainGraphicsContext.selectAll(FocusElementSelector.selector).data(elementToFocus ? [ elementToFocus ] : []).join(function(enter) {
                return enter.append("circle").attr("class", FocusElementSelector.class).attr("tabindex", 0).attr("focusable", !0).attr("role", "option").classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge());
            }).attr("aria-selected", function(d) {
                return d.selected;
            }).attr("aria-label", function(d) {
                var _a, _b;
                if (isAnomaly(d)) return viewModel.hostService.getLocalizedString("Anomaly_ScreenReader_Hint");
                var hasAnomaly = !1;
                hasAnomalies(viewModel.activeData) && (hasAnomaly = _.some(viewModel.activeData.anomalyDetections[0].anomaliesCategoryIndex, function(index) {
                    return index === d.categoryIndex;
                }));
                var description = (0, tooltipUtils.X)(d.tooltipInfo);
                return (null === (_a = null == d ? void 0 : d.uncertainty) || void 0 === _a ? void 0 : _a.upperTooltip) && (description += " ".concat((0, 
                tooltipUtils.X)([ d.uncertainty.upperTooltip ]))), (null === (_b = null == d ? void 0 : d.uncertainty) || void 0 === _b ? void 0 : _b.lowerTooltip) && (description += " ".concat((0, 
                tooltipUtils.X)([ d.uncertainty.lowerTooltip ]))), hasAnomaly && (description += " ".concat(viewModel.hostService.getLocalizedString("AnomalyPoint_ScreenReader_Hint"))), 
                description;
            }).attr("cx", function(d) {
                return getXPositionWithOffset(viewModel, d);
            }).attr("cy", function(d) {
                return isAnomaly(d) ? (0, anomalyDetectionCartesianRenderer.v8)(d, viewModel.yAxisProperties.scale, viewModel.activeData.anomalyDetections[0].marker.size) : getYPosition(viewModel, d);
            }).attr("r", function(d) {
                return isAnomaly(d) ? (0, anomalyDetectionCartesianRenderer.bj)(viewModel.activeData.anomalyDetections[0].marker.size) : d.marker.show ? d.marker.size * marker_renderer.Wo.sizeRatio : d.marker.focusOnlySize;
            }).style("fill", "none");
        }
        var LineChartTooltipHelper = function() {
            function LineChartTooltipHelper(tooltipService, mainGraphicsSVG, supportsHoverLineTooltip) {
                this.tooltipService = tooltipService, this.mainGraphicsSVG = mainGraphicsSVG, this.supportsHoverLineTooltip = supportsHoverLineTooltip, 
                this.isHoverLineTooltipActive = !1, supportsHoverLineTooltip && (this.hoverLineTooltipOverlay = mainGraphicsSVG.append("rect").classed(TooltipOverlaySelector.class, !0));
            }
            return LineChartTooltipHelper.prototype.applyTooltips = function(context, plotAreaHelper, tooltipInteractivity) {
                !this.supportsHoverLineTooltip || context.activeData.binnedLineSamplingApplied && context.activeData.hasDynamicSeries ? this.applyPointTooltip(context, plotAreaHelper, tooltipInteractivity) : this.applyHoverLineTooltip(context, plotAreaHelper, tooltipInteractivity);
            }, LineChartTooltipHelper.prototype.removeTooltips = function(context, tooltipInteractivity) {
                this.removePointTooltip(context), this.removeHoverLineTooltip(tooltipInteractivity);
            }, LineChartTooltipHelper.prototype.applyHoverLineTooltip = function(context, plotAreaHelper, tooltipInteractivity) {
                this.removePointTooltip(context), this.hoverLineTooltipOverlay.attrs({
                    x: 0,
                    width: context.availableWidth,
                    height: context.availableHeight
                }), this.tooltipService.addTooltip(this.mainGraphicsSVG, function(args) {
                    var yValue, index = plotAreaHelper.getCategoryIndexFromTooltipEvent(args, args.elementCoordinates[0]), hoverLineData = tooltipInteractivity.getHoverLineDataForCategory(index);
                    return hoverLineData && hoverLineData.hasUncertainty && (yValue = plotAreaHelper.getYValueFromTooltipEvent(args.elementCoordinates[1], args.context)), 
                    LineChartTooltipHelper.getSeriesTooltipInfo(hoverLineData, yValue);
                }, function(args) {
                    return LineChartTooltipHelper.getCategoryIdentityForHoverLineTooltipEvent(plotAreaHelper, tooltipInteractivity, args);
                }, !0), this.mainGraphicsSVG.on("mouseout.hoverline", function() {
                    return tooltipInteractivity.clearHoverLine();
                }), this.mainGraphicsSVG.on("touchmove.hoverline", function() {
                    return tooltipInteractivity.clearHoverLine();
                }), this.setHoverLineTooltipActive(!0);
            }, LineChartTooltipHelper.prototype.removeHoverLineTooltip = function(tooltipInteractivity) {
                this.isHoverLineTooltipActive && (tooltipInteractivity.clearHoverLine(), this.tooltipService.removeTooltips(this.mainGraphicsSVG), 
                this.mainGraphicsSVG.on(".hoverline", null), this.setHoverLineTooltipActive(!1));
            }, LineChartTooltipHelper.prototype.setHoverLineTooltipActive = function(active) {
                this.isHoverLineTooltipActive = active;
            }, LineChartTooltipHelper.prototype.applyPointTooltip = function(context, plotAreaHelper, tooltipInteractivity) {
                this.removeHoverLineTooltip(tooltipInteractivity);
                var getDataPointIdentity = context.isComboChart ? function(args) {
                    return LineChartTooltipHelper.getCategoryIdentityForHoverLineTooltipEvent(plotAreaHelper, tooltipInteractivity, args);
                } : function(args) {
                    return args.data && [ args.data.identity ];
                }, getDataPointTooltipInfo = function(args) {
                    var _a;
                    return null === (_a = args.data) || void 0 === _a ? void 0 : _a.tooltipInfo;
                };
                this.tooltipService.addTooltip(context.interactivityLines, function(args) {
                    return plotAreaHelper.getTooltipInfoForPoint(args, args.elementCoordinates[0]);
                }, getDataPointIdentity, !0), this.tooltipService.addTooltip(context.dots, getDataPointTooltipInfo, getDataPointIdentity, !0), 
                this.tooltipService.addTooltip(context.explicitDots, getDataPointTooltipInfo, getDataPointIdentity, !0), 
                this.tooltipService.addTooltip(context.focusElement, getDataPointTooltipInfo, getDataPointIdentity, !0);
            }, LineChartTooltipHelper.prototype.removePointTooltip = function(context) {
                this.isHoverLineTooltipActive || (this.tooltipService.removeTooltips(context.interactivityLines), 
                this.tooltipService.removeTooltips(context.dots), this.tooltipService.removeTooltips(context.explicitDots));
            }, LineChartTooltipHelper.getCategoryIdentityForHoverLineTooltipEvent = function(plotAreaHelper, tooltipInteractivity, args) {
                var _a;
                if (args) {
                    if (args.data && isForecastPoint(args.data)) return null;
                    var categoryIndex = plotAreaHelper.getCategoryIndexFromTooltipEvent(args, args.elementCoordinates[0]);
                    return tooltipInteractivity.getHoverLineIdentities(categoryIndex, null === (_a = args.data) || void 0 === _a ? void 0 : _a.data);
                }
            }, LineChartTooltipHelper.getSeriesTooltipInfo = function(hoverLineData, yPositions) {
                var _a, _b, _c, _d, _e;
                if (!hoverLineData) return null;
                var pointData = hoverLineData.dataPoints;
                if (_.isEmpty(pointData)) return null;
                var hiddenMarker = {
                    show: !1,
                    color: "#000000",
                    transparency: 100,
                    shape: markerShape.ZO.circle
                }, hasDynamicSeries = !_.isEmpty(pointData) && pointData[0].seriesDisplayName, tooltipInfo = [], pushTooltipDataItem = function(info) {
                    return !(tooltipInfo.length >= LineChartTooltipHelper.MaxNumberOfItems || (tooltipInfo.push(info), 
                    0));
                }, legendMarkerRendering = hoverLineData.legendMarkerRendering, useStrokePattern = legendMarkerRendering !== types_legendMarkerRendering._.markerOnly && legendMarkerRendering !== types_legendMarkerRendering._.markerCircleDefault, firstAdditionalTooltipItems = pointData[0].additionalTooltipItems, allAdditionalTooltipItemsMatch = pointData.every(function(point) {
                    return _.isEqual(point.additionalTooltipItems, firstAdditionalTooltipItems);
                }), markerLineInfo = function(point) {
                    return useStrokePattern ? point.line : void 0;
                };
                if (allAdditionalTooltipItemsMatch) {
                    var tooltipItemPointMapping = [];
                    for (var pointIndex in pointData) if (null != (point = pointData[pointIndex]).value) {
                        if (!pushTooltipDataItem({
                            header: point.category,
                            subheader: point.multipleDisplayName,
                            displayName: point.seriesName || point.measureDisplayName,
                            value: null !== (_c = null === (_b = null === (_a = point.uncertainty) || void 0 === _a ? void 0 : _a.rangeTooltip) || void 0 === _b ? void 0 : _b.value) && void 0 !== _c ? _c : point.formattedValue,
                            marker: point.marker,
                            line: markerLineInfo(point)
                        })) break;
                        tooltipItemPointMapping.push(+pointIndex);
                    }
                    hoverLineData.hasUncertainty && (debug.fF.assertValue(yPositions, "expect to have VerticalPositionInfo if uncertainty information present"), 
                    tooltipInfo = function(tooltipItems, points, tooltipItemPointMapping, yPositions) {
                        debug.fF.assert(function() {
                            return tooltipItems.length === tooltipItemPointMapping.length;
                        }, "augmentTooltipInfoWitUncertainty -- expected length of tooltipItems and mapping array to be identical");
                        for (var closePointsWithError = [], closestErrorDist = 1 / 0, closestErrorItem = -1, i = 0, len = tooltipItemPointMapping.length; i < len; i++) {
                            var dist;
                            (point = points[tooltipItemPointMapping[i]]).uncertainty && (point.isY2 ? (dist = Math.abs(point.value - yPositions.y2.point)) < yPositions.y2.threshold ? closePointsWithError.push(i) : dist < closestErrorDist && (closestErrorDist = dist, 
                            closestErrorItem = i) : ((dist = Math.abs(point.value - yPositions.y.point)) < yPositions.y.threshold && closePointsWithError.push(i), 
                            dist < closestErrorDist && (closestErrorDist = dist, closestErrorItem = i)));
                        }
                        var finalTooltips = [];
                        for (i = 0, len = tooltipItemPointMapping.length; i < len; i++) {
                            var point = points[tooltipItemPointMapping[i]], tooltipItem = tooltipItems[i];
                            if (_.includes(closePointsWithError, i) || closestErrorItem === i) {
                                var pointUncertainty = point.uncertainty;
                                debug.fF.assertValue(pointUncertainty, "added point as having error when no uncertainty info exists"), 
                                pointUncertainty.upperTooltip && finalTooltips.push((0, tslib_es6.__assign)({
                                    header: point.category,
                                    subheader: point.multipleDisplayName
                                }, pointUncertainty.upperTooltip)), finalTooltips.push(tooltipItem), pointUncertainty.lowerTooltip && finalTooltips.push(pointUncertainty.lowerTooltip);
                            } else finalTooltips.push(tooltipItem);
                        }
                        return finalTooltips;
                    }(tooltipInfo, pointData, tooltipItemPointMapping, yPositions));
                    for (var _i = 0, _f = null != firstAdditionalTooltipItems ? firstAdditionalTooltipItems : []; _i < _f.length && pushTooltipDataItem({
                        displayName: (additionalTooltipItem = _f[_i]).displayName,
                        value: additionalTooltipItem.value,
                        marker: hiddenMarker
                    }); _i++) ;
                } else for (var _g = 0, pointData_1 = pointData; _g < pointData_1.length; _g++) {
                    var point = pointData_1[_g];
                    if (tooltipInfo.length >= LineChartTooltipHelper.MaxNumberOfItems) break;
                    if (null != point.value) {
                        hasDynamicSeries && pushTooltipDataItem({
                            header: point.category,
                            subheader: point.multipleDisplayName,
                            displayName: point.seriesDisplayName,
                            value: point.seriesName,
                            marker: point.marker,
                            line: markerLineInfo(point)
                        }), pushTooltipDataItem({
                            header: point.category,
                            subheader: point.multipleDisplayName,
                            displayName: hasDynamicSeries ? point.measureActualDisplayName : point.measureDisplayName,
                            value: point.formattedValue,
                            marker: hasDynamicSeries ? hiddenMarker : point.marker,
                            line: hasDynamicSeries ? void 0 : markerLineInfo(point)
                        });
                        for (var _h = 0, _j = null !== (_d = point.additionalTooltipItems) && void 0 !== _d ? _d : []; _h < _j.length && pushTooltipDataItem({
                            header: point.category,
                            subheader: point.multipleDisplayName,
                            displayName: (additionalTooltipItem = _j[_h]).displayName,
                            value: additionalTooltipItem.value,
                            marker: hiddenMarker
                        }); _h++) ;
                    }
                }
                for (var _k = 0, _l = null !== (_e = hoverLineData.additionalTooltipItems) && void 0 !== _e ? _e : []; _k < _l.length; _k++) {
                    var additionalTooltipItem;
                    if (!pushTooltipDataItem({
                        header: pointData[0].category,
                        subheader: pointData[0].multipleDisplayName,
                        displayName: (additionalTooltipItem = _l[_k]).displayName,
                        value: additionalTooltipItem.value,
                        marker: hiddenMarker
                    })) break;
                }
                return 0 === tooltipInfo.length ? null : tooltipInfo;
            }, LineChartTooltipHelper.MaxNumberOfItems = 15, LineChartTooltipHelper;
        }(), formatStringProp = lineChart_capabilities.zK.general.formatString, LineChart = function(_super) {
            function LineChart(options) {
                var _this = _super.call(this, options) || this;
                return _this.options = options, _this.pathXAdjustment = 0, _this.deferDragMoveOperation = (0, 
                Utility.S5)(function() {
                    if (_this.lastDragMoveXPosition && _this.data && _this.margin) {
                        var index = LineChart.findCategoryIndex({
                            pointX: _this.lastDragMoveXPosition - _this.margin.left,
                            offsetX: 0,
                            categoryData: _this.data.categoryData,
                            currentViewport: _this.currentViewport,
                            scale: _this.xAxisProperties.scale,
                            categoryThickness: _this.xAxisProperties.categoryThickness,
                            isScalar: _this.data.isScalar
                        });
                        _this.selectColumn(index), _this.lastDragMoveXPosition = void 0;
                    }
                }), _this.tooltipsEnabledOnHost = options.tooltipsEnabled, _this.markerRenderer = new marker_renderer.Wo, 
                _this.anomalyNavigationHelper = new anomalyDetectionKeyboardNavigationHelper.B, 
                _this;
            }
            return (0, tslib_es6.__extends)(LineChart, _super), LineChart.getInteractiveLineChartDomElement = function(element) {
                return element.children("svg").get(0);
            }, LineChart.createStackedValueDomain = function(data, isStacked100) {
                if (debug.fF.assertValue(data, "data"), 0 === data.length) return null;
                var range = [ d3.min(data, function(kv) {
                    return d3.min(kv.data, function(d) {
                        return d && d.stackedValue;
                    });
                }), d3.max(data, function(kv) {
                    return d3.max(kv.data, function(d) {
                        return d && d.stackedValue;
                    });
                }) ];
                return isStacked100 && (range[0] = (0, Double.W0)(range[0], 1e-4), range[1] = (0, 
                Double.W0)(range[1], 1e-4)), range;
            }, Object.defineProperty(LineChart.prototype, "lineChartType", {
                get: function() {
                    return this.options.lineChartType;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChart.prototype, "isAreaChart", {
                get: function() {
                    return 2 === this.lineChartType || 16 === this.lineChartType || 32 === this.lineChartType;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChart.prototype, "isStacked", {
                get: function() {
                    return 16 === this.lineChartType || 32 === this.lineChartType;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChart.prototype, "isStacked100", {
                get: function() {
                    return 32 === this.lineChartType;
                },
                enumerable: !1,
                configurable: !0
            }), LineChart.prototype.initRenderer = function(options) {
                var _this = this;
                if (_super.prototype.initRenderer.call(this, options), this.svg.classed(LineChart.ClassName, !0), 
                this.mainGraphicsSVG = this.svg.append("svg").classed(LineChart.lineChartSVGClassName, !0), 
                this.svgDefs = this.mainGraphicsSVG.append("defs"), this.lineChartTooltipHelper = new LineChartTooltipHelper(this.tooltipService, this.mainGraphicsSVG, !this.isComboChart && !this.mobileTileInteractive), 
                this.mainGraphicsContext = this.mainGraphicsSVG.append("g").attr("role", "listbox").attr("aria-label", this.localizer("Visual_Plot")).attr("aria-live", "polite").classed(LineChart.MainGraphicsContextClassName, !0), 
                this.mainGraphicsContext.append("g").attr("class", SelectedMarkerLineClassSelector.class), 
                this.interactivityService && (this.isComboChart ? this.mainGraphicsContext.attr(DOMConstants.Rh, !0) : (options.useManagedTabIndex ? this.mainGraphicsContext.classed(gridLayoutBehaviors.rG.class, !0).attr(DOMConstants.Rh, !0) : this.mainGraphicsContext.attr("tabindex", 0).attr("focusable", !0), 
                this.mainGraphicsContext.classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()))), 
                initHoverLine.call(this), this.xAxisProperties = {
                    d3Axis: null,
                    scale: null,
                    valueType: null,
                    formatter: null,
                    graphicsContext: null,
                    values: [],
                    axisLabel: null,
                    isCategoryAxis: !0
                }, this.mobileTileInteractive) {
                    var rootSvg_1 = LineChart.getInteractiveLineChartDomElement(this.element), dragMove = function() {
                        _this.lastDragMoveXPosition = d3.mouse(rootSvg_1)[0], _this.deferDragMoveOperation();
                    }, drag = d3.drag().on("drag", dragMove);
                    d3.select(rootSvg_1).style("touch-action", "none").call(drag).on("click", dragMove);
                }
            }, LineChart.prototype.setData = function(dataViews, multipleInfo) {
                var _a, _b, _c;
                if (this.data = this.originalData = {
                    series: [],
                    totals: [],
                    legendData: (0, legend_converter.Fe)(this.style),
                    isScalar: !1,
                    dataLabelsSettings: getDefaultLineChartLabelSettings(this.style, this.isComboChart, this.isStacked100),
                    seriesLabelSettings: getDefaultSeriesLabelSettings(this.style),
                    hasDynamicSeries: !1,
                    hasHighlights: !1,
                    categories: [],
                    categoryMetadata: void 0,
                    valuesMetadata: [],
                    categoryData: [],
                    categoryIdentities: [],
                    lineStyle: getDefaultLineStyle(),
                    binnedLineSamplingApplied: !1,
                    legendMarkerRendering: types_legendMarkerRendering._.markerCircleDefault,
                    matchLineColor: !1,
                    layout: {
                        seriesOrderReversed: !1
                    }
                }, this.focusedDatum = void 0, _.isEmpty(dataViews)) this.dataView = void 0; else {
                    var firstDataView = _.first(dataViews);
                    if (null == firstDataView ? void 0 : firstDataView.categorical) {
                        this.dataView = firstDataView;
                        var scalarKeys, dvCategories = firstDataView.categorical.categories, categoryType = {
                            text: !0
                        };
                        dvCategories && !_.isEmpty(dvCategories) && (dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type), 
                        scalarKeys = (0, scalarUtils.A8)(dvCategories[0]));
                        var hostTooltips = null === (_a = this.hostService) || void 0 === _a ? void 0 : _a.tooltips(), tooltipsEnabled = this.tooltipsEnabled = this.tooltipsEnabledOnHost && (!hostTooltips || (null == hostTooltips ? void 0 : hostTooltips.enabled()));
                        this.data = this.originalData = LineChartConverter.convert({
                            dataView: firstDataView,
                            style: this.style,
                            isScalar: (0, scalarUtils.PX)(null !== (_c = null === (_b = firstDataView.metadata) || void 0 === _b ? void 0 : _b.objects) && void 0 !== _c ? _c : null, lineChart_capabilities.zK.categoryAxis.axisType, categoryType, scalarKeys, (0, 
                            dataViewHelper.n$)(firstDataView)),
                            interactivityService: this.interactivityService,
                            isComboChart: this.isComboChart,
                            tooltipsEnabled,
                            forecastDataView: _.find(dataViews, function(dataView) {
                                return (0, forecastHelper1.Aq)(dataView);
                            }),
                            anomalyDetectionDataView: _.find(dataViews, function(dataView) {
                                return (0, anomalyDetection_converter.Ik)(dataView);
                            }),
                            isStacked: this.isStacked,
                            isAreaChart: this.isAreaChart,
                            isStacked100: this.isStacked100,
                            multipleInfo,
                            supportsTotalLabels: !multipleInfo && this.supportsTotalLabels(),
                            featureSwitches: this.featureSwitches,
                            hostServices: this.hostService
                        });
                        var currentCategoryIds = this.data.categoryIdentities;
                        this.suppressAnimation = LineChart.shouldSuppressAnimations(this.previousCategoryIds, currentCategoryIds), 
                        this.previousCategoryIds = currentCategoryIds;
                        var lowestSeries = _.find(this.data.series, function(series) {
                            return series.data[0];
                        });
                        this.focusedDatum = null == lowestSeries ? void 0 : lowestSeries.data[0];
                    }
                }
            }, LineChart.shouldSuppressAnimations = function(previousCategoryIds, currentCategoryIds) {
                var suppressAnimation;
                if (null != previousCategoryIds && !(previousCategoryIds.length > animatorCommon.dt || currentCategoryIds.length > animatorCommon.dt)) if (suppressAnimation = !1, 
                0 === previousCategoryIds.length) suppressAnimation = !0; else for (var categoryIndex = 0, categoryCount = Math.min(previousCategoryIds.length, currentCategoryIds.length); categoryIndex < categoryCount; categoryIndex++) if (!selection_selectionId.l0.isEqual(previousCategoryIds[categoryIndex], currentCategoryIds[categoryIndex])) {
                    suppressAnimation = !0;
                    break;
                }
                return suppressAnimation;
            }, LineChart.prototype.getCategoryDomain = function(data) {
                var _a;
                return cartesianAxisHelper.createDomain(data.series, this.getCategoryValueType(), data.isScalar, [ cartesianAxisHelper.createScalarDomainOptions(null === (_a = LineChart.getForecastDomain(data.forecastLines)) || void 0 === _a ? void 0 : _a.x, 0) ]);
            }, LineChart.prototype.getAxesDomains = function(includeZero, requestedDomains) {
                var _a, _b, _c, _d;
                if (!this.data) return {};
                var data = this.data, axesDomains = {};
                if (requestedDomains.categoryAxis && data.isScalar) {
                    var categoryAxisDataDomain = this.getCategoryDomain(data);
                    if (categoryAxisDataDomain) {
                        cartesianAxisHelper.assertScalarDomain(categoryAxisDataDomain.domain);
                        var categoryAxisMin = (_a = categoryAxisDataDomain.domain)[0], categoryAxisMax = _a[1];
                        void 0 !== categoryAxisMin && void 0 !== categoryAxisMax && (axesDomains.categoryAxis = [ categoryAxisMin, categoryAxisMax ]);
                    }
                }
                if (requestedDomains.valueAxis || requestedDomains.secondaryValueAxis) {
                    var valueAxisForecastDomain = null === (_d = LineChart.getForecastDomain(data.forecastLines)) || void 0 === _d ? void 0 : _d.y;
                    if (requestedDomains.valueAxis) {
                        var valueAxisDataDomain = this.getValueDataDomain(includeZero, !1), valueAxisMin = (_b = cartesianAxisHelper.mergeDomains(valueAxisForecastDomain, valueAxisDataDomain))[0], valueAxisMax = _b[1];
                        void 0 !== valueAxisMin && void 0 !== valueAxisMax && (axesDomains.valueAxis = [ valueAxisMin, valueAxisMax ]);
                    }
                    if (requestedDomains.secondaryValueAxis) {
                        var secondaryValueAxisDataDomain = this.getValueDataDomain(includeZero, !0), secondaryValueAxisMin = (_c = cartesianAxisHelper.mergeDomains(valueAxisForecastDomain, secondaryValueAxisDataDomain))[0], secondaryValueAxisMax = _c[1];
                        void 0 !== secondaryValueAxisMin && void 0 !== secondaryValueAxisMax && (axesDomains.secondaryValueAxis = [ secondaryValueAxisMin, secondaryValueAxisMax ]);
                    }
                }
                return axesDomains;
            }, LineChart.prototype.getValueDataDomain = function(includeZero, isSecondaryValueAxis) {
                var seriesData = LineChart.getDataForValueAxis(this.data, isSecondaryValueAxis).seriesData;
                return this.isStacked ? LineChart.createStackedValueDomain(seriesData, this.isStacked100) : cartesianAxisHelper.createUncertaintyAwareValueDomain(seriesData, includeZero);
            }, LineChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || this.data.series && (this.data.series.length > 1 || this.data.valuesMetadata.length > 1));
            }, LineChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = (0, Prototype.ED)(this.data);
                data.series = LineChart.sliceSeries(data.series, startIndex, endIndex), data.categories = data.categories.slice(startIndex, endIndex), 
                this.clippedData = data;
            }, LineChart.getCategoryCount = function(data) {
                var _a;
                return (null === (_a = data.series) || void 0 === _a ? void 0 : _a.length) > 0 ? data.series[0].data.length : 0;
            }, LineChart.prototype.getSeriesLabelsSettings = function() {
                return (0, Prototype.ED)(this.data).seriesLabelSettings;
            }, LineChart.getForecastDomain = function(forecastLines) {
                if (!_.isEmpty(forecastLines)) {
                    for (var xs = [], ys = [], _i = 0, forecastLines_1 = forecastLines; _i < forecastLines_1.length; _i++) {
                        var forecastLine = forecastLines_1[_i];
                        _.isEmpty(forecastLine.points) || (xs.push.apply(xs, _.map(forecastLine.points, function(p) {
                            return p.point.x;
                        })), ys.push.apply(ys, _.map(forecastLine.points, function(p) {
                            return p.point.y;
                        })), xs.push.apply(xs, _.map(forecastLine.points, function(p) {
                            return p.upperBound.x;
                        })), ys.push.apply(ys, _.map(forecastLine.points, function(p) {
                            return p.upperBound.y;
                        })), xs.push.apply(xs, _.map(forecastLine.points, function(p) {
                            return p.lowerBound.x;
                        })), ys.push.apply(ys, _.map(forecastLine.points, function(p) {
                            return p.lowerBound.y;
                        })));
                    }
                    return {
                        x: d3.extent(xs),
                        y: d3.extent(ys)
                    };
                }
            }, LineChart.prototype.calculateAxesProperties = function(options) {
                var _a, _b, _c, _d, _e, _this = this;
                this.updateCurrentViewport(options);
                var categoryAxisOptions = options.categoryAxisOptions, valueAxisOptions = options.valueAxisOptions, initialCategoryCount = LineChart.getCategoryCount(this.data), categoryLayout = this.data ? (0, 
                cartesianHelper.is)({
                    data: this.data,
                    availableWidth: this.availableWidth,
                    categoryCount: initialCategoryCount,
                    preferredCategoryWidth: null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.preferredCategoryWidth) && void 0 !== _b ? _b : null,
                    domain: null === (_d = cartesianAxisHelper.createDomain(this.data.series, cartesianAxisHelper.getCategoryValueType(null === (_c = this.data) || void 0 === _c ? void 0 : _c.categoryMetadata), this.getVisualCategoryAxisIsScalar(), [ options.categoryAxisOptions.includeDomain ])) || void 0 === _d ? void 0 : _d.domain,
                    isScalar: this.getVisualCategoryAxisIsScalar(),
                    cartesianOptions: this.options,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow,
                    outerPaddingRatio: options.outerPaddingRatio,
                    innerPaddingRatio: options.innerPaddingRatio
                }) : (0, cartesianHelper.u8)(), data = this.adjustLayoutForScroll(this.data, initialCategoryCount, options.trimOrdinalDataOnOverflow, categoryLayout), seriesData = data.series, dataIsForY2 = !1, valuesMetadata = this.data.valuesMetadata;
                if (_.some(seriesData, function(s) {
                    return s.isY2;
                })) {
                    var filteredData = LineChart.getDataForValueAxis(data, dataIsForY2 = options.roleName === lineChartRoles.R.Y2);
                    seriesData = filteredData.seriesData, valuesMetadata = filteredData.valuesMetadata;
                }
                var xMetaDataColumn = !_.isEmpty(data.series) && data.series[0].xCol, yMetaDataColumn = !_.isEmpty(seriesData) && seriesData[0].yCol, axesDomains = this.getAxesDomains(!1, {
                    categoryAxis: !0,
                    valueAxis: !dataIsForY2,
                    secondaryValueAxis: dataIsForY2
                }), axisFormatString = cartesianAxisHelper.getAxisFormatString(seriesData), valueAxisDomainOptions = cartesianAxisHelper.createScalarDomainOptions(dataIsForY2 ? axesDomains.secondaryValueAxis : axesDomains.valueAxis, 0);
                valueAxisDomainOptions = cartesianAxisHelper.mergeScalarAxisDomains(valueAxisOptions.includeDomain, valueAxisDomainOptions);
                var categoryAxisDomainOptions = data.isScalar ? cartesianAxisHelper.mergeScalarAxisDomains(cartesianAxisHelper.createScalarDomainOptions(axesDomains.categoryAxis, 0), categoryAxisOptions.includeDomain) : this.getCategoryDomain(data), preferredPlotArea = this.getPreferredPlotArea(categoryLayout), getDefaultAxisOptions = function(axisType) {
                    var _a, isXAxis = "x" === axisType, isYAxis = "y" === axisType, axisOptions = isXAxis ? categoryAxisOptions : valueAxisOptions;
                    return {
                        pixelSpan: isXAxis ? preferredPlotArea.width : preferredPlotArea.height,
                        domainOptions: isXAxis ? categoryAxisDomainOptions : valueAxisDomainOptions,
                        metaDataColumn: isXAxis ? xMetaDataColumn : valuesMetadata,
                        axisZoom: options.axisZoom,
                        isScalar: isYAxis || data.isScalar,
                        isVertical: isYAxis,
                        isCategoryAxis: isXAxis,
                        forcedTickCount: options.forcedTickCount,
                        axis: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axisOptions.axis), {
                            invertAxis: axisOptions.axis.invertAxis && (isYAxis || data.isScalar)
                        }),
                        useTickIntervalForDisplayUnits: !0,
                        margin: _this.margin,
                        includeZero: !!isYAxis && _this.isStacked && (null === (_a = _this.data) || void 0 === _a ? void 0 : _a.series.length) > 1 && cartesianAxisHelper.shouldIncludeZero(axisOptions.includeDomain),
                        zeroScalarDomain: LineChart.DefaultZeroScalarDomain,
                        formatString: isXAxis ? (0, valueFormatter.EO)(xMetaDataColumn, formatStringProp) : _this.isStacked100 ? _this.hostService.getLocalizedString("Percentage") : null != axisFormatString ? axisFormatString : (0, 
                        valueFormatter.EO)(yMetaDataColumn, formatStringProp),
                        outerPadding: isXAxis && data.isScalar ? LineChart.ScalarOuterPadding : 0,
                        outerPaddingRatio: isXAxis ? categoryLayout.outerPaddingRatio : 0,
                        categoryThickness: isXAxis ? categoryLayout.categoryThickness : void 0,
                        allowSingleScalarTick: !!isXAxis && data.isScalar,
                        maxTickCount: isXAxis ? data.scalarKeyCount : void 0,
                        preventNice: isXAxis ? !!data.isScalar && cartesianAxisHelper.hasForcedDomain(categoryAxisDomainOptions) : cartesianAxisHelper.hasForcedDomain(valueAxisDomainOptions),
                        shouldClamp: !isYAxis && void 0,
                        isSecValueAxis: isYAxis ? dataIsForY2 || _this.isComboChart : void 0,
                        is100Pct: isYAxis && _this.isStacked100,
                        getValueFn: isXAxis ? function(index, type) {
                            return (0, cartesianHelper.dZ)(data, index, type, data.isScalar);
                        } : void 0
                    };
                }, yAxisProperties = cartesianAxisHelper.createAxis(getDefaultAxisOptions("y")), shouldAdjustForStackedTotals = !1, maxMarkerRadius = 0, shouldAdjustForAnomalyMarkers = !1;
                if (yAxisProperties.dataDomain && _.isNumber(yAxisProperties.dataDomain[0]) && _.isNumber(yAxisProperties.dataDomain[1]) && (shouldAdjustForStackedTotals = (null === (_e = data.totalLabelsSettings) || void 0 === _e ? void 0 : _e.show) && this.supportsTotalLabels(), 
                maxMarkerRadius = LineChart.getMaximumMarkerSize(data.series), shouldAdjustForAnomalyMarkers = _.some(data.anomalyDetections, function(ad) {
                    return -1 !== ad.highestAnomalyPointIndex || -1 !== ad.lowestAnomalyPointIndex;
                })), shouldAdjustForStackedTotals || maxMarkerRadius || shouldAdjustForAnomalyMarkers) {
                    debug.fF.assert(function() {
                        return !!yAxisProperties.dataDomain && _.isNumber(yAxisProperties.dataDomain[0]) && _.isNumber(yAxisProperties.dataDomain[1]);
                    });
                    var adjustedDomain_1 = [ Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY ], madeAdjustment_1 = !1, setAdjustedDomain = function(domain) {
                        adjustedDomain_1 = [ Math.min(adjustedDomain_1[0], domain[0]), Math.max(adjustedDomain_1[1], domain[1]) ], 
                        madeAdjustment_1 = !0;
                    };
                    if (shouldAdjustForStackedTotals) {
                        var adjustedDomainForLabelsResult = LineChart.adjustDomainForLabels(yAxisProperties, data);
                        adjustedDomainForLabelsResult.adjusted && setAdjustedDomain(adjustedDomainForLabelsResult.domain);
                    }
                    if (maxMarkerRadius) {
                        var adjustedDomainForMarkersResult = LineChart.adjustDomainCommon(yAxisProperties, maxMarkerRadius);
                        adjustedDomainForMarkersResult.adjusted && setAdjustedDomain(adjustedDomainForMarkersResult.domain);
                    }
                    shouldAdjustForAnomalyMarkers && setAdjustedDomain((0, anomalyDetectionVisualPlugin.LS)(yAxisProperties.dataDomain, yAxisProperties.scale, data.anomalyDetections)), 
                    madeAdjustment_1 && (yAxisProperties = cartesianAxisHelper.createAxis((0, tslib_es6.__assign)((0, 
                    tslib_es6.__assign)({}, getDefaultAxisOptions("y")), {
                        domainOptions: cartesianAxisHelper.mergeScalarAxisDomains(valueAxisOptions.includeDomain, valueAxisDomainOptions, cartesianAxisHelper.createScalarDomainOptions(adjustedDomain_1, 0)),
                        preventNice: !0
                    })));
                }
                dataIsForY2 ? this.y2AxisProperties = yAxisProperties : this.yAxisProperties = yAxisProperties;
                var xAxisProperties = cartesianAxisHelper.createAxis(getDefaultAxisOptions("x"));
                return this.interactivityService && !this.data.isScalar && (xAxisProperties.categoryIdentities = _.map(data.categoryIdentities, function(categoryIdentity) {
                    return function() {
                        return categoryIdentity;
                    };
                })), [ xAxisProperties, yAxisProperties ];
            }, LineChart.prototype.getCategoryValueType = function() {
                return cartesianAxisHelper.getCategoryValueType(this.data.scalarMetadata || this.data.categoryMetadata);
            }, LineChart.getDataForValueAxis = function(data, isSecondaryValueAxis) {
                var valuesMetadata = data.valuesMetadata, filterRole = isSecondaryValueAxis ? {
                    roles: {
                        Y2: !0
                    }
                } : {
                    roles: {
                        Y: !0
                    }
                };
                return {
                    seriesData: _.filter(data.series, function(s) {
                        return s.isY2 === isSecondaryValueAxis;
                    }),
                    valuesMetadata: _.filter(valuesMetadata, filterRole)
                };
            }, LineChart.prototype.adjustLayoutForScroll = function(data, initialCategoryCount, trimOrdinalDataOnOverflow, chartLayout) {
                if (this.clippedData = void 0, data && !data.isScalar && !this.options.isScrollable && trimOrdinalDataOnOverflow) {
                    var categoryCount = Math.min(initialCategoryCount, chartLayout.categoryCount);
                    initialCategoryCount !== categoryCount && ((data = this.clippedData = (0, Prototype.ED)(data)).series = LineChart.sliceSeries(data.series, 0, categoryCount), 
                    data.categories = data.categories.slice(0, categoryCount), data.categoryIdentities && (data.categoryIdentities = data.categoryIdentities.slice(0, categoryCount)));
                }
                return data;
            }, LineChart.prototype.setAxesLayout = function(options) {
                this.updateCurrentViewport(options.layout), this.xAxisProperties = options.layout.axes.x, 
                2 & options.axisType && (this.isComboChart ? this.yAxisProperties = options.layout.axes.y2 : this.y2AxisProperties = options.layout.axes.y2), 
                1 & options.axisType && (this.yAxisProperties = options.layout.axes.y1);
                var chartLayout = this.data ? {
                    categoryCount: this.xAxisProperties.values.length,
                    categoryThickness: this.xAxisProperties.categoryThickness,
                    outerPaddingRatio: this.xAxisProperties.outerPaddingRatio,
                    innerPaddingRatio: this.xAxisProperties.innerPaddingRatio,
                    isScalar: this.getVisualCategoryAxisIsScalar()
                } : (0, cartesianHelper.u8)();
                this.data = this.adjustLayoutForScroll(this.data, LineChart.getCategoryCount(this.data), options.trimOrdinalDataOnOverflow, chartLayout);
            }, LineChart.adjustDomainForLabels = function(axisProperties, data) {
                var formatString = LineChart.getCategoryCount(data) ? data.series[0].data[0].labelFormatString : "", formattersCache = (0, 
                dataLabelViewModel1.fI)(), labelUnitsAndPrecision = (0, dataLabelRendererEnhanced.d6)(axisProperties, data.totalLabelsSettings), formatter = formattersCache.getOrCreate(formatString, data.totalLabelsSettings, labelUnitsAndPrecision.units, data.totalLabelsSettings.precision), sampleString = axisProperties.dataDomain[0].toString(), sampleText = (0, 
                dataLabelRendererEnhanced.Bw)(formatter.format(sampleString)), textProperties = (0, 
                common_fontProperties.qk)(data.totalLabelsSettings.fontProperties, sampleText), textPrimaryDimension = textMeasurementService.b.estimateSvgTextHeight(textProperties);
                return LineChart.adjustDomainCommon(axisProperties, textPrimaryDimension + dataLabelViewModel1Consts.FJ);
            }, LineChart.getMaximumMarkerSize = function(allSeries) {
                return allSeries.length > 0 ? d3.max(allSeries, function(d) {
                    return d.lineStyle.markerProperties.show ? d.lineStyle.markerProperties.size : 0;
                }) * marker_renderer.Wo.sizeRatio : 0;
            }, LineChart.adjustDomainCommon = function(axisProperties, pixelOffset) {
                var dataDomain = axisProperties.dataDomain, axisDomain = axisProperties.scale.domain(), oldScale = axisProperties.scale, newPixelMin = oldScale(dataDomain[0]) + pixelOffset, newPixelMax = oldScale(dataDomain[1]) - pixelOffset, newDomainMin = oldScale.invert(newPixelMin), newDomainMax = oldScale.invert(newPixelMax);
                return cartesianAxisHelper.adjustDomainWithConstantPixelDifference(axisDomain[0], axisDomain[1], newDomainMin, newDomainMax);
            }, LineChart.prototype.getFormattingCards = function(formattingCardOptions) {
                return lineChart_formatter_getFormattingCards.call(this, formattingCardOptions);
            }, LineChart.prototype.getDisambiguationSubSelectables = function(subSelectionHelper, filterType) {
                return getDisambiguationSubSelectables.call(this, subSelectionHelper, filterType);
            }, LineChart.prototype.getSelectorsByColumnFromSubselectedElement = function(e) {
                return lineChart_formatter_getSelectorsByColumnFromSubselectedElement.call(this, e);
            }, LineChart.prototype.getSubSelectionCustomOutlines = function(subSelection) {
                return getSubSelectionCustomOutlines.call(this, subSelection);
            }, LineChart.prototype.getSubSelectionCustomElements = function(subSelection) {
                return getSubSelectionCustomElements.call(this, subSelection);
            }, LineChart.prototype.getSubSelectionStyles = function(subSelections) {
                return lineChart_formatter_getSubSelectionStyles.call(this, subSelections);
            }, LineChart.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                return lineChart_formatter_getSubSelectionShortcuts.call(this, subSelections, filter);
            }, LineChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                return enumerateObjectInstances.call(this, enumeration, options);
            }, LineChart.prototype.getDataViewObjectLayerChanges = function(propertySaveObjects, sourceType) {
                return lineChart_formatter_getDataViewObjectLayerChanges.call(this, propertySaveObjects, sourceType);
            }, LineChart.prototype.showSeriesCard = function() {
                return !(this.isComboChart && !this.data.hasY2Role);
            }, LineChart.prototype.supportsTotalLabels = function() {
                return !(this.data && this.data.multipleIdentity) && 16 === this.lineChartType;
            }, LineChart.prototype.supportsTrendLine = function() {
                return !this.data.multipleIdentity && !this.isStacked && this.getVisualCategoryAxisIsScalar() && this.data.hasValues && !(this.haveY2Data() && !this.isComboChart);
            }, LineChart.prototype.supportsStaticReferenceLines = function() {
                return this.getVisualCategoryAxisIsScalar();
            }, LineChart.prototype.supportsForecast = function() {
                return !this.data.multipleIdentity && !this.isStacked && this.getVisualCategoryAxisIsScalar() && this.data.hasValues && 1 === this.data.series.length && !this.hasLegend();
            }, LineChart.prototype.supportsAnomalyDetection = function() {
                return !this.data.multipleIdentity && this.featureSwitches.daxTransformEnabled && !this.isStacked && this.data.hasValues;
            }, LineChart.prototype.supportsPerCategoryMarker = function() {
                return !this.isComboChart;
            }, LineChart.prototype.shouldSuppressAnimation = function() {
                return !!this.suppressAnimation;
            }, LineChart.prototype.showLabelPerSeries = function() {
                var data = this.originalData;
                return data.series.length > 1 || !data.categoryMetadata || this.isComboChart;
            }, LineChart.prototype.getSeriesAxisProperties = function(series) {
                return series.isY2 ? this.y2AxisProperties : this.yAxisProperties;
            }, LineChart.prototype.render = function(suppressAnimations, _resizeMode, formatMode) {
                var _this = this, duration = this.suppressAnimation ? 0 : (0, animatorCommon.Mb)(this.animator, suppressAnimations), viewModel = this.viewModel;
                this.mainGraphicsPositionRect = this.mainGraphicsSVG.selectAll(PositionRectSelector.selector).data(function(d) {
                    return !_this.lineChartTooltipHelper.hoverLineTooltipOverlay && formatMode ? [ d ] : [];
                }).join("rect").attrs({
                    x: 0,
                    width: 0,
                    height: 0
                }).style("pointer-events", "none").classed(PositionRectSelector.class, !0), (0, 
                anomalyDetectionCartesianRenderer.WI)(this.data.anomalyDetections, this.mainGraphicsSVG, this.xAxisProperties.scale, this.yAxisProperties.scale, duration, this.hostService, this.isVisualInteractive), 
                this.anomalyNavigationHelper.update(hasAnomalies(this.data) ? this.data.anomalyDetections[0].anomalies : [], this.clippedData, this.focusedDatum, function(dataPoint) {
                    return updateFocusElement(viewModel, dataPoint);
                }, this.mainGraphicsContext);
                var result = function(viewModel, duration, formatMode) {
                    var _a, _b, _c, _d, renderContext = viewModel.renderContext, plotAreaHelper = viewModel.plotAreaHelper, lineChartTooltipHelper = viewModel.lineChartTooltipHelper, tooltipInteractivity = viewModel.tooltipInteractivity, markerRenderer = viewModel.markerRenderer, style = viewModel.style, hostService = viewModel.hostService, isStackedArea = viewModel.isStackedArea, isStacked100 = viewModel.isStacked100, viewport = viewModel.currentViewport, interactivityService = viewModel.interactivityService, mobileTileInteractive = viewModel.mobileTileInteractive, featureSwitches = viewModel.featureSwitches, isComboChart = viewModel.isComboChart, data = viewModel.activeData;
                    if (data) {
                        for (var isScalar = data.isScalar, seriesWithUncertainty = _.filter(data.series, function(series) {
                            var _a;
                            return null === (_a = series.uncertainty) || void 0 === _a ? void 0 : _a.renderUncertainty;
                        }), renderUncertainty = !_.isEmpty(seriesWithUncertainty), isAreaSubSelectable = !isComboChart, markerSettings = [], _i = 0, _e = data.series; _i < _e.length; _i++) markerSettings.push((series = _e[_i]).lineStyle.markerProperties);
                        renderUncertainty && (0, uncertainty_renderer.iD)(data.series, markerSettings), 
                        markerRenderer.ensureMarkers(renderContext.svgDefs, markerSettings);
                        var yScale = viewModel.yAxisProperties.scale, y2Scale = null === (_a = viewModel.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale, hasSelection = null == interactivityService ? void 0 : interactivityService.hasSelection(), seriesWithShadeAreas = _.filter(data.series, function(s) {
                            return s.lineStyle.areaShow;
                        }), renderAreas = seriesWithShadeAreas.length > 0;
                        (data.categories.length * data.series.length > animatorCommon.dt || browserUtils.M.isInternetExplorerOrEdge() && _.some(markerSettings, function(markerDefs) {
                            return markerDefs.show;
                        }) || renderAreas) && (duration = 0);
                        var xPosition = function(d) {
                            return getXPositionWithOffset(viewModel, d);
                        }, yPosition = function(d) {
                            return getYPosition(viewModel, d);
                        }, y0Position = isStackedArea ? function(d) {
                            return yScale(d.stackedValue - d.value);
                        } : function(d) {
                            return d.isY2 ? y2Scale(0) : yScale(0);
                        }, seriesLineGen = [];
                        _.forEach(data.series, function(series) {
                            seriesLineGen[series.index] = d3.line().x(xPosition).y(yPosition).defined(function(d) {
                                return isDataPointDefined(d);
                            }).curve((0, lineInterpolation.By)(series.lineStyle));
                        }), renderContext.mainGraphicsContext.attr("aria-label", "".concat(hostService.getLocalizedString("Visual_Plot"), " ").concat(hasAnomalies(data) ? hostService.getLocalizedString("Visual_Plot_ScreenReader_NavigateToAnomalies") : "").trim()), 
                        renderContext.mainGraphicsSVG.attr("height", viewModel.availableHeight).attr("width", viewModel.availableWidth);
                        var areasUpdate = renderContext.mainGraphicsContext.selectAll(CategoryAreaSelector.selector).data(seriesWithShadeAreas, function(d) {
                            return d.identity.getKey();
                        }).join(function(enter) {
                            return enter.append("path").classed(CategoryAreaSelector.class, !0);
                        }).style("fill", function(d) {
                            return style.isHighContrast ? common_colorHelper.v.getThemeColor(style, colorHelper.U) : d.lineStyle.areaColor;
                        }).style("pointer-events", formatMode && isAreaSubSelectable ? "auto" : null).classed(htmlSubSelectionHelper.cy, isAreaSubSelectable).attr(htmlSubSelectionHelper.Ez, "area").attr(htmlSubSelectionHelper.QZ, 3).each(function(d) {
                            htmlSubSelectionHelper.O5.setDataForElement(this, {
                                getDisplayName: function() {
                                    return hostService.getLocalizedString("MiniToolbar_Area", d.displayName);
                                },
                                getRegionOutlines: function() {
                                    for (var _a, _b = renderContext.mainGraphicsSVG.node().getBoundingClientRect(), left = _b.left, top = _b.top, clipPath = {
                                        type: 1,
                                        x: _b.x,
                                        y: _b.y,
                                        height: _b.height,
                                        width: _b.width
                                    }, scale = viewport.scale, yScaleRange = yScale.range(), yScaleRangeMin = _.min(yScaleRange), yScaleRangeMax = _.max(yScaleRange), outlines = [], definedDataArray = function(data) {
                                        for (var dataLength = data.length, result = [], temp = [], i = 0; i < dataLength; i++) {
                                            var currentDataPoint = data[i];
                                            isDataPointDefined(currentDataPoint) ? (temp.push(currentDataPoint), i === dataLength - 1 && result.push(temp)) : temp.length > 0 && (result.push(temp), 
                                            temp = []);
                                        }
                                        return result;
                                    }(d.data), _loop_1 = function(definedData) {
                                        var toplineDataPoints = definedData.map(function(lineChartDataPoint) {
                                            return {
                                                x: Mockable.convertSvgXToClientX(xPosition(lineChartDataPoint), scale, left),
                                                y: Mockable.convertSvgYToClientY(yPosition(lineChartDataPoint), scale, top)
                                            };
                                        }), baselineDataPoints = [];
                                        toplineDataPoints.forEach(function(point, i) {
                                            var svgY = _.clamp(y0Position(definedData[i]), yScaleRangeMin, yScaleRangeMax);
                                            baselineDataPoints.unshift({
                                                x: point.x,
                                                y: Mockable.convertSvgYToClientY(svgY, scale, top)
                                            });
                                        });
                                        var points = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], toplineDataPoints, !0), baselineDataPoints, !0);
                                        outlines.push({
                                            type: 3,
                                            points,
                                            clipPath
                                        });
                                    }, _i = 0, definedDataArray_1 = definedDataArray; _i < definedDataArray_1.length; _i++) _loop_1(definedDataArray_1[_i]);
                                    return [ {
                                        id: "".concat("area", "-").concat(d.index).concat(null !== (_a = viewModel.data.multipleDisplayName) && void 0 !== _a ? _a : ""),
                                        outline: {
                                            type: 0,
                                            outlines
                                        }
                                    } ];
                                }
                            });
                        }).interrupt();
                        if ((duration ? areasUpdate.transition().ease(d3.easeLinear).duration(duration) : areasUpdate).attr("d", function(d) {
                            return d3.area().x(xPosition).y0(y0Position).y1(yPosition).defined(function(dP) {
                                return isDataPointDefined(dP);
                            }).curve((0, lineInterpolation.By)(d.lineStyle))(d.data);
                        }), renderUncertainty) {
                            var uncertaintyGroup = (0, uncertainty_renderer.B9)(renderContext.mainGraphicsContext), uncertaintyArea = d3.area().x(xPosition).y0(function(d) {
                                return null != d.uncertainty.lower ? getUncertaintyLowerYPosition(viewModel, d) : yPosition(d);
                            }).y1(function(d) {
                                return null != d.uncertainty.upper ? getUncertaintyUpperYPosition(viewModel, d) : yPosition(d);
                            }).defined(function(d) {
                                var _a, _b;
                                return null != (null === (_a = null == d ? void 0 : d.uncertainty) || void 0 === _a ? void 0 : _a.upper) || null != (null === (_b = null == d ? void 0 : d.uncertainty) || void 0 === _b ? void 0 : _b.lower);
                            }), uncertaintyLineLower = d3.line().x(xPosition).y(function(d) {
                                return getUncertaintyLowerYPosition(viewModel, d);
                            }).defined(function(d) {
                                var _a;
                                return null != (null === (_a = null == d ? void 0 : d.uncertainty) || void 0 === _a ? void 0 : _a.lower);
                            }), uncertaintyLineUpper = d3.line().x(xPosition).y(function(d) {
                                return getUncertaintyUpperYPosition(viewModel, d);
                            }).defined(function(d) {
                                var _a;
                                return null != (null === (_a = null == d ? void 0 : d.uncertainty) || void 0 === _a ? void 0 : _a.upper);
                            });
                            (0, uncertainty_renderer.EC)(uncertaintyGroup, seriesWithUncertainty, uncertaintyLineUpper, uncertaintyLineLower, uncertaintyArea, function(d, baseTransparency) {
                                return (0, renderUtil.eR)(d.selected, !1, hasSelection, !1, (0, color.TD)(baseTransparency));
                            }), (0, uncertainty_renderer.FZ)(uncertaintyGroup, seriesWithUncertainty, function(d) {
                                return d.isY2 ? y2Scale : yScale;
                            }, function(d) {
                                return "translate(".concat(xPosition(d), ", ").concat(d.isY2 ? y2Scale(d.value) : yScale(d.value), ")");
                            }, 10), (0, uncertainty_renderer.di)(uncertaintyGroup, seriesWithUncertainty, uncertaintyLineUpper, uncertaintyLineLower, yScale.range()[1] > yScale.range()[0], markerRenderer), 
                            (0, uncertainty_renderer.DI)(uncertaintyGroup);
                        } else (0, uncertainty_renderer.OY)(renderContext.mainGraphicsContext);
                        var linesUpdate = renderContext.mainGraphicsContext.selectAll(LineClassSelector.selector).data(_.filter(data.series, function(s) {
                            return s.lineStyle.strokeShow;
                        }), function(d) {
                            return d.identity.getKey();
                        }).join(function(enter) {
                            return enter.append("path").classed(LineClassSelector.class, !0);
                        }).styles(function(d) {
                            return (0, common_strokeStyle.bc)(d.lineStyle, style);
                        }).interrupt();
                        (duration ? linesUpdate.transition().ease(d3.easeLinear).duration(duration) : linesUpdate).attr("d", function(d) {
                            return seriesLineGen[d.index](d.data);
                        });
                        var interactivityLinesUpdate, markerPathsUpdate = renderContext.mainGraphicsContext.selectAll(MarkerLineClassSelector.selector).data(_.filter(data.series, function(series) {
                            return series.lineStyle.markerProperties.show;
                        }), function(d) {
                            return d.identity.getKey();
                        }).join(function(enter) {
                            return enter.append("path").classed(MarkerLineClassSelector.class, !0);
                        }).style("stroke", "#ffffff").style("stroke-width", 2).style("stroke-opacity", 0).attrs({
                            "marker-start": function(d) {
                                return markerRenderer.getMarkerKey(d.lineStyle.markerProperties);
                            },
                            "marker-mid": function(d) {
                                return markerRenderer.getMarkerKey(d.lineStyle.markerProperties);
                            },
                            "marker-end": function(d) {
                                return markerRenderer.getMarkerKey(d.lineStyle.markerProperties);
                            }
                        }).interrupt(), markerLineGen = d3.line().x(xPosition).y(yPosition).defined(function(d) {
                            return isDataPointDefined(d) && (!featureSwitches.lineChartMarkerRendering || !d.marker.perCategoryStyle);
                        });
                        (duration ? markerPathsUpdate.transition().ease(d3.easeLinear).duration(duration) : markerPathsUpdate).attr("d", function(d) {
                            return markerLineGen(d.data);
                        }).style("opacity", function(d) {
                            return (0, renderUtil.eR)(d.selected, !1, hasSelection, !1);
                        }).style("pointer-events", "none"), mobileTileInteractive || (interactivityLinesUpdate = renderContext.mainGraphicsContext.selectAll(InteractivityLineClassSelector.selector).data(_.filter(data.series, function(s) {
                            return getLeftmostPathPointFromSeriesData(s);
                        }), function(d) {
                            return d.identity.getKey();
                        }).join(function(enter) {
                            return enter.append("path").classed(InteractivityLineClassSelector.class, !0).style("stroke-width", 10).style("stroke-linejoin", strokeLineJoin.t.round).attr(htmlSubSelectionHelper.Ez, "lines").attr(htmlSubSelectionHelper.Zx, "markers").attr(htmlSubSelectionHelper.QZ, 3).classed(htmlSubSelectionHelper.cy, !renderAreas || !isAreaSubSelectable);
                        }).attr("d", function(series) {
                            if (!isScalar) {
                                var firstPathPoint_1 = getLeftmostPathPointFromSeriesData(series);
                                if (firstPathPoint_1) {
                                    var sliceIndex = _.findIndex(series.data, function(dataPoint) {
                                        return dataPoint && dataPoint.categoryIndex === firstPathPoint_1.categoryIndex;
                                    });
                                    if (sliceIndex > 0 && sliceIndex < series.data.length) {
                                        var seriesDataThatAlwaysStartsWithALineSegment = series.data.slice(sliceIndex);
                                        return seriesLineGen[series.index](seriesDataThatAlwaysStartsWithALineSegment);
                                    }
                                }
                            }
                            return seriesLineGen[series.index](series.data);
                        }).each(function(d) {
                            htmlSubSelectionHelper.O5.setDataForElement(this, {
                                getDisplayName: function() {
                                    return hostService.getLocalizedString("MiniToolbar_Line", d.displayName);
                                },
                                getRegionOutlines: function() {
                                    return getMarkerOutlinesForSeries(d, viewModel);
                                }
                            });
                        }));
                        var dotGroupsUpdate = renderContext.mainGraphicsContext.selectAll(CategorySelector.selector).data(data.series, function(d) {
                            return d.identity.getKey();
                        }).join(function(enter) {
                            return enter.append("g").classed(CategorySelector.class, !0);
                        }), dotsUpdate = dotGroupsUpdate.selectAll(CategoryValuePoint.selector).data(function(series) {
                            return series.lineStyle.strokeShow ? series.data.filter(function(_dp, i) {
                                return function(d, i) {
                                    var current = d.data[i];
                                    if (null == current || null === current.value) return !1;
                                    var previous = d.data[i - 1], next = d.data[i + 1];
                                    return !(null != previous && null !== previous.value || null != next && null !== next.value);
                                }(series, i);
                            }) : [];
                        }, function(d) {
                            return d.key;
                        }).join(function(enter) {
                            return enter.append("circle").classed(CategoryValuePoint.class, !0).classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "lines").attr(htmlSubSelectionHelper.Zx, "markers").attr(htmlSubSelectionHelper.QZ, 3);
                        }).style("fill", function(d) {
                            return d.marker.color;
                        }).style("fill-opacity", function(d) {
                            return d.marker.show ? 0 : (0, renderUtil.eR)(d.selected, !1, hasSelection, !1, (0, 
                            color.TD)(d.marker.transparency));
                        }).each(function() {
                            var lineSeries = d3.select(this.parentNode).datum();
                            htmlSubSelectionHelper.O5.setDataForElement(this, {
                                getDisplayName: function() {
                                    return hostService.getLocalizedString("MiniToolbar_Line", lineSeries.displayName);
                                },
                                getRegionOutlines: function() {
                                    return getMarkerOutlinesForSeries(lineSeries, viewModel);
                                }
                            });
                        }), selectionSize = dotsUpdate.size(), endedTransitionCount = 0;
                        (duration ? dotsUpdate.transition().duration(duration) : dotsUpdate).attrs({
                            cx: function(d) {
                                return getXPositionWithOffset(viewModel, d);
                            },
                            cy: function(d) {
                                return getYPosition(viewModel, d);
                            },
                            r: getFocusOnlyMarkerRadius(data.lineStyle)
                        }).on("end", function() {
                            ++endedTransitionCount === selectionSize && finalizeIfInteractiveLegend();
                        }), duration || finalizeIfInteractiveLegend();
                        var explicitDotsUpdate = dotGroupsUpdate.selectAll(CategoryPointSelector.selector).data(function(series) {
                            return isComboChart ? [] : _.filter(series.data, function(d) {
                                return (null == d ? void 0 : d.marker.perCategoryStyle) && null != d.value;
                            });
                        }, function(d) {
                            return d.key;
                        }).join(function(enter) {
                            return enter.append("path").classed(CategoryPointSelector.class, !0).style("pointer-events", "none");
                        }).attrs({
                            transform: function(d) {
                                var scale = featureSwitches.lineChartMarkerRendering ? d.marker.size * marker_renderer.Wo.sizeRatio : 5;
                                return "translate(".concat(getXPositionWithOffset(viewModel, d), ", ").concat(getYPosition(viewModel, d), ") scale(").concat(2 * scale, ")");
                            },
                            d: function(_d2) {
                                return (0, marker_renderer.jM)(featureSwitches.lineChartMarkerRendering ? _d2.marker.shape : markerShape.ZO.circle, .5);
                            }
                        }).style("stroke-width", function(d) {
                            return featureSwitches.lineChartMarkerRendering ? 2 * (0, marker_renderer.F)(d.marker.shape) / 20 : 0;
                        });
                        (duration ? explicitDotsUpdate.transition().duration(duration) : explicitDotsUpdate).style("fill", function(d) {
                            return d.marker.color;
                        }).style("stroke", function(d) {
                            return d.marker.color;
                        });
                        var focusElement, renderSelectedPoints = function(viewModel) {
                            return function(hasSelection) {
                                var mainGraphicsContext = viewModel.renderContext.mainGraphicsContext, selectedDataPoints = _.flatten(_.map(viewModel.activeData.series, function(series) {
                                    return _.filter(series.data, function(datum) {
                                        return (null == datum ? void 0 : datum.selected) && null !== datum.value;
                                    });
                                })), selectedIndex = _.map(selectedDataPoints, function(selectedDatum) {
                                    return selectedDatum.seriesIndex;
                                }), selectedPointsUpdate = mainGraphicsContext.selectAll(SelectedMarkerLineClassSelector.selector).selectAll("path").data(selectedDataPoints, function(d) {
                                    return d.key;
                                }).join(function(enter) {
                                    return enter.append("path").attr("pointer-events", "none");
                                }).attr("d", function(d) {
                                    return d.marker.show ? (0, marker_renderer.jM)(d.marker.shape, d.marker.size * marker_renderer.Wo.sizeRatio) : (0, 
                                    marker_renderer.jM)(markerShape.ZO.circle, d.marker.focusOnlySize);
                                }).attr("transform", function(d) {
                                    return "translate(".concat(getXPositionWithOffset(viewModel, d), ",").concat(getYPosition(viewModel, d), ")");
                                }).style("stroke-width", function(d) {
                                    return (0, marker_renderer.F)(d.marker.shape);
                                }).style("stroke-opacity", 1).style("stroke", function(d) {
                                    return d.marker.focusOnlyColor;
                                }).style("fill", function(d) {
                                    return d.marker.focusOnlyColor;
                                }), entireSeriesSelected = [];
                                return mainGraphicsContext.selectAll(LineClassSelector.selector).each(function(d, index) {
                                    entireSeriesSelected[index] = d.selected, d.selected = selectedIndex.indexOf(d.index) > -1;
                                }).style("stroke-opacity", function(d, index) {
                                    return (0, renderUtil.eR)(d.selected, !1, hasSelection && !entireSeriesSelected[index], !1, (0, 
                                    color.TD)(d.lineStyle.strokeTransparency));
                                }), mainGraphicsContext.selectAll(CategoryAreaSelector.selector).style("fill-opacity", function(d) {
                                    return (0, renderUtil.eR)(d.selected, !1, hasSelection, !1, (0, color.TD)(d.lineStyle.areaTransparency));
                                }), mainGraphicsContext.selectAll(MarkerLineClassSelector.selector).style("opacity", (0, 
                                renderUtil.eR)(!1, !1, hasSelection, !1)), (0, uncertainty_renderer.fM)(mainGraphicsContext.select(uncertainty_renderer.jx.selector), function(d, baseTransparency) {
                                    return (0, renderUtil.eR)(d.selected || selectedIndex.indexOf(d.index) > -1, !1, hasSelection && !entireSeriesSelected[d.index], !1, null != baseTransparency ? (0, 
                                    color.TD)(baseTransparency) : void 0);
                                }), selectedPointsUpdate;
                            };
                        }(viewModel);
                        renderSelectedPoints(hasSelection), interactivityService && (focusElement = updateFocusElement(viewModel, viewModel.focusedDatum));
                        var labelDataPointGroups = [], labelDataPointSeriesGroups = [];
                        if ((null === (_b = data.dataLabelsSettings) || void 0 === _b ? void 0 : _b.show) && (labelDataPointGroups = labelDataPointGroups.concat(function(viewModel) {
                            var _a, formattersCache = (0, dataLabelRendererEnhanced.fI)(), unsortedLabelDataPointGroups = viewModel.activeData.series.map(function(currentSeries) {
                                var _a, _b, labelSettings = currentSeries.labelSettings || viewModel.data.dataLabelsSettings;
                                if (!labelSettings.show) return {
                                    labelDataPoints: [],
                                    maxNumberOfLabels: 0
                                };
                                var densityAtMax = 100 === labelSettings.labelDensity, numberOfLabelsToRender = (0, 
                                dataLabelRendererEnhanced.SS)(viewModel.currentViewport.width, labelSettings.labelDensity, 4, labelDataPointSorter.v.estimatedLabelWidth), maxNumberOfLabels = !densityAtMax && viewModel.data.isScalar ? numberOfLabelsToRender : currentSeries.data.length, currentAxisProperties = currentSeries.isY2 ? viewModel.y2AxisProperties : viewModel.yAxisProperties, labelDataPoints = currentSeries.data.map(function(cartesianDataPoint, categoryIndex) {
                                    if (null != cartesianDataPoint && null != cartesianDataPoint.value) {
                                        var labelDataPoint = function(viewModel, currentSeries, lineChartDataPoint, categoryIndex, valueLabelSettings, currentAxisProperties, formattersCache, isStacked100) {
                                            var _a, _b, _c, _d, parentShape, labelText, isStackedArea = viewModel.isStackedArea, style = viewModel.style, featureSwitches = viewModel.featureSwitches, fontProperties = valueLabelSettings.fontProperties, valueScale = currentSeries.isY2 ? null === (_a = viewModel.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale : viewModel.yAxisProperties.scale, labelFill = null !== (_b = lineChartDataPoint.labelFill) && void 0 !== _b ? _b : fontProperties.color, isParentRect = !1;
                                            (null == valueLabelSettings ? void 0 : valueLabelSettings.displayUnits) === dataLabelViewModel1Consts.In && (valueLabelSettings.precision = void 0);
                                            var labelUnitsAndPrecision = (0, dataLabelRendererEnhanced.d6)(currentAxisProperties, valueLabelSettings);
                                            if (null === (_c = lineChartDataPoint.dynamicLabelValue) || void 0 === _c ? void 0 : _c.enabled) labelText = (0, 
                                            dataLabelUtil.nU)(lineChartDataPoint.dynamicLabelValue, formattersCache, valueLabelSettings, labelUnitsAndPrecision, currentSeries, "Value"), 
                                            !featureSwitches.labelEnhancementsM0 && featureSwitches.measureDrivenDataLabels && "" === labelText && (labelText = void 0); else {
                                                var customFormatString = lineChartDataPoint.labelSettings.displayUnits === dataLabelViewModel1Consts.In ? lineChartDataPoint.labelSettings.valueCustomFormatString : void 0, formatString = isStacked100 && !featureSwitches.labelEnhancementsM0 ? dataLabelViewModel1Consts.L0 : null != customFormatString ? customFormatString : lineChartDataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, valueLabelSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!formatString, currentSeries.type)), value = lineChartDataPoint.value;
                                                isStacked100 && (value = lineChartDataPoint.originalValue), labelText = (0, dataLabelRendererEnhanced.Bw)(formatter.format(value));
                                            }
                                            var properties = (0, common_fontProperties.qk)(fontProperties, labelText);
                                            if (isStackedArea) {
                                                var bottomPos = Math.max(lineChartDataPoint.stackedValue - lineChartDataPoint.value, valueScale.domain()[0]), areaWidth = viewModel.currentViewport.width, validPositions = void 0;
                                                switch (null == valueLabelSettings ? void 0 : valueLabelSettings.position) {
                                                  case labelPosition1.h.insideCenter:
                                                    validPositions = [ 1 ];
                                                    break;

                                                  case labelPosition1.h.insideEnd:
                                                    validPositions = [ 4 ];
                                                    break;

                                                  default:
                                                    validPositions = [ 1, 4 ];
                                                }
                                                parentShape = {
                                                    rect: {
                                                        left: getXPositionWithOffset(viewModel, lineChartDataPoint) - areaWidth / 2,
                                                        top: valueScale(Math.max(lineChartDataPoint.stackedValue, lineChartDataPoint.stackedValue - lineChartDataPoint.value)),
                                                        width: areaWidth,
                                                        height: Math.abs(valueScale(lineChartDataPoint.stackedValue) - valueScale(bottomPos))
                                                    },
                                                    orientation: lineChartDataPoint.value >= 0 ? 1 : 2,
                                                    validPositions
                                                }, isParentRect = !0;
                                            } else {
                                                var markerProperties = currentSeries.lineStyle.markerProperties;
                                                switch (validPositions = void 0, null == valueLabelSettings ? void 0 : valueLabelSettings.position) {
                                                  case labelPosition1.h.above:
                                                    validPositions = [ 1 ];
                                                    break;

                                                  case labelPosition1.h.under:
                                                    validPositions = [ 2 ];
                                                    break;

                                                  default:
                                                    validPositions = 100 === valueLabelSettings.labelDensity ? [ 1 ] : function(series, categoryIndex) {
                                                        var data = series.data, currentValue = data[categoryIndex].value, previousValue = data[categoryIndex - 1] && data[categoryIndex - 1].value, nextValue = data[categoryIndex + 1] && data[categoryIndex + 1].value, previousRelativePosition = 1, nextRelativePosition = 1;
                                                        if (null == previousValue ? previousRelativePosition = 0 : previousValue > currentValue ? previousRelativePosition = 3 : previousValue < currentValue && (previousRelativePosition = 2), 
                                                        null === nextValue ? nextRelativePosition = 0 : nextValue > currentValue ? nextRelativePosition = 3 : nextValue < currentValue && (nextRelativePosition = 2), 
                                                        0 === categoryIndex) return 3 === nextRelativePosition ? [ 2, 1 ] : [ 1, 2 ];
                                                        if (categoryIndex === data.length - 1) return 3 === previousRelativePosition ? [ 2, 1 ] : [ 1, 2 ];
                                                        switch (previousRelativePosition) {
                                                          case 0:
                                                            switch (nextRelativePosition) {
                                                              case 0:
                                                                return [ 1, 2, 8, 4 ];

                                                              case 1:
                                                              case 2:
                                                                return [ 1, 2, 4, 8 ];

                                                              case 3:
                                                                return [ 2, 1, 4, 8 ];
                                                            }

                                                          case 1:
                                                            switch (nextRelativePosition) {
                                                              case 0:
                                                              case 1:
                                                              case 2:
                                                                return [ 1, 2, 8, 4 ];

                                                              case 3:
                                                                return [ 2, 1, 8, 4 ];
                                                            }

                                                          case 3:
                                                            switch (nextRelativePosition) {
                                                              case 0:
                                                              case 3:
                                                                return [ 2, 1, 8, 4 ];

                                                              case 1:
                                                                return [ 2, 1, 4, 8 ];

                                                              case 2:
                                                                return [ 1, 2, 8, 4 ];
                                                            }

                                                          case 2:
                                                            switch (nextRelativePosition) {
                                                              case 0:
                                                              case 3:
                                                              case 2:
                                                                return [ 1, 2, 8, 4 ];

                                                              case 1:
                                                                return [ 1, 2, 4, 8 ];
                                                            }
                                                        }
                                                    }(currentSeries, categoryIndex);
                                                }
                                                parentShape = {
                                                    point: {
                                                        x: getXPositionWithOffset(viewModel, lineChartDataPoint),
                                                        y: valueScale(lineChartDataPoint.value)
                                                    },
                                                    radius: markerProperties.show ? markerProperties.size : 0,
                                                    validPositions
                                                };
                                            }
                                            return {
                                                isPreferred: !1,
                                                text: labelText,
                                                textSize: {
                                                    width: textMeasurementService.b.measureSvgTextWidth(properties) + dataLabelViewModel1Consts.TS,
                                                    height: textMeasurementService.b.estimateSvgTextHeight(properties, !0)
                                                },
                                                outsideFill: null != labelFill ? labelFill : common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ),
                                                insideFill: labelFill && isStackedArea ? labelFill : common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl),
                                                parentType: isParentRect ? 1 : 0,
                                                parentShape,
                                                fontProperties,
                                                identity: lineChartDataPoint.identity,
                                                key: lineChartDataPoint.key,
                                                hasBackground: valueLabelSettings.enableBackground,
                                                backgroundColor: valueLabelSettings.backgroundColor,
                                                backgroundTransparency: valueLabelSettings.backgroundTransparency,
                                                transparency: valueLabelSettings.transparency,
                                                leaderLine: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, valueLabelSettings.leaderLine), {
                                                    strokeColor: null !== (_d = null == lineChartDataPoint ? void 0 : lineChartDataPoint.leaderLineColor) && void 0 !== _d ? _d : valueLabelSettings.leaderLine.strokeColor
                                                })
                                            };
                                        }(viewModel, currentSeries, cartesianDataPoint, categoryIndex, labelSettings, currentAxisProperties, formattersCache, viewModel.isStacked100);
                                        return cartesianDataPoint.labelDataPointContainerEnabled ? (0, dataLabelContainerUtils.U)({
                                            seriesName: currentSeries.displayName,
                                            labelDataPoint,
                                            enableValueDataLabel: labelSettings.enableValueDataLabel,
                                            valueShowBlankAs: labelSettings.showBlankAs,
                                            cartesianDataPoint,
                                            isStacked100: viewModel.isStacked100,
                                            percentOfTotal: cartesianDataPoint.value,
                                            formattersCache,
                                            currentSeries,
                                            currentAxisProperties,
                                            valueDataLabelSettings: labelSettings,
                                            getOutsideLabelFill: function(content) {
                                                var _a;
                                                return null !== (_a = content.labelFill) && void 0 !== _a ? _a : common_colorHelper.v.getThemeColor(viewModel.style, dataLabelViewModel1Consts.uQ);
                                            },
                                            getInsideLabelFill: function(content) {
                                                var _a;
                                                return content.labelFill && viewModel.isStackedArea ? null !== (_a = content.labelFill) && void 0 !== _a ? _a : content.labelSettings.fontProperties.color : common_colorHelper.v.getThemeColor(viewModel.style, dataLabelViewModel1Consts.pl);
                                            }
                                        }) : labelDataPoint;
                                    }
                                }).filter(function(dp) {
                                    return dp;
                                });
                                return {
                                    labelDataPoints,
                                    maxNumberOfLabels,
                                    enableLeaderLines: null == labelSettings ? void 0 : labelSettings.leaderLine.strokeShow,
                                    offset: {
                                        min: null !== (_a = null == labelSettings ? void 0 : labelSettings.minimumOffset) && void 0 !== _a ? _a : dataLabelViewModel1Consts.ki,
                                        max: null !== (_b = null == labelSettings ? void 0 : labelSettings.maximumOffset) && void 0 !== _b ? _b : dataLabelViewModel1Consts.wh
                                    }
                                };
                            });
                            return new labelDataPointSorter.v(unsortedLabelDataPointGroups, viewModel.activeData.series, viewModel.currentViewport, viewModel.yAxisProperties.scale, null === (_a = viewModel.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale).getSortedDataLabels();
                        }(viewModel))), null === (_c = data.seriesLabelSettings) || void 0 === _c ? void 0 : _c.show) {
                            var seriesLabelsOnRight = data.seriesLabelSettings.position === labelPosition2.M.right;
                            labelDataPointSeriesGroups = labelDataPointSeriesGroups.concat(function(viewModel, xPositionValue, seriesLabelsOnRight) {
                                var isStackedArea = viewModel.isStackedArea, isScalar = viewModel.data.isScalar, lineHeight = textMeasurementService.b.estimateSvgTextHeight(dataLabelViewModel1Consts.bN), xScaleDomainMin = viewModel.xAxisProperties.scale.domain()[0], xScaleDomainMax = viewModel.xAxisProperties.scale.domain()[1];
                                return viewModel.activeData.series.map(function(currentSeries) {
                                    var _a, labelSettings = currentSeries.seriesLabelSettings || viewModel.data.seriesLabelSettings;
                                    if (!(null == labelSettings ? void 0 : labelSettings.show)) return {
                                        labelDataPoints: [],
                                        maxNumberOfLabels: 0
                                    };
                                    var valueScale = currentSeries.isY2 ? null === (_a = viewModel.y2AxisProperties) || void 0 === _a ? void 0 : _a.scale : viewModel.yAxisProperties.scale, yScaleDomainMin = valueScale.domain()[0], yScaleDomainMax = valueScale.domain()[1], seriesFontSize = labelSettings ? labelSettings.fontProperties.size.px : 0, seriesWordWrap = !!labelSettings && !!labelSettings.wordWrap, maxHeight = viewModel.currentViewport.height - (seriesFontSize + lineHeight + (viewModel.currentViewport.height - lineHeight - seriesFontSize) / 2), seriesLabelDataPoints = [], addSeriesLabelDataPoint = function(dataPoint) {
                                        var _a;
                                        if (null != dataPoint) {
                                            var yPosition = isStackedArea ? dataPoint.stackedValue : dataPoint.value;
                                            if (null != yPosition && yPosition >= yScaleDomainMin && yPosition <= yScaleDomainMax) {
                                                var properties = (0, common_fontProperties.qk)(labelSettings.fontProperties, currentSeries.displayName);
                                                debug.fF.assertValue(dataPoint.value, "seriesLabels - createLabelDataPoint called on a dataPoint with no value"), 
                                                seriesLabelDataPoints.push({
                                                    identity: dataPoint.identity,
                                                    key: dataPoint.key,
                                                    isPreferred: !1,
                                                    text: currentSeries.displayName,
                                                    textSize: {
                                                        width: textMeasurementService.b.measureSvgTextWidth(properties),
                                                        height: textMeasurementService.b.estimateSvgTextHeight(properties, !0)
                                                    },
                                                    outsideFill: null !== (_a = labelSettings.seriesColor) && void 0 !== _a ? _a : common_colorHelper.v.getThemeColor(viewModel.style, dataLabelViewModel1Consts.uQ),
                                                    insideFill: labelSettings.seriesColor && isStackedArea ? labelSettings.seriesColor : common_colorHelper.v.getThemeColor(viewModel.style, dataLabelViewModel1Consts.pl),
                                                    parentType: 0,
                                                    parentShape: {
                                                        point: {
                                                            x: xPositionValue,
                                                            y: getYPosition(viewModel, dataPoint)
                                                        },
                                                        radius: currentSeries.lineStyle.markerProperties.show ? currentSeries.lineStyle.markerProperties.size : 0,
                                                        validPositions: [ 512 ]
                                                    },
                                                    fontProperties: labelSettings.fontProperties,
                                                    wordBreak: seriesWordWrap && (0, dataLabelRendererEnhanced.W1)(currentSeries.displayName, properties, viewModel.availableSeriesLabelWidth, maxHeight, void 0, !0, !0).length > 1,
                                                    hasBackground: labelSettings.enableBackground,
                                                    backgroundColor: labelSettings.backgroundColor,
                                                    backgroundTransparency: labelSettings.backgroundTransparency
                                                });
                                            }
                                        }
                                    }, dataPoints = currentSeries.data;
                                    if (!_.isEmpty(dataPoints) && currentSeries.displayName) {
                                        var seriesRepresentativeDataPoint = seriesLabelsOnRight ? _.last(_.compact(dataPoints)) : _.first(_.compact(dataPoints));
                                        if (isScalar) {
                                            for (var categoryIndex = 0; categoryIndex < dataPoints.length; categoryIndex++) {
                                                var dataPoint = dataPoints[categoryIndex];
                                                if (null != dataPoint && null != dataPoint.value && dataPoint) {
                                                    var dataPointXValue = getXValue(viewModel, dataPoint);
                                                    if (seriesLabelsOnRight ? dataPointXValue > xScaleDomainMax : dataPointXValue > xScaleDomainMin) {
                                                        var dataPointPosition = -1;
                                                        seriesLabelsOnRight && 0 <= categoryIndex - 1 ? dataPointPosition = categoryIndex - 1 : seriesLabelsOnRight || (dataPointPosition = categoryIndex), 
                                                        dataPointPosition >= 0 && addSeriesLabelDataPoint(dataPoints[dataPointPosition]);
                                                        break;
                                                    }
                                                }
                                            }
                                            categoryIndex === dataPoints.length && addSeriesLabelDataPoint(seriesRepresentativeDataPoint);
                                        } else addSeriesLabelDataPoint(seriesRepresentativeDataPoint);
                                    }
                                    return {
                                        labelDataPoints: seriesLabelDataPoints,
                                        maxNumberOfLabels: 1
                                    };
                                });
                            }(viewModel, seriesLabelsOnRight ? viewModel.availableWidth : 0, seriesLabelsOnRight));
                        }
                        (null === (_d = data.totalLabelsSettings) || void 0 === _d ? void 0 : _d.show) && isStackedArea && !isStacked100 && (labelDataPointGroups = labelDataPointGroups.concat(function(viewModel) {
                            var style = viewModel.style, metadataColumn = (0, cartesianHelper.GN)(viewModel.data.valuesMetadata), columnFormatString = (0, 
                            valueFormatter.EO)(metadataColumn, cartesian_capabilities.p.general.formatString), data = viewModel.activeData, formattersCache = (0, 
                            dataLabelRendererEnhanced.fI)(), labelSettings = data.totalLabelsSettings, labelUnitsAndPrecision = (0, 
                            dataLabelRendererEnhanced.d6)(viewModel.yAxisProperties, labelSettings), fontProperties = labelSettings.fontProperties, labelDataPoints = data.totals.filter(function(totalDataPoint) {
                                return 0 !== (null == totalDataPoint ? void 0 : totalDataPoint.net);
                            }).map(function(totalDataPoint) {
                                var _a, _b, _c, _d, total = totalDataPoint.net, formatter = formattersCache.getOrCreate(totalDataPoint.dynamicFormatString || columnFormatString, labelSettings, labelUnitsAndPrecision.units, labelSettings.precision), text = (0, 
                                dataLabelRendererEnhanced.Bw)(formatter.format(total)), textProperties = (0, common_fontProperties.qk)(fontProperties, text), position = total > 0 ? totalDataPoint.positive : totalDataPoint.negative, positioningDataPoint = {
                                    value: position,
                                    originalValue: void 0,
                                    stackedValue: position,
                                    categoryIndex: totalDataPoint.categoryIndex,
                                    categoryValue: totalDataPoint.categoryValue,
                                    labelSettings: void 0,
                                    key: void 0,
                                    identity: void 0,
                                    marker: void 0,
                                    seriesIndex: void 0,
                                    selected: !1
                                }, areaWidth = viewModel.currentViewport.width;
                                return {
                                    isPreferred: !1,
                                    text,
                                    textSize: {
                                        width: textMeasurementService.b.measureSvgTextWidth(textProperties),
                                        height: textMeasurementService.b.estimateSvgTextHeight(textProperties, !0)
                                    },
                                    outsideFill: null !== (_b = null !== (_a = totalDataPoint.labelFill) && void 0 !== _a ? _a : fontProperties.color) && void 0 !== _b ? _b : common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ),
                                    insideFill: null !== (_d = null !== (_c = totalDataPoint.labelFill) && void 0 !== _c ? _c : fontProperties.color) && void 0 !== _d ? _d : common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl),
                                    parentType: 1,
                                    parentShape: {
                                        rect: {
                                            left: getXPositionWithOffset(viewModel, positioningDataPoint) - areaWidth / 2,
                                            top: viewModel.yAxisProperties.scale(position),
                                            width: areaWidth,
                                            height: 0
                                        },
                                        orientation: total >= 0 ? 1 : 2,
                                        validPositions: [ 16 ]
                                    },
                                    identity: void 0,
                                    fontProperties,
                                    hasBackground: labelSettings.enableBackground,
                                    backgroundColor: labelSettings.backgroundColor,
                                    backgroundTransparency: labelSettings.backgroundTransparency,
                                    isTotal: !0
                                };
                            });
                            return [ {
                                labelDataPoints,
                                maxNumberOfLabels: data.totals.length
                            } ];
                        }(viewModel)));
                        var dataPointsToBind, behaviorOptions, anomaliesToBind, uncertaintyLabelSettings = _.map(_.filter(seriesWithUncertainty, function(series) {
                            return series.uncertainty.labels.show;
                        }), function(series) {
                            return series.uncertainty.labels;
                        });
                        if (uncertaintyLabelSettings && (labelDataPointGroups = labelDataPointGroups.concat(function(viewModel) {
                            var style = viewModel.style, hostServices = viewModel.hostService, seriesWithUncertaintyLabels = _.filter(viewModel.activeData.series, function(series) {
                                var _a, _b;
                                return (null === (_a = series.uncertainty) || void 0 === _a ? void 0 : _a.renderUncertainty) && (null === (_b = series.uncertainty) || void 0 === _b ? void 0 : _b.labels.show);
                            });
                            if (0 === seriesWithUncertaintyLabels.length) return [];
                            var formattersCache = (0, dataLabelRendererEnhanced.fI)();
                            return seriesWithUncertaintyLabels.map(function(currentSeries) {
                                var labelSettings = currentSeries.uncertainty.labels, fontProperties = labelSettings.fontProperties, currentAxisProperties = currentSeries.isY2 ? viewModel.y2AxisProperties : viewModel.yAxisProperties, labelUnitsAndPrecision = (0, 
                                dataLabelRendererEnhanced.d6)(currentAxisProperties, labelSettings), yScale = currentAxisProperties.scale, seriesLabelDataPoints = [];
                                return currentSeries.data.forEach(function(dataPoint) {
                                    if (null != dataPoint && null != dataPoint.value && null != dataPoint.uncertainty) {
                                        for (var uncertaintyLabels = [], errorFormattedUncertainty = (0, uncertainty_util.Ww)(dataPoint.value, dataPoint.uncertainty, labelSettings.errorFormat), errorFormattedData = [ errorFormattedUncertainty.lower, errorFormattedUncertainty.upper ], i = 0; i < 2; i++) {
                                            var formattedUncertainty = errorFormattedData[i], isUpper = 1 === i, uncertaintyDatum = isUpper ? dataPoint.uncertainty.upper : dataPoint.uncertainty.lower;
                                            if (null != uncertaintyDatum) {
                                                var text = void 0;
                                                if (labelSettings.errorFormat === errorFormat.K.relativePercentage) text = (0, uncertainty_util.O2)(formattedUncertainty, hostServices); else {
                                                    var formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!formatString, currentSeries.type));
                                                    text = (0, dataLabelRendererEnhanced.Bw)(formatter.format(formattedUncertainty));
                                                }
                                                debug.fF.assertValue(text, "label has no value -- lineChart.createUncertaintyLabels");
                                                var textProperties = (0, common_fontProperties.qk)(fontProperties, text);
                                                uncertaintyLabels.push({
                                                    isPreferred: !1,
                                                    text,
                                                    textSize: {
                                                        width: textMeasurementService.b.measureSvgTextWidth(textProperties) + dataLabelViewModel1Consts.TS,
                                                        height: textMeasurementService.b.estimateSvgTextHeight(textProperties, !0)
                                                    },
                                                    outsideFill: fontProperties.color ? fontProperties.color : common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ),
                                                    insideFill: fontProperties.color ? fontProperties.color : common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl),
                                                    parentType: 0,
                                                    parentShape: {
                                                        point: {
                                                            x: getXPositionWithOffset(viewModel, dataPoint),
                                                            y: yScale(uncertaintyDatum)
                                                        },
                                                        radius: 0,
                                                        validPositions: [ isUpper ? 1 : 2 ]
                                                    },
                                                    identity: void 0,
                                                    fontProperties,
                                                    hasBackground: labelSettings.enableBackground,
                                                    backgroundColor: labelSettings.backgroundColor,
                                                    backgroundTransparency: labelSettings.backgroundTransparency
                                                });
                                            }
                                        }
                                        _.isEmpty(uncertaintyLabels) || seriesLabelDataPoints.push.apply(seriesLabelDataPoints, uncertaintyLabels);
                                    }
                                }), {
                                    labelDataPoints: seriesLabelDataPoints,
                                    maxNumberOfLabels: 100
                                };
                            });
                        }(viewModel))), !mobileTileInteractive) {
                            var tooltipContext = {
                                availableHeight: viewModel.availableHeight,
                                availableWidth: viewModel.availableWidth,
                                isComboChart,
                                activeData: viewModel.activeData,
                                interactivityLines: interactivityLinesUpdate,
                                dots: dotsUpdate,
                                focusElement,
                                explicitDots: explicitDotsUpdate
                            };
                            lineChartTooltipHelper.removeTooltips(tooltipContext, tooltipInteractivity), viewModel.tooltipsEnabled && !formatMode && lineChartTooltipHelper.applyTooltips(tooltipContext, plotAreaHelper, tooltipInteractivity);
                        }
                        (0, d3Helper.LL)(renderContext.mainGraphicsContext, [ CategoryAreaSelector, uncertainty_renderer.jx, LineClassSelector, MarkerLineClassSelector, InteractivityLineClassSelector, CategorySelector, SelectedMarkerLineClassSelector, FocusElementSelector ]);
                        var selectableSeries = [];
                        if (viewModel.interactivityService && !mobileTileInteractive) {
                            dataPointsToBind = [];
                            for (var _f = 0, _g = viewModel.data.series; _f < _g.length; _f++) {
                                var series;
                                selectableSeries.push(series = _g[_f]);
                                var seriesDataPoints = _.filter(series.data, function(d) {
                                    return d;
                                });
                                dataPointsToBind.push.apply(dataPointsToBind, seriesDataPoints || []);
                            }
                            if (anomaliesToBind = [], hasAnomalies(data)) {
                                var anomalies = _.filter(data.anomalyDetections[0].anomalies, function(anomaly) {
                                    return anomaly.isAnomaly;
                                });
                                anomaliesToBind.push.apply(anomaliesToBind, anomalies || []);
                            }
                            behaviorOptions = {
                                interactivityLines: interactivityLinesUpdate,
                                root: renderContext.mainGraphicsContext,
                                focusMarker: focusElement,
                                selectedMarkersCallback: renderSelectedPoints,
                                dots: dotsUpdate,
                                areas: areasUpdate,
                                hoverLineTooltipOverlay: lineChartTooltipHelper.hoverLineTooltipOverlay,
                                isHoverLineTooltipActive: lineChartTooltipHelper.isHoverLineTooltipActive,
                                getCategoryIndex: function(seriesData, pointX, constrainToSeries) {
                                    return plotAreaHelper.getCategoryIndexFromSeriesAndPointX(seriesData, pointX, constrainToSeries = constrainToSeries && !lineChartTooltipHelper.isHoverLineTooltipActive);
                                },
                                categoryIdentities: data.categoryIdentities,
                                hitTester: new LineChartHitTester({
                                    dataPoints: dataPointsToBind,
                                    isComboChart,
                                    isScalar,
                                    hasCategories: data.categoryIdentities.length > 0
                                }),
                                onSelecting: hostService.onSelecting,
                                anomalies: renderContext.mainGraphicsSVG.selectAll(anomalyDetectionCartesianRenderer.ec.selector),
                                anomalyNavigationHelper: viewModel.anomalyNavigationHelper,
                                onLineSubSelection: function(seriesData, pointX, subSelectionHelper, d3Event, showUI) {
                                    !function(viewModel, d, pointX, subSelectionHelper, d3Event, showUI) {
                                        var _a, markerXPosition, objectName, displayNameRes, position = (0, interactivityUtils.bt)(), categoryIndex = viewModel.plotAreaHelper.getCategoryIndexFromSeriesAndPointX(d, pointX, !0);
                                        try {
                                            markerXPosition = function(chart, seriesData, categoryIndex) {
                                                var left = chart.renderContext.mainGraphicsSVG.node().getBoundingClientRect().left, matchingDataPoint = _.find(seriesData.data, function(dataPoint) {
                                                    return dataPoint && dataPoint.categoryIndex === categoryIndex;
                                                });
                                                return Math.floor(getMarkerXPositionCalc(chart, matchingDataPoint, left));
                                            }(viewModel, d, categoryIndex);
                                        } catch (_error) {
                                            return void debug.fF.assertFail("Could not find data for categoryIndex in seriesData - getMarkerXPosition");
                                        }
                                        d.lineStyle.markerProperties.show && Math.abs(markerXPosition - position.x) <= d.lineStyle.markerProperties.size / 2 ? (objectName = "markers", 
                                        displayNameRes = "MiniToolbar_Markers") : (objectName = "lines", displayNameRes = "MiniToolbar_Line");
                                        var visualSubSelection = subSelectionHelper.createVisualSubSelectionForSingleObject({
                                            objectName,
                                            subSelectionType: 3,
                                            displayName: viewModel.hostService.getLocalizedString(displayNameRes, d.displayName),
                                            showUI,
                                            selectorsByColumn: null === (_a = d.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn(),
                                            selectionOrigin: {
                                                x: d3Event.clientX,
                                                y: d3Event.clientY
                                            }
                                        });
                                        subSelectionHelper.subSelect(visualSubSelection);
                                    }(viewModel, seriesData, pointX, subSelectionHelper, d3Event, showUI);
                                },
                                onDotSubSelection: function(seriesData, subSelectionHelper, d3Event, showUI) {
                                    !function(viewModel, d, subSelectionHelper, d3Event, showUI) {
                                        var _a, objectName, displayNameRes;
                                        d.lineStyle.markerProperties.show ? (objectName = "markers", displayNameRes = "MiniToolbar_Markers") : (objectName = "lines", 
                                        displayNameRes = "MiniToolbar_Line");
                                        var visualSubSelection = subSelectionHelper.createVisualSubSelectionForSingleObject({
                                            objectName,
                                            subSelectionType: 3,
                                            displayName: viewModel.hostService.getLocalizedString(displayNameRes, d.displayName),
                                            showUI,
                                            selectorsByColumn: null === (_a = d.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn(),
                                            selectionOrigin: {
                                                x: d3Event.clientX,
                                                y: d3Event.clientY
                                            }
                                        });
                                        subSelectionHelper.subSelect(visualSubSelection);
                                    }(viewModel, seriesData, subSelectionHelper, d3Event, showUI);
                                },
                                onAreaPointerMove: function(d3Event) {
                                    !function(viewModel, d3Event) {
                                        var eventCopy = new MouseEvent("pointerover", d3Event), areaElement = lineChart_renderer_Mockable_findSubSelectedAreaElement(viewModel, {
                                            x: d3Event.clientX,
                                            y: d3Event.clientY
                                        });
                                        null == areaElement || areaElement.dispatchEvent(eventCopy);
                                    }(viewModel, d3Event);
                                }
                            };
                        }
                        return {
                            dataPoints: dataPointsToBind ? (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], selectableSeries, !0), dataPointsToBind, !0) : void 0,
                            behaviorOptions: mobileTileInteractive ? void 0 : behaviorOptions,
                            labelDataPoints: mobileTileInteractive ? [] : null,
                            labelsAreNumeric: !mobileTileInteractive || null,
                            labelDataPointGroups,
                            labelDataPointSeriesGroups,
                            animateLabels: !1,
                            anomalies: anomaliesToBind,
                            navigationOptions: viewModel.navigationOptions
                        };
                    }
                    function finalizeIfInteractiveLegend() {
                        mobileTileInteractive && function(series) {
                            if (0 === series.length) return !1;
                            for (var i = 0, len = series.length; i < len; i++) if (series[i].data.length > 0) return !0;
                            return !1;
                        }(data.series) && tooltipInteractivity.selectColumn((0, cartesianHelper.Pg)(data.series), !0);
                    }
                }(viewModel, duration, formatMode);
                return (0, forecastHelper1.h8)(this.data.forecastLines, this.mainGraphicsSVG, this.xAxisProperties.scale, this.yAxisProperties.scale, duration), 
                (0, svgUtil.bL)(this.dataInitOptions), result;
            }, Object.defineProperty(LineChart.prototype, "navigationOptions", {
                get: function() {
                    if (this.interactivityService) return {
                        helper: this,
                        navigationStrategy: this.data.isScalar ? services_interactivityService.jN.SeriesFirst : services_interactivityService.jN.CategoryFirst
                    };
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChart.prototype, "viewModel", {
                get: function() {
                    var _a;
                    return {
                        currentViewport: this.currentViewport,
                        activeData: this.activeData,
                        data: this.data,
                        horizontalOffset: this.horizontalOffset,
                        isComboChart: this.isComboChart,
                        lineType: this.lineChartType,
                        margin: this.margin,
                        tooltipsEnabled: this.tooltipsEnabled,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        y2AxisProperties: this.y2AxisProperties,
                        focusedDatum: this.focusedDatum,
                        style: this.style,
                        renderContext: {
                            mainGraphicsSVG: this.mainGraphicsSVG,
                            mainGraphicsContext: this.mainGraphicsContext,
                            svgDefs: this.svgDefs,
                            mainGraphicsPositionOverlay: (null === (_a = this.lineChartTooltipHelper) || void 0 === _a ? void 0 : _a.hoverLineTooltipOverlay) || this.mainGraphicsPositionRect
                        },
                        isStackedArea: this.isStacked,
                        isStacked100: this.isStacked100,
                        availableWidth: this.availableWidth - this.availableSeriesLabelWidth,
                        availableHeight: this.availableHeight,
                        availableSeriesLabelWidth: this.availableSeriesLabelWidth,
                        hostService: this.hostService,
                        markerRenderer: this.markerRenderer,
                        interactivityService: this.interactivityService,
                        navigationOptions: this.navigationOptions,
                        lineChartTooltipHelper: this.lineChartTooltipHelper,
                        tooltipInteractivity: this,
                        plotAreaHelper: this,
                        anomalyNavigationHelper: this.anomalyNavigationHelper,
                        featureSwitches: this.featureSwitches,
                        mobileTileInteractive: this.mobileTileInteractive
                    };
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(LineChart.prototype, "availableSeriesLabelWidth", {
                get: function() {
                    return (0, seriesLabelViewModel.lr)(this.activeData.seriesLabelSettings, this.availableWidth);
                },
                enumerable: !1,
                configurable: !0
            }), LineChart.prototype.getFirstElement = function(categoryIndex, reverse) {
                var _a;
                if (void 0 === reverse && (reverse = !1), null != categoryIndex) {
                    var foundDataPoint_1, findFunc_1 = reverse ? _.findLast : _.find;
                    return findFunc_1(this.data.series, function(series) {
                        return foundDataPoint_1 = findFunc_1(series.data, function(dataPoint) {
                            return dataPoint && dataPoint.categoryIndex === categoryIndex && null != dataPoint.value;
                        });
                    }), foundDataPoint_1 && -1 === (null === (_a = this.clippedData) || void 0 === _a ? void 0 : _a.categories.indexOf(foundDataPoint_1.categoryValue)) ? {
                        element: null,
                        targetCategoryIndex: foundDataPoint_1.categoryIndex,
                        targetSeriesIndex: foundDataPoint_1.seriesIndex
                    } : foundDataPoint_1 ? (this.focusedDatum = foundDataPoint_1, {
                        element: updateFocusElement(this.viewModel, foundDataPoint_1).node(),
                        targetCategoryIndex: categoryIndex,
                        targetSeriesIndex: foundDataPoint_1.seriesIndex
                    }) : {
                        element: null,
                        targetCategoryIndex: categoryIndex,
                        targetSeriesIndex: reverse ? this.data.series.length - 1 : 0
                    };
                }
                return {
                    element: this.mainGraphicsContext.select(FocusElementSelector.selector).node()
                };
            }, LineChart.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var _a, nextDataPoint = this.focusedDatum;
                switch (direction) {
                  case services_interactivityService.x0.NextCategory:
                  case services_interactivityService.x0.PreviousCategory:
                    var currentSeries = this.data.series[seriesIndex];
                    if (currentSeries) {
                        var seriesEntries = currentSeries.data, nextCategoryIndex = _.findIndex(seriesEntries, function(dataPoint) {
                            return dataPoint && dataPoint.categoryIndex === categoryIndex;
                        });
                        nextDataPoint = this.pickNextAvailableIndex(seriesEntries, nextCategoryIndex, seriesIndex, direction);
                    } else nextDataPoint = void 0;
                    break;

                  case services_interactivityService.x0.NextSeries:
                  case services_interactivityService.x0.PreviousSeries:
                    var categoryEntries = _.map(this.data.series, function(series) {
                        return _.find(series.data, function(dataPoint) {
                            return dataPoint && dataPoint.categoryIndex === categoryIndex;
                        });
                    });
                    nextDataPoint = this.pickNextAvailableIndex(categoryEntries, seriesIndex, categoryIndex, direction);
                    break;

                  default:
                    debug.fF.assertNever(direction);
                }
                if (!nextDataPoint) {
                    var incrementor = direction === services_interactivityService.x0.NextSeries || direction === services_interactivityService.x0.NextCategory ? 1 : -1;
                    categoryIndex = LineChart.incrementIndex(categoryIndex, incrementor, this.data.categories.length);
                    var targetSeriesIndex = seriesIndex;
                    return direction !== services_interactivityService.x0.NextSeries && direction !== services_interactivityService.x0.PreviousSeries || (targetSeriesIndex = incrementor < 0 ? this.data.series.length - 1 : 0), 
                    {
                        element: null,
                        targetCategoryIndex: categoryIndex,
                        targetSeriesIndex
                    };
                }
                return -1 === (null === (_a = this.clippedData) || void 0 === _a ? void 0 : _a.categories.indexOf(nextDataPoint.categoryValue)) ? {
                    element: null,
                    targetCategoryIndex: nextDataPoint.categoryIndex,
                    targetSeriesIndex: nextDataPoint.seriesIndex
                } : (this.focusedDatum = nextDataPoint, {
                    element: updateFocusElement(this.viewModel, nextDataPoint).node(),
                    targetCategoryIndex: nextDataPoint.categoryIndex,
                    targetSeriesIndex: nextDataPoint.seriesIndex
                });
            }, LineChart.prototype.pickNextAvailableIndex = function(thisDataGroup, startingIndex, orthogonalIndex, direction) {
                var rollFunc = direction === services_interactivityService.x0.NextCategory || direction === services_interactivityService.x0.PreviousCategory ? this.rollToNextSeries : this.rollToNextCategory, incrementor = direction === services_interactivityService.x0.NextSeries || direction === services_interactivityService.x0.NextCategory ? 1 : -1, nextIndex = startingIndex;
                do {
                    if ((nextIndex += incrementor) >= thisDataGroup.length || nextIndex < 0) return rollFunc.call(this, orthogonalIndex, direction);
                    if (nextIndex === startingIndex) break;
                } while (!thisDataGroup[nextIndex] || null == thisDataGroup[nextIndex].value);
                if (null != thisDataGroup[nextIndex].value) return thisDataGroup[nextIndex];
            }, LineChart.prototype.rollToNextSeries = function(seriesIndex, direction) {
                debug.fF.assert(function() {
                    return direction === services_interactivityService.x0.PreviousCategory || direction === services_interactivityService.x0.NextCategory;
                }, "expected a direction having to do with category");
                var findFunc = direction === services_interactivityService.x0.PreviousCategory ? _.findLast : _.find;
                return seriesIndex = LineChart.incrementIndex(seriesIndex, direction === services_interactivityService.x0.PreviousCategory ? -1 : 1, this.data.series.length), 
                findFunc(this.data.series[seriesIndex].data, function(dataPoint) {
                    return dataPoint && null != dataPoint.value;
                });
            }, LineChart.prototype.rollToNextCategory = function(categoryIndex, direction) {
                debug.fF.assert(function() {
                    return direction === services_interactivityService.x0.PreviousSeries || direction === services_interactivityService.x0.NextSeries;
                }, "expected a direction having to do with series");
                var findFunc = direction === services_interactivityService.x0.PreviousSeries ? _.findLast : _.find;
                categoryIndex = LineChart.incrementIndex(categoryIndex, direction === services_interactivityService.x0.PreviousSeries ? -1 : 1, this.data.categories.length);
                var nextCategoryData = _.map(this.data.series, function(series) {
                    return _.find(series.data, function(dataPoint) {
                        return dataPoint && dataPoint.categoryIndex === categoryIndex;
                    });
                }), foundDataPoint = findFunc(nextCategoryData, function(dataPoint) {
                    return dataPoint && null != dataPoint.value;
                });
                return foundDataPoint || (foundDataPoint = findFunc(nextCategoryData, function(dataPoint) {
                    return !!dataPoint;
                })), foundDataPoint;
            }, LineChart.incrementIndex = function(index, incrementor, totalNum) {
                return (index += incrementor) >= totalNum ? index = 0 : index < 0 && (index = totalNum - 1), 
                index;
            }, LineChart.prototype.getTooltipInfoForPoint = function(tooltipEvent, pointX) {
                var _a, seriesData = tooltipEvent.data, categoryIndex = this.getCategoryIndexFromSeriesAndPointX(seriesData, pointX, !0, tooltipEvent.context);
                if (null === (_a = null == seriesData ? void 0 : seriesData.data) || void 0 === _a ? void 0 : _a.length) {
                    var dataPointMatched = _.find(seriesData.data, function(dataPoint) {
                        return (null == dataPoint ? void 0 : dataPoint.categoryIndex) === categoryIndex;
                    });
                    if (dataPointMatched) return _.concat(dataPointMatched.tooltipInfo, dataPointMatched.additionalTooltipItems || []);
                }
            }, LineChart.isDataPointData = function(data) {
                return data && null != data.categoryIndex;
            }, LineChart.prototype.getCategoryIndexFromTooltipEvent = function(tooltipEvent, pointX) {
                var data = tooltipEvent.data;
                if (!isForecastPoint(data)) return LineChart.isDataPointData(data) ? data.categoryIndex : this.getCategoryIndexFromSeriesAndPointX(data, pointX, !1);
                debug.fF.assertFail("should not receive pointer events for forecast lines");
            }, LineChart.prototype.getCategoryIndexFromSeriesAndPointX = function(seriesData, pointX, constrainToSeries, interactivityLine) {
                var offsetX = 0, categoryData = this.data.categoryData, scale = this.xAxisProperties.scale;
                if (seriesData && !_.isEmpty(seriesData.data) && this.xAxisProperties) {
                    pointX = this.adjustPathXCoordinate(pointX, interactivityLine);
                    var firstPathPoint = getLeftmostPathPointFromSeriesData(seriesData, this.data.isScalar && scale.range()[1] < scale.range()[0]);
                    debug.fF.assertValue(firstPathPoint, "If there is data on the tooltipEvent but no categoryIndex, there should always be two consecutive non-null values"), 
                    firstPathPoint && (offsetX = getXPositionWithOffset(this.viewModel, firstPathPoint)), 
                    constrainToSeries && (categoryData = _.map(seriesData.data, function(dataPoint) {
                        return extractCategoryFromDataPoint(dataPoint, void 0);
                    }));
                }
                return LineChart.findCategoryIndex({
                    pointX,
                    offsetX,
                    categoryData,
                    currentViewport: this.currentViewport,
                    scale,
                    categoryThickness: this.xAxisProperties.categoryThickness,
                    isScalar: this.data.isScalar
                });
            }, LineChart.prototype.getYValueFromTooltipEvent = function(pointY, context) {
                var _a, _b, yPosInfo, y2PosInfo, yAxisScale = null === (_a = this.yAxisProperties) || void 0 === _a ? void 0 : _a.scale, y2AxisScale = null === (_b = this.y2AxisProperties) || void 0 === _b ? void 0 : _b.scale, yScale = this.currentViewport.scale;
                if ((0, Double.GG)(yScale, 1, 1e-5) || (pointY /= yScale), context.classList.contains(TooltipOverlaySelector.class) || context.classList.contains(LineChart.lineChartSVGClassName) || (pointY += context.getBBox().y), 
                yAxisScale) {
                    var scaleDomain = yAxisScale.domain();
                    yPosInfo = {
                        point: yAxisScale.invert(pointY),
                        threshold: .1 * (scaleDomain[1] - scaleDomain[0])
                    };
                }
                return y2AxisScale && (scaleDomain = y2AxisScale.domain(), y2PosInfo = {
                    point: y2AxisScale.invert(pointY),
                    threshold: .1 * (scaleDomain[1] - scaleDomain[0])
                }), {
                    y: yPosInfo,
                    y2: y2PosInfo
                };
            }, LineChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return !!this.data && this.data.isScalar;
            }, LineChart.prototype.getSupportedCategoryAxisType = function() {
                var _a, _b, supportContinuous = !1, dvCategories = null === (_b = null === (_a = this.dataView) || void 0 === _a ? void 0 : _a.categorical) || void 0 === _b ? void 0 : _b.categories;
                return _.isEmpty(dvCategories) || (supportContinuous = dvCategories.some(function(dvCategory) {
                    var _a, categoryType = null === (_a = dvCategory.source) || void 0 === _a ? void 0 : _a.type;
                    if (categoryType) {
                        var scalarKeys = (0, scalarUtils.A8)(dvCategory);
                        return !(0, axisHelper.c$)(categoryType) || scalarKeys && !_.isEmpty(scalarKeys.values);
                    }
                })), supportContinuous ? axisType.w.both : axisType.w.categorical;
            }, LineChart.sliceSeries = function(series, startIndex, endIndex) {
                var _a;
                return null !== (_a = null == series ? void 0 : series.map(function(currentSeries) {
                    var newSeries = (0, Prototype.ED)(currentSeries);
                    return newSeries.data = currentSeries.data.slice(startIndex, endIndex), newSeries;
                })) && void 0 !== _a ? _a : [];
            }, Object.defineProperty(LineChart.prototype, "horizontalOffset", {
                get: function() {
                    if (!this.data.isScalar) {
                        var xScale = this.xAxisProperties.scale;
                        if ((0, d3Helper._9)(xScale)) return xScale.bandwidth() / 2;
                    }
                    return 0;
                },
                enumerable: !1,
                configurable: !0
            }), LineChart.prototype.getHoverLineDataForCategory = function(categoryIndex) {
                var hoverLineData = this.createTooltipData(categoryIndex);
                if (hoverLineData) return setHoverlineAndDotsForTooltip.call(this, categoryIndex, hoverLineData.dataPoints), 
                hoverLineData;
            }, LineChart.prototype.getHoverLineIdentities = function(categoryIndex, dataPoints) {
                var _a, _b, _c, _d, _e, _f, _g, _h, categoriesIdentity = null === (_e = null === (_d = this.data) || void 0 === _d ? void 0 : _d.categoryIdentities) || void 0 === _e ? void 0 : _e[categoryIndex], multiplesCategoriesIdentity = null === (_g = null === (_f = this.data) || void 0 === _f ? void 0 : _f.multiplesCategoryIdentities) || void 0 === _g ? void 0 : _g[categoryIndex], identities = [], fullIdentity = null === (_h = _.find(null != dataPoints ? dataPoints : [], function(dataPoint) {
                    return (null == dataPoint ? void 0 : dataPoint.categoryIndex) === categoryIndex;
                })) || void 0 === _h ? void 0 : _h.identity;
                return fullIdentity && (multiplesCategoriesIdentity.exclude = ((_a = {})[1] = !0, 
                _a[0] = !1, _a), categoriesIdentity.exclude = ((_b = {})[1] = !0, _b[0] = !1, _b), 
                fullIdentity.exclude = ((_c = {})[1] = !1, _c[0] = !0, _c), identities.push(fullIdentity)), 
                (multiplesCategoriesIdentity || categoriesIdentity) && identities.push(null != multiplesCategoriesIdentity ? multiplesCategoriesIdentity : categoriesIdentity), 
                identities;
            }, LineChart.prototype.clearHoverLine = function() {
                clearHoverLine.call(this);
            }, LineChart.prototype.selectColumn = function(columnIndex, force) {
                if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== columnIndex) {
                    this.lastInteractiveSelectedColumnIndex = columnIndex;
                    var x = this.getChartX(columnIndex);
                    this.setHoverLine(x, columnIndex);
                    var legendItems = this.createLegendDataPoints(columnIndex);
                    legendItems && this.cartesianVisualHost.updateLegend(legendItems);
                }
            }, LineChart.prototype.setHoverLine = function(chartX, columnIndex) {
                setHoverLine.call(this, chartX, columnIndex);
            }, LineChart.prototype.getChartX = function(columnIndex) {
                var x = 0;
                this.data.isScalar ? columnIndex >= 0 && columnIndex < this.data.categoryData.length && (x = Math.max(0, this.xAxisProperties.scale(this.data.categoryData[columnIndex].categoryValue))) : x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                var rangeEnd = Math.max.apply(Math, this.xAxisProperties.scale.range());
                return x = Math.min(x, rangeEnd), this.horizontalOffset + (isNaN(x) ? 0 : x);
            }, LineChart.findCategoryIndex = function(options) {
                var offsetX = options.offsetX, categoryData = options.categoryData, scale = options.scale, pointX = options.pointX, xScale = options.currentViewport.scale;
                (0, Double.GG)(xScale, 1, 1e-5) || (pointX /= xScale), offsetX && (pointX += offsetX);
                var categoryIndex = cartesianAxisHelper.invertScale(scale, pointX, 0, 0, void 0).value;
                if (options.isScalar) {
                    var index = LineChart.findClosestXAxisIndex(categoryIndex, categoryData, scale);
                    return index >= 0 ? categoryData[index].categoryIndex : -1;
                }
                if (categoryData[categoryIndex] && !categoryData[categoryIndex].hasData) {
                    for (var closestLeftIndex = -1, currentBestLeftIndex = categoryIndex; currentBestLeftIndex > 0 && -1 === closestLeftIndex && categoryData[--currentBestLeftIndex].hasData; ) closestLeftIndex = currentBestLeftIndex;
                    for (var closestRightIndex = -1, currentBestRightIndex = categoryIndex, endIndex = categoryData.length - 1; currentBestRightIndex < endIndex && -1 === closestRightIndex && categoryData[++currentBestRightIndex].hasData; ) closestRightIndex = currentBestRightIndex;
                    var leftDistance = Math.abs(closestLeftIndex - categoryIndex), rightDistance = Math.abs(closestRightIndex - categoryIndex);
                    leftDistance < rightDistance ? categoryIndex = closestLeftIndex : leftDistance > rightDistance ? categoryIndex = closestRightIndex : leftDistance === rightDistance && (categoryIndex = pointX > scale(categoryIndex) + options.categoryThickness / 2 ? closestRightIndex : closestLeftIndex);
                }
                return categoryIndex;
            }, LineChart.findClosestXAxisIndex = function(categoryValue, categoryAxisValues, scale) {
                var domain = scale.domain(), domainExtent = [ domain[0], domain[1] ], closestValueIndex = -1;
                if (debug.fF.assert(function() {
                    return domainExtent[1] >= domainExtent[0];
                }, "expected max extent to not be less than min"), domainExtent[0] > domainExtent[1]) return closestValueIndex;
                var minDistance = Number.MAX_VALUE;
                for (var i in categoryAxisValues) {
                    var thisCategoryValue = categoryAxisValues[i].categoryValue;
                    if (!(thisCategoryValue < domainExtent[0] || thisCategoryValue > domainExtent[1])) {
                        var distance = Math.abs(categoryValue - thisCategoryValue);
                        distance < minDistance && (minDistance = distance, closestValueIndex = parseInt(i, 10));
                    }
                }
                return closestValueIndex;
            }, LineChart.prototype.findSubSelectedAreaElement = function(clientPoint) {
                return lineChart_renderer_Mockable_findSubSelectedAreaElement(this.viewModel, clientPoint);
            }, LineChart.prototype.createTooltipData = function(columnIndex) {
                var data = this.data;
                if (data && 0 !== data.series.length && data.categories && data.categoryData) {
                    var dataPoints = [];
                    debug.fF.assert(function() {
                        return columnIndex < data.categoryData.length;
                    }, "category index out of range (categoryData)"), debug.fF.assert(function() {
                        return columnIndex < data.categories.length;
                    }, "category index out of range (categories)");
                    for (var additionalTooltipItems, categoryDataPoint = data.categoryData[columnIndex], categoryHasUncertainty = !1, multipleDisplayName = data.multipleDisplayName, _i = 0, _a = data.series; _i < _a.length; _i++) {
                        var series = _a[_i], lineDataPoint = this.data.isScalar ? categoryDataPoint ? series.data.filter(function(lineDataItem) {
                            return lineDataItem.categoryValue === categoryDataPoint.categoryValue;
                        })[0] : void 0 : series.data[columnIndex];
                        if (null != (value = null == lineDataPoint ? void 0 : lineDataPoint.originalValue)) {
                            var formattedValue = (0, valueFormatter.WU)(value, lineDataPoint.labelFormatString || (0, 
                            valueFormatter.EO)(series.yCol, formatStringProp));
                            dataPoints.push({
                                category: (0, concatenateUtils.BJ)(categoryDataPoint.hierarchyCategoryLevels),
                                multipleDisplayName,
                                measureDisplayName: series.displayName,
                                measureActualDisplayName: series.measureDisplayName,
                                formattedValue: this.isStacked100 ? "".concat(formattedValue, " (").concat((0, valueFormatter.WU)(lineDataPoint.value, this.hostService.getLocalizedString("Percentage")), ")") : formattedValue,
                                value,
                                stackedValue: lineDataPoint.stackedValue,
                                uncertainty: lineDataPoint.uncertainty,
                                showHoverlineDots: !series.lineStyle.markerProperties.show,
                                marker: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, (0, marker_converter.lw)(series.lineStyle.markerProperties, data.legendMarkerRendering, markerShape.ZO.longDash)), {
                                    color: (0, marker_converter.XU)(series.lineStyle.markerProperties, series.lineStyle.strokeColor, data.legendMarkerRendering, data.matchLineColor)
                                }),
                                line: series.lineStyle,
                                isY2: lineDataPoint.isY2,
                                seriesDisplayName: data.hasDynamicSeries ? data.seriesDisplayName : void 0,
                                seriesName: data.hasDynamicSeries ? series.displayName : void 0,
                                additionalTooltipItems: data.hasDynamicSeries ? lineDataPoint.additionalTooltipItems : void 0
                            }), categoryHasUncertainty || (categoryHasUncertainty = !!lineDataPoint.uncertainty), 
                            data.hasDynamicSeries || additionalTooltipItems || (additionalTooltipItems = lineDataPoint.additionalTooltipItems);
                        }
                    }
                    if (!_.isEmpty(data.forecastLines) && categoryDataPoint) {
                        series = _.head(data.series), debug.fF.assertValue(series, "expected a line chart series when forecast is present");
                        for (var _b = 0, _c = data.forecastLines; _b < _c.length; _b++) {
                            var value, forecastLine = _c[_b], forecastDataPoint = _(forecastLine.points).filter(function(point) {
                                return point.point.x === categoryDataPoint.categoryValue;
                            }).first();
                            null != (value = null == forecastDataPoint ? void 0 : forecastDataPoint.point.y) && dataPoints.push({
                                category: (0, concatenateUtils.BJ)(categoryDataPoint.hierarchyCategoryLevels),
                                multipleDisplayName,
                                measureDisplayName: forecastLine.displayName,
                                measureActualDisplayName: this.originalData.valuesMetadata[0].displayName,
                                formattedValue: (0, valueFormatter.WU)(value, (0, valueFormatter.EO)(series.yCol, formatStringProp)),
                                value,
                                additionalTooltipItems: [ {
                                    displayName: this.localizer("Visual_Confidence_Band_Upper"),
                                    value: (0, valueFormatter.WU)(forecastDataPoint.upperBound.y, (0, valueFormatter.EO)(series.yCol, formatStringProp))
                                }, {
                                    displayName: this.localizer("Visual_Confidence_Band_Lower"),
                                    value: (0, valueFormatter.WU)(forecastDataPoint.lowerBound.y, (0, valueFormatter.EO)(series.yCol, formatStringProp))
                                } ],
                                showHoverlineDots: !0,
                                marker: {
                                    show: !0,
                                    color: forecastLine.stroke.strokeColor,
                                    shape: markerShape.ZO.circle
                                },
                                line: void 0
                            });
                        }
                    }
                    return {
                        dataPoints,
                        additionalTooltipItems,
                        legendMarkerRendering: data.legendMarkerRendering,
                        hasUncertainty: categoryHasUncertainty
                    };
                }
            }, LineChart.prototype.createLegendDataPoints = function(columnIndex) {
                var _a, _b, _c, _d, _this = this, data = this.data;
                if (data && data.series && !(data.series.length < 1)) {
                    var category, categoryDataPoint = data.categoryData[columnIndex];
                    this.mobileTileInteractive && categoryDataPoint && (this.data.isScalar ? (category = categoryDataPoint.categoryValue, 
                    (0, axisHelper.v9)(this.xAxisProperties.valueType) && (category = formattingService.y3.fromTimeValue(category))) : category = (0, 
                    cartesianHelper.dZ)(this.data, columnIndex, this.xAxisProperties.valueType, this.data.isScalar));
                    var legendDataPoints = data.series.map(function(series, i) {
                        var measure, lineData = series.data;
                        if (_this.mobileTileInteractive) {
                            var lineDataPoint = void 0;
                            if (_this.data.isScalar) {
                                if (categoryDataPoint) for (var targetCategoryValue = categoryDataPoint.categoryValue, _i = 0, lineData_1 = lineData; _i < lineData_1.length; _i++) {
                                    var datum = lineData_1[_i];
                                    if (datum.categoryValue === targetCategoryValue) {
                                        lineDataPoint = datum;
                                        break;
                                    }
                                }
                            } else lineDataPoint = lineData[columnIndex];
                            measure = null == lineDataPoint ? void 0 : lineDataPoint.value;
                        }
                        return {
                            marker: {
                                show: !0,
                                shape: markerShape.ZO.circle,
                                color: series.lineStyle.strokeColor
                            },
                            label: (0, converterHelper.TO)(series.yCol, _this.dataView.categorical.values, formatStringProp),
                            category: (0, valueFormatter.WU)(category, (0, valueFormatter.EO)(series.xCol, formatStringProp)),
                            measure: (0, valueFormatter.WU)(measure, (0, valueFormatter.EO)(series.yCol, formatStringProp)),
                            identity: series.identity,
                            selected: series.selected,
                            index: i
                        };
                    });
                    return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, (0, legend_converter.Fe)(this.style)), {
                        title: (null === (_d = null === (_c = null === (_b = null === (_a = this.dataView) || void 0 === _a ? void 0 : _a.categorical) || void 0 === _b ? void 0 : _b.values) || void 0 === _c ? void 0 : _c.source) || void 0 === _d ? void 0 : _d.displayName) || "",
                        dataPoints: legendDataPoints,
                        grouped: data.hasDynamicSeries
                    });
                }
            }, LineChart.prototype.adjustPathXCoordinate = function(x, interactivityLine) {
                browserUtils.M.isFirefox() && null != interactivityLine && (this.pathXAdjustment = this.getPathXAdjustmentForFirefox(interactivityLine)), 
                browserUtils.M.isInternetExplorerOrEdge() && (this.pathXAdjustment = 5);
                var xScale = this.currentViewport.scale;
                return x - this.pathXAdjustment * ((0, Double.GG)(xScale, 1, 1e-5) ? 1 : xScale);
            }, LineChart.prototype.getPathXAdjustmentForFirefox = function(interactivityLine) {
                var interactiveLineBoundingRect = interactivityLine.getBoundingClientRect(), tightBounding = (0, 
                svgUtil.jL)(interactivityLine);
                if (tightBounding.height > 0 && tightBounding.width > 0) return (interactiveLineBoundingRect.width / this.currentViewport.scale - tightBounding.width) / 2;
            }, Object.defineProperty(LineChart.prototype, "hasSingleStaticSeries", {
                get: function() {
                    return this.data && !this.data.hasDynamicSeries && this.hasSingleSeriesPerValueAxis();
                },
                enumerable: !1,
                configurable: !0
            }), LineChart.prototype.getCartesianVisualCapabilities = function() {
                var data = this.data, supportsTopLevelValueAggregates = !this.isStacked || this.hasSingleStaticSeries;
                return {
                    supportsHierarchicalCategoryAxis: !0,
                    axesCapabilities: {
                        categoryAxis: {
                            domainAggregateRole: lineChartRoles.R.Category,
                            supportedDomainAggregates: data && data.isScalar ? data.scalarKeyCount ? 1 : 3 : 0
                        },
                        valueAxis: {
                            domainAggregateRole: lineChartRoles.R.Y,
                            supportedDomainAggregates: supportsTopLevelValueAggregates ? 3 : 1
                        },
                        secondaryValueAxis: this.haveY2Data() || this.isComboChart ? {
                            domainAggregateRole: lineChartRoles.R.Y2,
                            supportedDomainAggregates: supportsTopLevelValueAggregates ? 3 : 1
                        } : void 0
                    }
                };
            }, LineChart.prototype.hasSingleSeriesPerValueAxis = function() {
                var data = this.data;
                if (!data || _.isEmpty(data.valuesMetadata)) return !1;
                for (var hasValueAxisValue = !1, hasSecondaryValueAxisValue = !1, _i = 0, _a = data.valuesMetadata; _i < _a.length; _i++) {
                    var roles = _a[_i].roles;
                    for (var role in roles) if (roles[role]) {
                        if (role === lineChartRoles.R.Y) {
                            if (hasValueAxisValue) return !1;
                            hasValueAxisValue = !0;
                        }
                        if (role === lineChartRoles.R.Y2) {
                            if (hasSecondaryValueAxisValue) return !1;
                            hasSecondaryValueAxisValue = !0;
                        }
                    }
                }
                return !0;
            }, LineChart.prototype.getStaticSeriesRole = function() {
                return this.isComboChart ? lineChartRoles.R.Y2 : lineChartRoles.R.Y;
            }, LineChart.prototype.haveY2Data = function() {
                var _a;
                return _.some(null === (_a = this.data) || void 0 === _a ? void 0 : _a.series, function(series) {
                    return null == series ? void 0 : series.isY2;
                });
            }, LineChart.prototype.customizeLegendFormattingModelOptions = function(options) {
                var data = this.originalData, legendMarker = data.legendMarkerRendering, supportMarkerCircleDefault = legendMarker === types_legendMarkerRendering._.markerCircleDefault;
                return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    legendMarkerRendering: legendMarker,
                    matchLineColor: legendMarker === types_legendMarkerRendering._.markerOnly || supportMarkerCircleDefault ? data.matchLineColor : void 0
                });
            }, LineChart.prototype.getTelemetryInformation = function() {
                var _a, telemetryInformation = {};
                if (_.isEmpty(null === (_a = this.data) || void 0 === _a ? void 0 : _a.anomalyDetections) || (telemetryInformation.AnomalyDetections = !0), 
                !_.isEmpty(telemetryInformation)) return telemetryInformation;
            }, LineChart.ClassName = "lineChart", LineChart.MainGraphicsContextClassName = "mainGraphicsContext", 
            LineChart.lineChartSVGClassName = "lineChartSVG", LineChart.ScalarOuterPadding = 10, 
            LineChart.DefaultZeroScalarDomain = [ -1, 1 ], LineChart;
        }(ResponsiveCartesianLayer), RealTimeLineChart = function(_super) {
            function RealTimeLineChart(options) {
                var _this = _super.call(this, options) || this;
                return _this.maxDataValue = Number.MIN_VALUE, _this.newDataInterval = 0, _this.duration = 3e5, 
                _this;
            }
            return (0, tslib_es6.__extends)(RealTimeLineChart, _super), RealTimeLineChart.prototype.initData = function(options) {
                _super.prototype.initData.call(this, options), this.data = this.defaultData;
            }, RealTimeLineChart.prototype.initRenderer = function(options) {
                _super.prototype.initRenderer.call(this, options), this.svg.classed("realTimeLineChart", !0).classed("cartesianChart", !0);
                var mainGraphicsSVG = this.mainGraphicsSVG = this.svg.append("svg");
                mainGraphicsSVG.classed("mainGraphicsSVG", !0), this.mainGraphicsContext = mainGraphicsSVG.append("g").classed("mainGraphicsContext", !0);
            }, Object.defineProperty(RealTimeLineChart.prototype, "defaultData", {
                get: function() {
                    return {
                        series: [],
                        totals: [],
                        legendData: (0, legend_converter.Fe)(this.style),
                        isScalar: !1,
                        dataLabelsSettings: getDefaultLineChartLabelSettings(this.style),
                        hasDynamicSeries: !1,
                        hasHighlights: !1,
                        categories: [],
                        categoryMetadata: void 0,
                        valuesMetadata: [],
                        categoryData: [],
                        lineStyle: getDefaultLineStyle(),
                        layout: {
                            seriesOrderReversed: !1
                        }
                    };
                },
                enumerable: !1,
                configurable: !0
            }), RealTimeLineChart.prototype.setData = function(dataViews) {
                var _a;
                if (null !== (_a = this.data) && void 0 !== _a || (this.data = this.defaultData), 
                !_.isEmpty(dataViews)) {
                    var dataView = _.head(dataViews);
                    if (dataView.categorical) {
                        var durationValue = cartesianHelper.Vk(dataView.metadata).duration;
                        durationValue && (this.duration = durationValue);
                        var dataViewCat = dataView.categorical;
                        this.removeOldData();
                        var dvCategories = dataViewCat.categories, categoryType = valueType.Ge.fromDescriptor({
                            text: !0
                        });
                        dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type && (categoryType = dvCategories[0].source.type);
                        var isScalar = (0, scalarUtils._K)(dataView.metadata ? dataView.metadata.objects : null, lineChart_capabilities.zK.categoryAxis.axisType, categoryType), convertedData = LineChartConverter.convert({
                            dataView,
                            style: this.style,
                            isComboChart: !1,
                            isScalar,
                            tooltipsEnabled: !1,
                            supportsTotalLabels: !1,
                            featureSwitches: this.featureSwitches
                        });
                        this.mergeNewData(convertedData), this.removeOldData(this.newDataInterval);
                    }
                }
            }, RealTimeLineChart.prototype.hasLegend = function() {
                return this.data && (this.data.hasDynamicSeries || !_.isEmpty(this.data.series));
            }, RealTimeLineChart.prototype.calculateAxesProperties = function(options) {
                var _a, _this = this;
                this.updateCurrentViewport(options);
                var categoryAxisOptions = options.categoryAxisOptions, valueAxisOptions = options.valueAxisOptions;
                if (this.newAxisData && (this.axisData = this.newAxisData), this.data) {
                    var axesDomains_1 = this.getAxesDomains(!1, {
                        categoryAxis: !0,
                        valueAxis: !0
                    }), computeAxis = function(axisType) {
                        var isXAxis = "x" === axisType, isYAxis = "y" === axisType, axisOptions = isXAxis ? categoryAxisOptions : valueAxisOptions, metaDataColumn = isXAxis ? _this.data.categoryMetadata : _this.containsEmptySeries() ? void 0 : _this.data.series[0].yCol, axisProperties = cartesianAxisHelper.createAxis({
                            pixelSpan: isXAxis ? _this.currentViewport.width : _this.availableHeight,
                            domainOptions: isXAxis ? {
                                domain: axesDomains_1.categoryAxis,
                                type: 0
                            } : {
                                domain: axesDomains_1.valueAxis,
                                type: 0
                            },
                            axisZoom: void 0,
                            metaDataColumn,
                            isScalar: !0,
                            isCategoryAxis: isXAxis,
                            isVertical: isYAxis,
                            formatString: (0, valueFormatter.EO)(metaDataColumn, cartesian_capabilities.p.general.formatString),
                            outerPadding: isXAxis ? 10 : 0,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: isXAxis ? function(index, type) {
                                return cartesianHelper.dZ(_this.data, index, type, !0);
                            } : void 0,
                            axis: AxesData.AxisDataDefaults,
                            margin: _this.margin,
                            preventNice: cartesianAxisHelper.hasForcedDomain(axisOptions.includeDomain),
                            categoryThickness: null
                        });
                        return isYAxis && axisProperties.d3Axis.tickSize(-options.viewport.width), axisProperties;
                    };
                    this.xAxisProperties = computeAxis("x"), this.yAxisProperties = computeAxis("y"), 
                    this.newAxisData = {
                        x: this.xAxisProperties,
                        y1: this.yAxisProperties
                    };
                }
                return null !== (_a = this.axisData) && void 0 !== _a || (this.axisData = this.newAxisData), 
                [ this.xAxisProperties, this.yAxisProperties ];
            }, RealTimeLineChart.prototype.getAxesDomains = function(_includeZero, requestedDomains) {
                var _a, _b, _c, axesDomains = {};
                if (!this.data) return axesDomains;
                var xSeries = this.truncateSeries();
                if (_.isEmpty(xSeries)) return axesDomains;
                if (requestedDomains.categoryAxis) {
                    var categoryDomain = cartesianAxisHelper.createDomain(xSeries, null !== (_c = null === (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.categoryMetadata) || void 0 === _b ? void 0 : _b.type) && void 0 !== _c ? _c : valueType.Ge.fromDescriptor({
                        text: !0
                    }), !0, [ cartesianAxisHelper.createScalarDomainOptions([ this.getMinData() + this.newDataInterval, void 0 ], 0, [ !0, void 0 ]) ]);
                    categoryDomain && (cartesianAxisHelper.assertScalarDomain(categoryDomain.domain), 
                    axesDomains.categoryAxis = categoryDomain.domain);
                }
                return requestedDomains.valueAxis && (axesDomains.valueAxis = cartesianAxisHelper.createValueDomain(xSeries)), 
                axesDomains;
            }, RealTimeLineChart.prototype.render = function(_suppressAnimations) {
                var _a;
                if (!this.containsEmptySeries()) return this.renderLines(), null === (_a = this.animator) || void 0 === _a || _a.refreshLastUpdate(), 
                {
                    dataPoints: [],
                    behaviorOptions: {},
                    labelDataPoints: [],
                    labelsAreNumeric: !0,
                    labelDataPointGroups: [],
                    animateLabels: !1
                };
            }, RealTimeLineChart.prototype.truncateSeries = function() {
                var minData = this.getMinData(), lineChartSeries = this.data.series;
                return lineChartSeries ? _.map(lineChartSeries, function(thisSeries) {
                    var series = (0, Prototype.ED)(thisSeries);
                    series.data = (0, Prototype.ED)(series.data);
                    var start = 0;
                    return _.findIndex(series.data, function(dp) {
                        return dp && dp.categoryValue >= minData;
                    }) > 0 && start++, series.data = series.data.slice(start), series;
                }) : [];
            }, RealTimeLineChart.prototype.removeOldData = function(realTimeDelta) {
                if (void 0 === realTimeDelta && (realTimeDelta = 0), !this.containsEmptySeries()) {
                    for (var minData = this.getMinData(realTimeDelta), data = this.data, _i = 0, _a = data.series; _i < _a.length; _i++) {
                        var s = _a[_i], index_1 = _.findIndex(s.data, function(dp) {
                            return dp && dp.categoryValue > minData;
                        });
                        index_1 > 0 && (s.data = s.data.slice(index_1));
                    }
                    var index = _.findIndex(data.categoryData, function(c) {
                        return c && c.categoryValue > minData;
                    });
                    index > 0 && (data.categoryData = this.data.categoryData.slice(index), data.categories = this.data.categories.slice(index));
                }
            }, RealTimeLineChart.prototype.mergeNewData = function(newData) {
                if (debug.fF.assertValue(newData, "newData"), this.containsEmptySeries()) return this.data = newData, 
                void (this.maxDataValue = this.getMaxData());
                this.data.series = RealTimeLineChart.mergeSeries(this.data.series, newData.series, this.maxDataValue), 
                RealTimeLineChart.mergeCategories(this.data, newData, this.maxDataValue);
                var newMaxData = this.getMaxData();
                this.newDataInterval = this.maxDataValue && newMaxData ? newMaxData - this.maxDataValue : 0, 
                this.maxDataValue = newMaxData;
            }, RealTimeLineChart.prototype.getMaxData = function() {
                for (var maxDataValue = 0, _i = 0, _a = this.data.series; _i < _a.length; _i++) {
                    var s = _a[_i];
                    s.data.length && (maxDataValue = Math.max(_.last(s.data).categoryValue, maxDataValue));
                }
                return maxDataValue;
            }, RealTimeLineChart.prototype.getMinData = function(additionalDelta) {
                return void 0 === additionalDelta && (additionalDelta = 0), this.maxDataValue - this.duration - 1.5 * additionalDelta;
            }, RealTimeLineChart.prototype.renderLines = function() {
                var _a, xScale = this.axisData.x.scale, yScale = this.axisData.y1.scale, pathGen = d3.line().x(function(d) {
                    return xScale(d.categoryValue);
                }).y(function(d) {
                    return yScale(d.value);
                });
                this.mainGraphicsSVG.attrs({
                    x: 0,
                    height: this.availableHeight,
                    width: this.availableWidth
                }), this.mainGraphicsContext.attr("transform", (0, svgUtil.Iu)(0, 0)), this.mainGraphicsContext.selectAll(".line").data(this.data.series, function(s) {
                    return s.identity.getKey();
                }).join(function(enter) {
                    return enter.append("path").classed("line", !0);
                }).style("stroke", function(d) {
                    return d.lineStyle.strokeColor;
                }).attr("d", function(d) {
                    return pathGen(d.data);
                }), null === (_a = this.animator) || void 0 === _a || _a.animate({
                    mainGraphicsContext: this.mainGraphicsContext,
                    interactivityService: null,
                    xTranslation: xScale(xScale.domain()[0] + this.newDataInterval) - xScale(xScale.domain()[0])
                });
            }, RealTimeLineChart.prototype.containsEmptySeries = function() {
                return !this.data || _.isEmpty(this.data.series);
            }, RealTimeLineChart.mergeCategories = function(existingChartData, newChartData, maxDataValue) {
                debug.fF.assertValue(existingChartData, "existingChartData"), debug.fF.assertValue(newChartData, "newChartData");
                var overlapPoint = _.findIndex(newChartData.categories, function(c) {
                    return c && c.categoryValue > maxDataValue;
                });
                overlapPoint > -1 ? (existingChartData.categories = existingChartData.categories.concat(newChartData.categories.slice(overlapPoint)), 
                existingChartData.categoryData = existingChartData.categoryData.concat(newChartData.categoryData.slice(overlapPoint))) : (existingChartData.categories = newChartData.categories, 
                existingChartData.categoryData = newChartData.categoryData);
            }, RealTimeLineChart.mergeSeries = function(existingSeries, newSeries, maxDataValue) {
                debug.fF.assertValue(existingSeries, "existingSeries"), debug.fF.assertValue(newSeries, "newSeries");
                for (var result = [], _i = 0, newSeries_1 = newSeries; _i < newSeries_1.length; _i++) {
                    var series = newSeries_1[_i], matchingSeries = _.find(existingSeries, function(s) {
                        return s.identity.equals(series.identity);
                    });
                    if (matchingSeries) {
                        result.push(matchingSeries);
                        for (var _a = 0, _b = series.data; _a < _b.length; _a++) {
                            var dp = _b[_a];
                            dp.categoryValue > maxDataValue && matchingSeries.data.push(dp);
                        }
                    } else result.push(series);
                }
                return result;
            }, RealTimeLineChart.prototype.getCartesianVisualCapabilities = function() {
                return {
                    supportsHierarchicalCategoryAxis: !1
                };
            }, RealTimeLineChart.prototype.getStaticSeriesRole = function() {
                return "Y";
            }, RealTimeLineChart;
        }(CartesianLayer), scatterChart_capabilities = __webpack_require__(14577), fillStyle = __webpack_require__(67165), point = __webpack_require__(81551), scatterChart_formatter = __webpack_require__(15458), scatterChart_converter = __webpack_require__(79972), scatterChart_renderer = __webpack_require__(56914), ScatterChart = function(_super) {
            function ScatterChart(options) {
                return _super.call(this, options) || this;
            }
            return (0, tslib_es6.__extends)(ScatterChart, _super), ScatterChart.prototype.initRenderer = function(options) {
                _super.prototype.initRenderer.call(this, options), this.svg.classed("".concat(ScatterChart.ClassName, " ").concat(playChart.qR), !0), 
                this.renderer = new scatterChart_renderer.WG(this, options.eventManager);
            }, ScatterChart.prototype.renderAtFrame = function(data) {
                this.data = this.originalData = data, this.updateViewModelAdapterAndData(), this.cartesianVisualHost.triggerRender(!1);
            }, ScatterChart.prototype.setData = function(dataViews) {
                var _a, _b, _c, _this = this;
                if (this.data = scatterChart_converter.vN(this.style), (null === (_a = this.playAxis) || void 0 === _a ? void 0 : _a.isCurrentlyPlaying()) && this.playAxis.stop(), 
                dataViews.length > 0) {
                    var dataView = dataViews[0] || dataViews[1];
                    if (dataView) {
                        this.categoryAxisProperties = (0, cartesianHelper.Vk)(dataView.metadata, !0), this.valueAxisProperties = (0, 
                        cartesianHelper.$w)(dataView.metadata, !0), this.dataView = dataView;
                        var converterOptions_1 = {
                            viewport: this.currentViewport,
                            colors: this.style.colorPalette.dataColors,
                            interactivityService: this.interactivityService,
                            categoryAxisProperties: this.categoryAxisProperties,
                            valueAxisProperties: this.valueAxisProperties,
                            style: this.style,
                            tooltipsEnabled: this.tooltipsEnabled,
                            useMatrixDV: !0
                        };
                        if ((0, playChart.vH)(dataView)) {
                            this.playAxis || (this.playAxis = new playChart.CT(this.interactivityService), this.dataView && (0, 
                            playChart.vH)(this.dataView) && (debug.fF.assertValue(this.playAxis, "playaxis"), 
                            this.playAxis.initData(this.dataInitOptions)));
                            var playData = this.playAxis.setData(dataView, function(callbackDataView, playFrameInfo, subtotals) {
                                return scatterChart_converter.OQ(callbackDataView, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, converterOptions_1), {
                                    useMatrixDV: !1
                                }), playFrameInfo, subtotals);
                            });
                            this.mergeSizeRanges(playData), this.data = playData.chartData, this.playAxis.setRenderFunction(function(data) {
                                return _this.renderAtFrame(data);
                            });
                        } else {
                            null === (_b = this.playAxis) || void 0 === _b || _b.remove(), this.playAxis = null;
                            var data = scatterChart_converter.OQ(dataView, converterOptions_1);
                            data && (this.data = data);
                        }
                    }
                } else null === (_c = this.playAxis) || void 0 === _c || _c.remove(), this.playAxis = null;
                this.originalData = this.data;
            }, ScatterChart.prototype.mergeSizeRanges = function(playData) {
                var _a, _b;
                if (null == playData ? void 0 : playData.chartData) {
                    for (var mergedSizeRange = playData.chartData.sizeRange, _i = 0, _c = playData.allChartData; _i < _c.length; _i++) {
                        var sizeRange = _c[_i].sizeRange;
                        null != sizeRange.min && (mergedSizeRange.min = Math.min(null !== (_a = mergedSizeRange.min) && void 0 !== _a ? _a : Number.POSITIVE_INFINITY, sizeRange.min)), 
                        null != sizeRange.max && (mergedSizeRange.max = Math.max(null !== (_b = mergedSizeRange.max) && void 0 !== _b ? _b : Number.NEGATIVE_INFINITY, sizeRange.max));
                    }
                    for (var _d = 0, _e = playData.allChartData; _d < _e.length; _d++) _e[_d].sizeRange = mergedSizeRange;
                }
            }, ScatterChart.prototype.hasLegend = function() {
                var _a;
                return null === (_a = this.data) || void 0 === _a ? void 0 : _a.hasDynamicSeries;
            }, ScatterChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                return scatterChart_formatter.qo.call(this, enumeration, options);
            }, ScatterChart.prototype.resolveFormattingPlaceholder = function(placeholder) {
                return scatterChart_formatter.u$.call(this, placeholder);
            }, ScatterChart.prototype.customizeFormattingCard = function(card) {
                return scatterChart_formatter.aD.call(this, card);
            }, ScatterChart.prototype.getFormattingCards = function(formattingCardOptions) {
                return scatterChart_formatter.nZ.call(this, formattingCardOptions);
            }, ScatterChart.prototype.supportsTrendLine = function() {
                var data = this.data;
                return !(!data || this.isXAxisCategorical() || this.playAxis) && !data.size && (data.hasCategory || data.hasDynamicSeries) && !!data.xCol && !!data.yCol;
            }, ScatterChart.prototype.supportsStaticReferenceLines = function() {
                return this.data && !this.isXAxisCategorical();
            }, ScatterChart.prototype.getAxisLocationForRole = function(roleName) {
                return "X" === roleName ? 0 : 1;
            }, ScatterChart.getExtents = function(data) {
                var _a, extents = {}, dps = data.dataPoints;
                if (_.isEmpty(dps)) return {
                    minY: 0,
                    maxY: 0,
                    formatStringY: void 0,
                    minX: 0,
                    maxX: 0,
                    formatStringX: void 0
                };
                var isXGrouped = !!data.xGroupMetadata, isXCategorical = isXGrouped && data.xGroupMetadata.isCategoricalAxis;
                return isXCategorical || (extents.minX = d3.min(dps, function(d) {
                    return d.x;
                }), extents.maxX = d3.max(dps, function(d) {
                    return d.x;
                }), extents.formatStringX = _.first(dps).xFormatString), isXGrouped && !isXCategorical && (dps = _.filter(dps, function(d) {
                    return null != d.x;
                })), extents.minY = d3.min(dps, function(d) {
                    return d.y;
                }), extents.maxY = d3.max(dps, function(d) {
                    return d.y;
                }), extents.formatStringY = null === (_a = _.first(dps)) || void 0 === _a ? void 0 : _a.yFormatString, 
                extents;
            }, ScatterChart.prototype.calculateAxesProperties = function(options) {
                var _this = this;
                this.updateCurrentViewport(options);
                var extents = {
                    minY: 0,
                    maxY: 10,
                    formatStringY: void 0,
                    formatStringX: void 0,
                    minX: 0,
                    maxX: 10
                };
                this.playAxis ? (extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents), 
                this.playAxisControlLayout = options.playAxisControlLayout) : _.isEmpty(this.data.dataPoints) || (extents = ScatterChart.getExtents(this.data));
                var axesDomains = this.getAxesDomains(!1, {
                    categoryAxis: !this.isXAxisCategorical(),
                    valueAxis: !0
                }), computeAxis = function(axisType) {
                    var _a, _b, _c, _d, isXAxis = "x" === axisType, isYAxis = "y" === axisType, axisOptions = isXAxis ? options.categoryAxisOptions : options.valueAxisOptions, xCategorical = isXAxis && _this.isXAxisCategorical(), domainOptions = xCategorical ? {
                        domain: _.uniq(_.map(_this.data.dataPoints, function(point) {
                            return point.categoryIndex;
                        })),
                        type: 0
                    } : cartesianAxisHelper.mergeScalarAxisDomains(axisOptions.includeDomain, cartesianAxisHelper.createScalarDomainOptions(isXAxis ? axesDomains.categoryAxis : axesDomains.valueAxis, 0)), metaDataColumn = isXAxis ? _this.data.xCol : _this.data.yCol, categoryLayout = xCategorical ? (0, 
                    cartesianHelper.is)({
                        availableWidth: _this.availableWidth,
                        categoryCount: _.size(_.uniqBy(_this.data.dataPoints, function(d) {
                            return d.categoryIndex;
                        })),
                        preferredCategoryWidth: (0, cartesianHelper.$K)((0, cartesianHelper.Vk)(_this.dataView.metadata)),
                        domain: domainOptions.domain,
                        isScalar: !_this.isXAxisCategorical(),
                        cartesianOptions: _this.options,
                        trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow,
                        outerPaddingRatio: options.outerPaddingRatio,
                        innerPaddingRatio: options.innerPaddingRatio
                    }) : void 0, axisProperties = cartesianAxisHelper.createAxis({
                        pixelSpan: isXAxis ? _this.availableWidth : _this.availableHeight,
                        domainOptions,
                        metaDataColumn,
                        axisZoom: options.axisZoom,
                        zeroScalarDomain: ScatterChart.DefaultZeroScalarDomain,
                        isScalar: isYAxis || !xCategorical,
                        isCategoryAxis: isXAxis,
                        isVertical: isYAxis,
                        formatString: (isXAxis ? extents.formatStringX : extents.formatStringY) || (0, valueFormatter.EO)(metaDataColumn, scatterChart_capabilities.il.general.formatString),
                        outerPadding: null !== (_a = null == categoryLayout ? void 0 : categoryLayout.outerPaddingRatio) && void 0 !== _a ? _a : 0,
                        categoryThickness: null !== (_b = null == categoryLayout ? void 0 : categoryLayout.categoryThickness) && void 0 !== _b ? _b : void 0,
                        innerPaddingRatio: null !== (_c = null == categoryLayout ? void 0 : categoryLayout.innerPaddingRatio) && void 0 !== _c ? _c : void 0,
                        outerPaddingRatio: null !== (_d = null == categoryLayout ? void 0 : categoryLayout.outerPaddingRatio) && void 0 !== _d ? _d : void 0,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: !0,
                        axis: axisOptions.axis,
                        margin: _this.margin,
                        preventNice: xCategorical ? void 0 : cartesianAxisHelper.hasForcedDomain(domainOptions),
                        getValueFn: xCategorical ? function(index, _type) {
                            var point = _.find(_this.data.dataPoints, function(d) {
                                return d.categoryIndex === index;
                            });
                            return null == point ? void 0 : point.formattedCategory.getValue();
                        } : void 0
                    });
                    return axisProperties.axisLabel = _this.data.axesLabels[axisType], isXAxis && (axisProperties.d3Axis.tickSizeInner(-_this.availableHeight).tickSizeOuter(0), 
                    xCategorical && (axisProperties.categoryIdentities = _this.data.categoryIdentities)), 
                    axisProperties;
                };
                return this.xAxisProperties = computeAxis("x"), this.yAxisProperties = computeAxis("y"), 
                [ this.xAxisProperties, this.yAxisProperties ];
            }, ScatterChart.prototype.getAxesDomains = function(_includeZero, requestedDomains) {
                var axesDomains = {}, data = this.data;
                if (!data) return axesDomains;
                var extents = {
                    minY: 0,
                    maxY: 10,
                    formatStringY: void 0,
                    formatStringX: void 0,
                    minX: 0,
                    maxX: 10
                };
                return this.playAxis ? extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents) : _.isEmpty(data.dataPoints) || (extents = ScatterChart.getExtents(data)), 
                requestedDomains.categoryAxis && !this.isXAxisCategorical() && (axesDomains.categoryAxis = [ extents.minX, extents.maxX ]), 
                requestedDomains.valueAxis && (axesDomains.valueAxis = [ extents.minY, extents.maxY ]), 
                axesDomains;
            }, ScatterChart.prototype.setFilteredData = function(startIndex, endIndex) {
                if (this.isXAxisCategorical()) {
                    var data = this.data = (0, Prototype.ED)(this.originalData);
                    data.dataPoints = _.filter(data.dataPoints, function(d) {
                        return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                    }), data.dataPointSeries = _.map(data.dataPointSeries, function(s) {
                        var series = (0, Prototype.ED)(s);
                        return series.dataPoints = _.filter(s.dataPoints, function(d) {
                            return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                        }), series;
                    });
                }
            }, ScatterChart.prototype.shouldSuppressAnimation = function() {
                var _a, _b;
                return (null === (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.dataPoints) || void 0 === _b ? void 0 : _b.length) > ScatterChart.NoAnimationThreshold;
            }, ScatterChart.prototype.render = function(suppressAnimations, resizeMode, formatMode) {
                var _a, _b, _c, _d, _e, _f, _g;
                if (this.data) {
                    this.playAxis && !this.playAxis.isRendererInitialized() && this.playAxis.initRenderer({
                        svg: this.svg
                    });
                    var playRenderResult, data = this.data, duration = (0, animatorCommon.Mb)(this.animator, suppressAnimations), drawBubbles = Boolean(this.data.size), viewModel = {
                        data: this.data,
                        allData: this.originalData,
                        currentViewport: this.currentViewport,
                        drawBubbles,
                        isPlay: !!this.playAxis,
                        hasCategoricalAxis: this.isXAxisCategorical(),
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        plotArea: {
                            width: this.availableWidth,
                            height: this.availableHeight
                        },
                        margin: this.margin,
                        hasSelection: null === (_a = this.interactivityService) || void 0 === _a ? void 0 : _a.hasSelection(),
                        animation: (null === (_b = this.playAxis) || void 0 === _b ? void 0 : _b.isCurrentlyPlaying()) && (this.mobileTileInteractive || duration > 0) ? playChart.Je : {
                            duration,
                            ease: d3.easeCubicInOut
                        },
                        animationOptions: this.animationOptions,
                        fillMarkers: !drawBubbles && data.fillPointStyle === fillStyle.f.fillOnly,
                        suppressDataPointRendering: 1 === resizeMode && (null === (_c = data.dataPoints) || void 0 === _c ? void 0 : _c.length) > ScatterChart.NoRenderResizeThreshold,
                        supportsPlotAreaSymmetryShading: this.isPlotSymmetryShadingSupported()
                    }, behaviorOptions = this.renderer.render(viewModel, this.interactivityService, this.hostService, formatMode);
                    if (this.mobileTileInteractive && (behaviorOptions = {
                        data: behaviorOptions.data,
                        dataPointsSelection: behaviorOptions.dataPointsSelection,
                        eventGroup: behaviorOptions.eventGroup,
                        root: behaviorOptions.root,
                        host: this.cartesianVisualHost,
                        mobileRoot: this.svg,
                        visualDataInitOptions: this.dataInitOptions,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        background: d3.select(this.element.get(0)),
                        visualInstanceId: behaviorOptions.visualInstanceId,
                        eventManager: behaviorOptions.eventManager
                    }), this.playAxis && (debug.fF.assertValue(this.playAxisControlLayout, "playAxisControlLayout"), 
                    this.playAxis.setPlayControlPosition(this.playAxisControlLayout), playRenderResult = this.playAxis.render(viewModel, this.currentViewport, this.margin), 
                    this.interactivityService && (behaviorOptions.playOptions = {
                        traceLineRenderer: new scatterChart_renderer.oz(playRenderResult.viewModel, this)
                    }, null === (_d = this.interactivityService) || void 0 === _d ? void 0 : _d.hasSelection()))) {
                        var selectedDataPoints = _.uniqBy(_.filter(playRenderResult.allDataPoints, function(d) {
                            return d.selected;
                        }), function(d) {
                            return d.identity.getKey();
                        });
                        behaviorOptions.playOptions.traceLineRenderer.render(selectedDataPoints, !suppressAnimations);
                    }
                    return {
                        dataPoints: null !== (_e = null == playRenderResult ? void 0 : playRenderResult.allDataPoints) && void 0 !== _e ? _e : data.dataPoints,
                        behaviorOptions,
                        navigationOptions: this.interactivityService ? {
                            helper: this.renderer,
                            navigationStrategy: this.isXAxisCategorical() ? services_interactivityService.jN.CategoryFirst : this.data.hasDynamicSeries ? services_interactivityService.jN.SeriesFirst : services_interactivityService.jN.CategoryOnly
                        } : void 0,
                        labelDataPoints: (null === (_f = data.dataLabelsSettings) || void 0 === _f ? void 0 : _f.show) || (null === (_g = data.dataLabelsSettings) || void 0 === _g ? void 0 : _g.showCategory) ? scatterChart_createLabelDataPoints(viewModel, this.style) : void 0,
                        labelsAreNumeric: !1,
                        animateLabels: !0
                    };
                }
            }, ScatterChart.prototype.getCategoryValueType = function() {
                return cartesianAxisHelper.getCategoryValueType(this.data.xCol);
            }, ScatterChart.prototype.getSupportedCategoryAxisType = function() {
                var _a;
                return (null === (_a = this.data) || void 0 === _a ? void 0 : _a.xGroupMetadata) ? this.data.xGroupMetadata.isScalarType ? axisType.w.both : axisType.w.categorical : axisType.w.scalar;
            }, ScatterChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return !this.isXAxisCategorical();
            }, ScatterChart.prototype.getSubSelectionMetadata = function(subSelectionElement) {
                return {
                    visualObject: subSelectionElement
                };
            }, ScatterChart.prototype.getSubSelectionShortcuts = function(subSelections) {
                return scatterChart_formatter.yV.call(this, subSelections);
            }, ScatterChart.prototype.getSubSelectionStyles = function(subSelections) {
                return scatterChart_formatter.mv.call(this, subSelections);
            }, ScatterChart.prototype.getSubSelectionCustomOutlines = function(subSelection) {
                return scatterChart_formatter.PH.call(this, subSelection);
            }, ScatterChart.prototype.getSelectorsByColumnFromSubselectedElement = function(e) {
                return scatterChart_formatter.l5.call(this, e);
            }, ScatterChart.prototype.getDataViewObjectLayerChanges = function(propertySaveObjects, sourceType) {
                return scatterChart_formatter.In.call(this, propertySaveObjects, sourceType);
            }, ScatterChart.prototype.getGroupBoundingRect = function(dataPoints, scale, mainGraphicsPositionOverlay) {
                var _a, _b, _c, svgScreenOffsetX = (_a = mainGraphicsPositionOverlay.node().getBoundingClientRect()).left, svgScreenOffsetY = _a.top, svgGroupOffsetX = (_b = mainGraphicsPositionOverlay.node().getBBox()).x, svgGroupOffsetY = _b.y, xMin = (_c = dataPoints.reduce(function(acc, curr) {
                    var _a = curr.geometry, size = _a.size, x = _a.x, y = _a.y;
                    return acc.xMin = Math.min(x - size, acc.xMin), acc.yMin = Math.min(y - size, acc.yMin), 
                    acc.xMax = Math.max(x + size, acc.xMax), acc.yMax = Math.max(y + size, acc.yMax), 
                    acc;
                }, {
                    xMin: Number.MAX_SAFE_INTEGER,
                    yMin: Number.MAX_SAFE_INTEGER,
                    xMax: Number.MIN_SAFE_INTEGER,
                    yMax: Number.MIN_SAFE_INTEGER
                }), _c.xMin), yMin = _c.yMin, widthScaled = (_c.xMax - xMin) * scale, height = Math.round((_c.yMax - yMin) * scale + 10), width = Math.round(widthScaled + 10), scaledMinX = (xMin - svgGroupOffsetX) * scale, y = Math.ceil((yMin - svgGroupOffsetY) * scale - 5 + svgScreenOffsetY);
                return {
                    x: Math.ceil(scaledMinX - 5 + svgScreenOffsetX),
                    y,
                    height,
                    width
                };
            }, ScatterChart.prototype.getCartesianVisualCapabilities = function() {
                return {
                    supportsHierarchicalCategoryAxis: !1
                };
            }, ScatterChart.prototype.getStaticSeriesRole = function() {}, ScatterChart.prototype.isXAxisCategorical = function() {
                var _a, _b;
                return null === (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.xGroupMetadata) || void 0 === _b ? void 0 : _b.isCategoricalAxis;
            }, ScatterChart.prototype.isPlotSymmetryShadingSupported = function() {
                var _a, _b;
                return !this.isXAxisCategorical() && !(null === (_a = this.valueAxisProperties) || void 0 === _a ? void 0 : _a.logAxisScale) && !(null === (_b = this.categoryAxisProperties) || void 0 === _b ? void 0 : _b.logAxisScale);
            }, ScatterChart.ClassName = "scatterChart", ScatterChart.NoAnimationThreshold = 1e3, 
            ScatterChart.NoRenderResizeThreshold = 1e3, ScatterChart.DefaultZeroScalarDomain = [ -1, 1 ], 
            ScatterChart;
        }(ResponsiveCartesianLayer);
        function scatterChart_createLabelDataPoints(viewModel, style) {
            var _a, labelSettings = viewModel.data.dataLabelsSettings, fontProperties = labelSettings.fontProperties, preferredLabelsKeys = null !== (_a = function(viewModel) {
                var quarterWidth, quarterHeight, _a = viewModel.plotArea, width = _a.width, height = _a.height;
                return function(visualCenter, quadrantsCenters, viewModel) {
                    for (var distance, minDistances = [ Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE ], ids = [], xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, _i = 0, _a = viewModel.data.dataPoints; _i < _a.length; _i++) {
                        var dp = _a[_i], x = xScale(dp.x), y = yScale(dp.y), quadrantNumber = getPointQuadrantNumber(x, y, visualCenter);
                        viewModel.drawBubbles ? ids[quadrantNumber] || (ids[quadrantNumber] = dp.identity) : (x1 = quadrantsCenters[quadrantNumber].x, 
                        y1 = quadrantsCenters[quadrantNumber].y, x2 = x, y2 = y, (distance = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))) < minDistances[quadrantNumber] && (ids[quadrantNumber] = dp.identity, 
                        minDistances[quadrantNumber] = distance));
                    }
                    var x1, y1, x2, y2;
                    return _.filter(ids, function(id) {
                        return !!id;
                    }).map(function(id) {
                        return id.getKey();
                    });
                }(new point.E(width / 2, height / 2), [ new point.E(quarterWidth = width / 4, quarterHeight = height / 4), new point.E(3 * quarterWidth, quarterHeight), new point.E(quarterWidth, 3 * quarterHeight), new point.E(3 * quarterWidth, 3 * quarterHeight) ], viewModel);
            }(viewModel)) && void 0 !== _a ? _a : [], labelColor = fontProperties.color || common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ);
            return _.map(viewModel.data.dataPoints, function(dataPoint) {
                var text = dataPoint.formattedCategory.getValue(), textProperties = (0, common_fontProperties.qk)(fontProperties, text);
                return {
                    isPreferred: isLabelPreferred(dataPoint.identity.getKey(), preferredLabelsKeys),
                    text,
                    textSize: {
                        width: textMeasurementService.b.measureSvgTextWidth(textProperties),
                        height: textMeasurementService.b.estimateSvgTextHeight(textProperties)
                    },
                    outsideFill: labelColor,
                    insideFill: common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl),
                    parentType: 0,
                    parentShape: {
                        point: {
                            x: viewModel.xAxisProperties.scale(dataPoint.x),
                            y: viewModel.yAxisProperties.scale(dataPoint.y)
                        },
                        radius: scatterChart_renderer.WG.calculateRadius(dataPoint.radius, viewModel.data.sizeRange, viewModel.plotArea, viewModel.data.marker.rangeType, viewModel.data.marker.multiplier),
                        validPositions: [ 2, 1, 8, 4, 16, 32, 64, 128 ]
                    },
                    identity: dataPoint.renderIdentity,
                    fontProperties,
                    leaderLine: {
                        strokeColor: labelColor,
                        strokeWidth: 1,
                        strokeTransparency: 50,
                        strokePattern: strokePattern.Dv.solid,
                        strokeShow: !0
                    },
                    hasBackground: labelSettings.enableBackground,
                    backgroundColor: labelSettings.backgroundColor,
                    backgroundTransparency: labelSettings.backgroundTransparency,
                    isCategory: !0
                };
            });
        }
        function getPointQuadrantNumber(x, y, centerPoint) {
            return x > centerPoint.x && y <= centerPoint.y ? 0 : x <= centerPoint.x && y <= centerPoint.y ? 1 : x <= centerPoint.x && y > centerPoint.y ? 2 : 3;
        }
        function isLabelPreferred(key, preferredLabelsKeys) {
            return _.some(preferredLabelsKeys, function(preferredLabel) {
                return 0 === key.localeCompare(preferredLabel);
            });
        }
        var waterfallChart_capabilities = __webpack_require__(5616), ValidLabelPositionsOptions = [ labelPosition1.h.auto, labelPosition1.h.outsideEnd, labelPosition1.h.insideEnd, labelPosition1.h.insideCenter, labelPosition1.h.insideBase ], MinimumBreakdowns = 1, MaximumBreakdowns = 20;
        function waterfallChart_formatter_getFormattingCards(formattingCardOptions) {
            return {
                type: 3,
                card: [ getSentimentColorCard.call(this, formattingCardOptions.categoryAxisData), getBreakdownCard.call(this), waterfallChart_formatter_getLabelsCard.call(this) ].filter(function(card) {
                    return card;
                })
            };
        }
        function getSentimentColorCard(categoryAxisData) {
            var _this = this, sentimentProps = waterfallChart_capabilities.wW.sentimentColors, data = this.originalData, sentimentColorsData = data.sentimentColors, cardBuilder = new build_control_util.CQ(new build_control_util.lg("sentimentColors"), "Role_DisplayName_Columns", (0, 
            tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], _.values(sentimentProps), !0), [ waterfallChart_capabilities.wW.valueAxis.totalsEnabled, waterfallChart_capabilities.wW.categoryAxis.innerPadding ], !1), this.localizer);
            return cardBuilder.addGroup("colors", function(groupBuilder) {
                groupBuilder.withDisplayName("Visual_Colors").addSimpleSlice("increaseFill", new build_control_util.BT({
                    descriptor: sentimentProps.increaseFill,
                    value: {
                        value: sentimentColorsData.increaseFill.solid.color
                    }
                }).build()).addSimpleSlice("decreaseFill", new build_control_util.BT({
                    descriptor: sentimentProps.decreaseFill,
                    value: {
                        value: sentimentColorsData.decreaseFill.solid.color
                    }
                }).build()).addSimpleSlice("otherFill", new build_control_util.BT({
                    descriptor: sentimentProps.otherFill,
                    value: {
                        value: sentimentColorsData.otherFill.solid.color
                    }
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled(!data.isBreakdown).withCustomDescription("Visual_Waterfall_Breakdown_OtherDescription");
                }), data.isBreakdown || groupBuilder.addSimpleSlice("totalsEnabled", new build_control_util.bd({
                    descriptor: waterfallChart_capabilities.wW.valueAxis.totalsEnabled,
                    value: _this.isTotalsEnabled()
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withCustomDisplayName("Visual_Axis_Total_Column");
                }), _this.isTotalsEnabled() && groupBuilder.addSimpleSlice("totalFill", new build_control_util.BT({
                    descriptor: sentimentProps.totalFill,
                    value: {
                        value: sentimentColorsData.totalFill.solid.color
                    }
                }).build());
            }), cardBuilder.addGroup("spacing", function(groupBuilder) {
                groupBuilder.withDisplayName("Visual_Spacing").addSimpleSlice("innerPadding", (0, 
                cartesianChart_formatter.Gf)(categoryAxisData, _this.localizer));
            }), cardBuilder.build();
        }
        function getBreakdownCard() {
            var _this = this, data = this.originalData, breakdownProps = waterfallChart_capabilities.wW.breakdown, cardBuilder = new build_control_util.CQ(new build_control_util.lg("breakdown"), "Visual_Waterfall_Breakdown", breakdownProps, this.localizer);
            return data.isBreakdown ? (cardBuilder.addGroup("breakdown", function(groupBuilder) {
                groupBuilder.addSimpleSlice("maxBreakdowns", new build_control_util.JN({
                    descriptor: breakdownProps.maxBreakdowns,
                    value: data.numberOfBreakdowns,
                    localize: _this.localizer,
                    options: {
                        minValue: {
                            type: 0,
                            value: MinimumBreakdowns
                        },
                        maxValue: {
                            type: 1,
                            value: Math.min(MaximumBreakdowns, data.totalBreakdownCategories)
                        }
                    }
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withCustomDisplayName("Visual_Waterfall_MaximumBreakdown");
                });
            }), cardBuilder.build()) : (cardBuilder.withDisabled(!0, "Visual_BreakdownCard_DisabledReason"), 
            cardBuilder.build());
        }
        function waterfallChart_formatter_getLabelsCard() {
            var _a, _b, labelProps = waterfallChart_capabilities.wW.labels, data = this.originalData, labelSettings = this.data.dataLabelsSettings, labelSettingOptions = {
                dataLabelsSettings: data.dataLabelsSettings,
                positionObject: ValidLabelPositionsOptions,
                show: !0,
                displayUnits: !0,
                precision: !0,
                fontSize: !0,
                fontFamily: !0,
                labelOrientation: !0,
                position: !0,
                enableBackground: labelSettings.enableBackground,
                backgroundColor: labelSettings.backgroundColor,
                backgroundTransparency: labelSettings.backgroundTransparency,
                style: this.style,
                bold: !0,
                italic: !0,
                underline: !0
            };
            labelSettings.position && labelSettingOptions.positionObject.indexOf(labelSettings.position) < 0 && (labelSettings.position = labelPosition1.h.auto);
            var formatCardOptions = {
                cardBuilder: new build_control_util.CQ(new build_control_util.lg("labels"), "Visual_DataPointsLabels", labelProps, this.localizer),
                dataLabelsProps: labelProps,
                featureSwitches: this.featureSwitches,
                hostServices: this.hostService,
                options: labelSettingOptions,
                individualSelector: (0, dataLabelViewModel1.WD)({
                    featureSwitches: this.featureSwitches,
                    hasCategories: null != _.first(data.categories),
                    hasDynamicSeries: !1,
                    hasSeriesSelector: !1
                })
            };
            if (data.isBreakdown) {
                var firstIdentity = null === (_b = _.first(null === (_a = _.first(data.series)) || void 0 === _a ? void 0 : _a.data)) || void 0 === _b ? void 0 : _b.identity.getSelector();
                firstIdentity && (formatCardOptions.repetitionSelector = {
                    metadata: firstIdentity.metadata
                });
            }
            return (0, dataLabelViewModel1.XQ)(formatCardOptions);
        }
        function waterfallChart_formatter_getSubSelectionShortcuts(subSelections, filter) {
            if (!filter) {
                var visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0) {
                    var localizer = this.localizer;
                    switch (visualObjects[0].objectName) {
                      case "increase-fill":
                        return getFillSubSelectionShortcuts("Format_Increase_Fill", localizer);

                      case "decrease-fill":
                        return getFillSubSelectionShortcuts("Format_Decrease_Fill", localizer);

                      case "other-fill":
                        return getFillSubSelectionShortcuts("Format_Other_Fill", localizer);

                      case "total-fill":
                        return getFillSubSelectionShortcuts("Format_Total_Fill", localizer);

                      default:
                        return;
                    }
                }
            }
        }
        function getFillSubSelectionShortcuts(label, localizer) {
            var addDataLabelToggleFormattingId = waterfallChart_capabilities.wW.labels.show, cardUid = "".concat("Visual", "-").concat("sentimentColors");
            return [ {
                type: 0,
                excludedResetFormattingIds: [ addDataLabelToggleFormattingId ]
            }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                type: 2
            }, addDataLabelToggleFormattingId), {
                enabledLabel: localizer("Format_AddDataLabels")
            }), {
                type: 1,
                destinationInfo: {
                    cardUid
                },
                label: localizer(label)
            } ];
        }
        function waterfallChart_formatter_getSubSelectionStyles(subSelections) {
            var _a, visualObjects = _.first(subSelections).visualObjects;
            if (visualObjects.length > 0) switch (visualObjects[0].objectName) {
              case "data-labels":
                return (0, onObjectUtil.Jf)({
                    hostServices: this.hostService,
                    omitSelectorForSingleSeries: !0,
                    individualSelector: !0,
                    selector: void 0,
                    repetitionSelector: void 0
                }, {
                    fontFamilyReference: (_a = waterfallChart_capabilities.wW.labels).fontFamily,
                    fontSizeReference: _a.fontSize,
                    boldReference: _a.bold,
                    italicReference: _a.italic,
                    underlineReference: _a.underline,
                    fontColorReference: _a.color,
                    displayUnitsReference: _a.labelDisplayUnits,
                    precisionReference: _a.labelPrecision
                });

              case "increase-fill":
                return (0, onObjectUtil.w3)(this.hostService, void 0, waterfallChart_capabilities.wW.sentimentColors.increaseFill);

              case "decrease-fill":
                return (0, onObjectUtil.w3)(this.hostService, void 0, waterfallChart_capabilities.wW.sentimentColors.decreaseFill);

              case "other-fill":
                return (0, onObjectUtil.w3)(this.hostService, void 0, waterfallChart_capabilities.wW.sentimentColors.otherFill);

              case "total-fill":
                return (0, onObjectUtil.w3)(this.hostService, void 0, waterfallChart_capabilities.wW.sentimentColors.totalFill);

              default:
                return;
            }
        }
        var WaterfallConnectorClasses = (0, CssConstants.CH)("waterfall-connector"), CategoryValueClasses = (0, 
        CssConstants.CH)("column");
        function render(suppressAnimations, formatMode) {
            var _this = this, data = this.clippedData.series[0].data, hasSelection = this.interactivityService && this.interactivityService.hasSelection(), xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, y0 = yScale.domain()[0], yInverted = this.yAxisProperties.invertAxis, onObjectEnabled = this.featureSwitches.onObject;
            this.mainGraphicsSVG.attr("height", this.availableHeight).attr("width", this.availableWidth), 
            (0, visualBorderUtil.H4)(this.mainGraphicsSVG, this.clippedData.strokeSettings);
            var bars = this.mainGraphicsContext.selectAll(CategoryValueClasses.selector).data(data, function(d) {
                return d.key;
            }).join(function(enter) {
                return enter.append("rect").classed(CategoryValueClasses.class, !0).classed("highlight", function(d) {
                    return d.highlight;
                });
            }).style("fill", function(d) {
                return d.color;
            }).style("fill-opacity", function(d) {
                return 1 === d.barType ? renderUtil.Ko : (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, _this.data.hasHighlights);
            }).attr("width", this.layout.categoryWidth).attr("x", function(d) {
                return xScale(d.categoryIndex);
            }).attr("y", function(d) {
                var height;
                return yInverted ? (height = d.position < y0 ? Math.abs(yScale(y0) - yScale(d.value)) : Math.abs(yScale(d.position) - yScale(d.position + d.value)), 
                getRectTop(yScale, d.position, d.value) - height) : getRectTop(yScale, d.position, d.value);
            }).attr("height", function(d) {
                return d.position < y0 ? Math.abs(yScale(y0) - yScale(d.value)) : Math.abs(yScale(d.position) - yScale(d.position + d.value));
            });
            this.interactivityService && bars.attrs({
                tabindex: 0,
                focusable: !0,
                "aria-label": function(d) {
                    return (0, tooltipUtils.X)(d.tooltipInfo());
                },
                role: "option",
                "aria-selected": function(d) {
                    return d.selected;
                }
            }).classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()), onObjectEnabled && bars.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, function(d) {
                return function(sentimentColorType) {
                    switch (sentimentColorType) {
                      case 1:
                        return "decrease-fill";

                      case 0:
                        return "increase-fill";

                      case 3:
                        return "other-fill";

                      case 2:
                        return "total-fill";

                      default:
                        debug.fF.assertNever(sentimentColorType);
                    }
                }(d.sentimentColorType);
            }).attr(htmlSubSelectionHelper.CK, function(d) {
                return function(sentimentColorType) {
                    switch (sentimentColorType) {
                      case 1:
                        return "Visual_DecreaseFill";

                      case 0:
                        return "Visual_IncreaseFill";

                      case 3:
                        return "Visual_OtherFill";

                      case 2:
                        return "Visual_TotalFill";

                      default:
                        debug.fF.assertNever(sentimentColorType);
                    }
                }(d.sentimentColorType);
            }).attr(htmlSubSelectionHelper.QZ, 3), this.mainGraphicsContext.selectAll(WaterfallConnectorClasses.selector).data(data.slice(0, data.length - 1), function(d) {
                return d.key;
            }).join(function(enter) {
                return enter.append("line").classed(WaterfallConnectorClasses.class, !0);
            }).style("stroke", common_colorHelper.v.getThemeColor(this.style, "foregroundNeutralTertiary")).attrs({
                x1: function(d) {
                    return xScale(d.categoryIndex);
                },
                y1: function(d) {
                    return yScale(d.position + d.value);
                },
                x2: function(d) {
                    return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth;
                },
                y2: function(d) {
                    return yScale(d.position + d.value);
                }
            }), this.tooltipsEnabled && this.tooltipService.addTooltip(bars, function(args) {
                return args.data && args.data.tooltipInfo();
            }, function(args) {
                return args.data && args.data.identity && [ args.data.identity ];
            });
            var behaviorOptions, navigationOptions, labelSettings = this.data.dataLabelsSettings, labelDataPoints = [];
            return (labelSettings && labelSettings.show || labelSettings.showCategory) && (labelDataPoints = this.createLabelDataPoints()), 
            this.interactivityService && (navigationOptions = {
                navigationStrategy: services_interactivityService.jN.CategoryOnly,
                helper: this
            }, behaviorOptions = {
                root: this.mainGraphicsContext,
                bars,
                isBreakdown: this.data.isBreakdown,
                formatMode
            }), (0, svgUtil.bL)(this.animationOptions), {
                dataPoints: this.data.series[0].data,
                behaviorOptions,
                navigationOptions,
                labelDataPoints,
                labelsAreNumeric: !0,
                labelOrientation: labelSettings.labelOrientation,
                animateLabels: !suppressAnimations
            };
        }
        function getRectTop(scale, pos, value) {
            return value < 0 ? scale(pos) : scale(pos) - (scale(0) - scale(value));
        }
        var WaterfallChart = function(_super) {
            function WaterfallChart(options) {
                var _a;
                return _super.call(this, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                    tooltipsEnabled: null === (_a = options.tooltipsEnabled) || void 0 === _a || _a
                })) || this;
            }
            return (0, tslib_es6.__extends)(WaterfallChart, _super), WaterfallChart.prototype.initRenderer = function(options) {
                if (_super.prototype.initRenderer.call(this, options), this.svg.classed(WaterfallChart.WaterfallClassName, !0), 
                this.mainGraphicsSVG = this.svg.append("svg"), this.mainGraphicsContext = this.mainGraphicsSVG.append("g").classed(WaterfallChart.MainGraphicsContextClassName, !0), 
                this.interactivityService) {
                    var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                    this.mainGraphicsContext.attrs({
                        tabindex: 0,
                        focusable: !0,
                        role: "listbox",
                        "aria-multiselectable": !0,
                        "aria-label": this.localizer("Visual_Plot")
                    }).classed(renderUtil.Pg, !isEdgeOrIE);
                }
            }, WaterfallChart.getDefaultWaterfallLabelSettings = function(style, show, labelColor, fontSizePt) {
                return void 0 === show && (show = !1), {
                    show,
                    labelOrientation: labelOrientation.B.Horizontal,
                    position: labelPosition1.h.auto,
                    displayUnits: 0,
                    precision: dataLabelViewModel1Consts.NZ,
                    fontProperties: (0, dataLabelViewModel1.bT)({
                        style,
                        textClassName: "smallLightLabel",
                        labelColor,
                        fontSize: fontSizePt
                    }).fontProperties,
                    enableBackground: !1,
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, WaterfallChart.doesDataLabelFitInShape = function(d, yAxisProperties, layout) {
                if (null == d || null === d.value) return !1;
                var properties = {
                    text: layout.labelText(d),
                    fontFamily: dataLabelViewModel1Consts.bN.fontFamily,
                    fontSize: dataLabelViewModel1Consts.bN.fontSize,
                    fontWeight: dataLabelViewModel1Consts.bN.fontWeight
                };
                if (getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelViewModel1Consts.FJ > 0) return !0;
                var textWidth = textMeasurementService.b.measureSvgTextWidth(properties), textHeight = textMeasurementService.b.estimateSvgTextHeight(properties), shapeWidth = layout.categoryWidth, shapeHeight = Math.abs((0, 
                axisHelper.sc)(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
                return !(textWidth > shapeWidth || textHeight > shapeHeight);
            }, WaterfallChart.prototype.setData = function(dataViews) {
                debug.fF.assertValue(dataViews, "dataViews");
                var sentimentColors = this.getSentimentColorsFromObjects(null), numberOfBreakdowns = WaterfallChart.DefaultBreakdowns, dataView = dataViews.length > 0 ? dataViews[0] : void 0;
                if (this.data = this.originalData = {
                    series: [ {
                        data: []
                    } ],
                    categories: [],
                    valuesMetadata: [],
                    legendData: (0, legend_converter.Fe)(this.style),
                    hasHighlights: !1,
                    categoryMetadata: null,
                    scalarCategoryAxis: !1,
                    positionMax: 0,
                    positionMin: 0,
                    dataLabelsSettings: WaterfallChart.getDefaultWaterfallLabelSettings(this.style, !1, void 0),
                    sentimentColors,
                    axesLabels: {
                        x: null,
                        y: null
                    },
                    numberOfBreakdowns,
                    totalBreakdownCategories: 0,
                    totalsEnabled: !0
                }, dataView) {
                    if (this.dataView = dataView, dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects, labelsObj = objects.labels;
                        labelsObj && (0, dataLabelViewModel1.ww)(labelsObj, this.data.dataLabelsSettings, !0, this.style), 
                        sentimentColors = this.getSentimentColorsFromObjects(objects), numberOfBreakdowns = (0, 
                        dataViewObject2.NA)(objects, waterfallChart_capabilities.wW.breakdown.maxBreakdowns, WaterfallChart.DefaultBreakdowns);
                    }
                    (dataView.categorical || dataView.matrix) && (this.data = this.originalData = WaterfallChartConverter.convert({
                        dataView,
                        style: this.style,
                        hostServices: this.hostService,
                        dataLabelSettings: this.data.dataLabelsSettings,
                        sentimentColors,
                        interactivityService: this.interactivityService,
                        tooltipsEnabled: this.tooltipsEnabled,
                        numberOfBreakdowns
                    }));
                }
            }, WaterfallChart.prototype.getFormattingCards = function(formattingCardOptions) {
                return waterfallChart_formatter_getFormattingCards.call(this, formattingCardOptions);
            }, WaterfallChart.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                return waterfallChart_formatter_getSubSelectionShortcuts.call(this, subSelections, filter);
            }, WaterfallChart.prototype.getSubSelectionStyles = function(subSelections) {
                return waterfallChart_formatter_getSubSelectionStyles.call(this, subSelections);
            }, WaterfallChart.prototype.isTotalsEnabled = function() {
                var _a, _b;
                return null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.totalsEnabled) && void 0 !== _b && _b;
            }, WaterfallChart.prototype.hasLegend = function() {
                return !0;
            }, WaterfallChart.createClippedDataIfOverflowed = function(data, renderableDataCount) {
                debug.fF.assertValue(data, "createClippedDataIfOverflowed");
                var dataPoints = data.series[0].data;
                if (renderableDataCount < dataPoints.length) {
                    var clipped = (0, Prototype.ED)(data);
                    return clipped.series = [ {
                        data: dataPoints.slice(0, renderableDataCount)
                    } ], clipped.categories = data.categories.slice(0, renderableDataCount), clipped;
                }
                return data;
            }, WaterfallChart.prototype.calculateAxesProperties = function(options) {
                var _a, _this = this;
                this.updateCurrentViewport(options);
                var categoryAxisOptions = options.categoryAxisOptions, valueAxisOptions = options.valueAxisOptions, data = this.clippedData = this.data, categoryCount = data.categories.length - (this.isTotalsEnabled() ? 0 : 1), preferredPlotArea = this.getPreferredPlotArea({
                    isScalar: !1,
                    categoryCount,
                    categoryThickness: cartesianHelper.jY,
                    outerPaddingRatio: options.outerPaddingRatio
                }), layout = (0, cartesianHelper.is)({
                    availableWidth: preferredPlotArea.width,
                    categoryCount,
                    preferredCategoryWidth: null !== (_a = null == data ? void 0 : data.preferredCategoryWidth) && void 0 !== _a ? _a : null,
                    domain: null,
                    isScalar: !1,
                    cartesianOptions: this.options,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow,
                    outerPaddingRatio: options.outerPaddingRatio,
                    innerPaddingRatio: options.innerPaddingRatio
                });
                this.options.isScrollable || (data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, layout.categoryCount));
                var yAxisDomainOptions = cartesianAxisHelper.createScalarDomainOptions(this.getAxesDomains(!1, {
                    valueAxis: !0
                }).valueAxis, 0);
                yAxisDomainOptions = cartesianAxisHelper.mergeScalarAxisDomains(valueAxisOptions.includeDomain, yAxisDomainOptions);
                var computeAxis = function(axisType) {
                    var _a, isXAxis = "x" === axisType, isYAxis = "y" === axisType, axisOptions = isXAxis ? categoryAxisOptions : valueAxisOptions, axisProperties = cartesianAxisHelper.createAxis({
                        pixelSpan: isXAxis ? preferredPlotArea.width : preferredPlotArea.height,
                        domainOptions: isXAxis ? cartesianAxisHelper.createDomain(data.series, cartesianAxisHelper.getCategoryValueType(data.categoryMetadata), !1, [ categoryAxisOptions.includeDomain ]) : yAxisDomainOptions,
                        metaDataColumn: isXAxis ? data.categoryMetadata : data.valuesMetadata,
                        axisZoom: void 0,
                        zeroScalarDomain: isYAxis ? WaterfallChart.DefaultZeroScalarDomain : void 0,
                        isScalar: isYAxis,
                        isVertical: isYAxis,
                        isCategoryAxis: isXAxis,
                        formatString: null !== (_a = cartesianAxisHelper.getAxisFormatString(isXAxis ? [] : _this.data.series)) && void 0 !== _a ? _a : (0, 
                        valueFormatter.EO)(isXAxis ? data.categoryMetadata : data.valuesMetadata[0], cartesian_capabilities.p.general.formatString),
                        outerPadding: isYAxis ? 0 : layout.categoryThickness * layout.outerPaddingRatio,
                        outerPaddingRatio: isYAxis ? 0 : layout.outerPaddingRatio,
                        innerPaddingRatio: isYAxis ? void 0 : options.innerPaddingRatio,
                        categoryThickness: isYAxis ? void 0 : layout.categoryThickness,
                        forcedTickCount: options.forcedTickCount,
                        axis: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, axisOptions.axis), {
                            invertAxis: axisOptions.axis.invertAxis && isYAxis
                        }),
                        preventNice: cartesianAxisHelper.hasForcedDomain(isXAxis ? axisOptions.includeDomain : yAxisDomainOptions),
                        useTickIntervalForDisplayUnits: !!isYAxis || void 0,
                        getValueFn: isXAxis ? function(index, type) {
                            return WaterfallChart.lookupXValue(data, index, type);
                        } : void 0
                    });
                    return isXAxis && (axisProperties.outerPaddingRatio = layout.outerPaddingRatio, 
                    data.categoryIdentities && (axisProperties.categoryIdentities = data.categoryIdentities)), 
                    axisProperties;
                };
                this.xAxisProperties = computeAxis("x"), this.yAxisProperties = computeAxis("y");
                var labelUnitsAndPrecision = (0, dataLabelRendererEnhanced.d6)(this.yAxisProperties, data.dataLabelsSettings), formattersCache = (0, 
                dataLabelViewModel1.fI)(), categoryWidth = this.xAxisProperties.categoryThickness * (1 - options.innerPaddingRatio);
                return this.layout = {
                    categoryCount: layout.categoryCount,
                    categoryThickness: layout.categoryThickness,
                    isScalar: layout.isScalar,
                    outerPaddingRatio: layout.outerPaddingRatio,
                    categoryWidth,
                    labelText: function(d) {
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, data.dataLabelsSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!d.labelFormatString, data.series[d.seriesIndex].type));
                        return (0, dataLabelViewModel1.Gv)({
                            label: formatter.format(d.value)
                        });
                    },
                    labelLayout: WaterfallChart.getLabelLayoutXYForWaterfall(this.xAxisProperties, categoryWidth, this.yAxisProperties, null == yAxisDomainOptions ? void 0 : yAxisDomainOptions.domain),
                    filter: function(d) {
                        return WaterfallChart.doesDataLabelFitInShape(d, _this.yAxisProperties, _this.layout);
                    },
                    style: {
                        fill: function(d) {
                            return d.isLabelInside ? common_colorHelper.v.getThemeColor(_this.style, dataLabelViewModel1Consts.pl) : d.labelFill;
                        }
                    }
                }, [ this.xAxisProperties, this.yAxisProperties ];
            }, WaterfallChart.getLabelLayoutXYForWaterfall = function(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                return {
                    x: function(d) {
                        return xAxisProperties.scale(d.categoryIndex) + categoryWidth / 2;
                    },
                    y: function(d) {
                        return WaterfallChart.getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain);
                    }
                };
            }, WaterfallChart.getWaterfallLabelYPosition = function(scale, d, dataDomain) {
                var yValue = scale(0) - scale(Math.abs(d.value)), yPos = scale(d.position), scaleMinDomain = scale(dataDomain[0]), endPosition = scale(d.position + d.value);
                if (d.value < 0) {
                    var outsideBelowPosition = yPos + yValue + textMeasurementService.b.estimateSvgTextHeight({
                        text: d.labelText,
                        fontFamily: dataLabelViewModel1Consts.bN.fontFamily,
                        fontSize: dataLabelViewModel1Consts.bN.fontSize,
                        fontWeight: dataLabelViewModel1Consts.bN.fontWeight
                    });
                    if (scaleMinDomain > outsideBelowPosition) return outsideBelowPosition;
                } else {
                    var outsideAbovePosition = yPos - yValue - dataLabelViewModel1Consts.FJ;
                    if (outsideAbovePosition > 0) return outsideAbovePosition;
                }
                return d.isLabelInside = !0, WaterfallChart.getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
            }, WaterfallChart.getWaterfallInsideLabelYPosition = function(startPosition, endPosition, scaleMinDomain) {
                return startPosition = (startPosition = startPosition < 0 ? 0 : startPosition) > scaleMinDomain ? scaleMinDomain : startPosition, 
                endPosition = (endPosition = endPosition < 0 ? 0 : endPosition) > scaleMinDomain ? scaleMinDomain : endPosition, 
                Math.abs(endPosition - startPosition) / 2 + Math.min(startPosition, endPosition);
            }, WaterfallChart.prototype.getAxesDomains = function(_includeZero, requestedDomains) {
                var axesDomains = {}, data = this.activeData;
                return data ? (requestedDomains.valueAxis && (axesDomains.valueAxis = [ data.positionMin, data.positionMax ]), 
                axesDomains) : axesDomains;
            }, WaterfallChart.lookupXValue = function(data, index, type) {
                var dataPoints = data.series[0].data;
                return index === dataPoints.length - 1 ? dataPoints[index].categoryValue : (0, cartesianHelper.dZ)(data, index, dataPoints[index].type || type, !1);
            }, WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function() {
                return !1;
            }, WaterfallChart.prototype.setFilteredData = function(startIndex, endIndex) {
                var data = this.clippedData = (0, Prototype.ED)(this.data);
                data.series = [ {
                    data: data.series[0].data.slice(startIndex, endIndex)
                } ], data.categories = data.categories.slice(startIndex, endIndex);
            }, WaterfallChart.prototype.render = function(suppressAnimations, _, formatMode) {
                return render.call(this, suppressAnimations, formatMode);
            }, WaterfallChart.prototype.getSupportedCategoryAxisType = function() {
                return axisType.w.categorical;
            }, WaterfallChart.prototype.getFirstElement = function() {
                return _.isEmpty(this.clippedData.series) || _.isEmpty(this.clippedData.series[0].data) ? {
                    element: null
                } : {
                    element: this.getHTMLElementFromCategoryIndex(this.clippedData.series[0].data[0].categoryIndex)
                };
            }, WaterfallChart.prototype.getNextDataPoint = function(categoryIndex, _seriesIndex, direction) {
                var nextDataPoint, startIndex = categoryIndex;
                do {
                    switch (direction) {
                      case services_interactivityService.x0.NextCategory:
                        categoryIndex += 1, ((this.isTotalsEnabled() || this.data.isBreakdown) && categoryIndex >= this.data.categories.length || !this.isTotalsEnabled() && !this.data.isBreakdown && categoryIndex >= this.data.categories.length - 1) && (categoryIndex = 0);
                        break;

                      case services_interactivityService.x0.PreviousCategory:
                        (categoryIndex -= 1) < 0 && (categoryIndex = this.isTotalsEnabled() || this.data.isBreakdown ? this.data.categories.length - 1 : this.data.categories.length - 2);
                        break;

                      case services_interactivityService.x0.NextSeries:
                      case services_interactivityService.x0.PreviousSeries:
                        break;

                      default:
                        debug.fF.assertNever(direction);
                    }
                    nextDataPoint = this.data.series[_seriesIndex].data[categoryIndex];
                } while (nextDataPoint && 0 === nextDataPoint.value && startIndex !== categoryIndex);
                return {
                    element: this.getHTMLElementFromCategoryIndex(categoryIndex),
                    targetCategoryIndex: categoryIndex
                };
            }, WaterfallChart.prototype.getHTMLElementFromCategoryIndex = function(categoryIndex) {
                return this.mainGraphicsContext.selectAll(CategoryValueClasses.selector).filter(function(d) {
                    return d.categoryIndex === categoryIndex;
                }).node();
            }, WaterfallChart.prototype.getSentimentColorsFromObjects = function(objects) {
                var colorHelper = common_colorHelper.v.create(this.style);
                return {
                    increaseFill: {
                        solid: {
                            color: colorHelper.getColorForPropertyWithDefaultColor(objects, waterfallChart_capabilities.wW.sentimentColors.increaseFill, common_colorHelper.v.getSentimentColor(this.style, "good"))
                        }
                    },
                    decreaseFill: {
                        solid: {
                            color: colorHelper.getColorForPropertyWithDefaultColor(objects, waterfallChart_capabilities.wW.sentimentColors.decreaseFill, common_colorHelper.v.getSentimentColor(this.style, "bad"))
                        }
                    },
                    totalFill: {
                        solid: {
                            color: colorHelper.getColorForPropertyWithDefaultColor(objects, waterfallChart_capabilities.wW.sentimentColors.totalFill, common_colorHelper.v.getDataColorByIndex(this.style, 0))
                        }
                    },
                    otherFill: {
                        solid: {
                            color: colorHelper.getColorForPropertyWithDefaultColor(objects, waterfallChart_capabilities.wW.sentimentColors.otherFill, common_colorHelper.v.getSentimentColor(this.style, "neutral"))
                        }
                    }
                };
            }, WaterfallChart.prototype.createLabelDataPoints = function() {
                for (var _a, scale, pos, value, labelDataPoints = [], data = this.data, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, yInverted = this.yAxisProperties.invertAxis, y0 = yScale(0), series = data.series, formattersCache = (0, 
                dataLabelViewModel1.fI)(), labelSettings = data.dataLabelsSettings, labelUnitsAndPrecision = (0, 
                dataLabelRendererEnhanced.d6)(this.yAxisProperties, labelSettings), _i = 0, series_1 = series; _i < series_1.length; _i++) for (var currentSeries = series_1[_i], _b = 0, _c = currentSeries.data; _b < _c.length; _b++) {
                    var dataPoint = _c[_b], formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, this.data.dataLabelsSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!formatString, currentSeries.type)), text = (0, 
                    dataLabelUtil.Bw)(formatter.format(dataPoint.value)), fontProperties = labelSettings.fontProperties, textProperties = (0, 
                    common_fontProperties.qk)(fontProperties, text);
                    labelDataPoints.push({
                        isPreferred: !0,
                        text,
                        textSize: {
                            width: textMeasurementService.b.measureSvgTextWidth(textProperties),
                            height: textMeasurementService.b.estimateSvgTextHeight(textProperties, !0)
                        },
                        outsideFill: null !== (_a = dataPoint.labelFill) && void 0 !== _a ? _a : common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.uQ),
                        insideFill: common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.pl),
                        parentType: 1,
                        parentShape: {
                            rect: {
                                left: xScale(dataPoint.categoryIndex),
                                top: yInverted ? (scale = yScale, pos = dataPoint.position, value = dataPoint.value, 
                                value < 0 ? scale(pos) - (scale(0) - scale(value)) : scale(pos)) : getRectTop(yScale, dataPoint.position, dataPoint.value),
                                width: this.layout.categoryWidth,
                                height: Math.abs(y0 - yScale(Math.abs(dataPoint.value)))
                            },
                            orientation: dataPoint.value >= 0 ? yInverted ? 2 : 1 : yInverted ? 1 : 2,
                            validPositions: WaterfallChart.getValidPositions(labelSettings.position, dataPoint.value)
                        },
                        fontProperties,
                        identity: void 0,
                        hasBackground: labelSettings.enableBackground,
                        backgroundColor: labelSettings.backgroundColor,
                        backgroundTransparency: labelSettings.backgroundTransparency
                    });
                }
                return labelDataPoints;
            }, WaterfallChart.getValidPositions = function(position, value) {
                if (0 === value) return WaterfallChart.validZeroLabelPosition;
                switch (position) {
                  case labelPosition1.h.insideEnd:
                    return [ 4 ];

                  case labelPosition1.h.insideCenter:
                    return [ 1 ];

                  case labelPosition1.h.insideBase:
                    return [ 2 ];

                  case labelPosition1.h.outsideEnd:
                    return [ 16 ];

                  default:
                    return [ 16, 4, 1, 2 ];
                }
            }, WaterfallChart.prototype.getCartesianVisualCapabilities = function() {
                return {
                    supportsHierarchicalCategoryAxis: !1
                };
            }, WaterfallChart.prototype.getStaticSeriesRole = function() {}, WaterfallChart.DefaultZeroScalarDomain = [ 0, 1 ], 
            WaterfallChart.DefaultBreakdowns = 5, WaterfallChart.WaterfallClassName = "waterfallChart", 
            WaterfallChart.MainGraphicsContextClassName = "mainGraphicsContext", WaterfallChart.validZeroLabelPosition = [ 16, 8 ], 
            WaterfallChart;
        }(ResponsiveCartesianLayer);
        function createLayerAdapter(options, layerType) {
            return {
                create: function(createOptions) {
                    return options.viewModelAdapterFactory.createLayerAdapter(layerType, createOptions);
                }
            };
        }
        var createColumnChart = function(options) {
            return new ColumnChart((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                columnChartType: function(t) {
                    switch (t) {
                      case 14:
                      case 5:
                        return 20;

                      case 13:
                      case 4:
                        return 12;

                      case 9:
                        return 52;

                      case 7:
                        return 18;

                      case 6:
                        return 10;

                      case 8:
                        return 50;

                      case 10:
                        return 84;

                      default:
                        return debug.fF.assertFail("Not supported"), 20;
                    }
                }(options.chartType),
                isComboChart: (0, cartesianHelper.LQ)(options.chartType),
                viewModelAdapterFactory: createLayerAdapter(options, 4)
            }));
        }, createLineChart = function(options) {
            return new LineChart((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                lineChartType: function(t) {
                    switch (t) {
                      case 0:
                      case 13:
                      case 14:
                        return 1;

                      case 3:
                        return 32;

                      case 1:
                        return 2;

                      case 2:
                        return 16;

                      default:
                        return debug.fF.assertFail("Not supported"), 1;
                    }
                }(options.chartType),
                isComboChart: (0, cartesianHelper.LQ)(options.chartType),
                viewModelAdapterFactory: createLayerAdapter(options, 0)
            }));
        }, dataViewConcatenateCategoricalColumns = __webpack_require__(42359), CartesianBoundReferenceLinesServiceInstance = new (function() {
            function CartesianBoundReferenceLinesService() {}
            return CartesianBoundReferenceLinesService.prototype.getDataBoundReferenceLines = function(layerDataView, layer, layerStyle) {
                var referenceLines = [], metadataColumns = [];
                if (layerDataView) if (layerDataView.matrix && layerDataView.matrix.valueSources) {
                    var matrix = layerDataView.matrix;
                    if (matrix.valueSources && metadataColumns.push.apply(metadataColumns, layerDataView.matrix.valueSources || []), 
                    matrix.rows && matrix.rows.levels) for (var _i = 0, _a = matrix.rows.levels; _i < _a.length; _i++) metadataColumns.push.apply(metadataColumns, _a[_i].sources || []);
                } else if (layerDataView.categorical && layerDataView.categorical.values) {
                    var columnGroup = _.head(layerDataView.categorical.values.grouped());
                    if (columnGroup) for (var _b = 0, _c = columnGroup.values; _b < _c.length; _b++) metadataColumns.push(_c[_b].source);
                }
                for (var i = 0; i < metadataColumns.length; i++) {
                    var metadataColumn = metadataColumns[i], defaultColor = common_colorHelper.v.getDataColorByIndex(layerStyle, i, colorHelper.fA), dataBoundReferenceLines = (0, 
                    dataViewObject2.AO)(metadataColumn.objects, "referenceLine"), axisLocation = this.getCartesianRoleKind(metadataColumn, layer);
                    referenceLines.push.apply(referenceLines, (0, referenceLineHelper1.UL)(dataBoundReferenceLines, defaultColor, "referenceLine", axisLocation, layerStyle, void 0, metadataColumn) || []);
                }
                return referenceLines;
            }, CartesianBoundReferenceLinesService.prototype.getCartesianRoleKind = function(column, layer) {
                var dataRoles = column.roles;
                if (layer.getAxisLocationForRole && dataRoles) for (var roleName in dataRoles) if (dataRoles[roleName]) return layer.getAxisLocationForRole(roleName);
                return 1;
            }, CartesianBoundReferenceLinesService;
        }()), CartesianChartConverter = function() {
            function CartesianChartConverter() {}
            return CartesianChartConverter.convert = function(options) {
                var _a, dataViews = options.dataViews, layers = options.layers, layerStyle = options.layerStyle, chartType = options.chartType, hasDataChanged = options.hasDataChanged, allowLegendWithNoSeries = layers.length > 1 && !!(dataViews[0] && dataViews[0].categorical && dataViews[0].categorical.values), sharedColorPalette = layerStyle.colorPalette.dataColors;
                sharedColorPalette.clearPreferredScale();
                for (var layerDataViews = getLayerDataViews(dataViews), forecastDataViews = _.filter(dataViews, forecastHelper1.Aq), trendLineDataViews = _.filter(dataViews, trendLineHelper.Qp), anomalyDetectionDataViews = _.filter(dataViews, anomalyDetection_converter.Ik), trendLines = [], referenceLines = [], layerLegendData = [], i = 0, layerCount = layers.length; i < layerCount; i++) {
                    var layerDataView = layerDataViews[i], currentLayerDataViews = layerDataView ? [ layerDataView ] : [];
                    if (null != forecastDataViews[i] && currentLayerDataViews.push(forecastDataViews[i]), 
                    null != anomalyDetectionDataViews[i] && currentLayerDataViews.push(anomalyDetectionDataViews[i]), 
                    layers[i].setData(currentLayerDataViews, options.multipleInfo), layerLegendData.push(getLegendDataForLayer(layers[i], layerDataView, layerStyle, allowLegendWithNoSeries, chartType)), 
                    referenceLines.push.apply(referenceLines, CartesianBoundReferenceLinesServiceInstance.getDataBoundReferenceLines(layerDataView, layers[i], layerStyle) || []), 
                    supportsTrendLines(dataViews, layers, i)) {
                        var trendLineDataView = trendLineDataViews[i];
                        if (trendLineDataView) {
                            var layerTrendLines = (0, trendLineHelper.VP)(trendLineDataView, layerDataView, i > 0, layerStyle);
                            trendLines.push.apply(trendLines, layerTrendLines || []);
                        }
                    }
                    layerCount > 1 && sharedColorPalette.rotateScale();
                }
                var axesData, zoomData = AxisZoom.converter(_.head(dataViews));
                if (_.isEmpty(dataViews)) axesData = new AxesData({
                    style: layerStyle,
                    chartType
                }); else {
                    var dataView = dataViews[0], hasScalarKeys = dataView.metadata && !_.isEmpty(null === (_a = dataView.categorical) || void 0 === _a ? void 0 : _a.categories) && !!(0, 
                    scalarUtils.A8)(dataView.categorical.categories[0]), isScatterChart = 11 === chartType;
                    axesData = new AxesData({
                        chartType,
                        valueAxisProperties: (0, cartesianHelper.$w)(dataView.metadata, isScatterChart),
                        y2AxisProperties: (0, cartesianHelper.$w)(dataView.metadata, isScatterChart, "y2Axis"),
                        categoryAxisProperties: (0, cartesianHelper.Vk)(dataView.metadata, hasScalarKeys || isScatterChart),
                        isValueAxisIrregular: isValueAxisIrregular(dataViews, layers),
                        style: layerStyle,
                        hasY2Role: (0, dataRoleHelper.c5)(dataView, "Y2") || dataViews[1] && (0, dataRoleHelper.c5)(dataViews[1], "Y2"),
                        forceShowY2: zoomData.show && zoomData.showOnValueSecAxis || !_.isEmpty(options.multipleInfo) && (0, 
                        cartesianHelper.LQ)(chartType),
                        seriesLabelSettings: getSeriesLabelSettings(layers, chartType, layerStyle),
                        featureSwitches: options.featureSwitches
                    }), hasDataChanged && function(dataViews, referenceLines, layerStyle, layers, chartType) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            if (dataViewMetadata) {
                                var isXReferenceLineSupported = supportsStaticReferenceLines(dataViews, layers);
                                referenceLines.push.apply(referenceLines, function(dataViewMetadata, layerStyle, isXReferenceLineSupported, chartType) {
                                    var defaultColor = common_colorHelper.v.getDataColorByIndex(layerStyle, 0, colorHelper.fA), referenceLines = [];
                                    if (isXReferenceLineSupported) {
                                        var xAxisReferenceLines = (0, dataViewObject2.AO)(dataViewMetadata.objects, referenceLineHelper1.XC);
                                        referenceLines.push.apply(referenceLines, (0, referenceLineHelper1.UL)(xAxisReferenceLines, defaultColor, referenceLineHelper1.XC, 0, layerStyle, chartType, void 0) || []);
                                    }
                                    var y1AxisReferenceLines = (0, dataViewObject2.AO)(dataViewMetadata.objects, referenceLineHelper1.Dk);
                                    return referenceLines.push.apply(referenceLines, (0, referenceLineHelper1.UL)(y1AxisReferenceLines, defaultColor, referenceLineHelper1.Dk, 1, layerStyle) || []), 
                                    referenceLines;
                                }(dataViewMetadata, layerStyle, isXReferenceLineSupported, chartType) || []);
                            }
                        }
                    }(dataViews, referenceLines, layerStyle, layers, options.chartType);
                }
                return {
                    legendData: (0, legend_converter.nh)(layerLegendData, layerStyle),
                    trendLines,
                    referenceLines,
                    axesData,
                    warningObjectCollection: new visualWarnings.tb,
                    showIcon: !1,
                    scrollbarOptions: {
                        scrollbarWidth: ScrollableAxes.ScrollbarWidth
                    },
                    zoomData
                };
            }, CartesianChartConverter;
        }();
        function getLegendDataForLayer(layer, layerDataView, layerStyle, allowLegendWithNoSeries, chartType) {
            var layerLegendData = layer.getLegendData();
            if ((null == layerLegendData ? void 0 : layerLegendData.dataPoints.length) > 1) return layerLegendData;
            var defaultLegendData = (0, legend_converter.pq)({
                dataView: layerDataView,
                showByDefault: !0,
                staticSeriesRoleNames: [ layer.getStaticSeriesRole() ],
                style: layerStyle,
                allowLegendWithNoSeries
            }, function(chartType) {
                return 4 === chartType || 6 === chartType || 5 === chartType || 7 === chartType || 9 === chartType || 8 === chartType || 11 === chartType || 10 === chartType;
            }(chartType));
            return !layerLegendData || (null == defaultLegendData ? void 0 : defaultLegendData.isGradientLegend) ? defaultLegendData : layerLegendData;
        }
        var CartesianSmallMultipleUpdateFactory = function() {
            function CartesianSmallMultipleUpdateFactory(staticUpdateOptions) {
                this.staticUpdateOptions = staticUpdateOptions;
            }
            return CartesianSmallMultipleUpdateFactory.prototype.create = function(updateOptions) {
                return new CartesianSmallMultipleUpdate(this.staticUpdateOptions, updateOptions);
            }, CartesianSmallMultipleUpdateFactory;
        }(), CartesianSmallMultipleUpdate = function() {
            function CartesianSmallMultipleUpdate(staticUpdateOptions, updateOptions) {
                this.staticUpdateOptions = staticUpdateOptions, this.updateOptions = updateOptions;
            }
            return CartesianSmallMultipleUpdate.prototype.apply = function(multiple, type) {
                var _a, multipleDataViews, _b = this.staticUpdateOptions, layerInitDataOptions = _b.layerInitDataOptions, updateGlobalAxesDomains = _b.updateGlobalAxesDomains, _c = this.updateOptions, isSmallMultiples = _c.isSmallMultiples, reader = _c.reader, dataViews = _c.dataViews, updateOptions = _c.updateOptions, requestedPerMultipleAxisDomains = _c.requestedPerMultipleAxisDomains;
                if (isSmallMultiples) {
                    multipleDataViews = (0, cartesianHelper.LQ)(type) ? reader.convertComboFrame(multiple.index) : [ reader.convertFrame(multiple.index) ];
                    for (var previousConcatenatedCategories = void 0, i = 0; i < multipleDataViews.length; i++) {
                        var dataView = multipleDataViews[i], concatenatedDataView = (0, dataViewConcatenateCategoricalColumns.eC)(dataView.metadata, dataViewObjectProperties.e0.formatString, cartesian_capabilities.x.category, dataView.categorical, !!previousConcatenatedCategories);
                        previousConcatenatedCategories ? concatenatedDataView.categorical.categories = previousConcatenatedCategories : previousConcatenatedCategories = null === (_a = concatenatedDataView.categorical) || void 0 === _a ? void 0 : _a.categories, 
                        multipleDataViews[i] = concatenatedDataView;
                    }
                } else multipleDataViews = dataViews;
                multiple.hasInitializedData() || multiple.initData(layerInitDataOptions);
                var multipleUpdateOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, updateOptions), {
                    dataViews: multipleDataViews,
                    multipleInfo: isSmallMultiples ? this.buildMultipleInfo(multiple.index) : void 0
                });
                multiple.update(multipleUpdateOptions), requestedPerMultipleAxisDomains && (requestedPerMultipleAxisDomains.categoryAxis || requestedPerMultipleAxisDomains.valueAxis || requestedPerMultipleAxisDomains.secondaryValueAxis) && updateGlobalAxesDomains(multiple.getAxesDomains(!0, requestedPerMultipleAxisDomains));
            }, CartesianSmallMultipleUpdate.prototype.applySynchronizedAxes = function(multiple, domains) {
                var isSmallMultiples = this.updateOptions.isSmallMultiples;
                debug.fF.assert(function() {
                    return isSmallMultiples;
                }, "Should not apply synchronizedAxes to non-small multiples"), multiple.applySynchronizedDomains(domains);
            }, CartesianSmallMultipleUpdate.prototype.applyResize = function(multiple) {
                multiple.resize(this.updateOptions.updateOptions.viewport);
            }, CartesianSmallMultipleUpdate.prototype.buildMultipleInfo = function(index) {
                var _this = this;
                debug.fF.assert(function() {
                    return _this.updateOptions.isSmallMultiples;
                }, "isSmallMultiples"), debug.fF.assert(function() {
                    return !!_this.updateOptions.reader;
                }, "reader");
                var reader = this.updateOptions.reader;
                if (reader) {
                    var frameNode = reader.getFrameNode(index), sources = reader.getFrameSourceColumns().map(function(metadata, i) {
                        return {
                            metadata,
                            value: frameNode.levelValues[i].value
                        };
                    });
                    return {
                        identity: frameNode.identity,
                        sources,
                        isCoreMultiple: 0 === index
                    };
                }
            }, CartesianSmallMultipleUpdate;
        }(), CartesianSmallMultiple = function() {
            function CartesianSmallMultiple(smallMultiples, index, featureSwitches, layers, type, interactivityService, getLayerInitOptions) {
                this.smallMultiples = smallMultiples, this.index = index, this.featureSwitches = featureSwitches, 
                this.layers = layers, this.type = type, this.interactivityService = interactivityService, 
                this.getLayerInitOptions = getLayerInitOptions, this.state = 0;
            }
            return CartesianSmallMultiple.create = function(smallMultiples, index, featureSwitches, interactivityService, layers, type, getLayerInitOptions) {
                return new CartesianSmallMultiple(smallMultiples, index, featureSwitches, layers, type, interactivityService, getLayerInitOptions);
            }, CartesianSmallMultiple.prototype.getDataPoint = function() {
                if (!this.dataPoint) {
                    var multipleInfo_1 = this.multipleInfo, multipleQueryName = _.first(multipleInfo_1.sources).metadata.queryName, multipleValueDetails = multipleInfo_1.sources.map(function(source) {
                        return (0, selection_selectionId.Y)(source.metadata, source.value, multipleInfo_1.identity);
                    }), selectionId = (new selection_selectionId.dw).withColumnIdentity(multipleInfo_1.identity, multipleQueryName, multipleValueDetails).createSelectionId();
                    this.dataPoint = {
                        selected: !1,
                        identity: selectionId
                    }, this.interactivityService && this.interactivityService.applySelectionStateToData([ this.dataPoint ]);
                }
                return this.dataPoint;
            }, CartesianSmallMultiple.prototype.getIndex = function() {
                return this.index;
            }, CartesianSmallMultiple.prototype.isSelected = function() {
                return this.getDataPoint().selected;
            }, CartesianSmallMultiple.prototype.getState = function() {
                return this.state;
            }, CartesianSmallMultiple.prototype.initRenderer = function(renderer) {
                var _this = this;
                debug.fF.assert(function() {
                    return !(2 & _this.getState());
                }, "`initRenderer` was called when there was already a renderer"), this.renderer = renderer;
                var layerInitOptions = this.getLayerInitOptions(renderer);
                this.layers.forEach(function(layer) {
                    return layer.initRenderer(layerInitOptions);
                }), this.state |= 2;
            }, CartesianSmallMultiple.prototype.getRenderer = function() {
                var _this = this;
                return debug.fF.assert(function() {
                    return !!(2 & _this.getState());
                }, "`getRenderer` was called before a renderer was set"), this.renderer;
            }, CartesianSmallMultiple.prototype.initData = function(initOptions) {
                var _this = this;
                debug.fF.assert(function() {
                    return !(1 & _this.getState());
                }, "`initData` multiple times"), this.layers.forEach(function(layer) {
                    var _a;
                    return null === (_a = layer.initData) || void 0 === _a ? void 0 : _a.call(layer, initOptions);
                }), this.style = initOptions.style, this.state |= 1;
            }, CartesianSmallMultiple.prototype.update = function(options) {
                var _this = this;
                debug.fF.assert(function() {
                    return !!(1 & _this.getState());
                }, "update was called before `initData`"), this.dataViews = options.dataViews, this.multipleInfo = options.multipleInfo, 
                this.dataPoint = void 0, this.adapterFactory = options.adapterFactory;
                var layers = this.layers;
                return this.responsiveData = void 0, this.data = CartesianChartConverter.convert({
                    layerStyle: this.style,
                    chartType: this.type,
                    dataViews: options.dataViews,
                    layers,
                    featureSwitches: this.featureSwitches,
                    hasDataChanged: null != options.operationKind,
                    multipleInfo: options.multipleInfo
                }), this.data;
            }, CartesianSmallMultiple.prototype.isVisible = function() {
                return !!(2 & this.state);
            }, CartesianSmallMultiple.prototype.hasInitializedData = function() {
                return !!(1 & this.state);
            }, CartesianSmallMultiple.prototype.getMultipleInfo = function() {
                return this.multipleInfo;
            }, CartesianSmallMultiple.prototype.applySynchronizedDomains = function(axesDomains) {
                var axesData = this.data && this.data.axesData;
                if (axesDomains && axesData) {
                    var applyIncludeDomain = function(domain, axisData) {
                        domain && axisData.includeDomains.push((0, cartesianAxisHelper.createScalarDomainOptions)(domain, 1));
                    }, categoryAxisData = axesData.categoryAxis, valueAxisData = axesData.valueAxis, secondaryValueAxisData = axesData.secondaryValueAxis, valueAxisDomain = axesDomains.valueAxis, secondaryValueAxisDomain = axesDomains.secondaryValueAxis;
                    applyIncludeDomain(axesDomains.categoryAxis, categoryAxisData), !categoryAxisData || !valueAxisData || !categoryAxisData.sharedAxis && categoryAxisData.scaleToFit || !valueAxisData.sharedAxis && valueAxisData.scaleToFit || (applyIncludeDomain(valueAxisDomain, valueAxisData), 
                    applyIncludeDomain(secondaryValueAxisDomain, secondaryValueAxisData));
                }
            }, CartesianSmallMultiple.prototype.resize = function(newViewport) {
                if (this.adapterFactory && this.data) {
                    var adapter = this.adapterFactory.createCartesianAdapter({
                        cartesianData: this.data,
                        dataView: this.dataViews[0],
                        viewport: newViewport,
                        isCoreMultiple: !this.multipleInfo || this.multipleInfo.isCoreMultiple
                    });
                    this.responsiveData = adapter.getData();
                }
            }, CartesianSmallMultiple.prototype.getCapabilities = function() {
                var categoryAxisCapabilities = {
                    domainAggregateRoles: [],
                    supportedDomainAggregates: void 0
                }, valueAxisCapabilities = {
                    domainAggregateRoles: [],
                    supportedDomainAggregates: void 0
                }, secondaryValueAxisCapabilities = {
                    domainAggregateRoles: [],
                    supportedDomainAggregates: void 0
                };
                return this.layers.forEach(function(layer) {
                    var capabilities = layer.getCartesianVisualCapabilities();
                    if (capabilities.axesCapabilities) {
                        var _a = capabilities.axesCapabilities, layerCategoryAxisCapabilities = _a.categoryAxis, layerValueAxisCapabilities = _a.valueAxis, layerSecondaryValueAxisCapabilities = _a.secondaryValueAxis, mergeAxisCapabilities = function(axisCapabilities, multipleAxisCapabilities) {
                            axisCapabilities && axisCapabilities.domainAggregateRole && (multipleAxisCapabilities.domainAggregateRoles.push(axisCapabilities.domainAggregateRole), 
                            void 0 === multipleAxisCapabilities.supportedDomainAggregates ? multipleAxisCapabilities.supportedDomainAggregates = axisCapabilities.supportedDomainAggregates : multipleAxisCapabilities.supportedDomainAggregates &= axisCapabilities.supportedDomainAggregates);
                        };
                        debug.fF.assertValue(layerCategoryAxisCapabilities, "layerCategoryAxisCapabilities"), 
                        mergeAxisCapabilities(layerCategoryAxisCapabilities, categoryAxisCapabilities), 
                        mergeAxisCapabilities(layerValueAxisCapabilities, valueAxisCapabilities), mergeAxisCapabilities(layerSecondaryValueAxisCapabilities, secondaryValueAxisCapabilities);
                    } else debug.fF.log("All small-multiples layers must provide `axesCapabilities`");
                }), {
                    axesCapabilities: {
                        categoryAxis: _.isEmpty(categoryAxisCapabilities.domainAggregateRoles) ? void 0 : (0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryAxisCapabilities), {
                            domainAggregateRoles: _.uniq(categoryAxisCapabilities.domainAggregateRoles)
                        }),
                        valueAxis: _.isEmpty(valueAxisCapabilities.domainAggregateRoles) ? void 0 : (0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, valueAxisCapabilities), {
                            domainAggregateRoles: _.uniq(valueAxisCapabilities.domainAggregateRoles)
                        }),
                        secondaryValueAxis: _.isEmpty(secondaryValueAxisCapabilities.domainAggregateRoles) ? void 0 : (0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, secondaryValueAxisCapabilities), {
                            domainAggregateRoles: _.uniq(secondaryValueAxisCapabilities.domainAggregateRoles)
                        })
                    }
                };
            }, CartesianSmallMultiple.prototype.getAxesDomains = function(includeZero, requestedDomains) {
                for (var axesDomains = {}, i = 0; i < this.layers.length; i++) {
                    var layer = this.layers[i];
                    if (layer.getAxesDomains) {
                        var layerAxesDomains = layer.getAxesDomains(includeZero, requestedDomains);
                        layerAxesDomains.categoryAxis && (axesDomains.categoryAxis = (0, cartesianAxisHelper.mergeDomains)(axesDomains.categoryAxis || cartesianHelper.be, layerAxesDomains.categoryAxis)), 
                        layerAxesDomains.valueAxis && (i > 0 && (0, cartesianHelper.LQ)(this.type) ? axesDomains.secondaryValueAxis = (0, 
                        cartesianAxisHelper.mergeDomains)(axesDomains.secondaryValueAxis || cartesianHelper.be, layerAxesDomains.valueAxis) : axesDomains.valueAxis = (0, 
                        cartesianAxisHelper.mergeDomains)(axesDomains.valueAxis || cartesianHelper.be, layerAxesDomains.valueAxis)), 
                        layerAxesDomains.secondaryValueAxis && (axesDomains.secondaryValueAxis = (0, cartesianAxisHelper.mergeDomains)(axesDomains.secondaryValueAxis || cartesianHelper.be, layerAxesDomains.secondaryValueAxis));
                    } else debug.fF.assertFail("getAxesDomains does not exist");
                }
                return axesDomains;
            }, CartesianSmallMultiple.prototype.getData = function() {
                return this.responsiveData || this.data;
            }, CartesianSmallMultiple.prototype.clearSelection = function() {
                for (var i = 0, len = this.layers.length; i < len; i++) this.layers[i].onClearSelection();
            }, CartesianSmallMultiple.prototype.updateLayers = function() {
                this.layers.forEach(function(layer) {
                    return layer.render(!0);
                });
            }, CartesianSmallMultiple.prototype.destroy = function() {
                var _this = this;
                this.renderer && (debug.fF.assert(function() {
                    return !!(2 & _this.getState());
                }, "`destroy` was called before we had a renderer"), this.renderer.destroy());
            }, CartesianSmallMultiple;
        }(), dataViewMultipleReader = __webpack_require__(54365), CartesianSmallMultiples = function() {
            function CartesianSmallMultiples(type, featureSwitches, layerFactory, getLayerInitRendererOptions) {
                this.type = type, this.featureSwitches = featureSwitches, this.layerFactory = layerFactory, 
                this.getLayerInitRendererOptions = getLayerInitRendererOptions, this.multiples = [];
            }
            return CartesianSmallMultiples.prototype.init = function(layerInitDataOptions, interactivityService) {
                var _this = this;
                this.rowLoadMoreDataHandler = new loadMoreDataHandler.J(layerInitDataOptions.host), 
                this.updateFactory = new CartesianSmallMultipleUpdateFactory({
                    layerInitDataOptions,
                    updateGlobalAxesDomains: function(axesDomains) {
                        return _this.updateGlobalAxesDomains(axesDomains);
                    }
                }), this.interactivityService = interactivityService, this.multiples = [];
            }, CartesianSmallMultiples.prototype.getObjects = function() {
                return this.reader ? this.reader.getObjects() : void 0;
            }, CartesianSmallMultiples.prototype.getCoreMultiple = function() {
                return this.coreMultiple || (this.coreMultiple = CartesianSmallMultiple.create(this, 0, this.featureSwitches, this.interactivityService, this.layerFactory(), this.type, this.getLayerInitRendererOptions)), 
                this.coreMultiple;
            }, CartesianSmallMultiples.prototype.getShouldResetRowMultipleScrollPosition = function() {
                return this.shouldResetRowMultipleScrollPosition;
            }, CartesianSmallMultiples.prototype.get = function(index) {
                var _this = this;
                if (debug.fF.assert(function() {
                    return _this.isSmallMultiples() || 0 === index;
                }, "Non-small multiples only supports 0 index"), !this.isSmallMultiples()) return this.getCoreMultiple();
                if (debug.fF.assertValue(this.multipleUpdate, "Can not get multiple value before having an update"), 
                null == this.multipleUpdate) return this.getCoreMultiple();
                var multiple = this.multiples[index];
                if (!multiple) for (var _loop_1 = function(currentIndex) {
                    debug.fF.assert(function() {
                        return currentIndex === _this.multiples.length;
                    }, "Multiples should only be added to the end"), multiple = this_1.multiples[currentIndex] = CartesianSmallMultiple.create(this_1, currentIndex, this_1.featureSwitches, this_1.interactivityService, this_1.layerFactory(), this_1.type, this_1.getLayerInitRendererOptions);
                    var multipleUpdate = this_1.multipleUpdate;
                    multipleUpdate.apply(multiple, this_1.type), this_1.isSmallMultiples() && multipleUpdate.applySynchronizedAxes(multiple, this_1.axesDomains), 
                    multipleUpdate.applyResize(multiple);
                }, this_1 = this, currentIndex = this.multiples.length; currentIndex <= index; currentIndex++) _loop_1(currentIndex);
                return multiple;
            }, CartesianSmallMultiples.prototype.clear = function() {
                this.getMultiples(!0).forEach(function(multiple) {
                    return multiple.destroy();
                }), this.multiples = [], this.coreMultiple = void 0, this.axesDomains = void 0, 
                this.shouldResetRowMultipleScrollPosition = void 0, this.multipleUpdate = void 0;
            }, CartesianSmallMultiples.prototype.resize = function(newViewport) {
                this.getMultiples(!0).forEach(function(m) {
                    return m.resize(newViewport);
                });
            }, CartesianSmallMultiples.prototype.update = function(updateOptions) {
                var numMultiples, dataViews = updateOptions.dataViews;
                this.updateOptions = updateOptions;
                var isSmallMultiples = this.isSmallMultiples(dataViews);
                this.shouldResetRowMultipleScrollPosition = !updateOptions.preserveScrollPosition;
                var coreMultiple = this.getCoreMultiple();
                isSmallMultiples ? (this.reader = dataViewMultipleReader.p.create(dataViews[0], dataViewObjectProperties.e0.formatString), 
                this.updateFactory.create({
                    dataViews: updateOptions.dataViews,
                    isSmallMultiples,
                    reader: this.reader,
                    requestedPerMultipleAxisDomains: void 0,
                    updateOptions
                }).apply(coreMultiple, this.type), updateOptions.preserveScrollPosition && !updateOptions.formatMode || (this.lastUpdatedFrameIndex = 0, 
                this.axesDomains = void 0, this.requestPerMultipleAxisDomains = this.updateSynchronizedDomainsFromAggregates()), 
                numMultiples = this.reader.getFrameCount(), this.rowLoadMoreDataHandler.updateDataView(updateOptions.dataViews[0]), 
                this.rowLoadMoreDataHandler.onLoadMoreDataCompleted()) : (this.reader = void 0, 
                this.lastUpdatedFrameIndex = 0, this.axesDomains = void 0, numMultiples = 1, this.rowLoadMoreDataHandler.updateDataView(void 0), 
                this.rowLoadMoreDataHandler.onLoadMoreDataCompleted()), this.multipleUpdate = this.updateFactory.create({
                    dataViews: updateOptions.dataViews,
                    isSmallMultiples,
                    reader: this.reader,
                    requestedPerMultipleAxisDomains: this.requestPerMultipleAxisDomains,
                    updateOptions
                }), this.updateMultiples(numMultiples);
            }, CartesianSmallMultiples.prototype.updateMultiples = function(numMultiples) {
                for (var _this = this, multiples = this.multiples, multipleUpdate = this.multipleUpdate, isSmallMultiples = this.isSmallMultiples(this.updateOptions.dataViews), coreMultiple = this.getCoreMultiple(), requestPerMultipleAxisDomains = this.requestPerMultipleAxisDomains, range = {
                    startIndex: this.lastUpdatedFrameIndex,
                    endIndex: numMultiples
                }, _loop_2 = function(index) {
                    var multiple = isSmallMultiples ? multiples[index] : coreMultiple;
                    !multiple && requestPerMultipleAxisDomains && (debug.fF.assert(function() {
                        return index === multiples.length;
                    }, "Multiples should only be added to the end"), multiple = multiples[index] = CartesianSmallMultiple.create(this_2, index, this_2.featureSwitches, this_2.interactivityService, this_2.layerFactory(), this_2.type, this_2.getLayerInitRendererOptions)), 
                    multiple && multipleUpdate.apply(multiple, this_2.type);
                }, this_2 = this, index = range.startIndex; index < range.endIndex; index++) _loop_2(index);
                this.getMultiples(!0).forEach(function(multiple) {
                    multiple && (isSmallMultiples && multipleUpdate.applySynchronizedAxes(multiple, _this.axesDomains), 
                    multipleUpdate.applyResize(multiple));
                }), this.lastUpdatedFrameIndex = range.endIndex;
            }, CartesianSmallMultiples.prototype.updateSynchronizedDomainsFromAggregates = function() {
                var _a, axesDomains, coreMultiple = this.getCoreMultiple(), axesCapabilities = coreMultiple.getCapabilities().axesCapabilities, categoryAxisCapabilities = axesCapabilities.categoryAxis, valueAxisCapabilities = axesCapabilities.valueAxis, secondaryValueAxisCapabilities = axesCapabilities.secondaryValueAxis, supportsTopLevelAggregates_categoryAxis = !!(2 & categoryAxisCapabilities.supportedDomainAggregates), supportsTopLevelAggregates_valueAxis = !!(2 & valueAxisCapabilities.supportedDomainAggregates), supportsTopLevelAggregates_secondaryValueAxis = !!(secondaryValueAxisCapabilities && 2 & secondaryValueAxisCapabilities.supportedDomainAggregates), supportsLocalAggregates = {
                    categoryAxis: !!(1 & categoryAxisCapabilities.supportedDomainAggregates),
                    valueAxis: !!(1 & valueAxisCapabilities.supportedDomainAggregates),
                    secondaryValueAxis: !!(secondaryValueAxisCapabilities && 1 & secondaryValueAxisCapabilities.supportedDomainAggregates)
                };
                if (supportsTopLevelAggregates_categoryAxis || supportsTopLevelAggregates_valueAxis || supportsTopLevelAggregates_secondaryValueAxis) {
                    var topLevelDomains = this.getTopLevelDomains(axesCapabilities);
                    topLevelDomains && (axesDomains = {
                        categoryAxis: supportsTopLevelAggregates_categoryAxis ? topLevelDomains.categoryAxis : void 0,
                        valueAxis: supportsTopLevelAggregates_valueAxis ? topLevelDomains.valueAxis : void 0,
                        secondaryValueAxis: supportsTopLevelAggregates_secondaryValueAxis ? topLevelDomains.secondaryValueAxis : void 0
                    });
                }
                this.axesDomains = axesDomains;
                var coreAxesData = null === (_a = coreMultiple.getData()) || void 0 === _a ? void 0 : _a.axesData, sharedAxis = coreAxesData && !coreAxesData.valueAxis.sharedAxis, requestPerMultipleAxisDomains = {
                    categoryAxis: supportsLocalAggregates.categoryAxis && (!axesDomains || _.isEmpty(axesDomains.categoryAxis)),
                    valueAxis: supportsLocalAggregates.valueAxis && (!axesDomains || _.isEmpty(axesDomains.valueAxis) || sharedAxis),
                    secondaryValueAxis: supportsLocalAggregates.secondaryValueAxis && (!axesDomains || _.isEmpty(axesDomains.secondaryValueAxis))
                };
                return _.every(requestPerMultipleAxisDomains, function(request) {
                    return !request;
                }) ? void 0 : requestPerMultipleAxisDomains;
            }, CartesianSmallMultiples.prototype.isSmallMultiples = function(dataViews) {
                return !(!dataViews && !this.updateOptions) && (0, cartesianHelper.sI)(dataViews = dataViews || this.updateOptions.dataViews);
            }, CartesianSmallMultiples.prototype.clearSelection = function(visibleMultiples) {
                this.getMultiples(!0).forEach(function(multiple) {
                    return multiple.clearSelection();
                }), this.executeActionForMultiplesInRange(function(multiple) {
                    return multiple.updateLayers();
                }, visibleMultiples, !1);
            }, CartesianSmallMultiples.prototype.checkIfNoLabelsCanBeRendered = function() {
                return _.every(this.getMultiples(), function(multiple) {
                    return multiple.isVisible() && multiple.getRenderer().noLabelsCanBeRendered;
                });
            }, CartesianSmallMultiples.prototype.scrollTo = function(position, visibleMultiples) {
                this.executeActionForMultiplesInRange(function(multiple) {
                    return multiple.getRenderer().axesRenderer.scrollTo(position);
                }, visibleMultiples, !1);
            }, CartesianSmallMultiples.prototype.shouldScrollTo = function(position, visibleMultiples) {
                return !!this.getValueForFirstMultipleInRange(function(multiple) {
                    return multiple.getRenderer().axesRenderer.shouldScrollTo(position);
                }, visibleMultiples, !1);
            }, CartesianSmallMultiples.prototype.scrollBy = function(steps, visibleMultiples) {
                this.executeActionForMultiplesInRange(function(multiple) {
                    return multiple.getRenderer().axesRenderer.scrollBy(steps);
                }, visibleMultiples, !1);
            }, CartesianSmallMultiples.prototype.scrollDelta = function(delta, visibleMultiples) {
                this.executeActionForMultiplesInRange(function(multiple) {
                    return multiple.getRenderer().axesRenderer.scrollDelta(delta);
                }, visibleMultiples, !1);
            }, CartesianSmallMultiples.prototype.clearRenderingTimeout = function() {
                this.getMultiples().forEach(function(multiple) {
                    return multiple.isVisible() && multiple.getRenderer().axesRenderer.clearRenderingTimeout();
                });
            }, CartesianSmallMultiples.prototype.updateScrollbarExtent = function(extent, visibleMultiples) {
                this.executeActionForMultiplesInRange(function(multiple) {
                    return multiple.getRenderer().axesRenderer.setExtent(extent);
                }, visibleMultiples, !1);
            }, CartesianSmallMultiples.prototype.executeActionForMultiplesInRange = function(action, range, includeCoreMultiple) {
                var multiples = this.getMultiples(includeCoreMultiple, range);
                _.isEmpty(multiples) || multiples.forEach(function(multiple) {
                    return action(multiple);
                });
            }, CartesianSmallMultiples.prototype.getValueForFirstMultipleInRange = function(action, range, includeCoreMultiple) {
                var multiples = this.getMultiples(includeCoreMultiple, range);
                if (!_.isEmpty(multiples)) return action(multiples[0]);
            }, CartesianSmallMultiples.prototype.getFrameCount = function() {
                return this.isSmallMultiples() ? this.reader.getFrameCount() : 1;
            }, CartesianSmallMultiples.prototype.updateGlobalAxesDomains = function(newMultipleAxesDomains) {
                var axesDomains = this.axesDomains = this.axesDomains || {};
                newMultipleAxesDomains.categoryAxis && (axesDomains.categoryAxis = (0, cartesianAxisHelper.mergeDomains)(axesDomains.categoryAxis || cartesianHelper.be, newMultipleAxesDomains.categoryAxis)), 
                newMultipleAxesDomains.valueAxis && (axesDomains.valueAxis = (0, cartesianAxisHelper.mergeDomains)(axesDomains.valueAxis || cartesianHelper.be, newMultipleAxesDomains.valueAxis)), 
                newMultipleAxesDomains.secondaryValueAxis && (axesDomains.secondaryValueAxis = (0, 
                cartesianAxisHelper.mergeDomains)(axesDomains.secondaryValueAxis || cartesianHelper.be, newMultipleAxesDomains.secondaryValueAxis));
            }, CartesianSmallMultiples.prototype.getTopLevelDomains = function(axesCapabilities) {
                var reader = this.reader;
                debug.fF.assertValue(reader, "this.reader");
                var categoryAxisDomain, valueAxisDomain, secondaryValueAxisDomain, categoryAxisCapabilities = axesCapabilities.categoryAxis, valueAxisCapabilities = axesCapabilities.valueAxis, secondaryValueAxisCapabilities = axesCapabilities.secondaryValueAxis, mergeAggregates = function(aggregatesMap) {
                    var valueDomain = [ Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY ];
                    for (var role in aggregatesMap) for (var _loop_3 = function(aggregate) {
                        var min = aggregate.min, max = aggregate.max;
                        if (!(_.isDate(min) || _.isNumber(min) && isFinite(min)) || !(_.isDate(max) || _.isNumber(max) && isFinite(max))) return "continue";
                        debug.fF.assert(function() {
                            return !_.isDate(min) || (0, dateWithEpochValue.M4)(min);
                        }, "If min is a date, it should implement DateWithEpochValue"), debug.fF.assert(function() {
                            return !_.isDate(max) || (0, dateWithEpochValue.M4)(max);
                        }, "If max is a date, it should implement DateWithEpochValue"), (0, dateWithEpochValue.M4)(min) && (0, 
                        dateWithEpochValue.M4)(max) && (min = min.epochTimeStamp, max = max.epochTimeStamp), 
                        valueDomain = (0, cartesianAxisHelper.mergeDomains)(valueDomain, [ +min, +max ]);
                    }, _i = 0, aggregates_1 = aggregatesMap[role]; _i < aggregates_1.length; _i++) _loop_3(aggregates_1[_i]);
                    return valueDomain;
                };
                if (2 & categoryAxisCapabilities.supportedDomainAggregates) {
                    var categoryAxisAggregates = reader.getTopLevelAggregates(categoryAxisCapabilities.domainAggregateRoles);
                    categoryAxisDomain = categoryAxisAggregates ? mergeAggregates(categoryAxisAggregates) : void 0;
                }
                if (2 & valueAxisCapabilities.supportedDomainAggregates) {
                    var valueAxisAggregates = reader.getTopLevelAggregates(valueAxisCapabilities.domainAggregateRoles);
                    valueAxisDomain = valueAxisAggregates ? mergeAggregates(valueAxisAggregates) : void 0;
                }
                if (secondaryValueAxisCapabilities && 2 & secondaryValueAxisCapabilities.supportedDomainAggregates) {
                    var secondaryValueAxisAggregates = secondaryValueAxisCapabilities && reader.getTopLevelAggregates(secondaryValueAxisCapabilities.domainAggregateRoles);
                    secondaryValueAxisDomain = secondaryValueAxisAggregates ? mergeAggregates(secondaryValueAxisAggregates) : void 0;
                }
                return categoryAxisDomain || valueAxisDomain || secondaryValueAxisDomain ? {
                    categoryAxis: categoryAxisDomain,
                    valueAxis: valueAxisDomain,
                    secondaryValueAxis: secondaryValueAxisDomain
                } : void 0;
            }, CartesianSmallMultiples.prototype.getMultiples = function(includeCoreMultiple, range) {
                void 0 === includeCoreMultiple && (includeCoreMultiple = !1);
                var multiples = [], isSmallMultiples = this.isSmallMultiples();
                if (!isSmallMultiples || includeCoreMultiple) {
                    var coreMultiple = this.getCoreMultiple();
                    coreMultiple && multiples.push(coreMultiple);
                }
                if (isSmallMultiples) {
                    var multiplesInRange = this.multiples;
                    range && (multiplesInRange = multiplesInRange.slice(range.startIndex, Math.min(range.endIndex, multiplesInRange.length))), 
                    multiples.push.apply(multiples, multiplesInRange);
                }
                return multiples;
            }, CartesianSmallMultiples;
        }(), viewModelAdapterUtils = __webpack_require__(30053), ResponsiveCartesianFontBreakpoints_size = [ {
            breakpoint: 240,
            maxSizePt: 9
        }, {
            breakpoint: 320,
            maxSizePt: 12
        }, {
            breakpoint: 460,
            maxSizePt: 16
        }, {
            breakpoint: 540,
            maxSizePt: 24
        } ], ResponsiveCartesianFontHelper = function() {
            function ResponsiveCartesianFontHelper() {
                this.lastViewportSeen = void 0, this.lastResolvedFontSizePt = void 0;
            }
            return ResponsiveCartesianFontHelper.prototype.adjustFontSize = function(viewport, originalFontProperties) {
                var maxFontSizePt = this.resolveMaxFontSizePtForViewport(viewport);
                return maxFontSizePt >= originalFontProperties.size.pt ? originalFontProperties : this.copyWithNewFontSize(originalFontProperties, maxFontSizePt);
            }, ResponsiveCartesianFontHelper.prototype.getFontSizeSeriesLabelWarning = function(originalData, currentData) {
                var labelWarning = this.getFontSizeLabelWarning(originalData.dataLabelsSettings, currentData.dataLabelsSettings);
                if (labelWarning) return labelWarning;
                if (originalData.series && currentData.series) {
                    debug.fF.assert(function() {
                        return originalData.series.length === currentData.series.length;
                    }, "Series are expected to be equal");
                    for (var originalSeries = originalData.series, currentSeries = currentData.series, i = 0; i < originalSeries.length; i++) if (labelWarning = this.getFontSizeLabelWarning(originalSeries[i].labelSettings, currentSeries[i].labelSettings)) return labelWarning;
                }
            }, ResponsiveCartesianFontHelper.prototype.getFontSizeLabelWarning = function(originalLabelSettings, currentLabelSettings) {
                if (originalLabelSettings && currentLabelSettings) {
                    if (!_.isEqual(originalLabelSettings.fontProperties.size, currentLabelSettings.fontProperties.size)) return {
                        selector: null,
                        warnings: [ new visualWarnings.er ]
                    };
                    debug.fF.assert(function() {
                        return originalLabelSettings.labelOverflow === currentLabelSettings.labelOverflow;
                    }, "Overflow switch should remain as is if no changes in label font size");
                } else debug.fF.assert(function() {
                    return originalLabelSettings === currentLabelSettings;
                }, "It's expected that both settings would be undefined / null");
            }, ResponsiveCartesianFontHelper.prototype.resolveMaxFontSizePtForViewport = function(viewport) {
                if (this.lastViewportSeen === viewport) return this.lastResolvedFontSizePt;
                for (var maxFontSizePt = StandaloneUtility1.PR, _i = 0, _a = ResponsiveCartesianFontBreakpoints_size; _i < _a.length; _i++) {
                    var fontSizeBreakpoint = _a[_i];
                    if (viewport.height < fontSizeBreakpoint.breakpoint || viewport.width < fontSizeBreakpoint.breakpoint) {
                        maxFontSizePt = fontSizeBreakpoint.maxSizePt;
                        break;
                    }
                }
                return this.lastViewportSeen = viewport, this.lastResolvedFontSizePt = maxFontSizePt, 
                maxFontSizePt;
            }, ResponsiveCartesianFontHelper.prototype.copyWithNewFontSize = function(originalFontProperties, newFontSizePt) {
                var newFontSize = units.B.createFromPt(newFontSizePt);
                return (0, common_fontProperties.ED)(originalFontProperties, {
                    size: newFontSize
                });
            }, ResponsiveCartesianFontHelper;
        }(), ColumnChartLayerViewModelAdapter = function() {
            function ColumnChartLayerViewModelAdapter(options) {
                this.responsiveFontHelper = new ResponsiveCartesianFontHelper, this.originalData = options.data, 
                this.dataView = options.dataView, this.viewport = options.viewport;
            }
            return ColumnChartLayerViewModelAdapter.prototype.getData = function() {
                var newData, data = this.originalData;
                return newData = viewModelAdapterUtils.a.shouldApplyResponsiveChanges(this.dataView, cartesian_capabilities.p) ? this.applyResponsiveChanges(this.viewport, data) : data, 
                this.currentData = newData, newData;
            }, ColumnChartLayerViewModelAdapter.prototype.getCartesianChartLayerType = function() {
                return 4;
            }, ColumnChartLayerViewModelAdapter.prototype.addWarnings = function(warningObjectCollection) {
                var originalData = this.originalData, currentData = this.currentData;
                if (originalData && currentData) {
                    var labelWarning = this.responsiveFontHelper.getFontSizeSeriesLabelWarning(originalData, currentData), totalWarning = this.responsiveFontHelper.getFontSizeLabelWarning(originalData.totalLabelsSettings, currentData.totalLabelsSettings);
                    labelWarning && warningObjectCollection.addForVisualObject("labels", labelWarning), 
                    totalWarning && warningObjectCollection.addForVisualObject("totals", totalWarning);
                }
            }, ColumnChartLayerViewModelAdapter.prototype.applyResponsiveChanges = function(viewport, data) {
                var updatedData = (0, Prototype.ED)(data);
                return this.applyDataLabelFontSizesChanges(viewport, updatedData), this.applySeriesDataLabelFontSizeChanges(viewport, updatedData), 
                this.applyTotalLabelFontSizesChanges(viewport, updatedData), updatedData;
            }, ColumnChartLayerViewModelAdapter.prototype.applyDataLabelFontSizesChanges = function(viewport, data) {
                data.dataLabelsSettings = (0, Prototype.ED)(data.dataLabelsSettings), this.updateLabelSettings(viewport, data.dataLabelsSettings);
            }, ColumnChartLayerViewModelAdapter.prototype.applySeriesDataLabelFontSizeChanges = function(viewport, data) {
                for (var dataSeries = data.series = (0, Prototype.ED)(data.series), i = 0; i < dataSeries.length; i++) if (dataSeries[i].labelSettings) {
                    var series = dataSeries[i] = (0, Prototype.ED)(dataSeries[i]);
                    series.labelSettings = (0, Prototype.ED)(series.labelSettings), this.updateLabelSettings(viewport, series.labelSettings);
                }
            }, ColumnChartLayerViewModelAdapter.prototype.applyTotalLabelFontSizesChanges = function(viewport, data) {
                data.totalLabelsSettings && (data.totalLabelsSettings = (0, Prototype.ED)(data.totalLabelsSettings), 
                this.updateLabelSettings(viewport, data.totalLabelsSettings));
            }, ColumnChartLayerViewModelAdapter.prototype.updateLabelSettings = function(viewport, labelSettings) {
                var oldFontProperties = labelSettings.fontProperties;
                labelSettings.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, labelSettings.fontProperties), 
                oldFontProperties !== labelSettings.fontProperties && (labelSettings.labelOverflow = !0);
            }, ColumnChartLayerViewModelAdapter;
        }(), LineChartLayerViewModelAdapter = function() {
            function LineChartLayerViewModelAdapter(options) {
                this.responsiveFontHelper = new ResponsiveCartesianFontHelper, this.originalData = options.data, 
                this.viewport = options.viewport, this.dataView = options.dataView;
            }
            return LineChartLayerViewModelAdapter.prototype.getData = function() {
                var newData, data = this.originalData;
                return newData = viewModelAdapterUtils.a.shouldApplyResponsiveChanges(this.dataView, cartesian_capabilities.p) ? this.applyResponsiveChanges(this.viewport, data) : data, 
                this.currentData = newData, newData;
            }, LineChartLayerViewModelAdapter.prototype.getCartesianChartLayerType = function() {
                return 0;
            }, LineChartLayerViewModelAdapter.prototype.addWarnings = function(warningObjectCollection) {
                var originalData = this.originalData, currentData = this.currentData;
                if (originalData && currentData) {
                    var labelWarning = this.responsiveFontHelper.getFontSizeSeriesLabelWarning(originalData, currentData), totalWarning = this.responsiveFontHelper.getFontSizeLabelWarning(originalData.totalLabelsSettings, currentData.totalLabelsSettings);
                    labelWarning && warningObjectCollection.addForVisualObject("labels", labelWarning), 
                    totalWarning && warningObjectCollection.addForVisualObject("totals", totalWarning);
                }
            }, LineChartLayerViewModelAdapter.prototype.applyResponsiveChanges = function(viewport, data) {
                var updatedData = (0, Prototype.ED)(data);
                return this.applyDataLabelFontSizesChanges(viewport, updatedData), this.applySeriesDataLabelFontSizeChanges(viewport, updatedData), 
                this.applyTotalLabelFontSizesChanges(viewport, updatedData), updatedData;
            }, LineChartLayerViewModelAdapter.prototype.applyDataLabelFontSizesChanges = function(viewport, data) {
                data.dataLabelsSettings = (0, Prototype.ED)(data.dataLabelsSettings), this.updateLabelSettings(viewport, data.dataLabelsSettings);
            }, LineChartLayerViewModelAdapter.prototype.applySeriesDataLabelFontSizeChanges = function(viewport, data) {
                for (var dataSeries = data.series = (0, Prototype.ED)(data.series), i = 0; i < dataSeries.length; i++) if (dataSeries[i].labelSettings) {
                    var series = dataSeries[i] = (0, Prototype.ED)(dataSeries[i]);
                    series.labelSettings = (0, Prototype.ED)(series.labelSettings), this.updateLabelSettings(viewport, series.labelSettings);
                }
            }, LineChartLayerViewModelAdapter.prototype.applyTotalLabelFontSizesChanges = function(viewport, data) {
                data.totalLabelsSettings && (data.totalLabelsSettings = (0, Prototype.ED)(data.totalLabelsSettings), 
                this.updateLabelSettings(viewport, data.totalLabelsSettings));
            }, LineChartLayerViewModelAdapter.prototype.updateLabelSettings = function(viewport, labelSettings) {
                labelSettings.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, labelSettings.fontProperties);
            }, LineChartLayerViewModelAdapter;
        }(), ScatterChartLayerViewModelAdapter = function() {
            function ScatterChartLayerViewModelAdapter(options) {
                this.responsiveFontHelper = new ResponsiveCartesianFontHelper, this.originalData = options.data, 
                this.viewport = options.viewport, this.dataView = options.dataView;
            }
            return ScatterChartLayerViewModelAdapter.prototype.getData = function() {
                var newData, data = this.originalData;
                return newData = viewModelAdapterUtils.a.shouldApplyResponsiveChanges(this.dataView, cartesian_capabilities.p) ? this.applyResponsiveChanges(this.viewport, data) : data, 
                this.currentData = newData, newData;
            }, ScatterChartLayerViewModelAdapter.prototype.getCartesianChartLayerType = function() {
                return 2;
            }, ScatterChartLayerViewModelAdapter.prototype.addWarnings = function(warningObjectCollection) {
                var originalData = this.originalData, currentData = this.currentData;
                if (originalData && currentData) {
                    var labelWarning = this.responsiveFontHelper.getFontSizeLabelWarning(originalData.dataLabelsSettings, currentData.dataLabelsSettings);
                    labelWarning && warningObjectCollection.addForVisualObject("categoryLabels", labelWarning);
                }
            }, ScatterChartLayerViewModelAdapter.prototype.applyResponsiveChanges = function(viewport, data) {
                var updatedData = (0, Prototype.ED)(data);
                return this.applyDataLabelFontSizesChanges(viewport, updatedData), updatedData;
            }, ScatterChartLayerViewModelAdapter.prototype.applyDataLabelFontSizesChanges = function(viewport, data) {
                data.dataLabelsSettings = (0, Prototype.ED)(data.dataLabelsSettings), data.dataLabelsSettings.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, data.dataLabelsSettings.fontProperties);
            }, ScatterChartLayerViewModelAdapter;
        }(), WaterfallChartLayerViewModelAdapter = function() {
            function WaterfallChartLayerViewModelAdapter(options) {
                this.responsiveFontHelper = new ResponsiveCartesianFontHelper, this.originalData = options.data, 
                this.viewport = options.viewport, this.dataView = options.dataView;
            }
            return WaterfallChartLayerViewModelAdapter.prototype.getData = function() {
                var newData, data = this.originalData;
                return newData = viewModelAdapterUtils.a.shouldApplyResponsiveChanges(this.dataView, cartesian_capabilities.p) ? this.applyResponsiveChanges(this.viewport, data) : data, 
                this.currentData = newData, newData;
            }, WaterfallChartLayerViewModelAdapter.prototype.getCartesianChartLayerType = function() {
                return 3;
            }, WaterfallChartLayerViewModelAdapter.prototype.addWarnings = function(warningObjectCollection) {
                var originalData = this.originalData, currentData = this.currentData;
                if (originalData && currentData) {
                    var labelWarning = this.responsiveFontHelper.getFontSizeLabelWarning(originalData.dataLabelsSettings, currentData.dataLabelsSettings);
                    labelWarning && warningObjectCollection.addForVisualObject("labels", labelWarning);
                }
            }, WaterfallChartLayerViewModelAdapter.prototype.applyResponsiveChanges = function(viewport, data) {
                var updatedData = (0, Prototype.ED)(data);
                return this.applyDataLabelFontSizesChanges(viewport, updatedData), updatedData;
            }, WaterfallChartLayerViewModelAdapter.prototype.applyDataLabelFontSizesChanges = function(viewport, data) {
                data.dataLabelsSettings = (0, Prototype.ED)(data.dataLabelsSettings), data.dataLabelsSettings.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, data.dataLabelsSettings.fontProperties);
            }, WaterfallChartLayerViewModelAdapter;
        }(), CartesianLayerViewModelAdapter = function() {
            function CartesianLayerViewModelAdapter(layerType, options) {
                switch (this.layerType = layerType, layerType) {
                  case 4:
                    this.adapter = new ColumnChartLayerViewModelAdapter(options);
                    break;

                  case 0:
                    this.adapter = new LineChartLayerViewModelAdapter(options);
                    break;

                  case 2:
                    this.adapter = new ScatterChartLayerViewModelAdapter(options);
                    break;

                  case 3:
                    this.adapter = new WaterfallChartLayerViewModelAdapter(options);
                    break;

                  default:
                    debug.fF.assertFail("Unsupported chart type for view model adapter");
                }
            }
            return CartesianLayerViewModelAdapter.prototype.getData = function() {
                return this.adapter.getData();
            }, CartesianLayerViewModelAdapter.prototype.getCartesianChartLayerType = function() {
                return this.layerType;
            }, CartesianLayerViewModelAdapter.prototype.addWarnings = function(warningObjectCollection) {
                return this.adapter.addWarnings(warningObjectCollection);
            }, CartesianLayerViewModelAdapter;
        }(), types_legendPosition = __webpack_require__(70700);
        function updatePlotResponsiveWarnings(cartesianData, originalCartesianData) {
            var warningObjectCollection = cartesianData.warningObjectCollection, warnings = {}, legendData = cartesianData.legendData, originalLegendData = originalCartesianData.legendData;
            if (cartesianData.showIcon) warnings.legend = new visualWarnings.ni, warnings.categoryAxis = new visualWarnings.Mk, 
            warnings.valueAxis = new visualWarnings.Mk; else {
                legendData.show !== originalLegendData.show ? warnings.legend = new visualWarnings.ni : legendData.position !== originalLegendData.position ? warnings.legend = new visualWarnings.TS : _.isEqual(legendData.fontProperties.size, originalLegendData.fontProperties.size) || (warnings.legend = new visualWarnings.p7("fontSize"));
                var axesData = cartesianData.axesData, originalAxesData = originalCartesianData.axesData, categoryAxisData = axesData.categoryAxis, originalCategoryAxisData = originalAxesData.categoryAxis, isCategoryAxisLabelWarning = !_.isEqual(categoryAxisData.labelFontProperties.size, originalCategoryAxisData.labelFontProperties.size), isCategoryAxisTitleWarning = !_.isEqual(categoryAxisData.titleFontProperties.size, originalCategoryAxisData.titleFontProperties.size);
                categoryAxisData.show !== originalCategoryAxisData.show ? warnings.categoryAxis = new visualWarnings.Mk : categoryAxisData.showAxisTitle !== originalCategoryAxisData.showAxisTitle ? warnings.categoryAxis = new visualWarnings.fk : (isCategoryAxisLabelWarning || isCategoryAxisTitleWarning) && (warnings.categoryAxis = new visualWarnings.Dr(isCategoryAxisLabelWarning ? "fontSize" : "titleFontSize"));
                var valueAxisData = axesData.valueAxis, originalValueAxisData = originalAxesData.valueAxis, isValueAxisLabelWarning = !_.isEqual(valueAxisData.labelFontProperties.size, originalValueAxisData.labelFontProperties.size), isValueAxisTitleWarning = !_.isEqual(valueAxisData.titleFontProperties.size, originalValueAxisData.titleFontProperties.size);
                valueAxisData.show !== originalValueAxisData.show ? warnings.valueAxis = new visualWarnings.Mk : valueAxisData.showAxisTitle !== originalValueAxisData.showAxisTitle ? warnings.valueAxis = new visualWarnings.fk : (isValueAxisLabelWarning || isValueAxisTitleWarning) && (warnings.valueAxis = new visualWarnings.Dr(isValueAxisLabelWarning ? "fontSize" : "titleFontSize"));
                var zoomData = cartesianData.zoomData, originalZoomData = originalCartesianData.zoomData;
                zoomData.showOnCategoryAxis === originalZoomData.showOnCategoryAxis && zoomData.showOnValueAxis === originalZoomData.showOnValueAxis && zoomData.showOnValueSecAxis === originalZoomData.showOnValueSecAxis || (warnings.zoom = new visualWarnings.JG);
            }
            for (var key in warnings) warningObjectCollection.addForVisualObject(key, {
                selector: null,
                warnings: [ warnings[key] ]
            });
        }
        var CartesianViewModelAdapter = function() {
            function CartesianViewModelAdapter(options) {
                this.viewport = options.viewport, this.cartesianData = options.cartesianData, this.dataView = options.dataView, 
                this.responsiveFontHelper = new ResponsiveCartesianFontHelper;
            }
            return CartesianViewModelAdapter.prototype.getData = function() {
                var responsiveVisualProperties = viewModelAdapterUtils.a.getResponsiveVisualProperties(this.dataView, cartesian_capabilities.p), isResponsiveVisual = responsiveVisualProperties.responsive, isResponsiveLegacyVisual = responsiveVisualProperties.responsiveLegacy, newData = this.cartesianData;
                return (isResponsiveVisual || isResponsiveLegacyVisual) && (newData = this.createResponsiveData(isResponsiveVisual, isResponsiveLegacyVisual)), 
                newData;
            }, CartesianViewModelAdapter.prototype.getResponsiveSlice = function(dataView, localize) {
                var generalProps = cartesian_capabilities.p.general, responsiveVisualProperties = viewModelAdapterUtils.a.getResponsiveVisualProperties(dataView, cartesian_capabilities.p);
                return {
                    item: new build_control_util.vi({
                        uidBuilder: new build_control_util.IN(new build_control_util.SS(new build_control_util.lg("visualPlaceholderCard"), "visualPlaceholderGroup"), "responsive"),
                        control: new build_control_util.bd({
                            descriptor: generalProps.responsive,
                            value: responsiveVisualProperties.responsive
                        }).build(),
                        localize
                    }).build(),
                    revertToDefaultDescriptors: [ generalProps.responsive ]
                };
            }, CartesianViewModelAdapter.prototype.createResponsiveData = function(isResponsiveVisual, isResponsiveLegacyVisual) {
                var cartesianData = viewModelAdapterUtils.a.cloneData(this.cartesianData);
                return isResponsiveVisual ? (this.applyIconResponsiveChanges(cartesianData), this.applyLegendResponsiveChanges(this.viewport, cartesianData.legendData.position, cartesianData), 
                this.applyAxesResponsiveChanges(this.viewport, cartesianData), this.applyZoomSliderResponsiveChanges(this.viewport, cartesianData), 
                this.applyFontSizesChanges(this.viewport, cartesianData), cartesianData.scrollbarOptions = CartesianViewModelAdapter.ScrollbarOptions) : isResponsiveLegacyVisual && function(viewport, cartesianData) {
                    !function(viewport, cartesianData) {
                        var cartesianAxesData = cartesianData.axesData;
                        if (viewport.height <= 58 && (cartesianAxesData.x.showAxisTitle = !1, cartesianAxesData.y.showAxisTitle = !1, 
                        cartesianAxesData.y2.showAxisTitle = !1), viewport.width <= 128 && (cartesianAxesData.y.showAxisTitle = !1, 
                        cartesianAxesData.y2.showAxisTitle = !1), viewport.height <= 58 && (cartesianAxesData.x.show = !1), 
                        viewport.width <= 76 && (cartesianAxesData.y.show = !1, cartesianAxesData.y2.show = !1), 
                        viewport.width <= 128 && (0, legend_util.cB)(cartesianData.legendData.position) && (cartesianAxesData.y.show = !1, 
                        cartesianAxesData.y2.show = !1), viewport.width <= 180) {
                            var newSizesPx = {
                                x: {
                                    tickLabels: cartesianHelper.CI,
                                    title: cartesianHelper.CI
                                },
                                y: {
                                    tickLabels: cartesianHelper.lc,
                                    title: cartesianHelper.lc
                                },
                                y2: {
                                    tickLabels: cartesianHelper.lc,
                                    title: cartesianHelper.lc
                                }
                            };
                            viewport.width <= 128 && (newSizesPx.y.tickLabels = cartesianHelper.yo, newSizesPx.y.title = cartesianHelper.yo, 
                            newSizesPx.y2.tickLabels = cartesianHelper.yo, newSizesPx.y2.title = cartesianHelper.yo), 
                            cartesianAxesData.x.titleFontProperties = (0, common_fontProperties.ED)(cartesianAxesData.x.titleFontProperties, {
                                size: units.B.createFromPx(newSizesPx.x.title)
                            }), cartesianAxesData.y.titleFontProperties = (0, common_fontProperties.ED)(cartesianAxesData.y.titleFontProperties, {
                                size: units.B.createFromPx(newSizesPx.y.title)
                            }), cartesianAxesData.y2.titleFontProperties = (0, common_fontProperties.ED)(cartesianAxesData.y2.titleFontProperties, {
                                size: units.B.createFromPx(newSizesPx.y2.title)
                            }), cartesianAxesData.x.labelFontProperties = (0, common_fontProperties.ED)(cartesianAxesData.x.labelFontProperties, {
                                size: units.B.createFromPx(newSizesPx.x.tickLabels)
                            }), cartesianAxesData.y.labelFontProperties = (0, common_fontProperties.ED)(cartesianAxesData.y.labelFontProperties, {
                                size: units.B.createFromPx(newSizesPx.y.tickLabels)
                            }), cartesianAxesData.y2.labelFontProperties = (0, common_fontProperties.ED)(cartesianAxesData.y2.labelFontProperties, {
                                size: units.B.createFromPx(newSizesPx.y2.tickLabels)
                            });
                        }
                    }(viewport, cartesianData), function(viewport, cartesianData) {
                        var position = cartesianData.legendData.position, isSmallViewportWidth = viewport.width <= 76 && (0, 
                        legend_util.cB)(position), isSmallViewportHeight = viewport.height <= 58 && (0, 
                        legend_util.s0)(position);
                        if ((isSmallViewportWidth || isSmallViewportHeight) && (cartesianData.legendData.show = !1), 
                        viewport.width <= 180) {
                            var minFontSize, sizePt = cartesianData.legendData.fontProperties.size.pt;
                            minFontSize = viewport.width <= 128 ? Math.min(sizePt, legend.hD) : Math.min(sizePt, legend.vs), 
                            cartesianData.legendData.fontProperties = (0, common_fontProperties.ED)(cartesianData.legendData.fontProperties, {
                                size: units.B.createFromPt(minFontSize)
                            });
                        }
                    }(viewport, cartesianData);
                }(this.viewport, cartesianData), updatePlotResponsiveWarnings(cartesianData, this.cartesianData), 
                cartesianData;
            }, CartesianViewModelAdapter.prototype.applyIconResponsiveChanges = function(cartesianData) {
                cartesianData.showIcon = this.viewport.height <= 50 || this.viewport.width <= 50;
            }, CartesianViewModelAdapter.prototype.applyLegendResponsiveChanges = function(viewport, legendPosition, cartesianData) {
                (viewport.width < 210 || viewport.height < 100) && (0, legend_util.cB)(legendPosition) && (cartesianData.legendData.position = types_legendPosition.tV.Top), 
                (viewport.height < 70 || viewport.width < 80) && (cartesianData.legendData.show = !1), 
                cartesianData.legendData.useLargeArrowHitArea = !0;
            }, CartesianViewModelAdapter.prototype.applyAxesResponsiveChanges = function(viewport, cartesianData) {
                viewport.height < 100 && (cartesianData.axesData.x.show = !1), viewport.width < 210 && (cartesianData.axesData.y.showAxisTitle = !1, 
                cartesianData.axesData.y2.showAxisTitle = !1), viewport.width < 100 && (cartesianData.axesData.y.show = !1, 
                cartesianData.axesData.y2.show = !1), viewport.height < 145 && (cartesianData.axesData.x.showAxisTitle = !1);
            }, CartesianViewModelAdapter.prototype.applyZoomSliderResponsiveChanges = function(viewport, cartesianData) {
                (viewport.height < 150 || viewport.width < 280) && (cartesianData.zoomData.showOnCategoryAxis = !1, 
                cartesianData.zoomData.showOnValueAxis = !1, cartesianData.zoomData.showOnValueSecAxis = !1);
            }, CartesianViewModelAdapter.prototype.applyFontSizesChanges = function(viewport, cartesianData) {
                cartesianData.legendData && cartesianData.legendData.fontProperties && (cartesianData.legendData.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, cartesianData.legendData.fontProperties));
                var axesData = cartesianData.axesData;
                axesData.x.labelFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.x.labelFontProperties), 
                axesData.x.titleFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.x.titleFontProperties), 
                axesData.y.labelFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y.labelFontProperties), 
                axesData.y.titleFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y.titleFontProperties), 
                axesData.y2.labelFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y2.labelFontProperties), 
                axesData.y2.titleFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y2.titleFontProperties);
            }, CartesianViewModelAdapter.ScrollbarOptions = {
                scrollbarWidth: 8,
                scrollbarRadius: 4,
                scrollbarClass: "responsive"
            }, CartesianViewModelAdapter;
        }(), SmallMultiplesCartesianViewModelAdapter = function() {
            function SmallMultiplesCartesianViewModelAdapter(options, smallMultiplesOptions) {
                this.smallMultiplesOptions = smallMultiplesOptions, this.cartesianData = options.cartesianData, 
                this.dataView = options.dataView, this.isCoreMultiple = options.isCoreMultiple, 
                this.responsiveFontHelper = new ResponsiveCartesianFontHelper;
            }
            return SmallMultiplesCartesianViewModelAdapter.prototype.getData = function() {
                var newData = this.cartesianData;
                return this.smallMultiplesOptions.isSmallMultiples ? (viewModelAdapterUtils.a.getResponsiveVisualProperties(this.dataView, cartesian_capabilities.p).responsive && (newData = this.applyResponsiveChanges(this.cartesianData, this.smallMultiplesOptions)), 
                newData) : (debug.fF.assertFail("Adapter does not support non-small multiples"), 
                newData);
            }, SmallMultiplesCartesianViewModelAdapter.prototype.getResponsiveSlice = function(_dataView, _localize) {}, 
            SmallMultiplesCartesianViewModelAdapter.prototype.applyResponsiveChanges = function(originalCartesianData, smallMultiplesOptions) {
                var cartesianData = viewModelAdapterUtils.a.cloneData(originalCartesianData), breakpoints = function(smallMultiplesOptions) {
                    var columns = smallMultiplesOptions.columns, rows = smallMultiplesOptions.rows;
                    return {
                        legendPositionHeight: 120 + 30 * rows,
                        legendPositionWidth: 210 + 40 * columns,
                        legendShowHeight: 90 + 30 * rows,
                        legendShowWidth: 90 + 40 * columns,
                        removeXAxisTitleHeight: 165 + 30 * rows,
                        removeXAxisHeight: 120 + 30 * rows,
                        removeYAxisTitleWidth: 210 + 40 * columns,
                        removeYAxisWidth: 120 + 40 * columns
                    };
                }(smallMultiplesOptions), viewport = smallMultiplesOptions.viewport;
                return this.applyAxesResponsiveChanges(breakpoints, viewport, cartesianData), this.applyLegendResponsiveChanges(breakpoints, viewport, cartesianData), 
                this.applyFontSizeResponsiveChanges(viewport, cartesianData), this.isCoreMultiple && updatePlotResponsiveWarnings(cartesianData, originalCartesianData), 
                cartesianData;
            }, SmallMultiplesCartesianViewModelAdapter.prototype.applyAxesResponsiveChanges = function(breakpoints, viewport, cartesianData) {
                var viewportHeight = viewport.height, viewportWidth = viewport.width;
                viewportHeight < breakpoints.removeXAxisTitleHeight && (cartesianData.axesData.x.showAxisTitle = !1), 
                viewportHeight < breakpoints.removeXAxisHeight && (cartesianData.axesData.x.show = !1, 
                cartesianData.axesData.x.showAxisTitle = !1), viewportWidth < breakpoints.removeYAxisTitleWidth && (cartesianData.axesData.y.showAxisTitle = !1, 
                cartesianData.axesData.y2.showAxisTitle = !1), viewportWidth < breakpoints.removeYAxisWidth && (cartesianData.axesData.y.show = !1, 
                cartesianData.axesData.y2.show = !1, cartesianData.axesData.y.showAxisTitle = !1, 
                cartesianData.axesData.y2.showAxisTitle = !1);
            }, SmallMultiplesCartesianViewModelAdapter.prototype.applyLegendResponsiveChanges = function(breakpoints, viewport, cartesianData) {
                if (cartesianData.legendData.show) {
                    var viewportHeight = viewport.height, viewportWidth = viewport.width;
                    (viewportHeight < breakpoints.legendPositionHeight || viewportWidth < breakpoints.legendPositionWidth) && (0, 
                    legend_util.cB)(cartesianData.legendData.position) && (cartesianData.legendData.position = types_legendPosition.tV.Top), 
                    (viewportHeight < breakpoints.legendShowHeight || viewportWidth < breakpoints.legendShowWidth) && (cartesianData.legendData.show = !1), 
                    cartesianData.legendData.useLargeArrowHitArea = !0;
                }
            }, SmallMultiplesCartesianViewModelAdapter.prototype.applyFontSizeResponsiveChanges = function(viewport, cartesianData) {
                cartesianData.legendData && cartesianData.legendData.fontProperties && (cartesianData.legendData.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, cartesianData.legendData.fontProperties));
                var axesData = cartesianData.axesData;
                axesData.x.labelFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.x.labelFontProperties), 
                axesData.x.titleFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.x.titleFontProperties), 
                axesData.y.labelFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y.labelFontProperties), 
                axesData.y.titleFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y.titleFontProperties), 
                axesData.y2.labelFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y2.labelFontProperties), 
                axesData.y2.titleFontProperties = this.responsiveFontHelper.adjustFontSize(viewport, axesData.y2.titleFontProperties);
            }, SmallMultiplesCartesianViewModelAdapter;
        }(), SmallMultiplesLayerViewModelAdapter = function() {
            function SmallMultiplesLayerViewModelAdapter(layerType, options) {
                this.layerType = layerType, this.layerData = options.data;
            }
            return SmallMultiplesLayerViewModelAdapter.prototype.getData = function() {
                return this.layerData;
            }, SmallMultiplesLayerViewModelAdapter.prototype.getCartesianChartLayerType = function() {
                return this.layerType;
            }, SmallMultiplesLayerViewModelAdapter.prototype.addWarnings = function(_warningObjectCollection) {}, 
            SmallMultiplesLayerViewModelAdapter;
        }();
        function interpolateValueFromBreakpoints(breakpoints, outputRange, input) {
            return debug.fF.assert(function() {
                return breakpoints[0] >= breakpoints[1];
            }, "breakpoints must be [max, min]"), debug.fF.assert(function() {
                return outputRange[0] >= outputRange[1];
            }, "outputRange must be [max, min]"), d3.scaleLinear().range(outputRange).domain(breakpoints).clamp(!0)(input);
        }
        function calculateSmallMultiplesViewModelAdapterBreakpoints(multiplesLayout) {
            var rowCount = multiplesLayout.rowCount, columnCount = multiplesLayout.columnCount;
            return {
                showIconHeight: 30 * columnCount,
                showIconWidth: 40 * rowCount,
                showSubheaderHeight: 80 + 50 * rowCount,
                gridlineRowUpperBreakpoint: 120 + 52 * rowCount,
                gridlineRowLowerBreakpoint: 120 + 32 * rowCount,
                gridlineColumnUpperBreakpoint: 120 + 62 * columnCount,
                gridlineColumnLowerBreakpoint: 120 + 42 * columnCount,
                removeGridLineHeight: 32 * rowCount,
                removeGridLineWidth: 42 * columnCount,
                paddingRowUpperBreakpoint: 120 + 130 * rowCount,
                paddingRowLowerBreakpoint: 120 + 30 * rowCount,
                paddingColumnUpperBreakpoint: 120 + 140 * columnCount,
                paddingColumnLowerBreakpoint: 120 + 40 * columnCount
            };
        }
        var SmallMultiplesViewModelAdapter = function() {
            function SmallMultiplesViewModelAdapter(options) {
                this.multiplesLayout = options.multiplesLayout, this.multiplesSubheader = options.multiplesSubheader, 
                this.dataView = options.dataView, this.viewport = options.viewport, this.responsiveFontHelper = new ResponsiveCartesianFontHelper;
            }
            return SmallMultiplesViewModelAdapter.prototype.getMultiplesLayout = function(warnings) {
                var newSmallMultiplesLayout = this.multiplesLayout;
                return viewModelAdapterUtils.a.getResponsiveVisualProperties(this.dataView, cartesian_capabilities.p).responsive && (newSmallMultiplesLayout = this.applyResponsiveChanges(this.viewport, this.multiplesLayout, warnings)), 
                newSmallMultiplesLayout;
            }, SmallMultiplesViewModelAdapter.prototype.getMultiplesSubheader = function(warnings) {
                var newMultiplesSubheader = this.multiplesSubheader;
                return viewModelAdapterUtils.a.getResponsiveVisualProperties(this.dataView, cartesian_capabilities.p).responsive && (newMultiplesSubheader = this.applySubheaderResponsiveChanges(this.viewport, newMultiplesSubheader, warnings)), 
                newMultiplesSubheader;
            }, SmallMultiplesViewModelAdapter.prototype.getResponsiveSlice = function(dataView, localize) {
                var generalProps = cartesian_capabilities.p.general, responsiveVisualProperties = viewModelAdapterUtils.a.getResponsiveVisualProperties(dataView, cartesian_capabilities.p);
                return {
                    item: new build_control_util.vi({
                        uidBuilder: new build_control_util.IN(new build_control_util.SS(new build_control_util.lg("visualPlaceholderCard"), "visualPlaceholderGroup"), "responsive"),
                        control: new build_control_util.bd({
                            descriptor: generalProps.responsive,
                            value: responsiveVisualProperties.responsive
                        }).build(),
                        localize
                    }).build(),
                    revertToDefaultDescriptors: [ generalProps.responsive ]
                };
            }, SmallMultiplesViewModelAdapter.prototype.applyResponsiveChanges = function(viewport, originalSmallMultiplesLayout, warnings) {
                var smallMultiplesLayout = viewModelAdapterUtils.a.cloneData(originalSmallMultiplesLayout), breakpoints = calculateSmallMultiplesViewModelAdapterBreakpoints(smallMultiplesLayout);
                return this.applyIconResponsiveChanges(breakpoints, viewport, smallMultiplesLayout), 
                this.applyGridlinesResponsiveChanges(breakpoints, viewport, smallMultiplesLayout), 
                this.applyPaddingResponsiveChanges(breakpoints, viewport, smallMultiplesLayout), 
                this.updateResponsiveWarnings(smallMultiplesLayout, originalSmallMultiplesLayout, warnings), 
                smallMultiplesLayout;
            }, SmallMultiplesViewModelAdapter.prototype.applyIconResponsiveChanges = function(breakpoints, viewport, smallMultiplesLayout) {
                (viewport.height < breakpoints.showIconHeight || viewport.width < breakpoints.showIconWidth) && (smallMultiplesLayout.showIcon = !0);
            }, SmallMultiplesViewModelAdapter.prototype.applyGridlinesResponsiveChanges = function(breakpoints, viewport, smallMultiplesLayout) {
                var gridline = smallMultiplesLayout.gridline;
                if (null != (null == gridline ? void 0 : gridline.strokeWidth)) {
                    var gridLineWidthColumn = gridline.strokeWidth, gridLineWidthRow = gridline.strokeWidth;
                    viewport.height < breakpoints.removeGridLineHeight || viewport.width < breakpoints.removeGridLineWidth ? gridline.strokeWidth = 0 : viewport.height <= breakpoints.gridlineRowLowerBreakpoint || viewport.width <= breakpoints.gridlineColumnLowerBreakpoint ? gridline.strokeWidth = 1 : (viewport.height < breakpoints.gridlineRowUpperBreakpoint && (gridLineWidthRow = Math.ceil(interpolateValueFromBreakpoints([ breakpoints.gridlineRowUpperBreakpoint, breakpoints.gridlineRowLowerBreakpoint ], [ gridline.strokeWidth, 1 ], viewport.height))), 
                    viewport.width < breakpoints.gridlineColumnUpperBreakpoint && (gridLineWidthColumn = Math.ceil(interpolateValueFromBreakpoints([ breakpoints.gridlineColumnUpperBreakpoint, breakpoints.gridlineColumnLowerBreakpoint ], [ gridline.strokeWidth, 1 ], viewport.width))), 
                    gridline.strokeWidth = Math.min(gridLineWidthColumn, gridLineWidthRow));
                }
            }, SmallMultiplesViewModelAdapter.prototype.applyPaddingResponsiveChanges = function(breakpoints, viewport, smallMultiplesLayout) {
                if (smallMultiplesLayout.advancedPaddingOptions || 0 !== smallMultiplesLayout.gridPadding) {
                    if (viewport.height < breakpoints.paddingRowUpperBreakpoint) {
                        var paddingBreakpoints = [ breakpoints.paddingRowUpperBreakpoint, breakpoints.paddingRowLowerBreakpoint ];
                        smallMultiplesLayout.rowPaddingOuter = smallMultiplesLayout.rowPaddingOuter && Math.ceil(interpolateValueFromBreakpoints(paddingBreakpoints, [ smallMultiplesLayout.rowPaddingOuter, 1 ], viewport.height)), 
                        smallMultiplesLayout.rowPaddingInner = smallMultiplesLayout.rowPaddingInner && Math.ceil(interpolateValueFromBreakpoints(paddingBreakpoints, [ smallMultiplesLayout.rowPaddingInner, 1 ], viewport.height));
                    }
                    viewport.width < breakpoints.paddingColumnUpperBreakpoint && (paddingBreakpoints = [ breakpoints.paddingColumnUpperBreakpoint, breakpoints.paddingColumnLowerBreakpoint ], 
                    smallMultiplesLayout.columnPaddingOuter = smallMultiplesLayout.columnPaddingOuter && Math.ceil(interpolateValueFromBreakpoints(paddingBreakpoints, [ smallMultiplesLayout.columnPaddingOuter, 1 ], viewport.width)), 
                    smallMultiplesLayout.columnPaddingInner = smallMultiplesLayout.columnPaddingInner && Math.ceil(interpolateValueFromBreakpoints(paddingBreakpoints, [ smallMultiplesLayout.columnPaddingInner, 1 ], viewport.width)));
                }
            }, SmallMultiplesViewModelAdapter.prototype.applySubheaderResponsiveChanges = function(viewport, originalMultiplesSubheader, warnings) {
                var multiplesSubheader = viewModelAdapterUtils.a.cloneData(originalMultiplesSubheader), breakpoints = calculateSmallMultiplesViewModelAdapterBreakpoints(this.multiplesLayout);
                return viewport.height < breakpoints.showSubheaderHeight && (multiplesSubheader.show = !1), 
                multiplesSubheader.show && multiplesSubheader.fontProperties && (multiplesSubheader.fontProperties = this.responsiveFontHelper.adjustFontSize(viewport, multiplesSubheader.fontProperties), 
                multiplesSubheader.height = multiplesSubheader.fontProperties.size.px + multiplesSubheader.margins.top + multiplesSubheader.margins.bottom), 
                this.updateSubheaderResponsiveWarnings(multiplesSubheader, originalMultiplesSubheader, warnings), 
                multiplesSubheader;
            }, SmallMultiplesViewModelAdapter.prototype.updateResponsiveWarnings = function(smallMultiplesLayout, originalSmallMultiplesLayout, warningBuilder) {
                var _a, _b, warningObjectCollection = warningBuilder, warnings = {};
                for (var key in smallMultiplesLayout.showIcon ? warnings.subheader = new visualWarnings.lC : (smallMultiplesLayout.rowPaddingInner === originalSmallMultiplesLayout.rowPaddingInner && smallMultiplesLayout.rowPaddingOuter === originalSmallMultiplesLayout.rowPaddingOuter && smallMultiplesLayout.columnPaddingInner === originalSmallMultiplesLayout.columnPaddingInner && smallMultiplesLayout.columnPaddingOuter === originalSmallMultiplesLayout.columnPaddingOuter || (warnings.smallMultiplesLayout = new visualWarnings.e), 
                (null === (_a = smallMultiplesLayout.gridline) || void 0 === _a ? void 0 : _a.strokeWidth) !== (null === (_b = originalSmallMultiplesLayout.gridline) || void 0 === _b ? void 0 : _b.strokeWidth) && (warnings.smallMultiplesLayout = new visualWarnings.IX)), 
                warnings) warningObjectCollection.addForVisualObject(key, {
                    selector: null,
                    warnings: [ warnings[key] ]
                });
            }, SmallMultiplesViewModelAdapter.prototype.updateSubheaderResponsiveWarnings = function(multiplesSubheader, originalMultiplesSubheader, warningBuilder) {
                var warningObjectCollection = warningBuilder, warnings = {};
                for (var key in multiplesSubheader.show !== originalMultiplesSubheader.show && (warnings.subheader = new visualWarnings.lC), 
                _.isEqual(multiplesSubheader.fontProperties.size, originalMultiplesSubheader.fontProperties.size) || (warnings.subheader = new visualWarnings.W0), 
                warnings) warningObjectCollection.addForVisualObject(key, {
                    selector: null,
                    warnings: [ warnings[key] ]
                });
            }, SmallMultiplesViewModelAdapter;
        }(), ResponsiveCartesianAdapterFactory = function() {
            function ResponsiveCartesianAdapterFactory() {}
            return ResponsiveCartesianAdapterFactory.prototype.createCartesianAdapter = function(options) {
                return this.isSmallMultiples() ? new SmallMultiplesCartesianViewModelAdapter(options, this.smallMultiplesOptions) : new CartesianViewModelAdapter(options);
            }, ResponsiveCartesianAdapterFactory.prototype.createLayerAdapter = function(layerType, options) {
                return this.isSmallMultiples() ? new SmallMultiplesLayerViewModelAdapter(layerType, options) : new CartesianLayerViewModelAdapter(layerType, options);
            }, ResponsiveCartesianAdapterFactory.prototype.setSmallMultiplesOptions = function(smallMultiplesOptions) {
                this.smallMultiplesOptions = smallMultiplesOptions;
            }, ResponsiveCartesianAdapterFactory.prototype.createSmallMultiplesAdapter = function(options) {
                if (this.isSmallMultiples()) return new SmallMultiplesViewModelAdapter(options);
                debug.fF.assertFail("Can not get SmallMultiplesAdapter for non-small multiples");
            }, ResponsiveCartesianAdapterFactory.prototype.isSmallMultiples = function() {
                return this.smallMultiplesOptions && this.smallMultiplesOptions.isSmallMultiples;
            }, ResponsiveCartesianAdapterFactory;
        }(), CartesianChart = function() {
            function CartesianChart(options) {
                var _a, _this = this;
                this.options = options, debug.fF.assertValue(options, "CartesianConstructorOptions"), 
                this.axes = new CartesianAxes(null !== (_a = options.isScrollable) && void 0 !== _a && _a, ScrollableAxes.ScrollbarWidth, this.trimOrdinalDataOnOverflow), 
                this.viewModelAdapterFactory = new ResponsiveCartesianAdapterFactory, this.layoutBuilder = new CartesianChartLayoutBuilder(options, this.axes, function() {
                    return _this.isPlayAxis();
                }, function() {
                    return _this.smallMultiplesViewModelAdapter;
                }), this.multiples = new CartesianSmallMultiples(this.chartType, this.featureSwitches, function() {
                    return function(options) {
                        switch (options.chartType) {
                          case 1:
                          case 0:
                          case 2:
                          case 3:
                            return [ createLineChart(options) ];

                          case 15:
                            return [ new RealTimeLineChart((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                                isScrollable: !1
                            })) ];

                          case 11:
                            return [ new ScatterChart((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                                viewModelAdapterFactory: createLayerAdapter(options, 2)
                            })) ];

                          case 12:
                            return [ new WaterfallChart((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options), {
                                viewModelAdapterFactory: createLayerAdapter(options, 3)
                            })) ];

                          case 5:
                          case 4:
                          case 9:
                          case 7:
                          case 6:
                          case 8:
                          case 10:
                            return [ createColumnChart(options) ];

                          case 13:
                          case 14:
                            return [ createColumnChart(options), createLineChart(options) ];

                          default:
                            return debug.fF.assertFail("Unknown CartesianChartType enum value"), [];
                        }
                    }((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, _this.options), {
                        viewModelAdapterFactory: _this.viewModelAdapterFactory,
                        interactivityService: _this.interactivityService
                    }));
                }, function(renderer) {
                    return _this.getLayerRendererInitOptions(renderer);
                });
            }
            return Object.defineProperty(CartesianChart.prototype, "featureSwitches", {
                get: function() {
                    return this.options.featureSwitches || {};
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianChart.prototype, "chartType", {
                get: function() {
                    return this.options.chartType;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(CartesianChart.prototype, "trimOrdinalDataOnOverflow", {
                get: function() {
                    var _a;
                    return null === (_a = this.options.trimOrdinalDataOnOverflow) || void 0 === _a || _a;
                },
                enumerable: !1,
                configurable: !0
            }), CartesianChart.prototype.init = function(options) {
                var _a, _this = this;
                debug.fF.assertValue(options, "CartesianChart.init(options)"), this.visualInitOptions = options;
                var element = options.element;
                this.currentViewport = options.viewport, this.hostServices = options.host, this.eventManager = new bubblingEventManager.B(d3.select(element.get(0))), 
                this.categoryLoadMoreDataHandler = new CartesianCategoryLoadMoreDataHandler(null, this.hostServices), 
                this.options.behaviorFactory && (this.interactivityService = (0, services_interactivityService.ub)(this.hostServices, this.featureSwitches)), 
                this.tooltipService = (0, tooltipService.r)(options.host);
                var style = this.visualInitOptions.style, layerStyle = (0, Prototype.ED)(style);
                layerStyle.colorPalette = (0, Prototype.ED)(style.colorPalette), layerStyle.colorPalette.dataColors = new SharedColorPalette(style.colorPalette.dataColors), 
                this.layerStyle = layerStyle;
                var axesData = new AxesData({
                    style,
                    chartType: this.chartType
                });
                this.axisZoom = new AxisZoom(element, this.hostServices, this.axes.isScrollable && !!options.interactivity, this.featureSwitches), 
                this.axes.init({
                    axesData,
                    axisZoom: this.axisZoom,
                    interactivityService: this.interactivityService
                }), this.legend = (0, legend.OG)(element, options.interactivity && options.interactivity.mobileTileInteractive, 12 !== this.chartType ? this.interactivityService : void 0, this.axes.isScrollable, void 0, style, this.hostServices);
                var layerInitOptions = (0, Prototype.ED)(options);
                if (layerInitOptions.style = layerStyle, layerInitOptions.services = {
                    tooltips: this.tooltipService
                }, this.multiples.init(layerInitOptions, this.interactivityService), this.layoutBuilder.init(options, this.tooltipService, this.legend, axesData, this.interactivityService, this.layerStyle, this.multiples.rowLoadMoreDataHandler, this.eventManager), 
                this.layout = this.layoutBuilder.create(this.visualInitOptions.element), this.isMobileChart = options.interactivity && options.interactivity.mobileTileInteractive, 
                this.featureSwitches.onObject) {
                    var subSelectionHostService = null === (_a = this.hostServices) || void 0 === _a ? void 0 : _a.getSubSelectionService(), renderer = null != subSelectionHostService ? subSelectionHostService : subSelectionOutlineRenderer.D.createWithDefaultHost();
                    this.subSelectionHelper = htmlSubSelectionHelper.O5.createHtmlSubselectionHelper({
                        hostElement: element.get(0),
                        hostServices: this.hostServices,
                        renderer,
                        targetSource: "format",
                        scale: function() {
                            return _this.currentViewport.scale;
                        },
                        selectorCallback: function(_element) {
                            return _this.getSelectorsByColumnSubSelection(_element);
                        },
                        customOutlineCallback: function(subSelection) {
                            return _this.getSubSelectionCustomOutlines(subSelection);
                        },
                        customElementCallback: function(subSelection) {
                            return _this.getSubSelectionCustomElements(subSelection);
                        },
                        subSelectionMetadataCallback: function(subSelectionElement) {
                            return _this.getSubSelectionMetadata(subSelectionElement);
                        }
                    }), this.interactivityService.setSubSelectionHelper(this.subSelectionHelper);
                }
            }, CartesianChart.prototype.isPlayAxis = function() {
                return !(!this.dataViews || !this.dataViews[0]) && 11 === this.chartType && (this.options.animator || this.isMobileChart) && (0, 
                dataRoleHelper.c5)(this.dataViews[0], "Play");
            }, CartesianChart.prototype.is100Stacked = function() {
                return 8 === this.chartType || 9 === this.chartType || 3 === this.chartType;
            }, CartesianChart.prototype.updateInternal = function(options, operationKind) {
                var _a;
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var dataViews, formatModeEnabled, preserveScrollPosition, renderMode, isSmallMultiples, smallMultiplesDataview, objects, layerStyle, multiplesLayout, multiplesSubheader, coreMultiple, layers, layerDataViews, dataView, shouldUpdateSubSelection, shouldAlertScreenReader, labels, message;
                    return (0, tslib_es6.__generator)(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return dataViews = this.dataViews = options.dataViews, formatModeEnabled = this.featureSwitches.onObject && options.formatMode, 
                            preserveScrollPosition = options.operationKind === enums.su.Append || null != options.resizeMode || formatModeEnabled, 
                            this.currentViewport = options.viewport, dataViews ? (isSmallMultiples = this.multiples.isSmallMultiples(dataViews), 
                            (smallMultiplesDataview = isSmallMultiples && dataViews[0]) ? (multiplesLayout = (0, 
                            cartesianHelper.Zw)(objects = smallMultiplesDataview.metadata.objects, layerStyle = this.layerStyle), 
                            multiplesSubheader = (0, cartesianHelper.yA)(objects, layerStyle), this.viewModelAdapterFactory.setSmallMultiplesOptions({
                                viewport: this.currentViewport,
                                isSmallMultiples,
                                columns: multiplesLayout.columnCount,
                                rows: multiplesLayout.rowCount
                            }), this.smallMultiplesViewModelAdapter = this.viewModelAdapterFactory.createSmallMultiplesAdapter({
                                dataView: smallMultiplesDataview,
                                multiplesLayout,
                                multiplesSubheader,
                                viewport: this.currentViewport
                            })) : (this.viewModelAdapterFactory.setSmallMultiplesOptions({
                                viewport: this.currentViewport,
                                isSmallMultiples,
                                columns: void 0,
                                rows: void 0
                            }), this.smallMultiplesViewModelAdapter = void 0), isSmallMultiples !== this.multiples.isSmallMultiples() && this.multiples.clear(), 
                            null != operationKind ? (coreMultiple = this.multiples.getCoreMultiple(), layers = coreMultiple.layers, 
                            _.isEmpty(dataViews) || (layerDataViews = getLayerDataViews(dataViews), this.cartesianVisualCapabilities = CartesianChart.getCartesianVisualCapabilities(layers), 
                            isSmallMultiples && this.cartesianVisualCapabilities && (this.cartesianVisualCapabilities.supportsHierarchicalCategoryAxis = !1), 
                            2 === (renderMode = this.categoryAxisRenderMode = CartesianChart.getRenderMode(layerDataViews, this.cartesianVisualCapabilities)) && (dataViews = dataViews.map(function(dataView) {
                                return (0, concatenateUtils.Zy)(dataView, cartesian_capabilities.p.general.formatString, cartesian_capabilities.x.category);
                            }))), this.multiples.update({
                                dataViews,
                                operationKind,
                                viewport: this.currentViewport,
                                adapterFactory: this.viewModelAdapterFactory,
                                preserveScrollPosition,
                                formatMode: formatModeEnabled
                            }), this.cartesianData = this.originalCartesianData = coreMultiple.getData()) : (this.multiples.resize(this.currentViewport), 
                            this.cartesianData = this.multiples.getCoreMultiple().getData()), null == operationKind && this.cartesianData && this.cartesianData.axesData ? this.axes.updateResize(this.cartesianData.axesData, this.cartesianData.scrollbarOptions.scrollbarWidth) : null != operationKind && (_.isEmpty(dataViews) || ((dataView = dataViews[0]).metadata && (this.background = {
                                image: (0, dataViewObject2.NA)(dataView.metadata.objects, cartesian_capabilities.p.plotArea.image),
                                transparency: (0, dataViewObject2.NA)(dataView.metadata.objects, cartesian_capabilities.p.plotArea.transparency, (0, 
                                visualBackgroundHelper.x6)())
                            }), this.categoryLoadMoreDataHandler.update(renderMode, isSmallMultiples), this.axes.update(dataView.categorical ? dataView.categorical.categories : null, this.cartesianData.axesData, renderMode, this.cartesianData.scrollbarOptions.scrollbarWidth)), 
                            this.categoryLoadMoreDataHandler.onLoadMoreDataCompleted()), this.cartesianData && this.cartesianData.zoomData && this.axisZoom.update({
                                dataViews,
                                zoomData: this.cartesianData.zoomData,
                                hasSmallMultiples: isSmallMultiples,
                                hasScalarCategoryAxis: this.categoryAxisIsScalar().isScalar,
                                hasYAxisCategorical: this.axes.isYAxisCategorical
                            }), [ 4, this.render(!this.hasSetData || options.suppressAnimations || isSmallMultiples, preserveScrollPosition, options.resizeMode) ]) : [ 2 ];

                          case 1:
                            return _b.sent(), this.isDestroyed || (this.hasSetData = this.hasSetData || !_.isEmpty(dataViews), 
                            this.updateWarnings(null === (_a = this.cartesianData) || void 0 === _a ? void 0 : _a.warningObjectCollection), 
                            shouldUpdateSubSelection = options.type & enums.EP.Data || options.type & enums.EP.ResizeEnd || options.type & enums.EP.FormattingSubSelectionChange, 
                            shouldAlertScreenReader = options.type & enums.EP.FormattingSubSelectionChange, 
                            this.subSelectionHelper && shouldUpdateSubSelection && (this.subSelectionHelper.updateOutlinesFromSubSelections(options.subSelections, !0), 
                            this.hostServices.alertScreenReader && shouldAlertScreenReader && (labels = this.subSelectionHelper.getLabelsFromSubSelections(options.subSelections, [ "aria-label" ]), 
                            (message = (null == labels ? void 0 : labels.length) && labels.join(" ")) && this.hostServices.alertScreenReader(message)))), 
                            [ 2 ];
                        }
                    });
                });
            }, CartesianChart.getCartesianVisualCapabilities = function(layers) {
                for (var cartesianVisualCapabilities, i = 0, layerCount = layers.length; i < layerCount; i++) {
                    var layerCartesianVisualCapabilities = layers[i].getCartesianVisualCapabilities();
                    cartesianVisualCapabilities ? cartesianVisualCapabilities.supportsHierarchicalCategoryAxis && (cartesianVisualCapabilities.supportsHierarchicalCategoryAxis = layerCartesianVisualCapabilities.supportsHierarchicalCategoryAxis) : cartesianVisualCapabilities = (0, 
                    Prototype.ED)(layerCartesianVisualCapabilities);
                }
                return cartesianVisualCapabilities;
            }, CartesianChart.getRenderMode = function(layerDataViews, cartesianVisualCapabilities) {
                for (var layerRenderModes, _i = 0, layerDataViews_1 = layerDataViews; _i < layerDataViews_1.length; _i++) {
                    var layerDataView = layerDataViews_1[_i];
                    if (null != layerDataView) {
                        var renderModes = new CartesianAxisRenderModeSelector(layerDataView, null == cartesianVisualCapabilities ? void 0 : cartesianVisualCapabilities.supportsHierarchicalCategoryAxis).getRenderModes();
                        layerRenderModes = layerRenderModes ? _.intersection(layerRenderModes, renderModes) : renderModes, 
                        debug.fF.assert(function() {
                            return !_.isEmpty(layerRenderModes);
                        }, "Could not find a valid render mode for all layers");
                    }
                }
                return _.head(layerRenderModes);
            }, CartesianChart.prototype.isSmallMultiples = function() {
                return (0, cartesianHelper.sI)(this.dataViews);
            }, CartesianChart.prototype.showSmallMultiplesCard = function() {
                return this.isSmallMultiples();
            }, CartesianChart.prototype.showSubheaderCard = function() {
                return this.isSmallMultiples();
            }, Object.defineProperty(CartesianChart.prototype, "hasHierarchicalAxisRenderMode", {
                get: function() {
                    return 3 === this.categoryAxisRenderMode;
                },
                enumerable: !1,
                configurable: !0
            }), CartesianChart.prototype.render = function(suppressAnimations, preserveScrollPosition, resizeMode) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        return [ 2, this.layout.render(this.multiples, this.currentViewport, this.categoryLoadMoreDataHandler, this.background, this.axisZoom, this.trimOrdinalDataOnOverflow, suppressAnimations, this.hasHierarchicalAxisRenderMode, preserveScrollPosition, this.formatMode, this.subSelectionHelper, this.isSelected, resizeMode) ];
                    });
                });
            }, CartesianChart.prototype.updateWarnings = function(warningObjectCollection) {
                var _a, _b, _c, _d, _e;
                if (!_.isEmpty(this.dataViews) && warningObjectCollection) {
                    var dataViews = this.dataViews, warnings = (0, invalidDataValuesChecker.b)(dataViews, !1, !1, !1, [ "Tooltips" ], !0);
                    if (_.isEmpty(warnings) || warningObjectCollection.add.apply(warningObjectCollection, warnings || []), 
                    this.axes.addWarnings(warningObjectCollection), this.multiples.checkIfNoLabelsCanBeRendered()) {
                        var labelWarning = {
                            selector: null,
                            warnings: [ new visualWarnings.we ]
                        };
                        warningObjectCollection.addForVisualObject("labels", labelWarning);
                    } else {
                        warningObjectCollection.removeForVisualObject("labels");
                        for (var _i = 0, layers_1 = null === (_b = this.multiples.getCoreMultiple()) || void 0 === _b ? void 0 : _b.layers; _i < layers_1.length; _i++) {
                            var layer = layers_1[_i];
                            null === (_c = layer.addWarnings) || void 0 === _c || _c.call(layer, warningObjectCollection);
                        }
                    }
                    for (var renderModeWarnings = [], supportsHierarchicalCategoryAxis = null === (_d = this.cartesianVisualCapabilities) || void 0 === _d ? void 0 : _d.supportsHierarchicalCategoryAxis, _f = 0, dataViews_1 = dataViews; _f < dataViews_1.length; _f++) new CartesianAxisRenderModeSelector(dataViews_1[_f], supportsHierarchicalCategoryAxis).addObjectWarnings(renderModeWarnings);
                    var warnForAxisRange = function(axisData, objectName) {
                        var _a = (0, cartesianAxisHelper.getMergedUserDomains)(axisData);
                        _a[0] >= _a[1] && warningObjectCollection.addForVisualObject(objectName, {
                            selector: null,
                            warnings: [ new visualWarnings.Dm ]
                        });
                    };
                    (null === (_e = this.originalCartesianData) || void 0 === _e ? void 0 : _e.axesData) && (warnForAxisRange(this.originalCartesianData.axesData.valueAxis, "valueAxis"), 
                    warnForAxisRange(this.originalCartesianData.axesData.categoryAxis, "categoryAxis"), 
                    warnForAxisRange(this.originalCartesianData.axesData.secondaryValueAxis, "y2Axis")), 
                    _.isEmpty(renderModeWarnings) || (_a = this.cartesianData.warningObjectCollection).addForVisualObject.apply(_a, (0, 
                    tslib_es6.__spreadArray)([ "categoryAxis" ], renderModeWarnings || [], !1)), this.hostServices.setWarnings(this.cartesianData.warningObjectCollection.complete());
                }
            }, CartesianChart.prototype.update = function(options) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        switch (_a.label) {
                          case 0:
                            return this.featureSwitches.onObject && options.formatMode !== this.formatMode && (this.subSelectionHelper.setFormatMode(options.formatMode), 
                            this.interactivityService.setFormatMode(options.formatMode), this.formatMode = options.formatMode), 
                            null == options.resizeMode ? [ 3, 2 ] : [ 4, this.updateInternal(options) ];

                          case 1:
                            return _a.sent(), [ 3, 4 ];

                          case 2:
                            return [ 4, this.updateInternal(options, null != options.operationKind ? options.operationKind : enums.su.Create) ];

                          case 3:
                            _a.sent(), _a.label = 4;

                          case 4:
                            return [ 2 ];
                        }
                    });
                });
            }, CartesianChart.prototype.destroy = function() {
                this.isDestroyed = !0, this.multiples && this.multiples.clear(), this.layout && this.layout.destroy(), 
                this.axisZoom && (this.axisZoom.destroy(), this.axisZoom = void 0);
            }, CartesianChart.prototype.onViewModeChanged = function(viewMode) {
                this.layout.viewMode = viewMode;
            }, CartesianChart.prototype.onSelectionStateChanged = function(isSelected) {
                if (this.isSelected = isSelected, this.cartesianData && this.multiples && this.dataViews) {
                    var suppressAnimations = !this.hasSetData || this.multiples.isSmallMultiples(this.dataViews);
                    this.render(suppressAnimations, !0);
                }
            }, CartesianChart.prototype.scrollTo = function(position) {
                var visibleMultiples = this.layout.getVisibleMultiples();
                this.multiples.scrollTo(position, visibleMultiples);
            }, CartesianChart.prototype.scrollRowsTo = function(position) {
                this.layout.scrollRowsTo(position);
            }, CartesianChart.prototype.isComboChart = function() {
                return cartesianHelper.LQ(this.chartType);
            }, CartesianChart.prototype.enumerateObjectInstances = function(options) {
                var _a, enumeration = new objectEnumerationBuilder.G, layers = this.getLayers();
                if (options.objectName === referenceLineHelper1.XC) {
                    var isScalar = this.categoryAxisIsScalar().isScalar;
                    if (supportsStaticReferenceLines(this.dataViews, layers) && isScalar) {
                        var categoryValueType = cartesianHelper.RN(layers);
                        this.enumerateReferenceLines(enumeration, options.objectName, categoryValueType);
                    }
                } else options.objectName === referenceLineHelper1.Dk ? this.enumerateReferenceLines(enumeration, options.objectName) : "referenceLine" === options.objectName ? function(dataViews, layers, layerIndex) {
                    return allLayerSupports(function(layer) {
                        return !layer.isStacked;
                    }, dataViews, layers, void 0);
                }(this.dataViews, layers) && this.enumerateReferenceLines(enumeration, options.objectName) : "trend" === options.objectName && supportsTrendLines(this.dataViews, layers) && (0, 
                trendLineHelper.md)(enumeration, this.originalCartesianData.trendLines, this.layerStyle);
                for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
                    var layer = layers_2[_i];
                    null === (_a = layer.enumerateObjectInstances) || void 0 === _a || _a.call(layer, enumeration, options);
                }
                return enumeration.complete();
            }, CartesianChart.prototype.getSelectorsByColumnSubSelection = function(e) {
                for (var _i = 0, layers_3 = this.getLayers(); _i < layers_3.length; _i++) {
                    var layer = layers_3[_i];
                    if (layer.getSelectorsByColumnFromSubselectedElement) {
                        var result = layer.getSelectorsByColumnFromSubselectedElement(e);
                        if (result) return result;
                    }
                }
                return {};
            }, CartesianChart.prototype.getSubSelectionCustomOutlines = function(subSelection) {
                return cartesianChart_formatter.PH.call(this, subSelection);
            }, CartesianChart.prototype.getSubSelectionCustomElements = function(subSelection) {
                return cartesianChart_formatter.xm.call(this, subSelection);
            }, CartesianChart.prototype.getSubSelectionMetadata = function(subSelectionElement) {
                return cartesianChart_formatter.H_.call(this, subSelectionElement);
            }, CartesianChart.prototype.getSubSelectionStyles = function(subSelections) {
                return cartesianChart_formatter.mv.call(this, subSelections);
            }, CartesianChart.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                return cartesianChart_formatter.yV.call(this, subSelections, filter);
            }, CartesianChart.prototype.getSubSelectables = function(filterType) {
                return cartesianChart_formatter.l$.call(this, filterType);
            }, CartesianChart.prototype.getNextSubSelectable = function(currentSubSelectable, backwards) {
                return this.subSelectionHelper.getNextSubSelectable(currentSubSelectable, backwards);
            }, CartesianChart.prototype.getFormattingModel = function() {
                return cartesianChart_formatter.fI.call(this);
            }, CartesianChart.prototype.resolveFormattingPlaceholder = function(placeholder) {
                if ((0, build_control_util.n$)(placeholder)) {
                    if ("responsive" === placeholder.name) return this.getResponsiveSlice();
                    for (var _i = 0, _a = this.getLayers(); _i < _a.length; _i++) {
                        var layer = _a[_i], result = layer.resolveFormattingPlaceholder && layer.resolveFormattingPlaceholder(placeholder);
                        if (result) return result;
                    }
                }
            }, Object.defineProperty(CartesianChart.prototype, "localizer", {
                get: function() {
                    var _this = this;
                    return function(key) {
                        return _this.hostServices.getLocalizedString(key);
                    };
                },
                enumerable: !1,
                configurable: !0
            }), CartesianChart.prototype.getResponsiveSlice = function() {
                var dataView = this.dataViews && this.dataViews[0];
                if (dataView) {
                    if (this.smallMultiplesViewModelAdapter) return this.smallMultiplesViewModelAdapter.getResponsiveSlice(dataView, this.localizer);
                    if (this.viewModelAdapterFactory) return this.viewModelAdapterFactory.createCartesianAdapter({
                        cartesianData: void 0,
                        dataView,
                        viewport: void 0,
                        isCoreMultiple: void 0
                    }).getResponsiveSlice(dataView, this.localizer);
                }
            }, CartesianChart.prototype.getTelemetryInformation = function() {
                var telemetryInformation = {};
                if (this.isSmallMultiples()) {
                    var layout = (0, cartesianHelper.Zw)(this.dataViews[0].metadata.objects, this.layerStyle);
                    debug.fF.assertValue(layout, "getTelemetryInformation - NULL layout"), telemetryInformation.smallMultiples = {
                        layout: {
                            type: layout.layoutType,
                            rows: layout.rowCount,
                            columns: layout.columnCount
                        }
                    };
                }
                for (var layers = this.getLayers(), layerIndex = 0; layerIndex < layers.length; layerIndex++) {
                    var layer = layers[layerIndex];
                    if (_.isFunction(layer.getTelemetryInformation)) {
                        var telemetryInformationForLayer = layer.getTelemetryInformation();
                        telemetryInformationForLayer && (telemetryInformation[layerIndex.toString()] = telemetryInformationForLayer);
                    }
                }
                if (!_.isEmpty(telemetryInformation)) return telemetryInformation;
            }, CartesianChart.prototype.getLayers = function() {
                var coreMultiple = this.multiples.getCoreMultiple();
                return 1 & coreMultiple.getState() ? coreMultiple.layers : [];
            }, CartesianChart.prototype.enumerateReferenceLines = function(enumeration, type, categoryAxisType) {
                var _a, _b;
                if ((null === (_a = this.originalCartesianData) || void 0 === _a ? void 0 : _a.referenceLines) && (null === (_b = this.originalCartesianData) || void 0 === _b ? void 0 : _b.axesData)) {
                    var refLineDefaultColor = common_colorHelper.v.getDataColorByIndex(this.layerStyle, 0, colorHelper.fA), refLines = _.filter(this.originalCartesianData.referenceLines, function(refLine) {
                        return refLine.type === type;
                    });
                    (0, referenceLineHelper1.Dr)(enumeration, refLines, refLineDefaultColor, type, this.originalCartesianData.axesData.isValueAxisIrregular, categoryAxisType);
                }
            }, CartesianChart.prototype.shouldShowLegendCard = function() {
                var _a, _b;
                if (_.isEmpty(this.dataViews) || !(null === (_a = this.cartesianData) || void 0 === _a ? void 0 : _a.legendData)) return !1;
                if (this.cartesianData.legendData.isGradientLegend) return !0;
                var layers = null === (_b = this.multiples.getCoreMultiple()) || void 0 === _b ? void 0 : _b.layers;
                if (layers && this.dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; i < layersLength; i++) {
                    if (layers[i].hasLegend()) return !0;
                    var dataView = this.dataViews[i];
                    if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && ++layersWithValuesCtr > 1) return !0;
                }
                return !1;
            }, CartesianChart.prototype.isLogAxisScaleAllowed = function(isValueAxis, isSecondaryAxis) {
                void 0 === isValueAxis && (isValueAxis = !1), void 0 === isSecondaryAxis && (isSecondaryAxis = !1);
                var isYAxisCategorical = this.axes.isYAxisCategorical;
                return this.axes.isLogScaleAllowed(isValueAxis ? isYAxisCategorical ? 0 : isSecondaryAxis ? 2 : 1 : isYAxisCategorical ? 1 : 0);
            }, CartesianChart.prototype.categoryAxisIsScalar = function() {
                var _a;
                if (!this.originalCartesianData) return {
                    isScalar: void 0,
                    supportedType: void 0
                };
                var categoryAxisData = this.originalCartesianData.axesData.categoryAxis, supportedType = this.hasHierarchicalAxisRenderMode ? axisType.w.categorical : axisType.w.both, isScalar = !1, layers = null === (_a = this.multiples.getCoreMultiple()) || void 0 === _a ? void 0 : _a.layers;
                return supportedType === axisType.w.both && layers && layers[0].getSupportedCategoryAxisType && ((supportedType = layers[0].getSupportedCategoryAxisType()) === axisType.w.scalar ? isScalar = !0 : (isScalar = cartesianHelper.qU(supportedType === axisType.w.both, categoryAxisData)) && (isScalar = layers && layers[0].getVisualCategoryAxisIsScalar ? layers[0].getVisualCategoryAxisIsScalar() : 0 === this.categoryAxisRenderMode)), 
                {
                    isScalar,
                    supportedType
                };
            }, CartesianChart.prototype.onClearSelection = function() {
                this.hasSetData && this.multiples.clearSelection(this.layout.getVisibleMultiples());
            }, CartesianChart.prototype.onRestoreSelection = function(options) {
                return !!this.interactivityService && this.interactivityService.restoreSelection(options.selection);
            }, CartesianChart.prototype.getLayerRendererInitOptions = function(renderer) {
                var _a, _this = this;
                return {
                    animator: null === (_a = renderer.cartesianOptions) || void 0 === _a ? void 0 : _a.animator,
                    svg: renderer.axesRenderer.getLayerContainer(),
                    cartesianHost: {
                        updateLegend: function(data) {
                            return _this.legend.drawLegend({
                                data,
                                parentViewport: _this.currentViewport,
                                isHierarchicalAxis: _this.hasHierarchicalAxisRenderMode,
                                onObject: _this.featureSwitches.onObject,
                                titleSliceUid: "".concat("legend", "-").concat("title", "-titleText")
                            });
                        },
                        triggerRender: function(suppressAnimations) {
                            return _this.render(suppressAnimations, !1);
                        }
                    },
                    eventManager: this.eventManager,
                    useManagedTabIndex: this.useManagedTabIndex()
                };
            }, CartesianChart.prototype.useManagedTabIndex = function() {
                return this.isSmallMultiples();
            }, CartesianChart.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                var layout = (0, cartesianHelper.Zw)(this.dataViews[0].metadata.objects, this.layerStyle), propertyUpdatedObjects = cartesianHelper.Te(propertySaveObjects, layout);
                if (!this.featureSwitches.onObject || 1 !== sourceType) return propertyUpdatedObjects;
                for (var updatedPropertyChanges, visualObjectBehaviorChanges = [], _i = 0, layers_4 = this.getLayers(); _i < layers_4.length; _i++) {
                    var layer = layers_4[_i];
                    layer.getDataViewObjectLayerChanges && visualObjectBehaviorChanges.push(layer.getDataViewObjectLayerChanges(propertyUpdatedObjects, sourceType));
                }
                if (_.isEmpty(visualObjectBehaviorChanges)) return propertyUpdatedObjects;
                if (visualObjectBehaviorChanges.length > 1) {
                    for (var requiredChanges = [], optionalChangesByLayer = [], index = 0; index < visualObjectBehaviorChanges.length; index++) {
                        optionalChangesByLayer[index] = [];
                        for (var _a = 0, _b = visualObjectBehaviorChanges[index]; _a < _b.length; _a++) {
                            var change = _b[_a];
                            change.required ? requiredChanges.push(change) : optionalChangesByLayer[index].push(change);
                        }
                    }
                    for (var intersection = optionalChangesByLayer[0], i = 1; i < optionalChangesByLayer.length; i++) intersection = _.intersectionWith(intersection, optionalChangesByLayer[i], _.isEqual);
                    updatedPropertyChanges = dataViewObjectChangeHelper.o.applyDataViewObjectsBehaviorChanges(propertySaveObjects, (0, 
                    tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], intersection, !0), requiredChanges, !0));
                } else updatedPropertyChanges = dataViewObjectChangeHelper.o.applyDataViewObjectsBehaviorChanges(propertyUpdatedObjects, _.first(visualObjectBehaviorChanges));
                return updatedPropertyChanges;
            }, CartesianChart;
        }(), CartesianAxisRenderModeSelector = function() {
            function CartesianAxisRenderModeSelector(dataView, supportsHierarchicalCategoryAxis) {
                this.processDataView(dataView, supportsHierarchicalCategoryAxis);
            }
            return CartesianAxisRenderModeSelector.prototype.processDataView = function(dataView, supportsHierarchicalCategoryAxis) {
                if (this.renderModes = [], dataView && dataView.metadata && dataView.categorical && !_.isEmpty(dataView.categorical.categories)) {
                    var metadata = dataView.metadata, categories = dataView.categorical.categories, categoryColumn = _.head(categories), scalarKeys = scalarUtils.A8(categoryColumn), hasHierarchy = (0, 
                    dataViewHelper.n$)(dataView), shouldDrawScalar = scalarUtils.PX(metadata.objects, cartesian_capabilities.p.categoryAxis.axisType, categoryColumn.source.type, scalarKeys, hasHierarchy);
                    if (hasHierarchy) {
                        var filteredToUniqueValue = CartesianAxisRenderModeSelector.areNonLeafLevelsFilteredToUniqueValue(categories), concatenateLabelsEnabled = (0, 
                        dataViewObject2.NA)(metadata.objects, cartesian_capabilities.p.categoryAxis.concatenateLabels, cartesianHelper.SM);
                        if (!filteredToUniqueValue || !concatenateLabelsEnabled && supportsHierarchicalCategoryAxis) {
                            var hasIdentityExprs = _.some(dataView.categorical.categories, function(category) {
                                return category.source && category.source.identityExprs;
                            }), canDrawHierarchy = supportsHierarchicalCategoryAxis && !concatenateLabelsEnabled && hasIdentityExprs;
                            this.renderModes.unshift(2), canDrawHierarchy && this.renderModes.unshift(3), concatenateLabelsEnabled || hasIdentityExprs || (this.warnings = [ {
                                selector: null,
                                warnings: [ new visualWarnings.Tr ]
                            } ]);
                        } else this.renderModes.unshift(1);
                        shouldDrawScalar && this.renderModes.unshift(0);
                    } else this.renderModes.unshift(1), shouldDrawScalar && this.renderModes.unshift(0);
                } else this.renderModes.push(2);
            }, CartesianAxisRenderModeSelector.prototype.getRenderMode = function() {
                return _.head(this.renderModes);
            }, CartesianAxisRenderModeSelector.prototype.getRenderModes = function() {
                return this.renderModes;
            }, CartesianAxisRenderModeSelector.prototype.addObjectWarnings = function(warnings) {
                debug.fF.assertValue(warnings, "warnings"), this.warnings && warnings.push.apply(warnings, this.warnings || []);
            }, CartesianAxisRenderModeSelector.areNonLeafLevelsFilteredToUniqueValue = function(categories) {
                if (_.isEmpty(categories)) return !1;
                for (var leafCategoryColumnIndex = categories.length - 1, categoryColumnIndex = 0; categoryColumnIndex < leafCategoryColumnIndex; categoryColumnIndex++) {
                    var metadata = categories[categoryColumnIndex].source;
                    if (!metadata || !(0, dataViewObject2.NA)(metadata.objects, cartesian_capabilities.p.filters.filteredToUniqueValue, !1)) return !1;
                }
                return !0;
            }, CartesianAxisRenderModeSelector;
        }(), SharedColorPalette = function() {
            function SharedColorPalette(palette) {
                this.palette = palette, this.clearPreferredScale();
            }
            return SharedColorPalette.prototype.getAllColors = function() {
                return this.palette.getAllColors();
            }, SharedColorPalette.prototype.getColorScaleByKey = function(scaleKey) {
                return this.setPreferredScale(scaleKey), this.preferredScale;
            }, SharedColorPalette.prototype.getNewColorScale = function() {
                return this.preferredScale;
            }, SharedColorPalette.prototype.getColorByIndex = function(index) {
                return this.palette.getColorByIndex(index);
            }, SharedColorPalette.prototype.getSentimentColors = function() {
                return this.palette.getSentimentColors();
            }, SharedColorPalette.prototype.getGradientColors = function() {
                return this.palette.getGradientColors();
            }, SharedColorPalette.prototype.getBasePickerColors = function() {
                return this.palette.getBasePickerColors();
            }, SharedColorPalette.prototype.clearPreferredScale = function() {
                this.preferredScale = this.palette.getNewColorScale(), this.rotated = !1;
            }, SharedColorPalette.prototype.rotateScale = function() {
                this.preferredScale = this.preferredScale.clone(), this.preferredScale.clearAndRotateScale(), 
                this.rotated = !0;
            }, SharedColorPalette.prototype.setPreferredScale = function(scaleKey) {
                this.rotated || (this.preferredScale = this.palette.getColorScaleByKey(scaleKey));
            }, SharedColorPalette;
        }(), CartesianCategoryLoadMoreDataHandler = function() {
            function CartesianCategoryLoadMoreDataHandler(scale, hostServices) {
                this.loadMoreThreshold = 1, this.enabled = !1, debug.fF.assertValue(hostServices, "hostServices"), 
                this.hostServices = hostServices, this.setScale(scale);
            }
            return CartesianCategoryLoadMoreDataHandler.prototype.update = function(renderMode, isSmallMultiples) {
                this.enabled = !isSmallMultiples && 0 !== renderMode;
            }, CartesianCategoryLoadMoreDataHandler.prototype.resetViewport = function(numVisibleCategories) {
                this.viewportDataRange = {
                    startIndex: 0,
                    endIndex: numVisibleCategories
                };
            }, CartesianCategoryLoadMoreDataHandler.prototype.setScale = function(scale) {
                var numCategories = scale && scale.domain && scale.domain().length;
                numCategories && (this.loadMoreThresholdIndex = numCategories - 1 - this.loadMoreThreshold);
            }, CartesianCategoryLoadMoreDataHandler.prototype.isLoadingMoreData = function() {
                return this.loadingMoreData;
            }, CartesianCategoryLoadMoreDataHandler.prototype.onLoadMoreDataCompleted = function() {
                this.loadingMoreData = !1;
            }, CartesianCategoryLoadMoreDataHandler.prototype.shouldLoadMoreData = function() {
                var viewportDataRange = this.viewportDataRange;
                return !(!this.enabled || !viewportDataRange || this.isLoadingMoreData()) && viewportDataRange.endIndex >= this.loadMoreThresholdIndex;
            }, CartesianCategoryLoadMoreDataHandler.prototype.loadMoreData = function() {
                var _this = this;
                return debug.fF.assert(function() {
                    return _this.shouldLoadMoreData();
                }, "unexpected call to loadMoreData"), this.isLoadingMoreData() ? loadMoreDataHandler.G.WaitingForData : (this.loadingMoreData = !0, 
                this.hostServices.loadMoreData(), loadMoreDataHandler.G.TriggeredLoadMore);
            }, CartesianCategoryLoadMoreDataHandler;
        }();
    },
    34969: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            $B: function() {
                return DefaultInnerPaddingRatio;
            },
            $K: function() {
                return getPreferredCategoryWidth;
            },
            $W: function() {
                return MultiplesLayoutMinRows;
            },
            $w: function() {
                return getValueAxisProperties;
            },
            Ao: function() {
                return DefaultGridlineColorName;
            },
            Au: function() {
                return shouldYAxisBeCategorical;
            },
            CI: function() {
                return xAxisSmallFontSizeInPx;
            },
            Fv: function() {
                return TickLabelPadding;
            },
            GN: function() {
                return getFirstMetadataColumn;
            },
            JI: function() {
                return DefaultGridlineDottedColorName;
            },
            K8: function() {
                return DefaultOuterPaddingRatio;
            },
            LK: function() {
                return getMaxMultiples;
            },
            LQ: function() {
                return isComboChart;
            },
            MH: function() {
                return getCategoryIdentity;
            },
            MI: function() {
                return addCartesianChartContainer;
            },
            PC: function() {
                return isLineOrComboChart;
            },
            Pg: function() {
                return findMaxCategoryIndex;
            },
            QB: function() {
                return shouldRenderAxis;
            },
            RN: function() {
                return getCategoryValueType;
            },
            SM: function() {
                return DefaultConcatenateLabelsValue;
            },
            Sq: function() {
                return ClassName;
            },
            T4: function() {
                return InnerPaddingMin;
            },
            Te: function() {
                return adjustMultiplesCellsCount;
            },
            Vk: function() {
                return getCategoryAxisProperties;
            },
            Zo: function() {
                return getScalarKeyinfo;
            },
            Zw: function() {
                return getMultiplesLayout;
            },
            be: function() {
                return DefaultDomain;
            },
            cI: function() {
                return InnerPaddingDefaultRibbon;
            },
            dZ: function() {
                return lookupXValue;
            },
            eX: function() {
                return DefaultAxisFontColorName;
            },
            fw: function() {
                return MultiplesLayoutMinColumns;
            },
            is: function() {
                return getCategoryLayout;
            },
            jY: function() {
                return MinCategoryThickness;
            },
            lc: function() {
                return yAxisMediumFontSizeInPx;
            },
            qE: function() {
                return getInnerPadding;
            },
            qU: function() {
                return isScalarAxis;
            },
            rX: function() {
                return getEmptyMargins;
            },
            rZ: function() {
                return DefaultAxisFontSizeInPt;
            },
            sI: function() {
                return isSmallMultiples;
            },
            se: function() {
                return DefaultAxisFontFamily;
            },
            u8: function() {
                return EmptyCategoryLayout;
            },
            yA: function() {
                return getMultiplesSubheader;
            },
            yo: function() {
                return yAxisSmallFontSizeInPx;
            },
            zn: function() {
                return InnerPaddingMax;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(81337), _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53197), _Visuals_cartesian_utils_scalarUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(86946), _Visuals_types_axisType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48766), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62458), _VisualsCommon_fontUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38265), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(72489), _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26543), _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28326), _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(22733), _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38958), _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(41640), _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(14599), _Visuals_cartesian_utils_smallMultiplesUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(61297), _Visuals_types_smallMultiplesLayout__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(91593), _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(90120), _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(82755), _Visuals_common_gridLayout__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(32476), _Visuals_types_gridLineType__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(49511), _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(47316), _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(18664), _Visuals_common_units__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(32105), _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(44783), _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(79154), _Visuals_types_verticalPosition__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(18765), _Visuals_types_horizontalPosition__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(92374), _Visuals_services_interactivityService__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(72902), _VisualsData_dataView_dataViewObject3__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(76045), InnerPaddingMin = 0, InnerPaddingMax = 75, DefaultInnerPaddingRatio = .2, InnerPaddingDefaultRibbon = .6, MultiplesLayoutMinColumns = 1, MultiplesLayoutMinRows = 1, MultiplesLayoutMaxCellCount = 36, ClassName = "cartesianChart", DefaultConcatenateLabelsValue = !0, MinCategoryThickness = 20, TickLabelPadding = 2, DefaultAxisFontFamily = _VisualsCommon_fontUtils__WEBPACK_IMPORTED_MODULE_0__.Wn.regular.css, DefaultAxisFontSizeInPt = 8, DefaultOuterPaddingRatio = .4, DefaultDomain = [ Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY ], MinScalarRectThickness = 2, xAxisSmallFontSizeInPx = 9, yAxisSmallFontSizeInPx = 9, yAxisMediumFontSizeInPx = 11, DefaultAxisFontColorName = "foregroundNeutralSecondaryAlt", DefaultGridlineColorName = "foregroundNeutralLight", DefaultGridlineDottedColorName = "foregroundNeutralTertiaryAlt";
        function EmptyCategoryLayout() {
            return {
                categoryCount: 0,
                categoryThickness: MinCategoryThickness,
                outerPaddingRatio: 0,
                innerPaddingRatio: 0,
                isScalar: !1
            };
        }
        function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
            var toReturn = axisTitleOnByDefault ? {
                showAxisTitle: !0
            } : {};
            if (!dataViewMetadata) return toReturn;
            var objects = dataViewMetadata.objects;
            if (objects) {
                var categoryAxisObject = objects.categoryAxis;
                categoryAxisObject && ((toReturn = _.clone(categoryAxisObject)).showAxisTitle = categoryAxisObject.showAxisTitle ?? axisTitleOnByDefault);
            }
            return toReturn;
        }
        function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault, objectName) {
            void 0 === objectName && (objectName = "valueAxis");
            var toReturn = axisTitleOnByDefault ? {
                showAxisTitle: !0
            } : {};
            if (!dataViewMetadata) return toReturn;
            var objects = dataViewMetadata.objects;
            if (objects) {
                var valueAxisObject = objects[objectName];
                valueAxisObject && ((toReturn = _.clone(valueAxisObject)).showAxisTitle = valueAxisObject.showAxisTitle ?? axisTitleOnByDefault);
            }
            return toReturn;
        }
        function getInnerPadding(axisData) {
            return void 0 !== axisData.innerPadding ? Math.round(100 * axisData.innerPadding) : void 0;
        }
        function isScalarAxis(supportsScalar, properties) {
            return !(!supportsScalar || properties && properties.axisType && properties.axisType !== _Visuals_types_axisType__WEBPACK_IMPORTED_MODULE_1__.w.scalar);
        }
        function isLineOrComboChart(chartType) {
            return isComboChart(chartType) || 0 === chartType || 1 === chartType || 2 === chartType || 3 === chartType;
        }
        function isComboChart(chartType) {
            return 13 === chartType || 14 === chartType;
        }
        function getPreferredCategoryWidth(xAxisCardProperties) {
            var stringValue = xAxisCardProperties.preferredCategoryWidth;
            return null == stringValue ? void 0 : +stringValue;
        }
        function lookupXValue(data, index, type, isScalar_) {
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assertValue(data, "data"), 
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assertValue(type, "type"), 
            isScalar_) return (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_3__.v9)(type) ? _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3.fromTimeValue(index) : index;
            if (type.text) return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assert(function() {
                return index < data.categories.length;
            }, "category index out of range"), data.categories[index];
            if (data && data.series && data.series.length > 0) {
                var firstSeries = data.series[0];
                if (firstSeries) {
                    var seriesValues = firstSeries.data;
                    if (seriesValues) {
                        data.hasHighlights && (index *= 2);
                        var dataAtIndex = seriesValues[index];
                        if (dataAtIndex) return (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_3__.v9)(type) && null != dataAtIndex.categoryValue ? _VisualsData_services_formattingService__WEBPACK_IMPORTED_MODULE_4__.y3.fromTimeValue(dataAtIndex.categoryValue) : dataAtIndex.categoryValue;
                    }
                }
            }
            return index;
        }
        function findMaxCategoryIndex(series) {
            if (_.isEmpty(series)) return 0;
            for (var maxCategoryIndex = 0, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                var singleSeries = series_1[_i];
                _.isEmpty(singleSeries.data) || (maxCategoryIndex = Math.max(singleSeries.data[singleSeries.data.length - 1].categoryIndex, maxCategoryIndex));
            }
            return maxCategoryIndex;
        }
        function getCategoryIdentity(categoryIndex, category) {
            var _a;
            return _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_5__.dw.builder().withCategory([ category ], categoryIndex, null === (_a = null == category ? void 0 : category.source) || void 0 === _a ? void 0 : _a.queryName, !0).createSelectionId();
        }
        function getScalarKeyinfo(categorical, isScalar_) {
            var category, scalarKeys, useScalarKeys = !1;
            if (isScalar_) {
                var firstCategory = _.head(categorical.categories);
                category = (useScalarKeys = (scalarKeys = (0, _Visuals_cartesian_utils_scalarUtils__WEBPACK_IMPORTED_MODULE_6__.A8)(firstCategory)) && !_.isEmpty(scalarKeys.values)) ? firstCategory : _.last(categorical.categories);
            } else category = _.isEmpty(categorical.categories) ? {
                source: void 0,
                values: [ (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_7__.WU)(null) ],
                identity: void 0
            } : _.last(categorical.categories);
            return {
                category,
                useScalarKeys,
                scalarKeys
            };
        }
        function getFirstMetadataColumn(metadataColumns) {
            return metadataColumns[0];
        }
        function getCategoryValueType(layers) {
            var _a;
            return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assert(function() {
                return !_.isEmpty(layers);
            }, "getCategoryValueType layers"), null === (_a = _.find(layers, function(layer) {
                return layer.getCategoryValueType && layer.hasData();
            })) || void 0 === _a ? void 0 : _a.getCategoryValueType();
        }
        function isSmallMultiples(dataViews) {
            var _a, _b, _c, _d, _e;
            if (_.size(dataViews) < 1) return !1;
            var firstLevelSources = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = dataViews[0]) || void 0 === _a ? void 0 : _a.matrix) || void 0 === _b ? void 0 : _b.rows) || void 0 === _c ? void 0 : _c.levels) || void 0 === _d ? void 0 : _d[0]) || void 0 === _e ? void 0 : _e.sources;
            return !(_.size(firstLevelSources) < 1) && !_.isEmpty(dataViews[0].matrix.rows.root.children) && _.every(firstLevelSources, function(source) {
                return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_8__.nu)(source, _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_9__.x.rows);
            });
        }
        function shouldYAxisBeCategorical(type) {
            switch (type) {
              case 7:
              case 6:
              case 8:
                return !0;
            }
            return !1;
        }
        function getCategoryLayout(options) {
            var categoryCount = options.categoryCount, availableWidth = options.availableWidth, _a = options.isScalar, isScalar = void 0 !== _a && _a, _b = options.cartesianOptions, isScrollable = (void 0 === _b ? {} : _b).isScrollable, result = function(options) {
                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, isScalar = options.isScalar, preferredCategoryWidth = options.preferredCategoryWidth, outerPaddingRatio = options.outerPaddingRatio, categoryThickness = function(options) {
                    var _a, _b, _c, categoryThickness, data = options.data, categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, isScalar = options.isScalar, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, outerPaddingRatio = options.outerPaddingRatio;
                    if (categoryCount < 2) categoryThickness = availableWidth * (1 - outerPaddingRatio); else if (isScalar && domain && domain.length > 1) {
                        var minInterval = function(seriesList) {
                            var minInterval = Number.MAX_VALUE;
                            if (seriesList.length > 0) for (var series0data = seriesList[0].data.filter(function(d) {
                                return !d.highlight;
                            }), _loop_1 = function(i, iLen) {
                                var nextValue = series0data[i + 1].categoryValue, currentValue = series0data[i].categoryValue;
                                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assert(function() {
                                    return _.isNumber(nextValue);
                                }, "nextValue"), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assert(function() {
                                    return _.isNumber(currentValue);
                                }, "currentValue"), minInterval = Math.min(minInterval, Math.abs(nextValue - currentValue));
                            }, i = 0, iLen = series0data.length - 1; i < iLen; i++) _loop_1(i);
                            return minInterval;
                        }(null !== (_a = null == data ? void 0 : data.series) && void 0 !== _a ? _a : []);
                        categoryThickness = availableWidth * (minInterval / (domain[domain.length - 1] - domain[0] + minInterval * outerPaddingRatio * 2));
                        var zoomFactor_1 = null !== (_c = null === (_b = options.axisZoom) || void 0 === _b ? void 0 : _b.getCategoryZoomFactor()) && void 0 !== _c ? _c : 1;
                        _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assert(function() {
                            return zoomFactor_1 >= 1;
                        }, "zoomFactor must be >= 1"), categoryThickness = Math.max(categoryThickness * zoomFactor_1, MinScalarRectThickness);
                    } else categoryThickness = availableWidth / (categoryCount + 2 * outerPaddingRatio), 
                    trimOrdinalDataOnOverflow && (categoryThickness = Math.max(categoryThickness, MinCategoryThickness));
                    return categoryThickness = Math.min(categoryThickness, availableWidth / (3 + 2 * outerPaddingRatio)), 
                    !isScalar && categoryCount >= 3 && trimOrdinalDataOnOverflow ? Math.max(categoryThickness, MinCategoryThickness) : categoryThickness;
                }(options);
                if (isScalar || null == preferredCategoryWidth || preferredCategoryWidth < categoryThickness) return {
                    categoryThickness,
                    outerPaddingRatio
                };
                var numberCategoriesCanShow = Math.floor((availableWidth - preferredCategoryWidth * outerPaddingRatio * 2) / preferredCategoryWidth);
                return numberCategoriesCanShow <= 0 ? categoryThickness = availableWidth / (1 + 2 * outerPaddingRatio) : numberCategoriesCanShow < categoryCount ? (outerPaddingRatio = (availableWidth - preferredCategoryWidth * numberCategoriesCanShow) / (2 * preferredCategoryWidth), 
                categoryThickness = preferredCategoryWidth) : categoryThickness = Math.min(preferredCategoryWidth, availableWidth), 
                {
                    categoryThickness,
                    outerPaddingRatio
                };
            }(options), categoryThickness = result.categoryThickness, outerPaddingRatio = result.outerPaddingRatio, calculatedBarCount = (0, 
            _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_10__.Uy)((availableWidth - categoryThickness * outerPaddingRatio * 2) / categoryThickness), visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
            return isScalar || visibleCategoryCount < categoryCount && isScrollable || (outerPaddingRatio = Math.max(0, (availableWidth - categoryThickness * visibleCategoryCount) / 2 / categoryThickness), 
            outerPaddingRatio = (0, _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_10__.GG)(outerPaddingRatio, 0) ? 0 : outerPaddingRatio), 
            {
                categoryCount: !isScalar && isScrollable ? categoryCount : visibleCategoryCount,
                categoryThickness,
                outerPaddingRatio,
                innerPaddingRatio: options.innerPaddingRatio,
                isScalar
            };
        }
        function shouldRenderAxis(axesData, isCombo) {
            return {
                x: axesData.x.show,
                y: axesData.y.show,
                y2: axesData.y2.show || isCombo && !1 !== axesData.y2.show
            };
        }
        function getMultiplesLayout(objects, style) {
            var _a, _b, dataViewObject = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_16__.RK)(objects, _Visuals_cartesian_utils_smallMultiplesUtils__WEBPACK_IMPORTED_MODULE_11__.Xi), layoutObject = function(dataViewObject) {
                return {
                    layoutType: null == dataViewObject ? void 0 : dataViewObject.layoutType,
                    rowCount: null == dataViewObject ? void 0 : dataViewObject.rowCount,
                    columnCount: null == dataViewObject ? void 0 : dataViewObject.columnCount,
                    backgroundColor: null == dataViewObject ? void 0 : dataViewObject.backgroundColor,
                    backgroundTransparency: null == dataViewObject ? void 0 : dataViewObject.backgroundTransparency,
                    gridPadding: null == dataViewObject ? void 0 : dataViewObject.gridPadding,
                    advancedPaddingOptions: null == dataViewObject ? void 0 : dataViewObject.advancedPaddingOptions,
                    columnPaddingInner: null == dataViewObject ? void 0 : dataViewObject.columnPaddingInner,
                    columnPaddingOuter: null == dataViewObject ? void 0 : dataViewObject.columnPaddingOuter,
                    rowPaddingInner: null == dataViewObject ? void 0 : dataViewObject.rowPaddingInner,
                    rowPaddingOuter: null == dataViewObject ? void 0 : dataViewObject.rowPaddingOuter
                };
            }(dataViewObject), defaults = function(style) {
                return {
                    layoutType: 0,
                    rowCount: _Visuals_cartesian_utils_smallMultiplesUtils__WEBPACK_IMPORTED_MODULE_11__.UE,
                    columnCount: _Visuals_cartesian_utils_smallMultiplesUtils__WEBPACK_IMPORTED_MODULE_11__.ZO,
                    backgroundColor: null,
                    backgroundTransparency: 0,
                    gridline: {
                        region: _Visuals_types_gridLineType__WEBPACK_IMPORTED_MODULE_12__.o.none,
                        strokeShow: !1,
                        strokePattern: _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_13__.kY.solid,
                        strokeWidth: 1,
                        strokeColor: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_14__.v.getThemeColor(style, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.md),
                        strokeTransparency: 0
                    },
                    advancedPaddingOptions: !1,
                    gridPadding: 12,
                    columnPaddingInner: 12,
                    columnPaddingOuter: 12,
                    rowPaddingInner: 12,
                    rowPaddingOuter: 12
                };
            }(style), colorHelper = _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_14__.v.create(style), gridlineShow = null == dataViewObject ? void 0 : dataViewObject.gridLineShow, gridlineRegion = null !== (_a = null == dataViewObject ? void 0 : dataViewObject.gridLineType) && void 0 !== _a ? _a : defaults.gridline.region;
            !1 === gridlineShow ? gridlineRegion = _Visuals_types_gridLineType__WEBPACK_IMPORTED_MODULE_12__.o.none : !0 === gridlineShow ? gridlineRegion !== _Visuals_types_gridLineType__WEBPACK_IMPORTED_MODULE_12__.o.none && gridlineRegion || (gridlineRegion = _Visuals_types_gridLineType__WEBPACK_IMPORTED_MODULE_12__.o.inner) : null == gridlineShow && (gridlineShow = gridlineRegion !== _Visuals_types_gridLineType__WEBPACK_IMPORTED_MODULE_12__.o.none);
            var layout = (0, tslib__WEBPACK_IMPORTED_MODULE_17__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_17__.__assign)({}, (null == layoutObject ? void 0 : layoutObject.layoutType) === _Visuals_types_smallMultiplesLayout__WEBPACK_IMPORTED_MODULE_18__.r.auto ? {
                layoutType: 0,
                rowCount: defaults.rowCount,
                columnCount: defaults.columnCount
            } : {
                layoutType: 1,
                rowCount: (null == layoutObject ? void 0 : layoutObject.rowCount) || defaults.rowCount,
                columnCount: (null == layoutObject ? void 0 : layoutObject.columnCount) || defaults.columnCount
            }), {
                backgroundColor: colorHelper.getColorForPropertyNameWithDefaultColor(dataViewObject, _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_19__.e0.smallMultiplesBackgroundColor.propertyName, defaults.backgroundColor, !0),
                backgroundTransparency: null !== (_b = null == layoutObject ? void 0 : layoutObject.backgroundTransparency) && void 0 !== _b ? _b : defaults.backgroundTransparency,
                gridline: {
                    region: gridlineRegion,
                    strokeShow: gridlineShow,
                    strokePattern: (0, _VisualsData_dataView_dataViewObject3__WEBPACK_IMPORTED_MODULE_20__.N)(dataViewObject, "gridLineStyle", defaults.gridline.strokePattern),
                    strokeColor: colorHelper.getColorForPropertyNameWithDefaultColor(dataViewObject, "gridLineColor", defaults.gridline.strokeColor),
                    strokeWidth: (0, _VisualsData_dataView_dataViewObject3__WEBPACK_IMPORTED_MODULE_20__.N)(dataViewObject, "gridLineWidth", defaults.gridline.strokeWidth),
                    strokeTransparency: (0, _VisualsData_dataView_dataViewObject3__WEBPACK_IMPORTED_MODULE_20__.N)(dataViewObject, "gridLineTransparency", defaults.gridline.strokeTransparency)
                }
            });
            return function(layout, layoutObject, defaults) {
                layout.gridPadding = layoutObject && void 0 !== layoutObject.gridPadding ? layoutObject.gridPadding : defaults.gridPadding, 
                layout.advancedPaddingOptions = layoutObject && void 0 !== layoutObject.advancedPaddingOptions ? layoutObject.advancedPaddingOptions : defaults.advancedPaddingOptions;
                var hasAdvancedOptions = layoutObject && layoutObject.advancedPaddingOptions, paddingOptions = {
                    gridPadding: layout.gridPadding,
                    gridLineRegion: layout.gridline.region
                };
                layout.columnPaddingInner = hasAdvancedOptions && void 0 !== layoutObject.columnPaddingInner ? layoutObject.columnPaddingInner : getPaddingFromGridPaddingAndDefaults(paddingOptions, 1), 
                hasAdvancedOptions && void 0 !== layoutObject.columnPaddingOuter ? layout.columnPaddingOuter = layoutObject.columnPaddingOuter : (paddingOptions.defaultPadding = defaults.columnPaddingOuter, 
                layout.columnPaddingOuter = getPaddingFromGridPaddingAndDefaults(paddingOptions, 0)), 
                layout.rowPaddingInner = hasAdvancedOptions && void 0 !== layoutObject.rowPaddingInner ? layoutObject.rowPaddingInner : getPaddingFromGridPaddingAndDefaults(paddingOptions, 2), 
                hasAdvancedOptions && void 0 !== layoutObject.rowPaddingOuter ? layout.rowPaddingOuter = layoutObject.rowPaddingOuter : (paddingOptions.defaultPadding = defaults.rowPaddingOuter, 
                layout.rowPaddingOuter = getPaddingFromGridPaddingAndDefaults(paddingOptions, 0));
            }(layout, layoutObject, defaults), layout;
        }
        function getPaddingFromGridPaddingAndDefaults(options, paddingType) {
            var gridPadding = options.gridPadding, gridLineSettings = options.gridLineRegion, defaultPadding = options.defaultPadding;
            switch (paddingType) {
              case 0:
                return _Visuals_common_gridLayout__WEBPACK_IMPORTED_MODULE_21__.Me.typeHasOuterGridLines(gridLineSettings) ? gridPadding : defaultPadding;

              case 1:
                return _Visuals_common_gridLayout__WEBPACK_IMPORTED_MODULE_21__.Me.typeHasVerticalGridLines(gridLineSettings) ? gridPadding : floatSafeHalf(gridPadding);

              case 2:
                return _Visuals_common_gridLayout__WEBPACK_IMPORTED_MODULE_21__.Me.typeHasHorizontalGridLines(gridLineSettings) ? gridPadding : floatSafeHalf(gridPadding);

              default:
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_2__.fF.assertNever(paddingType);
            }
        }
        function floatSafeHalf(input) {
            return input % 2 == 0 ? input / 2 : Math.ceil(input / 2);
        }
        function getMultiplesSubheader(objects, style) {
            var subheader = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_16__.RK)(objects, "subheader"), defaults = MultiplesSubheaderDefaults(), colorHelper = _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_14__.v.create(style), fontProperties = (0, 
            _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_22__.Zi)(subheader, {
                family: "fontFamily",
                size: "fontSize",
                color: "fontColor",
                bold: "bold",
                italic: "italic",
                underline: "underline"
            }, colorHelper, style, defaults.ColorName, defaults.TextClassName, {
                color: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_14__.v.getThemeColor(style, defaults.ColorName),
                size: _Visuals_common_units__WEBPACK_IMPORTED_MODULE_23__.B.createFromPt(defaults.FontPointSize),
                family: defaults.FontFamily,
                weight: _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_24__.AI,
                style: _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_24__.AI,
                textDecoration: _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_24__.zu
            }), margins = {
                top: 0,
                bottom: 2,
                left: 5,
                right: 0
            }, height = fontProperties.size.px + margins.top + margins.bottom, vertical = defaults.Vertical, horizontal = defaults.Horizontal, titleWrap = defaults.TitleWrap, show = defaults.Show, labelBold = !1, labelItalic = !1, labelUnderline = !1;
            if (subheader) {
                switch (subheader.position) {
                  case _Visuals_types_verticalPosition__WEBPACK_IMPORTED_MODULE_25__.cL.top:
                    vertical = 0;
                    break;

                  case _Visuals_types_verticalPosition__WEBPACK_IMPORTED_MODULE_25__.cL.bottom:
                    vertical = 1;
                }
                switch (subheader.alignment) {
                  case _Visuals_types_horizontalPosition__WEBPACK_IMPORTED_MODULE_26__.D.left:
                    horizontal = 0;
                    break;

                  case _Visuals_types_horizontalPosition__WEBPACK_IMPORTED_MODULE_26__.D.center:
                    horizontal = 1;
                    break;

                  case _Visuals_types_horizontalPosition__WEBPACK_IMPORTED_MODULE_26__.D.right:
                    horizontal = 2;
                }
                titleWrap = subheader.titleWrap, void 0 !== subheader.show && (show = subheader.show), 
                void 0 !== subheader.bold && (labelBold = subheader.bold), void 0 !== subheader.italic && (labelItalic = subheader.italic), 
                void 0 !== subheader.underline && (labelUnderline = subheader.underline);
            }
            return {
                fontProperties,
                show,
                height,
                margins,
                vertical,
                horizontal,
                titleWrap,
                labelBold,
                labelItalic,
                labelUnderline
            };
        }
        var MultiplesSubheaderDefaults = function() {
            return {
                FontFamily: _VisualsCommon_fontUtils__WEBPACK_IMPORTED_MODULE_0__.Wn.regular.css,
                FontPointSize: 8,
                ColorName: "foregroundNeutralSecondary",
                TextClassName: "title",
                Vertical: 0,
                Horizontal: 0,
                Show: !0,
                TitleWrap: !1,
                bold: !1,
                italic: !1,
                underline: !1
            };
        };
        function getEmptyMargins() {
            return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
            };
        }
        function addCartesianChartContainer(element, viewport) {
            var d3Container = d3.select(element.get(0)), d3SmallMultiplesArea = d3Container.select("svg");
            d3SmallMultiplesArea.empty() && ((d3SmallMultiplesArea = d3Container.append("svg")).classed(ClassName, !0), 
            d3SmallMultiplesArea.style("position", "absolute"));
            var clearCatcher = (0, _Visuals_services_interactivityService__WEBPACK_IMPORTED_MODULE_27__.EX)(d3SmallMultiplesArea);
            return viewport && d3SmallMultiplesArea.attrs({
                width: viewport.width,
                height: viewport.height
            }), {
                element: d3SmallMultiplesArea,
                clearCatcher
            };
        }
        function adjustMultiplesCellsCount(propertySaveObjects, multiplesCount) {
            if (propertySaveObjects[0].objectName === _Visuals_cartesian_utils_smallMultiplesUtils__WEBPACK_IMPORTED_MODULE_11__.Xi) {
                var rowCount = _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_19__.N_.smallMultiplesLayout.rowCount, columnCount = _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_19__.N_.smallMultiplesLayout.columnCount, value = propertySaveObjects[0].propertyValue;
                if (propertySaveObjects[0].propertyName === rowCount.propertyName) {
                    var maxMultiples = getMaxMultiples({
                        rowCount: value,
                        columnCount: multiplesCount.columnCount
                    });
                    propertySaveObjects.push({
                        objectName: columnCount.objectName,
                        propertyName: columnCount.propertyName,
                        propertyValue: Math.min(maxMultiples.maxColumnCount, multiplesCount.columnCount),
                        propertyType: {
                            integer: !0
                        }
                    });
                } else propertySaveObjects[0].propertyName === columnCount.propertyName && (maxMultiples = getMaxMultiples({
                    rowCount: multiplesCount.rowCount,
                    columnCount: value
                }), propertySaveObjects.push({
                    objectName: rowCount.objectName,
                    propertyName: rowCount.propertyName,
                    propertyValue: Math.min(maxMultiples.maxRowCount, multiplesCount.rowCount),
                    propertyType: {
                        integer: !0
                    }
                }));
            }
            return propertySaveObjects;
        }
        function getMaxMultiples(multiplesCount) {
            return {
                maxRowCount: Math.floor(MultiplesLayoutMaxCellCount / multiplesCount.columnCount),
                maxColumnCount: Math.floor(MultiplesLayoutMaxCellCount / multiplesCount.rowCount)
            };
        }
    },
    3406: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            mM: function() {
                return BorderRenderUtil;
            },
            bk: function() {
                return applyInteractivity;
            },
            Wv: function() {
                return drawDefaultShapes;
            },
            hJ: function() {
                return drawRibbonConnectors;
            },
            kC: function() {
                return drawSeries;
            },
            WR: function() {
                return drawUncertainty;
            },
            vA: function() {
                return getRibbonFillOpacity;
            },
            sY: function() {
                return render;
            },
            Gm: function() {
                return selectRectShapes;
            },
            rT: function() {
                return setSelectedColumnOpacity;
            },
            Ls: function() {
                return updateLayoutAndOpacity;
            },
            pM: function() {
                return updateSelected;
            }
        });
        var interactivityService = __webpack_require__(72902), marker_renderer = __webpack_require__(51995), renderUtil = __webpack_require__(60066), htmlSubSelectionHelper = __webpack_require__(52287), uncertainty_renderer = __webpack_require__(58691), visualBorderUtil = __webpack_require__(34021), svgUtil = __webpack_require__(10389), CssConstants = __webpack_require__(79154), browserUtils = __webpack_require__(59107), debug = __webpack_require__(62458), color = __webpack_require__(64067), selectionId = __webpack_require__(26543), cartesianHelper = __webpack_require__(34969), columnChart_util = __webpack_require__(38859), shapes6 = __webpack_require__(80758), cartesianAxisHelper = __webpack_require__(11956), ColumnChartHitTester = function() {
            function ColumnChartHitTester(options) {
                debug.fF.assert(function() {
                    return options.columnWidth > 0;
                }, "Columns should have a width"), debug.fF.assert(function() {
                    return options.categoryWidth > 0;
                }, "Categories should have a width"), this.categoryAxisScale = options.categoryAxisScale, 
                this.categoryWidth = options.categoryWidth, this.columnWidth = options.columnWidth, 
                this.dataPoints = options.dataPoints, this.hasCategories = options.hasCategories, 
                this.isBar = options.isBar, this.isClustered = options.isClustered, this.isScalar = options.isScalar, 
                this.seriesLength = options.seriesLength;
            }
            return ColumnChartHitTester.prototype.queryRegion = function(rect) {
                var categoryLowerBound_1, categoryUpperBound_1, valueLowerBound_1, valueUpperBound_1, _this = this, selectedPoints = [], dataSpaceRect = rect.dataSpace;
                return (this.isScalar || this.hasCategories && !_.some([ dataSpaceRect.bottom, dataSpaceRect.left, dataSpaceRect.right, dataSpaceRect.top ], function(d) {
                    return void 0 === d;
                })) && (this.isBar ? (this.isScalar ? (categoryLowerBound_1 = dataSpaceRect.bottom.value, 
                categoryUpperBound_1 = dataSpaceRect.top.value) : (categoryLowerBound_1 = this.getAdjustedCategoryIndex(dataSpaceRect.top.value, dataSpaceRect.top.seriesIndex, this.seriesLength), 
                categoryUpperBound_1 = this.getAdjustedCategoryIndex(dataSpaceRect.bottom.value, dataSpaceRect.bottom.seriesIndex, this.seriesLength)), 
                valueLowerBound_1 = dataSpaceRect.left.value, valueUpperBound_1 = dataSpaceRect.right.value) : (this.isScalar ? (categoryLowerBound_1 = dataSpaceRect.left.value, 
                categoryUpperBound_1 = dataSpaceRect.right.value) : (categoryLowerBound_1 = this.getAdjustedCategoryIndex(dataSpaceRect.left.value, dataSpaceRect.left.seriesIndex, this.seriesLength), 
                categoryUpperBound_1 = this.getAdjustedCategoryIndex(dataSpaceRect.right.value, dataSpaceRect.right.seriesIndex, this.seriesLength)), 
                valueLowerBound_1 = dataSpaceRect.bottom.value, valueUpperBound_1 = dataSpaceRect.top.value), 
                selectedPoints = _.filter(this.dataPoints, function(point) {
                    return 0 !== point.valueAbsolute && categoryLowerBound_1 <= categoryUpperBound_1 && valueLowerBound_1 <= valueUpperBound_1 && (0, 
                    shapes6.WN)(categoryLowerBound_1, categoryUpperBound_1, _this.getAreaCategoryBound(point, !1), _this.getAreaCategoryBound(point, !0)) && (0, 
                    shapes6.WN)(valueLowerBound_1, valueUpperBound_1, _this.getAreaValueLowerBound(point), _this.getAreaValueUpperBound(point));
                })), selectedPoints;
            }, ColumnChartHitTester.prototype.getAreaValueLowerBound = function(point) {
                return this.isClustered ? Math.min(0, point.value) : point.position - point.valueAbsolute;
            }, ColumnChartHitTester.prototype.getAreaValueUpperBound = function(point) {
                return this.isClustered ? Math.max(0, point.value) : point.position;
            }, ColumnChartHitTester.prototype.getAreaCategoryBound = function(point, upperBound) {
                if (this.isScalar) {
                    this.isBar && (upperBound = !upperBound);
                    var upperBoundAdjustment = upperBound ? this.columnWidth : 0, seriesIndexAdjustment = this.isClustered ? point.seriesIndex : 0, categoryStart = this.categoryAxisScale(point.categoryValue) - this.categoryWidth / 2;
                    return (0, cartesianAxisHelper.invertScale)(this.categoryAxisScale, categoryStart + seriesIndexAdjustment * this.columnWidth + upperBoundAdjustment, 0, 0, void 0).value;
                }
                return this.getAdjustedCategoryIndex(point.categoryIndex, point.seriesIndex, this.seriesLength);
            }, ColumnChartHitTester.prototype.getAdjustedCategoryIndex = function(categoryIndex, seriesIndex, seriesLength) {
                return this.isClustered ? (debug.fF.assert(function() {
                    return void 0 !== seriesIndex;
                }, "Series index should be present when getting adjusted category index for a clustered chart."), 
                categoryIndex * seriesLength + seriesIndex) : categoryIndex;
            }, ColumnChartHitTester;
        }(), RibbonChartLayerCS = (0, CssConstants.CH)("ribbonChartLayer"), RibbonChartDefsCS = (0, 
        CssConstants.CH)("ribbonChartDefs"), RibbonChartSeriesCS = (0, CssConstants.CH)("ribbonChartSeries"), RibbonChartDataPointCS = (0, 
        CssConstants.CH)("ribbonChartDataPoint");
        function render(suppressAnimations, formatMode) {
            var _this = this, columnChartDrawInfo = this.drawColumns(!suppressAnimations), data = this.data, hasCrispEdges = this.xAxisProperties.isCategoryAxis && 0 === this.xAxisProperties.innerPaddingRatio || this.yAxisProperties.isCategoryAxis && 0 === this.yAxisProperties.innerPaddingRatio;
            this.mainGraphicsContext.attr("height", this.availableHeight).attr("width", this.availableWidth).classed("withCrispEdges", hasCrispEdges);
            var getRibbonDataPointsSelection = function() {
                return _this.mainGraphicsContext.selectAll(RibbonChartDataPointCS.selector);
            };
            this.tooltipsEnabled && !formatMode ? (this.tooltipService.addTooltip(columnChartDrawInfo.eventGroup, function(args) {
                var _a;
                return null === (_a = args.data) || void 0 === _a ? void 0 : _a.tooltipInfo;
            }, function(args) {
                var _a;
                return (null === (_a = args.data) || void 0 === _a ? void 0 : _a.identity) && [ args.data.identity ];
            }), this.hasRibbonBands && this.tooltipService.addTooltip(getRibbonDataPointsSelection(), function(args) {
                var _a;
                return null === (_a = args.data) || void 0 === _a ? void 0 : _a.tooltipInfo;
            }, function() {
                return [ selectionId.l0.createNull() ];
            })) : (this.tooltipService.removeTooltips(columnChartDrawInfo.eventGroup), this.hasRibbonBands && this.tooltipService.removeTooltips(getRibbonDataPointsSelection()));
            var behaviorOptions, navigationOptions, allDataPoints = [];
            if (this.interactivityService) {
                for (var _i = 0, _a = data.series; _i < _a.length; _i++) allDataPoints = allDataPoints.concat(_a[_i].data);
                behaviorOptions = {
                    datapoints: allDataPoints,
                    columnChartDrawInfo,
                    hasHighlights: data.hasHighlights,
                    root: this.mainGraphicsContext,
                    showLabel: data.dataLabelsSettings.show,
                    visualInstanceId: this.hostService.instanceId,
                    hitTester: new ColumnChartHitTester({
                        dataPoints: allDataPoints,
                        isScalar: data.isScalar,
                        hasCategories: !!data.categoryIdentities && data.categoryIdentities.length > 0,
                        isBar: this.isBar,
                        isClustered: this.isClustered,
                        categoryAxisScale: this.categoryAxis.scale,
                        columnWidth: this.columnWidth,
                        categoryWidth: this.categoryWidth,
                        seriesLength: data.series.length
                    }),
                    useManagedTabIndex: this.useManagedTabIndex,
                    ribbonSeriesSelection: this.mainGraphicsContext.selectAll(RibbonChartSeriesCS.selector),
                    style: this.style
                }, navigationOptions = {
                    navigationStrategy: data.series.length > 1 ? interactivityService.jN.CategoryFirst : interactivityService.jN.CategoryOnly,
                    helper: this
                };
            }
            return this.isMobileInteractiveLegend() && selectLastSelectedColumnOrDefault.call(this, !0), 
            (0, svgUtil.bL)(this.animationOptions), {
                dataPoints: allDataPoints,
                behaviorOptions,
                navigationOptions,
                labelDataPoints: [],
                labelDataPointGroups: columnChartDrawInfo.labelDataPointGroups,
                labelsAreNumeric: !0,
                labelOrientation: data.dataLabelsSettings.labelOrientation,
                animateLabels: columnChartDrawInfo.animateLabels,
                categorySubRangeCount: this.isClustered ? this.data.series.length : 1,
                verticalCategoryAxis: this.isBar
            };
        }
        function selectLastSelectedColumnOrDefault(forceDimAll) {
            void 0 === forceDimAll && (forceDimAll = !1);
            var columnIndexToSelect = void 0 === this.lastInteractiveSelectedColumnIndex ? (0, 
            cartesianHelper.Pg)(this.data.series) : this.lastInteractiveSelectedColumnIndex;
            this.selectColumn(columnIndexToSelect, forceDimAll);
        }
        function applyInteractivity(columns, onDragStart) {
            debug.fF.assertValue(columns, "columns"), onDragStart && columns.attr("draggable", "true").on("dragstart", onDragStart);
        }
        function drawSeries() {
            var _this = this;
            (0, visualBorderUtil.H4)(this.mainGraphicsContext, this.data.strokeSettings);
            var colGroupSelection = this.mainGraphicsContext.selectAll(columnChart_util.L0.selector);
            if (this.usesUngroupedRenderer()) {
                var allDataPoints = _.flatten(this.activeData.series.map(function(series) {
                    return series.data;
                }));
                return allDataPoints.sort(function(p1, p2) {
                    var highlightDiff = (p1.highlight ? 1 : 0) - (p2.highlight ? 1 : 0);
                    if (highlightDiff) return highlightDiff;
                    var seriesIndexDiff = p1.seriesPosition - p2.seriesPosition;
                    return _this.activeData.layout.clusteredGapOverlapReverse && (seriesIndexDiff *= -1), 
                    seriesIndexDiff;
                }), colGroupSelection.data([ {
                    data: allDataPoints
                } ], function(_) {
                    return "*";
                }).join(function(enter) {
                    return enter.append("g").classed(columnChart_util.L0.class, !0);
                });
            }
            return colGroupSelection.data(this.activeData.series, function(d) {
                return d.key;
            }).join(function(enter) {
                return enter.append("g").classed(columnChart_util.L0.class, !0);
            }).styles({
                fill: function(series) {
                    return series.columnStyle.fillColor;
                },
                "stroke-width": function(series) {
                    return BorderRenderUtil.size(series.columnStyle.border, _this.style);
                },
                stroke: function(series) {
                    return BorderRenderUtil.color(series.columnStyle.border, _this.style);
                }
            }).attr("role", "listbox").attr("aria-label", function(series) {
                return series.displayName;
            });
        }
        var BorderRenderUtil = {
            opacity: function(border, style, isDimmed) {
                return (0, color.TD)(style.isHighContrast ? 0 : border.strokeTransparency) * (isDimmed ? renderUtil.eU : 1);
            },
            size: function(border, style) {
                return style.isHighContrast ? null : border.strokeShow ? 2 * border.strokeWidth : 0;
            },
            color: function(border, style) {
                return style.isHighContrast ? null : border.strokeColor;
            },
            optimized: function(selfV, groupV) {
                return selfV === groupV ? null : selfV;
            },
            rectClipPath: function(d, style, useFillbox) {
                var _a;
                return (null === (_a = d.columnStyle.border) || void 0 === _a ? void 0 : _a.strokeShow) && !style.isHighContrast ? "".concat(useFillbox ? "fill-box " : "", "inset(0px)") : null;
            },
            strokePattern: function(d, layout, isColumn, valueAxisIsInverted) {
                var _a;
                if (!(null === (_a = d.columnStyle.border) || void 0 === _a ? void 0 : _a.outlineOnly) || d.highlight) return null;
                var _b = isColumn ? [ !1, !0, !1, !0 ] : [ !0, !1, !0, !1 ], top = _b[0], right = _b[1], bottom = _b[2], left = _b[3], capTopRight = function() {
                    isColumn ? top = !0 : right = !0;
                }, capBottomLeft = function() {
                    isColumn ? bottom = !0 : left = !0;
                };
                d.indexFromBottom === d.countOfPointsInCategory - 1 ? valueAxisIsInverted ? capBottomLeft() : capTopRight() : 0 === d.indexFromBottom && (valueAxisIsInverted ? capTopRight() : capBottomLeft());
                var w = layout.shapeLayout.width(d), h = layout.shapeLayout.height(d), pattern = "", addEdge = function(skip, len) {
                    pattern += skip ? "".concat(len, " 0 ") : "0 ".concat(len, " ");
                };
                return addEdge(top, w), addEdge(right, h), addEdge(bottom, w), addEdge(left, h), 
                pattern;
            }
        };
        function selectRectShapes(chart, series, data, filterZeros) {
            void 0 === filterZeros && (filterZeros = !1);
            var shapes = series.selectAll(chart.CS.selector).data(function(d) {
                return filterZeros ? _.filter(d.data, function(datapoint) {
                    return !!datapoint.value;
                }) : d.data;
            }, function(d) {
                return d.key;
            }), newShapes = shapes.enter().append("rect").classed(chart.CS.class, !0).classed("highlight", function(d) {
                return Boolean(d.highlight);
            }).styles({
                "clip-path": function(d) {
                    return BorderRenderUtil.rectClipPath(d, chart.style, !1);
                },
                "-webkit-clip-path": function(d) {
                    return BorderRenderUtil.rectClipPath(d, chart.style, !0);
                }
            });
            return chart.featureSwitches.onObject && newShapes.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "columns").attr(htmlSubSelectionHelper.QZ, 3).each(function(d, i, shapeNodes) {
                htmlSubSelectionHelper.O5.setDataForElement(shapeNodes[i], {
                    outlineRestrictionOptions: {
                        margin: chart.scaledMargin
                    },
                    getDisplayName: function() {
                        return chart.hostService.getLocalizedString(chart.isBar ? "MiniToolbar_Bars" : "MiniToolbar_Columns", data.series[d.seriesIndex].displayName);
                    }
                });
            }), {
                newShapes,
                updatedShapes: shapes.merge(newShapes).style("fill", function(d) {
                    return d.columnStyle.fillColor !== data.series[d.seriesIndex].columnStyle.fillColor || chart.usesUngroupedRenderer() ? d.columnStyle.fillColor : null;
                }).attr("aria-hidden", function(d) {
                    return !!d.highlight || null;
                }).order(),
                removedShapes: shapes.exit()
            };
        }
        function updateLayoutAndOpacity(selection, layout, options) {
            return selection.attrs({
                width: layout.width,
                height: layout.height,
                x: layout.x,
                y: layout.y
            }).styles({
                "fill-opacity": options ? function(d) {
                    var _a;
                    return getDataPointFillOpacity(d, null === (_a = options.interactivityService) || void 0 === _a ? void 0 : _a.hasSelection(), options.chart.activeData.hasHighlights);
                } : 0,
                "stroke-opacity": options ? function(d) {
                    var _a;
                    return BorderRenderUtil.opacity(d.columnStyle.border, options.chart.style, (options.chart.activeData.hasHighlights || (null === (_a = options.interactivityService) || void 0 === _a ? void 0 : _a.hasSelection())) && !d.highlight);
                } : 0
            });
        }
        function updateSelected(selection, hasSelection, hasHighlights, style) {
            return selection.attr("aria-selected", function(d) {
                return d.selected;
            }).style("fill-opacity", function(d) {
                return getDataPointFillOpacity(d, hasSelection, hasHighlights);
            }).style("stroke-opacity", function(d) {
                return BorderRenderUtil.opacity(d.columnStyle.border, style, (hasSelection || hasHighlights) && !d.selected);
            });
        }
        function drawDefaultShapes(series) {
            var _this = this, data = this.activeData, style = this.style, _a = selectRectShapes(this, series, data, !this.animator), shapesUpdate = _a.updatedShapes, removedShapes = _a.removedShapes;
            return shapesUpdate.interrupt(), this.interactivityService && shapesUpdate.attrs({
                tabindex: 0,
                focusable: !0,
                role: "option",
                "aria-selected": function(d) {
                    return d.selected;
                },
                "aria-label": function(d) {
                    return null != d.value ? d.value : "null";
                },
                "data-automation-type": "column-chart-rect"
            }).classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()), this.usesUngroupedRenderer() ? shapesUpdate.styles({
                "stroke-width": function(d) {
                    return BorderRenderUtil.size(d.columnStyle.border, style);
                },
                stroke: function(d) {
                    return BorderRenderUtil.color(d.columnStyle.border, style);
                },
                fill: function(d) {
                    return data.series[d.seriesIndex].columnStyle.fillColor;
                }
            }) : shapesUpdate.styles({
                "stroke-width": function(d) {
                    return BorderRenderUtil.optimized(BorderRenderUtil.size(d.columnStyle.border, style), BorderRenderUtil.size(data.series[d.seriesIndex].columnStyle.border, style));
                },
                stroke: function(d) {
                    return BorderRenderUtil.optimized(BorderRenderUtil.color(d.columnStyle.border, style), BorderRenderUtil.color(data.series[d.seriesIndex].columnStyle.border, style));
                }
            }), shapesUpdate.styles({
                "stroke-dasharray": function(d) {
                    return BorderRenderUtil.strokePattern(d, _this.layout, _this.isColumn, _this.valueAxis.invertAxis);
                },
                "clip-path": function(d) {
                    return BorderRenderUtil.rectClipPath(d, style, !1);
                },
                "-webkit-clip-path": function(d) {
                    return BorderRenderUtil.rectClipPath(d, style, !0);
                }
            }).attrs({
                "aria-setsize": data.dataPointsCount,
                "aria-posinset": function(d) {
                    return d.posinset;
                }
            }), updateLayoutAndOpacity(shapesUpdate, this.layout.shapeLayout, {
                chart: this,
                interactivityService: this.interactivityService
            }), removedShapes.remove(), shapesUpdate;
        }
        function drawUncertainty(options) {
            var renderUncertainty, uncertaintySeries, bars, markerPaths, markerUpdateFunction_Closure, isBar = options.isBar, valueAxisProps = options.valueAxisProps, layout = options.layout, columnWidth = options.columnWidth, interactivityService = options.interactivityService, _a = this.activeData, hasHighlights = _a.hasHighlights;
            if (void 0 !== valueAxisProps && (uncertaintySeries = _.filter(_a.series, function(thisSeries) {
                return thisSeries.uncertainty.renderUncertainty;
            }), renderUncertainty = !_.isEmpty(uncertaintySeries)), renderUncertainty) {
                var uncertaintyLineLower_1, uncertaintyLineUpper_1, valueAxisInverted_1, hasSelection = null == interactivityService ? void 0 : interactivityService.hasSelection(), columnMidpoint_1 = columnWidth / 2, valueAxisScaleRange = valueAxisProps.scale.range(), valueScale_1 = valueAxisProps.scale, dataPointPosition = void 0;
                if (isBar) {
                    var valuePosition_1 = function(d) {
                        return layout.shapeLayout.y(d) + columnMidpoint_1 - (d.drawThinner ? columnMidpoint_1 / 2 : 0);
                    };
                    dataPointPosition = function(d) {
                        return "translate(".concat(valueScale_1(d.value), ", ").concat(valuePosition_1(d), ")");
                    }, uncertaintyLineLower_1 = d3.line().x(layout.uncertaintyLayout.lower).y(valuePosition_1), 
                    uncertaintyLineUpper_1 = d3.line().x(layout.uncertaintyLayout.upper).y(valuePosition_1), 
                    valueAxisInverted_1 = valueAxisScaleRange[1] < valueAxisScaleRange[0];
                } else {
                    var valuePosition_2 = function(d) {
                        return layout.shapeLayout.x(d) + columnMidpoint_1 - (d.drawThinner ? columnMidpoint_1 / 2 : 0);
                    };
                    dataPointPosition = function(d) {
                        return "translate(".concat(valuePosition_2(d), ", ").concat(valueScale_1(d.value), ")");
                    }, uncertaintyLineLower_1 = d3.line().x(valuePosition_2).y(layout.uncertaintyLayout.lower), 
                    uncertaintyLineUpper_1 = d3.line().x(valuePosition_2).y(layout.uncertaintyLayout.upper), 
                    valueAxisInverted_1 = valueAxisScaleRange[1] > valueAxisScaleRange[0];
                }
                uncertaintyLineLower_1.defined(function(d) {
                    var _a;
                    return null != (null === (_a = null == d ? void 0 : d.uncertainty) || void 0 === _a ? void 0 : _a.lower) && (!hasHighlights || d.highlight);
                }), uncertaintyLineUpper_1.defined(function(d) {
                    var _a;
                    return null != (null === (_a = null == d ? void 0 : d.uncertainty) || void 0 === _a ? void 0 : _a.upper) && (!hasHighlights || d.highlight);
                });
                var uncertaintyGroup = (0, uncertainty_renderer.B9)(this.mainGraphicsContext);
                bars = (0, uncertainty_renderer.FZ)(uncertaintyGroup, uncertaintySeries, function(_) {
                    return valueScale_1;
                }, dataPointPosition, Math.min(10, columnWidth - 2), hasHighlights, hasSelection);
                var seriesWithErrorMarkers = _.filter(uncertaintySeries, function(thisSeries) {
                    return thisSeries.uncertainty.markers.show;
                });
                if (_.isEmpty(seriesWithErrorMarkers)) uncertaintyGroup.selectAll(uncertainty_renderer.YU.selector).remove(); else {
                    var markerRenderer_1 = new marker_renderer.Wo, markerDefs = this.mainGraphicsContext.selectAll("defs").data([ 1 ]).join("defs").attr("class", uncertainty_renderer.Ok.class), markerDefinitions = [];
                    renderUncertainty && (0, uncertainty_renderer.iD)(seriesWithErrorMarkers, markerDefinitions), 
                    markerRenderer_1.ensureMarkers(markerDefs, markerDefinitions);
                    var uncertaintyMarkers_1 = (0, uncertainty_renderer.di)(uncertaintyGroup, uncertaintySeries, uncertaintyLineUpper_1, uncertaintyLineLower_1, valueAxisInverted_1, markerRenderer_1, hasSelection, hasHighlights);
                    markerPaths = uncertaintyGroup.selectAll(uncertainty_renderer.E6.selector), (markerUpdateFunction_Closure = function(currentHasSelection, currentHasHighlights) {
                        (0, uncertainty_renderer.xl)(uncertaintyMarkers_1, uncertaintyLineUpper_1, uncertaintyLineLower_1, valueAxisInverted_1, markerRenderer_1, currentHasSelection, currentHasHighlights);
                    })(hasSelection, hasHighlights);
                }
            } else (0, uncertainty_renderer.OY)(this.mainGraphicsContext);
            return {
                bars,
                markerPaths,
                updateActiveHighlightMarkers: markerUpdateFunction_Closure
            };
        }
        function setSelectedColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastSelectedColumnIndex, forceDimAll) {
            var useAnimation = !forceDimAll, allColumnDataPoints = mainGraphicsContext.selectAll(columnChart_util.L0.selector).selectAll("rect".concat(columnGroupSelector));
            allColumnDataPoints.filter(function(d) {
                return d.categoryIndex === selectedColumnIndex;
            }).interrupt().style("fill-opacity", function(d) {
                return renderUtil.Ko * (0, color.TD)(d.columnStyle.fillTransparency);
            });
            var dataPointsToDim = allColumnDataPoints.filter(function(d) {
                return (void 0 === lastSelectedColumnIndex || forceDimAll || d.categoryIndex === lastSelectedColumnIndex) && d.categoryIndex !== selectedColumnIndex;
            });
            (useAnimation ? dataPointsToDim.transition() : dataPointsToDim).style("fill-opacity", function(d) {
                return renderUtil.eU * (0, color.TD)(d.columnStyle.fillTransparency);
            });
        }
        function getDataPointFillOpacity(d, hasSelection, hasPartialHighlights) {
            return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, hasPartialHighlights, (0, 
            color.TD)(d.columnStyle.fillTransparency));
        }
        function getRibbonFillOpacity(style, hasSelection) {
            return (0, color.TD)(style.fillTransparency) * (hasSelection ? renderUtil.eU : renderUtil.Ko);
        }
        function drawRibbonConnectors(useAnimation, animator) {
            var _this = this, style = this.style, scaledMargin = this.scaledMargin, ribbonGapSize = this.ribbonGapSize, layout = this.layout, graphicsContext = this.mainGraphicsContext, isColumn = this.isColumn, interactivityService = this.interactivityService, hostServices = this.hostService, series = this.hasRibbonBands ? this.activeData.series : [];
            useAnimation && (useAnimation = null != animator);
            var ribbonBandShapeFunc = function(dataPoint) {
                var d = function(layout, ribbonChartDataPoint, ribbonGapSize, isColumn) {
                    var bottomLeft, topLeft, bottomRight, topRight, shapeLayout = layout.shapeLayout, d1 = ribbonChartDataPoint.d1, d2 = ribbonChartDataPoint.d2, x1 = shapeLayout.x(d1), y1 = shapeLayout.y(d1), width1 = shapeLayout.width(d1), height1 = shapeLayout.height(d1), x2 = shapeLayout.x(d2), y2 = shapeLayout.y(d2), width2 = shapeLayout.width(d2), height2 = shapeLayout.height(d2);
                    if (isColumn) {
                        var left = x1 + width1 + ribbonGapSize, right = x2 - ribbonGapSize;
                        bottomLeft = {
                            x: left,
                            y: y1
                        }, topLeft = {
                            x: left,
                            y: y1 + height1
                        }, bottomRight = {
                            x: right,
                            y: y2
                        }, topRight = {
                            x: right,
                            y: y2 + height2
                        };
                    } else {
                        var bottom = y1 - ribbonGapSize, top_1 = y2 + height2 + ribbonGapSize;
                        bottomLeft = {
                            x: x1,
                            y: bottom
                        }, topLeft = {
                            x: x1 + width1,
                            y: bottom
                        }, bottomRight = {
                            x: x2,
                            y: top_1
                        }, topRight = {
                            x: x2 + width2,
                            y: top_1
                        };
                    }
                    return {
                        bottomLeft,
                        topLeft,
                        bottomRight,
                        topRight
                    };
                }(layout, dataPoint, ribbonGapSize, isColumn), xi = d3.interpolateNumber(d.bottomLeft.x, d.bottomRight.x), yi = d3.interpolateNumber(d.bottomLeft.y, d.bottomRight.y), path = "M".concat(d.bottomLeft.x, ",").concat(d.bottomLeft.y);
                return path += isColumn ? "C".concat(xi(.7), ",").concat(d.bottomLeft.y, " ").concat(xi(1 - .7), ",").concat(d.bottomRight.y, " ").concat(d.bottomRight.x, ",").concat(d.bottomRight.y) : "C".concat(d.bottomLeft.x, ",").concat(yi(.7), " ").concat(d.bottomRight.x, ",").concat(yi(1 - .7), " ").concat(d.bottomRight.x, ",").concat(d.bottomRight.y), 
                path += "L".concat(d.topRight.x, ",").concat(d.topRight.y), xi = d3.interpolateNumber(d.topRight.x, d.topLeft.x), 
                yi = d3.interpolateNumber(d.topRight.y, d.topLeft.y), (path += isColumn ? "C".concat(xi(.7), ",").concat(d.topRight.y, " ").concat(xi(1 - .7), ",").concat(d.topLeft.y, " ").concat(d.topLeft.x, ",").concat(d.topLeft.y) : "C".concat(d.topRight.x, ",").concat(yi(.7), " ").concat(d.topLeft.x, ",").concat(yi(1 - .7), " ").concat(d.topLeft.x, ",").concat(d.topLeft.y)) + "L".concat(d.bottomLeft.x, ",").concat(d.bottomLeft.y, "Z");
            }, layer = graphicsContext.select(RibbonChartLayerCS.selector);
            layer.empty() && (layer = graphicsContext.append("g").classed(RibbonChartLayerCS.class, !0));
            var defs = graphicsContext.select(RibbonChartDefsCS.selector);
            defs.empty() && (defs = graphicsContext.append("defs").classed(RibbonChartDefsCS.class, !0));
            var getUniqueID = function(d) {
                return "".concat(hostServices.instanceId, "-").concat(d.d1.categoryIndex, "-").concat(d.d1.seriesIndex);
            }, clipPaths = defs.selectAll("clipPath").data(_.flatMap(series, function(s) {
                var _a, _b;
                return (null === (_a = s.ribbonBands) || void 0 === _a ? void 0 : _a.border.strokeShow) ? null === (_b = s.ribbonBands) || void 0 === _b ? void 0 : _b.dataPoints : [];
            }), getUniqueID), newClipPaths = clipPaths.enter().append("clipPath").attr("id", getUniqueID);
            newClipPaths.append("path");
            var paths = newClipPaths.merge(clipPaths).select("path");
            (useAnimation ? paths.transition().duration(animator.getDuration()) : paths.interrupt()).attr("d", ribbonBandShapeFunc), 
            clipPaths.exit().remove(), layer.selectAll(RibbonChartSeriesCS.selector).data(series, function(s) {
                return s.key;
            }).join(function(enter) {
                return enter.append("g").classed(RibbonChartSeriesCS.class, !0);
            }).styles({
                fill: function(d) {
                    return style.isHighContrast ? style.colorPalette.backgroundNeutral.value : d.ribbonBands.fillColor;
                },
                "fill-opacity": function(d) {
                    return getRibbonFillOpacity(d.ribbonBands, null == interactivityService ? void 0 : interactivityService.hasSelection());
                },
                stroke: function(d) {
                    return BorderRenderUtil.color(d.ribbonBands.border, style);
                },
                "stroke-width": function(d) {
                    return BorderRenderUtil.size(d.ribbonBands.border, style);
                },
                "stroke-opacity": function(d) {
                    return BorderRenderUtil.opacity(d.ribbonBands.border, style, null == interactivityService ? void 0 : interactivityService.hasSelection());
                }
            }).each(function(theSeries, seriesIndex, nodes) {
                debug.fF.assert(function() {
                    return void 0 !== theSeries.ribbonBands;
                }, "ribbonBands must be defined.");
                var dataPoints = theSeries.ribbonBands.dataPoints;
                debug.fF.assert(function() {
                    return void 0 !== dataPoints;
                }, "dataPoints must be defined.");
                var shapesUpdate = d3.select(nodes[seriesIndex]).selectAll(RibbonChartDataPointCS.selector).data(dataPoints, function(d) {
                    var _a;
                    return null !== (_a = d.d1.pairKey) && void 0 !== _a ? _a : d.d1.key;
                }).join(function(enter) {
                    return enter.append("path").classed(RibbonChartDataPointCS.class, !0);
                }).style("clip-path", function(d) {
                    return theSeries.ribbonBands.border.strokeShow && !style.isHighContrast ? "url(#".concat(getUniqueID(d), ")") : null;
                });
                _this.featureSwitches.onObject && shapesUpdate.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "ribbon").attr(htmlSubSelectionHelper.QZ, 3).each(function() {
                    htmlSubSelectionHelper.O5.setDataForElement(this, {
                        outlineRestrictionOptions: {
                            margin: scaledMargin
                        },
                        getDisplayName: function() {
                            return hostServices.getLocalizedString("MiniToolbar_Ribbon", theSeries.displayName);
                        },
                        getRegionOutlines: function() {
                            return [];
                        }
                    });
                }), (useAnimation ? shapesUpdate.transition().duration(animator.getDuration()) : shapesUpdate.interrupt()).attr("d", ribbonBandShapeFunc);
            });
        }
    },
    38859: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            $3: function() {
                return createTotalLabelDataPoints;
            },
            C3: function() {
                return isStacked;
            },
            Ds: function() {
                return isStacked100;
            },
            E5: function() {
                return ClusteredGapSizeMax;
            },
            EX: function() {
                return createUncertaintyLabels;
            },
            G1: function() {
                return canSupportOutsidePosition;
            },
            HQ: function() {
                return DefaultLayout;
            },
            L0: function() {
                return SeriesClasses;
            },
            L2: function() {
                return getDefaultColumnLabelSettings;
            },
            Q4: function() {
                return createLabelDataPoints;
            },
            V5: function() {
                return isClustered;
            },
            VY: function() {
                return calcValueDomain;
            },
            _f: function() {
                return StackedExplodeGapSizeMax;
            },
            bS: function() {
                return getDefaultRibbon;
            },
            e3: function() {
                return validLabelPositions;
            },
            fX: function() {
                return StackedGapSizeMin;
            },
            fl: function() {
                return DefaultFillTransparency;
            },
            hg: function() {
                return isBar;
            },
            iR: function() {
                return DefaultZeroScalarDomain;
            },
            jL: function() {
                return ClusteredOverlapSizeMax;
            },
            nD: function() {
                return StackedErodeGapSizeMax;
            },
            nO: function() {
                return getDefaultBorder;
            },
            o9: function() {
                return addExplodedGap;
            },
            t3: function() {
                return isColumn;
            }
        });
        var _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(44783), _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79154), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62458), _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(41640), _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(32041), _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(43286), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(72489), _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(22733), _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90120), _Visuals_common_dataLabelUtil__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(46769), _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21181), _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(18664), _Visuals_common_labelDataPointSorter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12198), _Visuals_common_uncertainty_util__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(44196), _Visuals_types_errorFormat__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(77558), _Visuals_types_labelOrientation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(20624), _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(382), _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(56707), _Visuals_common_dataLabelContainerUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(34519), _Visuals_common_dataLabelContainerTruncation__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(45028), _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33948), _Visuals_types_detailContentType__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(93907), _Visuals_types_labelContentLayout__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(63892), _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47316), _cartesianHelper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(34969), _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5381), ClusteredValidLabelPositionOptions = [ _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.auto, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.outsideEnd, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideEnd, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideCenter, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideBase ], StackedValidLabelPositionOptions = [ _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.auto, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideCenter, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideEnd, _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideBase ], SeriesClasses = (0, 
        _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_1__.CH)("series"), validLabelPositionsAutoClustered = [ 16, 4, 1, 2 ], validLabelPositionsAutoStacked = [ 1, 4, 2 ], validTotalLabelPositions = [ 16 ], minimumLabelsToRender = 4, DefaultZeroScalarDomain = [ 0, 1 ], DefaultFillTransparency = 0, DefaultLayout = {
            seriesOrderReversed: !1,
            seriesOrderSorted: !1,
            stackedGapSize: 0,
            stackedGapExplodes: !1,
            clusteredGapSize: 0,
            clusteredGapOverlaps: !1,
            clusteredGapOverlapReverse: !1,
            ribbonGapSize: 0
        }, StackedGapSizeMin = 0, StackedExplodeGapSizeMax = 10, StackedErodeGapSizeMax = 5, ClusteredGapSizeMax = 75, ClusteredOverlapSizeMax = 100;
        function getDefaultBorder(style) {
            return {
                strokeShow: !1,
                strokeColorMatch: !1,
                strokeTransparency: 0,
                strokeWidth: 1,
                strokeColor: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, "foregroundNeutralSecondaryAlt"),
                strokePattern: _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__.Dv.solid,
                outlineOnly: !1
            };
        }
        function getDefaultRibbon(style) {
            return {
                fillMatchColor: !0,
                fillColor: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, "backgroundNeutral"),
                fillTransparency: 30,
                border: getDefaultBorder(style)
            };
        }
        function addExplodedGap(dataPoint, layout) {
            if (layout.stackedGapExplodes && layout.stackedGapSize > 0) {
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_4__.fF.assert(function() {
                    return layout.stackedGapExplodeStepSize > 0;
                }, "stackedGapExplodeStepSize must be pre-computed via the converter.");
                var adjustment = dataPoint.indexFromZeroValue * (dataPoint.value < 0 ? -1 : 1) * layout.stackedGapExplodeStepSize;
                dataPoint.position += adjustment, dataPoint.originalPosition += adjustment;
            }
        }
        function createLabelDataPoints(style) {
            var _a, _this = this, data = this.activeData;
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_4__.fF.assertValue(data, "createLabelDataPoints this.activeData must be set"), 
            !(null === (_a = data.dataLabelsSettings) || void 0 === _a ? void 0 : _a.show)) return [];
            var series = data.series, formattersCache = (0, _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_5__.fI)(), labelDataPointGroups = series.map(function(currentSeries) {
                var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.dataLabelsSettings;
                if (!labelSettings.show) return {
                    labelDataPoints: [],
                    maxNumberOfLabels: 0
                };
                var maxNumberOfLabels = 100 !== labelSettings.labelDensity && data.isScalar ? (0, 
                _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.SS)(_this.availableWidth, labelSettings.labelDensity, minimumLabelsToRender, _Visuals_common_labelDataPointSorter__WEBPACK_IMPORTED_MODULE_7__.v.estimatedLabelWidth) : currentSeries.data.length;
                return {
                    labelDataPoints: currentSeries.data.filter(function(dp) {
                        return !(null == dp || null == dp.value || data.hasHighlights && !dp.highlight);
                    }).map(function(cartesianDataPoint) {
                        var labelDataPoint = createLabelDataPoint.call(_this, cartesianDataPoint, labelSettings, formattersCache, style, currentSeries);
                        return cartesianDataPoint.labelDataPointContainerEnabled ? (0, _Visuals_common_dataLabelContainerUtils__WEBPACK_IMPORTED_MODULE_8__.U)({
                            cartesianDataPoint,
                            currentAxisProperties: _this.valueAxis,
                            currentSeries,
                            enableValueDataLabel: labelSettings.enableValueDataLabel,
                            formattersCache,
                            isStacked100: _this.isStacked100,
                            labelDataPoint,
                            percentOfTotal: cartesianDataPoint.value,
                            seriesName: currentSeries.displayName,
                            valueDataLabelSettings: labelSettings,
                            valueShowBlankAs: labelSettings.showBlankAs,
                            getOutsideLabelFill: function(appendedLabelContent) {
                                return (0, _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__.j)(appendedLabelContent.labelFill, !1, _this.isComboChart, style);
                            },
                            getInsideLabelFill: function(appendedLabelContent) {
                                return (0, _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__.j)(appendedLabelContent.labelFill, !0, _this.isComboChart, style);
                            }
                        }) : labelDataPoint;
                    }),
                    maxNumberOfLabels
                };
            });
            return data.isScalar ? new _Visuals_common_labelDataPointSorter__WEBPACK_IMPORTED_MODULE_7__.v(labelDataPointGroups, series, {
                width: this.availableWidth,
                height: this.availableHeight
            }, this.valueAxis.scale).getSortedDataLabels() : labelDataPointGroups;
        }
        function createLabelDataPoint(dataPoint, valueLabelSettings, formattersCache, style, currentSeries) {
            var _a, labelText;
            (null == valueLabelSettings ? void 0 : valueLabelSettings.displayUnits) === _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.In && (valueLabelSettings.precision = void 0);
            var labelUnitsAndPrecision = (0, _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.d6)(this.valueAxis, valueLabelSettings);
            if (null === (_a = dataPoint.dynamicLabelValue) || void 0 === _a ? void 0 : _a.enabled) labelText = (0, 
            _Visuals_common_dataLabelUtil__WEBPACK_IMPORTED_MODULE_11__.nU)(dataPoint.dynamicLabelValue, formattersCache, valueLabelSettings, labelUnitsAndPrecision, currentSeries, "Value"), 
            !this.featureSwitches.labelEnhancementsM0 && this.featureSwitches.measureDrivenDataLabels && "" === labelText && (labelText = void 0); else {
                var customFormatString = (null == valueLabelSettings ? void 0 : valueLabelSettings.displayUnits) === _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.In ? valueLabelSettings.valueCustomFormatString : void 0, formatString = (0, 
                _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__.yE)(this.columnChartType, 48) && !this.featureSwitches.labelEnhancementsM0 ? _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.L0 : null != customFormatString ? customFormatString : dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, valueLabelSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!formatString, currentSeries.type)), value = dataPoint.value;
                this.isStacked100 && this.featureSwitches.labelEnhancementsM0 && (value = dataPoint.originalValue), 
                labelText = (0, _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.Bw)(formatter.format(value));
            }
            var validPositions, positions, matchingOverflowPosition, overflowPositions, orientation, fontProperties = valueLabelSettings.fontProperties, properties = (0, 
            _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_13__.qk)(fontProperties, labelText), textWidth = _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__.b.measureSvgTextWidth(properties), textHeight = _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__.b.estimateSvgTextHeight(properties, !0);
            return validPositions = this.isClusteredOptimized ? function(position) {
                switch (position) {
                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideEnd:
                    return [ 4 ];

                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideCenter:
                    return [ 1 ];

                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideBase:
                    return [ 2 ];

                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.outsideEnd:
                    return [ 16 ];

                  default:
                    return validLabelPositionsAutoClustered;
                }
            }(valueLabelSettings.position) : function(position) {
                switch (position) {
                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideEnd:
                    return [ 4 ];

                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideBase:
                    return [ 2 ];

                  case _Visuals_types_labelPosition1__WEBPACK_IMPORTED_MODULE_0__.h.insideCenter:
                    return [ 1 ];

                  default:
                    return validLabelPositionsAutoStacked;
                }
            }(valueLabelSettings.position), valueLabelSettings.labelOverflow && (positions = validPositions, 
            matchingOverflowPosition = function(position) {
                switch (position) {
                  case 4:
                    return 128;

                  case 2:
                    return 64;

                  case 1:
                    return 32;

                  default:
                    return;
                }
            }, overflowPositions = _.map(positions, function(position) {
                return matchingOverflowPosition(position);
            }).filter(function(overflowPosition) {
                return void 0 !== overflowPosition;
            }), validPositions = positions.concat(overflowPositions)), orientation = this.isBar ? dataPoint.value >= 0 ? this.valueAxis.invertAxis ? 4 : 3 : this.valueAxis.invertAxis ? 3 : 4 : dataPoint.value >= 0 ? this.valueAxis.invertAxis ? 2 : 1 : this.valueAxis.invertAxis ? 1 : 2, 
            {
                isPreferred: !1,
                text: labelText,
                textSize: {
                    width: textWidth,
                    height: textHeight
                },
                outsideFill: (0, _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__.j)(dataPoint.labelFill, !1, this.isComboChart, style),
                insideFill: (0, _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__.j)(dataPoint.labelFill, !0, this.isComboChart, style),
                parentType: 1,
                parentShape: {
                    rect: {
                        left: this.layout.shapeLayout.x(dataPoint),
                        top: this.layout.shapeLayout.y(dataPoint),
                        width: this.layout.shapeLayout.width(dataPoint),
                        height: this.layout.shapeLayout.height(dataPoint)
                    },
                    orientation,
                    validPositions
                },
                identity: dataPoint.identity,
                fontProperties,
                hasBackground: valueLabelSettings.enableBackground,
                backgroundColor: valueLabelSettings.backgroundColor,
                backgroundTransparency: valueLabelSettings.backgroundTransparency,
                transparency: valueLabelSettings.transparency
            };
        }
        function createTotalLabelDataPoints(style) {
            var _a, _this = this, data = this.activeData;
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_4__.fF.assertValue(data, "createTotalLabelDataPoints this.activeData must be set"), 
            !this.isStackedOptimized || !(null === (_a = data.totalLabelsSettings) || void 0 === _a ? void 0 : _a.show) || this.isStacked100) return [];
            for (var metadataColumn = (0, _cartesianHelper__WEBPACK_IMPORTED_MODULE_15__.GN)(data.valuesMetadata), columnFormatString = (0, 
            _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_16__.EO)(metadataColumn, _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_17__.p.general.formatString), formattersCache = (0, 
            _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_5__.fI)(), shapeLayout = this.layout.shapeLayout, labelSettings = data.totalLabelsSettings, labelUnitsAndPrecision = (0, 
            _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.d6)(this.valueAxis, labelSettings), seriesLabelDataPoints = [], createTotalDataPoint = function(total, totalIndex, invertValueAxis_) {
                if (0 !== total) {
                    var totalDataPoint = data.totals[totalIndex], formatter = formattersCache.getOrCreate(totalDataPoint.dynamicFormatString || columnFormatString, labelSettings, labelUnitsAndPrecision.units, labelSettings.precision), text = (0, 
                    _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.Bw)(formatter.format(total)), fontProperties = labelSettings.fontProperties, textProperties = (0, 
                    _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_13__.qk)(fontProperties, text), labelPosition = labelSettings.showPositiveAndNegative ? total : total > 0 ? totalDataPoint.positive : totalDataPoint.negative, positioningDataPoint = {
                        value: labelPosition,
                        position: labelPosition < 0 ? 0 : labelPosition,
                        valueAbsolute: Math.abs(labelPosition),
                        categoryIndex: totalDataPoint.categoryIndex,
                        categoryValue: totalDataPoint.categoryValue,
                        labelSettings: void 0,
                        columnStyle: {
                            fillColor: void 0,
                            fillTransparency: 0,
                            border: getDefaultBorder(style)
                        },
                        originalValue: void 0,
                        originalPosition: void 0,
                        key: void 0,
                        seriesIndex: void 0,
                        selected: void 0,
                        identity: void 0,
                        labelDataPointContainerEnabled: !1,
                        indexFromZeroValue: _this.data.layout.stackedGapExplodes ? (total > 0 ? totalDataPoint.positiveCount : totalDataPoint.negativeCount) - 1 : 0
                    };
                    addExplodedGap(positioningDataPoint, _this.data.layout), seriesLabelDataPoints.push({
                        isPreferred: !1,
                        text,
                        textSize: {
                            width: _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__.b.measureSvgTextWidth(textProperties),
                            height: _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__.b.estimateSvgTextHeight(textProperties, !0)
                        },
                        outsideFill: (0, _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__.j)(null == totalDataPoint ? void 0 : totalDataPoint.labelFill, !1, _this.isComboChart, style),
                        insideFill: (0, _Visuals_common_getLabelFill__WEBPACK_IMPORTED_MODULE_9__.j)(null == totalDataPoint ? void 0 : totalDataPoint.labelFill, !0, _this.isComboChart, style),
                        parentType: 1,
                        parentShape: {
                            rect: {
                                left: shapeLayout.x(positioningDataPoint),
                                top: shapeLayout.y(positioningDataPoint),
                                width: shapeLayout.width(positioningDataPoint),
                                height: shapeLayout.height(positioningDataPoint)
                            },
                            orientation: _this.isBar ? total >= 0 ? invertValueAxis_ ? 4 : 3 : invertValueAxis_ ? 3 : 4 : total >= 0 ? invertValueAxis_ ? 2 : 1 : invertValueAxis_ ? 1 : 2,
                            validPositions: validTotalLabelPositions
                        },
                        identity: void 0,
                        fontProperties,
                        hasBackground: labelSettings.enableBackground,
                        backgroundColor: labelSettings.backgroundColor,
                        backgroundTransparency: labelSettings.backgroundTransparency,
                        isTotal: !0
                    });
                }
            }, totalIndex = 0; totalIndex < data.totals.length; totalIndex++) {
                var totals = data.totals[totalIndex];
                totals && (data.totalLabelsSettings.showPositiveAndNegative ? (createTotalDataPoint(totals.positive, totalIndex, this.valueAxis.invertAxis), 
                createTotalDataPoint(totals.negative, totalIndex, this.valueAxis.invertAxis)) : createTotalDataPoint(totals.net, totalIndex, this.valueAxis.invertAxis));
            }
            return [ {
                labelDataPoints: seriesLabelDataPoints,
                maxNumberOfLabels: 2 * data.totals.length,
                isTotal: !0
            } ];
        }
        function createUncertaintyLabels(style) {
            var _this = this, data = this.activeData;
            if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_4__.fF.assertValue(data, "createUncertaintyLabels this.activeData must be set"), 
            this.isStackedOptimized || _.isEmpty(_.filter(this.activeData.series, function(series) {
                var _a;
                return null === (_a = series.uncertainty) || void 0 === _a ? void 0 : _a.labels.show;
            }))) return [];
            var formattersCache = (0, _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_5__.fI)(), shapeLayout = this.layout.shapeLayout, uncertaintyLayout = this.layout.uncertaintyLayout, columnMidpoint = this.columnWidth / 2, columnMidpointThinner = columnMidpoint / 2;
            return data.series.map(function(currentSeries) {
                var uncertainty = currentSeries.uncertainty;
                if (!uncertainty || !uncertainty.renderUncertainty || !uncertainty.labels.show) return {
                    labelDataPoints: [],
                    maxNumberOfLabels: 0
                };
                var labelSettings = uncertainty.labels, fontProperties = labelSettings.fontProperties, labelUnitsAndPrecision = (0, 
                _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.d6)(_this.valueAxis, labelSettings), seriesLabelDataPoints = [];
                return currentSeries.data.forEach(function(dataPoint) {
                    if (null != dataPoint && null != dataPoint.value && (!data.hasHighlights || dataPoint.highlight) && null != dataPoint.uncertainty) {
                        for (var uncertaintyLabels = [], errorFormattedUncertainty = (0, _Visuals_common_uncertainty_util__WEBPACK_IMPORTED_MODULE_18__.Ww)(dataPoint.value, dataPoint.uncertainty, labelSettings.errorFormat), errorFormattedData = [ errorFormattedUncertainty.lower, errorFormattedUncertainty.upper ], i = 0; i < 2; i++) {
                            var formattedUncertainty = errorFormattedData[i], isUpper = 1 === i;
                            if (null != (isUpper ? dataPoint.uncertainty.upper : dataPoint.uncertainty.lower)) {
                                var text = void 0;
                                if (labelSettings.errorFormat === _Visuals_types_errorFormat__WEBPACK_IMPORTED_MODULE_19__.K.relativePercentage) text = (0, 
                                _Visuals_common_uncertainty_util__WEBPACK_IMPORTED_MODULE_18__.O2)(formattedUncertainty, _this.hostService); else {
                                    var formatString = dataPoint.labelFormatString, formatter = formattersCache.getOrCreate(formatString, labelSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!formatString, currentSeries.type));
                                    text = (0, _Visuals_common_dataLabelRendererEnhanced__WEBPACK_IMPORTED_MODULE_6__.Bw)(formatter.format(formattedUncertainty));
                                }
                                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_4__.fF.assertValue(text, "label has no value -- columnUtil.createUncertaintyLabels");
                                var textProperties = (0, _Visuals_common_fontProperties__WEBPACK_IMPORTED_MODULE_13__.qk)(fontProperties, text), parentPoint = void 0, validPositions = void 0;
                                _this.isBar ? (parentPoint = {
                                    x: isUpper ? uncertaintyLayout.upper(dataPoint) : uncertaintyLayout.lower(dataPoint),
                                    y: shapeLayout.y(dataPoint) + (dataPoint.drawThinner ? columnMidpointThinner : columnMidpoint)
                                }, validPositions = [ isUpper ? 8 : 4 ]) : (parentPoint = {
                                    x: shapeLayout.x(dataPoint) + (dataPoint.drawThinner ? columnMidpointThinner : columnMidpoint),
                                    y: isUpper ? uncertaintyLayout.upper(dataPoint) : uncertaintyLayout.lower(dataPoint)
                                }, validPositions = [ isUpper ? 1 : 2 ]), uncertaintyLabels.push({
                                    isPreferred: !1,
                                    text,
                                    textSize: {
                                        width: _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__.b.measureSvgTextWidth(textProperties) + _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.TS,
                                        height: _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_14__.b.estimateSvgTextHeight(textProperties, !0)
                                    },
                                    outsideFill: fontProperties.color ? fontProperties.color : _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.uQ),
                                    insideFill: fontProperties.color ? fontProperties.color : _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.pl),
                                    parentType: 0,
                                    parentShape: {
                                        point: parentPoint,
                                        radius: 0,
                                        validPositions
                                    },
                                    identity: void 0,
                                    fontProperties,
                                    hasBackground: labelSettings.enableBackground,
                                    backgroundColor: labelSettings.backgroundColor,
                                    backgroundTransparency: labelSettings.backgroundTransparency
                                });
                            }
                        }
                        _.isEmpty(uncertaintyLabels) || seriesLabelDataPoints.push.apply(seriesLabelDataPoints, uncertaintyLabels);
                    }
                }), {
                    labelDataPoints: seriesLabelDataPoints,
                    maxNumberOfLabels: 100
                };
            });
        }
        var PctRoundingError = 1e-4;
        function calcValueDomain(data, is100pct) {
            if (0 === data.length) return {
                min: 0,
                max: 10
            };
            var min = d3.min(data, function(d) {
                return d3.min(d.data, function(e) {
                    return e.position - e.valueAbsolute;
                });
            }), max = d3.max(data, function(d) {
                return d3.max(d.data, function(e) {
                    return e.position;
                });
            });
            return is100pct && (min = (0, _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_20__.W0)(min, PctRoundingError), 
            max = (0, _VisualsCommon_Double__WEBPACK_IMPORTED_MODULE_20__.W0)(max, PctRoundingError)), 
            {
                min,
                max
            };
        }
        function getDefaultColumnLabelSettings(style, stacked100, isCombo, chartType, seriesCount) {
            void 0 === isCombo && (isCombo = !1);
            var labelSettings = (0, _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_5__.bT)({
                style,
                textClassName: "smallLightLabel",
                noColor: !0
            });
            return labelSettings.position = null, labelSettings.labelDensity = _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.go, 
            labelSettings.labelOrientation = _Visuals_types_labelOrientation__WEBPACK_IMPORTED_MODULE_21__.B.Horizontal, 
            isCombo ? (labelSettings.enableBackground = !0, labelSettings.backgroundColor = _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_22__.U), 
            labelSettings.backgroundTransparency = _Visuals_common_consts_dataLabelViewModel1Consts__WEBPACK_IMPORTED_MODULE_10__.r_) : labelSettings.enableBackground = !1, 
            labelSettings.enableTitleDataLabel = !1, stacked100 ? (labelSettings.enableValueDataLabel = !1, 
            labelSettings.enableDetailDataLabel = !0, labelSettings.detailContentType = _Visuals_types_detailContentType__WEBPACK_IMPORTED_MODULE_23__.W.Percent) : (labelSettings.enableValueDataLabel = !0, 
            labelSettings.enableDetailDataLabel = !1), labelSettings.labelContainerMaxWidth = _Visuals_common_dataLabelContainerTruncation__WEBPACK_IMPORTED_MODULE_24__.w9, 
            labelSettings.labelContentLayout = function(chartType, seriesCount) {
                return chartType && !isBar(chartType) && (isClustered(chartType) || isStacked(chartType, seriesCount) || isStacked100(chartType)) || isColumn(chartType) ? _Visuals_types_labelContentLayout__WEBPACK_IMPORTED_MODULE_25__.v.MultiLine : _Visuals_types_labelContentLayout__WEBPACK_IMPORTED_MODULE_25__.v.SingleLine;
            }(chartType, seriesCount), labelSettings;
        }
        function canSupportOutsidePosition(chartType, seriesCount) {
            return !isStacked(chartType, seriesCount);
        }
        function validLabelPositions(chartType, seriesCount) {
            return canSupportOutsidePosition(chartType, seriesCount) ? ClusteredValidLabelPositionOptions : StackedValidLabelPositionOptions;
        }
        function isStacked(chartType, seriesLength) {
            return (0, _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__.yE)(chartType, 16) && (1 !== seriesLength || isStacked100(chartType));
        }
        function isStacked100(chartType) {
            return (0, _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__.yE)(chartType, 48);
        }
        function isBar(chartType) {
            return (0, _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__.yE)(chartType, 2);
        }
        function isColumn(chartType) {
            return (0, _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__.yE)(chartType, 4);
        }
        function isClustered(chartType) {
            return (0, _VisualsCommon_Utility_StandaloneUtility3__WEBPACK_IMPORTED_MODULE_12__.yE)(chartType, 8);
        }
    },
    88439: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            GJ: function() {
                return mergeFormattingCards;
            },
            on: function() {
                return getRoleGroups;
            },
            pD: function() {
                return sortComboChartFormattingCards;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81337), _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84741), _Visuals_common_formattingModelUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61617), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62458), _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56578), _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32379), RoleGroups = [ [ _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__.rJ.y, _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__.rJ.tooltips ], [ _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__.rJ.y2 ] ];
        function getRoleGroups() {
            return RoleGroups;
        }
        function mergeFormattingCards(layerCards, type, localize) {
            if (0 === layerCards.length) return [];
            var ordering, topLevelToggleType, cardsToMerge;
            switch (type) {
              case 13:
              case 14:
                ordering = [ 4, 0 ], topLevelToggleType = 4;
                break;

              default:
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("There is no support to merge formatting cards for this chart type (enum): ".concat(type));
            }
            if (cardsToMerge = function(layerCards, layerOrdering) {
                if (0 !== layerOrdering.length) {
                    var layerDict = {};
                    layerCards.forEach(function(cardAndType) {
                        layerDict[cardAndType.type] = cardAndType.card;
                    });
                    for (var sortedLayerCards = [], _loop_1 = function(layerType) {
                        layerDict[layerType] && layerDict[layerType].forEach(function(card) {
                            return sortedLayerCards.push({
                                card,
                                type: layerType
                            });
                        });
                    }, _i = 0, layerOrdering_1 = layerOrdering; _i < layerOrdering_1.length; _i++) _loop_1(layerOrdering_1[_i]);
                    return sortedLayerCards;
                }
            }(layerCards, ordering), 0 === cardsToMerge.length) return [];
            for (var cardDict = {}, _i = 0, cardsToMerge_1 = cardsToMerge; _i < cardsToMerge_1.length; _i++) {
                var cardAndType = cardsToMerge_1[_i], card = cardAndType.card;
                cardDict[card.uid] = cardDict[card.uid] ? {
                    card: mergeFormattingCard(cardDict[card.uid].card, card, cardDict[card.uid].type, cardAndType.type, localize, topLevelToggleType),
                    type: cardAndType.type
                } : {
                    card,
                    type: cardAndType.type
                };
            }
            for (var cards = [], _a = 0, _b = _.values(cardDict); _a < _b.length; _a++) cards.push(_b[_a].card);
            return cards;
        }
        function mergeFormattingCard(card1, card2, type1, type2, localize, topLevelToggleType) {
            var topLevelToggle = topLevelToggleType === type2 ? card2.topLevelToggle : card1.topLevelToggle, newFormattingCard = (0, 
            tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, card1), {
                topLevelToggle
            }), card2GroupDict = {};
            card2.groups.forEach(function(group) {
                card2GroupDict[group.uid] = group;
            }), card1.groups.forEach(function(card1Group, index) {
                if ((0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(card1Group)) _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("Unsupported placeholder"); else {
                    var card2Group = card2GroupDict[card1Group.uid];
                    card2Group && (newFormattingCard.groups[index] = mergeFormattingGroup(card1Group, card2Group, type1, type2, localize, "errorBars" === card1.uid), 
                    delete card2GroupDict[card1Group.uid]);
                }
            });
            for (var _i = 0, _a = card2.groups; _i < _a.length; _i++) {
                var group2Slice = _a[_i];
                if ((0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(group2Slice)) return void _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("Unsupported placeholder");
                var group2SliceInDict = card2GroupDict[group2Slice.uid];
                group2SliceInDict && newFormattingCard.groups.push(group2SliceInDict);
            }
            var revertToDefaultDescriptors = _.unionWith(card1.revertToDefaultDescriptors, card2.revertToDefaultDescriptors, _.isEqual), existingComboProps = _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__.OA;
            return newFormattingCard.revertToDefaultDescriptors = revertToDefaultDescriptors.filter(function(d) {
                return existingComboProps[d.objectName] && existingComboProps[d.objectName][d.propertyName];
            }), newFormattingCard;
        }
        function mergeFormattingGroup(group1, group2, type1, type2, localize, appendOnly) {
            var newFormattingGroup = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, group2), group1Slices = group1.slices;
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return !group1Slices || group1Slices.every(function(s) {
                    return !(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(s);
                });
            }, "Unexpected placeholder");
            var group2Slices = group2.slices;
            return _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return !group2Slices || group2Slices.every(function(s) {
                    return !(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(s);
                });
            }, "Unexpected placeholder"), newFormattingGroup.slices = mergeFormattingSlices(group1Slices, group2Slices, type1, type2, localize), 
            newFormattingGroup.container = group1.container && group2.container ? function(container1, container2, type1, type2, localize, appendOnly) {
                var _a, newFormattingContainer = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, container2);
                newFormattingContainer.containerItems = [];
                var container1Items = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], container1.containerItems, !0), container2Items = (0, 
                tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], container2.containerItems, !0);
                if (appendOnly) (_a = newFormattingContainer.containerItems).push.apply(_a, (0, 
                tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], container2Items, !1), container1Items, !1)); else {
                    var templateContainerItem = void 0;
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                        return container1Items[0].displayName === container2Items[0].displayName;
                    }, "Trying to create a template from formattingContainerItems from items that are not equal"), 
                    container1.containerItems.length > 0 && container2.containerItems.length > 0 && (templateContainerItem = function(item1, item2, type1, type2, localize) {
                        var newItem = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, item2), {
                            groups: [],
                            slices: []
                        }), item2GroupDict = {};
                        item2.groups.forEach(function(group) {
                            item2GroupDict[group.uid] = group;
                        }), item1.groups.forEach(function(item1Group, index) {
                            var item2Group = item2GroupDict[item1Group.uid];
                            item2Group ? (newItem.groups[index] = mergeFormattingGroup(item1Group, item2Group, type1, type2, localize), 
                            delete item2GroupDict[item1Group.uid]) : newItem.groups[index] = item1Group;
                        });
                        for (var _i = 0, _a = item2.groups; _i < _a.length; _i++) {
                            var item = _a[_i];
                            item2GroupDict[item.uid] && newItem.groups.push(item2GroupDict[item.uid]);
                        }
                        return newItem.slices = mergeFormattingSlices(item1.slices, item2.slices, type1, type2, localize), 
                        newItem;
                    }(container1Items.shift(), container2Items.shift(), type1, type2, localize)), newFormattingContainer.containerItems.push(templateContainerItem);
                    for (var containerItems = [], _i = 0, container1Items_1 = container1Items; _i < container1Items_1.length; _i++) containerItems.push({
                        containerItem: container1Items_1[_i],
                        layerType: type1
                    });
                    for (var _b = 0, container2Items_1 = container2Items; _b < container2Items_1.length; _b++) containerItems.push({
                        containerItem: container2Items_1[_b],
                        layerType: type2
                    });
                    for (var _c = 0, containerItems_1 = containerItems; _c < containerItems_1.length; _c++) {
                        var item = containerItems_1[_c];
                        newFormattingContainer.containerItems.push(matchContainerItemToTemplate(templateContainerItem, item.containerItem, item.layerType));
                    }
                }
                return newFormattingContainer;
            }(group1.container, group2.container, type1, type2, localize, appendOnly) : group1.container || group2.container, 
            newFormattingGroup;
        }
        function getLabelDensitySliceIndex(slices) {
            return _.findIndex(slices, function(slice) {
                return !(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice) && function(slice) {
                    var labelDensityProp = _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__.OA.labels.labelDensity, descriptor = slice.control.properties.descriptor;
                    return descriptor.objectName === labelDensityProp.objectName && descriptor.propertyName === labelDensityProp.propertyName;
                }(slice);
            });
        }
        function mergeFormattingSlices(slices1, slices2, type1, type2, localize) {
            var newSlices = [], labelDensitySlice1Index = getLabelDensitySliceIndex(slices1), labelDensitySlice1 = slices1[labelDensitySlice1Index], labelDensitySlice2Index = getLabelDensitySliceIndex(slices2), labelDensitySlice2 = slices2[labelDensitySlice2Index];
            labelDensitySlice1 && labelDensitySlice2 && (slices1 = slices1.filter(function(slice, index) {
                return !(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice) && index !== labelDensitySlice1Index;
            }), slices2 = slices2.filter(function(slice, index) {
                return !(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice) && index !== labelDensitySlice2Index;
            }));
            var existingComboProps = _Visuals_capabilities_comboChart_capabilities__WEBPACK_IMPORTED_MODULE_0__.OA, slice2Dict = {};
            slices2.forEach(function(slice) {
                existsInProps(slice, existingComboProps) && (slice2Dict[(0, _Visuals_common_formattingModelUtil__WEBPACK_IMPORTED_MODULE_4__.zU)(slice, !1)] = slice);
            }), slices1.forEach(function(slice1) {
                if (existsInProps(slice1, existingComboProps)) {
                    var slice2 = slice2Dict[(0, _Visuals_common_formattingModelUtil__WEBPACK_IMPORTED_MODULE_4__.zU)(slice1, !1)], displayName = slice1.displayName;
                    if (function(slice1, slice2) {
                        return !(!slice2 || slice2.control.type !== slice1.control.type || !function(slice1, slice2) {
                            if (!(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice1) && !(0, 
                            _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice2)) {
                                var firstDescriptor = slice1.control.properties.descriptor, secondDescriptor = slice2.control.properties.descriptor;
                                if (_.isEqual(_.omit(secondDescriptor, [ "selector", "instanceKind" ]), _.omit(firstDescriptor, [ "selector", "instanceKind" ]))) {
                                    if (_VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.fS(secondDescriptor.selector, firstDescriptor.selector)) return !0;
                                    var wildcardMatch = void 0;
                                    if (null == secondDescriptor.selector && (wildcardMatch = _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.N6(firstDescriptor.selector)), 
                                    null == firstDescriptor.selector && (wildcardMatch = _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.N6(secondDescriptor.selector)), 
                                    wildcardMatch) return function(slice1, slice2) {
                                        var _a, firstDescriptor = slice1.control.properties.descriptor, secondDescriptor = slice2.control.properties.descriptor;
                                        firstDescriptor.instanceKind |= secondDescriptor.instanceKind, null !== (_a = firstDescriptor.selector) && void 0 !== _a || (firstDescriptor.selector = secondDescriptor.selector);
                                    }(slice1, slice2), !0;
                                }
                                return !1;
                            }
                            return !0;
                        }(slice1, slice2) || "Dropdown" === slice2.control.type && !dropdownEquals(slice2.control.properties, slice1.control.properties));
                    }(slice1, slice2)) {
                        if ((0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice1) && (0, 
                        _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice2)) for (var key in slice1.control.properties) {
                            var subslice1 = slice1.control.properties[key], subslice2 = slice2.control.properties[key];
                            subslice1 && subslice2 && _.isEqual(subslice1.descriptor, subslice2.descriptor) && (subslice1.value = subslice2.value);
                        } else slice1.control.properties.value = slice2.control.properties.value;
                        delete slice2Dict[(0, _Visuals_common_formattingModelUtil__WEBPACK_IMPORTED_MODULE_4__.zU)(slice2, !1)];
                    } else displayName = getChartTypeSliceName(slice1.uid, type1, localize);
                    newSlices.push((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, slice1), {
                        displayName
                    }));
                }
            });
            for (var _i = 0, slices2_1 = slices2; _i < slices2_1.length; _i++) {
                var slice2 = slices2_1[_i], slice2InDict = slice2Dict[(0, _Visuals_common_formattingModelUtil__WEBPACK_IMPORTED_MODULE_4__.zU)(slice2, !1)], uid = getMergedSliceUid(slice2.uid, type2);
                if (slice2InDict) {
                    var displayName = getChartTypeSliceName(slice2InDict.uid, type2, localize);
                    newSlices.push((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, slice2InDict), {
                        displayName,
                        uid
                    }));
                }
            }
            return labelDensitySlice1 && labelDensitySlice2 && function(labelDensitySlice1, labelDensitySlice2, newSlices, localize) {
                labelDensitySlice1.control.properties.value = labelDensitySlice2.control.properties.value;
                var displayName = localize("Visual_LabelDensity");
                newSlices.push((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, labelDensitySlice1), {
                    displayName
                }));
            }(labelDensitySlice1, labelDensitySlice2, newSlices, localize), newSlices;
        }
        function matchContainerItemToTemplate(template, containerItem, layerType) {
            var newContainerItem = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, containerItem), containerItemGroupDict = {};
            return containerItem.groups.forEach(function(group) {
                containerItemGroupDict[_VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.SS.getGroupUid(group.uid)] = group;
            }), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                return template.groups.length <= containerItem.groups.length;
            }, "template container item has more groups than created container item"), template.groups.forEach(function(templateGroup, index) {
                var templateGroupUid = _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.SS.getGroupUid(templateGroup.uid);
                if (containerItemGroupDict[templateGroupUid]) {
                    var containerSlicesDict_1 = {};
                    containerItemGroupDict[templateGroupUid].slices.forEach(function(slice) {
                        containerSlicesDict_1[_VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IN.getGroupAndSliceUid(slice.uid)] = slice;
                    }), newContainerItem.groups[index].slices = [], templateGroup.slices.forEach(function(templateSlice) {
                        if ((0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(templateSlice)) _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("Unsupported placeholder"); else {
                            var uid, suffix, templateSliceUid = _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IN.getGroupAndSliceUid(templateSlice.uid), containerSlice = containerSlicesDict_1[templateSliceUid];
                            if (containerSlice || (containerSlice = containerSlicesDict_1[(uid = templateSliceUid, 
                            suffix = layerType, uid.replace("__".concat(suffix, "__"), ""))]), containerSlice) if ("Dropdown" === containerSlice.control.type && "Dropdown" === templateSlice.control.type) if (dropdownEquals(containerSlice.control.properties, templateSlice.control.properties)) containerSlice.displayName = templateSlice.displayName, 
                            newContainerItem.groups[index].slices.push(containerSlice); else {
                                var groupUid = newContainerItem.groups[index].uid;
                                newContainerItem.groups[index].slices.push((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, 
                                tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, templateSlice), {
                                    uid: "".concat(groupUid).concat(templateSlice.uid),
                                    displayName: templateSlice.displayName,
                                    disabled: !0
                                }));
                            } else containerSlice.displayName = templateSlice.displayName, newContainerItem.groups[index].slices.push(containerSlice); else groupUid = newContainerItem.groups[index].uid, 
                            newContainerItem.groups[index].slices.push((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, 
                            tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, templateSlice), {
                                uid: "".concat(groupUid).concat(templateSlice.uid),
                                displayName: templateSlice.displayName,
                                disabled: !0
                            }));
                        }
                    });
                }
            }), newContainerItem;
        }
        function isAutoDropdown(dropdown) {
            return void 0 === dropdown.items;
        }
        function dropdownEquals(dropdown1, dropdown2) {
            return !(!isAutoDropdown(dropdown1) || !isAutoDropdown(dropdown2)) && _.isEqual(dropdown1.filterValues, dropdown2.filterValues);
        }
        function getMergedSliceUid(uid, suffix) {
            return "".concat(uid, "__").concat(suffix, "__");
        }
        function existsInProps(slice, props) {
            if ((0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IW)(slice)) {
                var properties_1 = slice.control.properties;
                return !!properties_1 && Object.keys(properties_1).every(function(key) {
                    var property = properties_1[key], descriptor = null == property ? void 0 : property.descriptor;
                    return !descriptor || !!(descriptor && props[descriptor.objectName] && props[descriptor.objectName][descriptor.propertyName]);
                });
            }
            var descriptor = slice.control.properties.descriptor;
            return !!(descriptor && props[descriptor.objectName] && props[descriptor.objectName][descriptor.propertyName]);
        }
        function sortComboChartFormattingCards(formattingCards, type) {
            var sortingOrder = [];
            switch (type) {
              case 13:
              case 14:
                sortingOrder = [ "bars", "lines", "shadeArea", "layout", "markers", "labels", "seriesLabels", "totals", "errorBars" ];
            }
            return function(formattingCards, uidOrdering) {
                if (0 === uidOrdering.length) return formattingCards;
                var cardDict = {};
                formattingCards.forEach(function(card) {
                    cardDict[card.uid] = card;
                });
                for (var sortedFormattingCards = [], _i = 0, uidOrdering_1 = uidOrdering; _i < uidOrdering_1.length; _i++) {
                    var uid = uidOrdering_1[_i];
                    cardDict[uid] && sortedFormattingCards.push(cardDict[uid]);
                }
                return sortedFormattingCards;
            }(formattingCards, sortingOrder);
        }
        function getChartTypeSliceName(uid, type, localize) {
            return localize("Visual_Slice_Placeholder_" + function(sliceUid) {
                for (var _i = 0, entriesArray_1 = Array.from(localizationKeyMap.entries()); _i < entriesArray_1.length; _i++) {
                    var _a = entriesArray_1[_i], value = _a[1];
                    if (_a[0].includes(sliceUid)) return value;
                }
                return sliceUid;
            }(_VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IN.getSliceUid(uid)), function(type, localize) {
                switch (type) {
                  case 4:
                    return localize("DisplayName_QuickCalc_PercentOfColumnTotal");

                  case 0:
                    return localize("Visual_Slice_PlaceholderChartType_Line");

                  default:
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertFail("There is not support for merging this chart layer type for formattingCards yet");
                }
            }(type, localize));
        }
        var localizationKeyMap = new Map([ [ [ "detailLabelDisplayUnits", "detailDisplayUnits", "titleLabelDisplayUnits" ], "displayUnits" ], [ [ "detailLabelPrecision", "titleLabelPrecision" ], "precision" ] ]);
    },
    54365: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            p: function() {
                return DataViewMultipleReader;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(53197), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62458), _VisualsCommon_Lazy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45034), _VisualsData_dataView_dataViewCategoricalEvaluateDataRepetition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1144), _VisualsData_dataView_dataViewScopeIdentity__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(78843), _VisualsData_dataView_dataViewTransform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(61289), _VisualsData_dataView_utils_dataViewMatrixUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82386), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(72489), _VisualsData_semanticQuery_sqExpr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(94419), _comboChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88439), ISeriesHandler = function() {
            function ISeriesHandler() {}
            return ISeriesHandler.prototype.ensureValueGroupAtSeriesIndex = function(valueGroups, index, series) {
                if (!valueGroups[index]) {
                    var columnNodeValue = this.getValueGroupName(series), valueGroup = {
                        identity: this.getSeriesIdentity(series),
                        values: [],
                        objects: this.getSeriesObjects(series),
                        name: columnNodeValue
                    };
                    valueGroups[index] = valueGroup;
                }
                return valueGroups[index];
            }, ISeriesHandler;
        }(), DynamicSeriesHandler = function(_super) {
            function DynamicSeriesHandler(matrix) {
                var _this = _super.call(this) || this;
                return _this.matrix = matrix, _this;
            }
            return (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(DynamicSeriesHandler, _super), 
            DynamicSeriesHandler.prototype.setSource = function(columns) {
                columns.source = this.matrix.columns.levels[0].sources[0];
            }, DynamicSeriesHandler.prototype.getSeriesGroups = function(seriesNodes, _valuesCount) {
                return seriesNodes && _.map(seriesNodes, function(seriesNode) {
                    return _.isEmpty(seriesNode.children) ? 1 : seriesNode.children.length;
                });
            }, DynamicSeriesHandler.prototype.getSeriesDataPoints = function(_requiredValueSources) {
                return _.filter(this.matrix.columns.root.children, function(node) {
                    return !node.isSubtotal;
                });
            }, DynamicSeriesHandler.prototype.getValueGroupName = function(seriesNode) {
                return seriesNode.value || seriesNode.levelValues && seriesNode.levelValues[0].value;
            }, DynamicSeriesHandler.prototype.getSeriesObjects = function(series) {
                return series.objects;
            }, DynamicSeriesHandler.prototype.getSeriesIdentity = function(series) {
                return series.identity;
            }, DynamicSeriesHandler.prototype.getSeriesSourceColumn = function(valueSource, groupName) {
                return void 0 === groupName && (groupName = null), _.create(valueSource, {
                    groupName
                });
            }, DynamicSeriesHandler.prototype.createValueColumnForMeasure = function(series, categoricalValues, valueSource, groupName, intersectionIndex) {
                if (!categoricalValues[intersectionIndex]) {
                    var valueColumn = {
                        identity: this.getSeriesIdentity(series),
                        values: [],
                        source: this.getSeriesSourceColumn(valueSource, groupName),
                        objects: void 0
                    };
                    categoricalValues[intersectionIndex] = valueColumn;
                }
                return categoricalValues[intersectionIndex];
            }, DynamicSeriesHandler;
        }(ISeriesHandler), StaticSeriesHandler = function(_super) {
            function StaticSeriesHandler(_matrix) {
                return _super.call(this) || this;
            }
            return (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(StaticSeriesHandler, _super), 
            StaticSeriesHandler.prototype.setSource = function(_columns) {}, StaticSeriesHandler.prototype.getSeriesGroups = function(_seriesNodes, valueCount) {
                return valueCount ? [ valueCount ] : [];
            }, StaticSeriesHandler.prototype.getSeriesDataPoints = function(requiredValueSources) {
                return requiredValueSources;
            }, StaticSeriesHandler.prototype.getValueGroupName = function(column) {
                return column.displayName;
            }, StaticSeriesHandler.prototype.getSeriesObjects = function(series) {
                return series.objects;
            }, StaticSeriesHandler.prototype.getSeriesIdentity = function(_column) {}, StaticSeriesHandler.prototype.getSeriesSourceColumn = function(valueSource, _groupName) {
                return valueSource;
            }, StaticSeriesHandler.prototype.createValueColumnForMeasure = function(series, categoricalValues, valueSource, groupName, intersectionIndex) {
                if (!categoricalValues[intersectionIndex]) {
                    var valueColumn = {
                        identity: this.getSeriesIdentity(series),
                        values: [],
                        source: this.getSeriesSourceColumn(valueSource, groupName),
                        objects: []
                    };
                    categoricalValues[intersectionIndex] = valueColumn;
                }
                return categoricalValues[intersectionIndex];
            }, StaticSeriesHandler;
        }(ISeriesHandler), DataViewMultipleReader = function() {
            function DataViewMultipleReader(sourceDataView, formatStringPropId) {
                var matrix, _this = this;
                this.sourceDataView = sourceDataView, this.formatStringPropId = formatStringPropId, 
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return sourceDataView && sourceDataView.metadata && !!sourceDataView.matrix;
                }, "sourceDataView && sourceDataView.metadata && !!sourceDataView.matrix"), this.matrix = sourceDataView.matrix, 
                this.hasRowChildren = !_.isEmpty(this.matrix.rows.root.children), this.hasColChildren = !_.isEmpty(this.matrix.columns.root.children), 
                this.hasSeries = this.hasColChildren && !_.isEmpty(this.matrix.columns.levels) && _.every(this.matrix.columns.levels[0].sources, function(source) {
                    return !source.isMeasure;
                }), this.hasCategories = this.matrix.rows.levels.length > 1 && this.hasRowChildren, 
                this.objects = sourceDataView.metadata.objects, this.frameCount = (matrix = this.matrix).rows.root.children ? _.filter(matrix.rows.root.children, function(child) {
                    return !child.isSubtotal;
                }).length : 0, this._frameDisplayNames = new _VisualsCommon_Lazy__WEBPACK_IMPORTED_MODULE_2__.o(function() {
                    return _this.getDisplayNameFromAllFrames();
                });
            }
            return DataViewMultipleReader.create = function(sourceDataView, formatStringPropId) {
                return new DataViewMultipleReader(sourceDataView, formatStringPropId);
            }, DataViewMultipleReader.prototype.getObjects = function() {
                return this.objects;
            }, DataViewMultipleReader.prototype.getFrameDisplayNames = function() {
                return this._frameDisplayNames.getValue();
            }, DataViewMultipleReader.prototype.hasFrames = function() {
                return this.matrix && this.frameCount > 0 && !_.isEmpty(this.matrix.rows.levels) && !!this.getFrameSourceColumns();
            }, DataViewMultipleReader.prototype.getFrameCount = function() {
                return this.frameCount;
            }, DataViewMultipleReader.prototype.getFrameSourceColumns = function() {
                return this.matrix.rows.levels[0].sources;
            }, DataViewMultipleReader.prototype.getFrameNode = function(frame) {
                return this.matrix.rows.root.children[frame];
            }, DataViewMultipleReader.prototype.getValueSources = function(shouldReadScopedValues) {
                return shouldReadScopedValues ? (0, _VisualsData_dataView_utils_dataViewMatrixUtils__WEBPACK_IMPORTED_MODULE_3__.vC)(this.matrix.rows.levels[this.hasCategories ? 1 : 0]) : this.matrix.valueSources;
            }, DataViewMultipleReader.prototype.buildCategoricals = function(frame, categoricals, categories, valueRolesList, isForColumnValuesList) {
                var _this = this, frameNode = this.matrix.rows.root.children[frame];
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return !frameNode.isSubtotal;
                }, "frame node should not be subtotal");
                var seriesInfoList = [];
                isForColumnValuesList.forEach(function(isForColumnValues, index) {
                    seriesInfoList[index] = {
                        shouldReadScopedValues: !isForColumnValues && _this.hasSeries
                    };
                });
                var seriesHandlers = isForColumnValuesList.map(function(isForColumnValues) {
                    return _this.hasSeries && isForColumnValues ? new DynamicSeriesHandler(_this.matrix) : new StaticSeriesHandler(_this.matrix);
                });
                seriesInfoList.forEach(function(seriesInfo) {
                    seriesInfo.allValueSources = _this.getValueSources(seriesInfo.shouldReadScopedValues);
                });
                for (var i = 0; i < seriesHandlers.length; i++) {
                    var _a = this.findUniqueFilteredValueSourcesAndIndices(seriesInfoList[i].allValueSources, valueRolesList && valueRolesList[i]), requiredValueSources = _a[0], requiredValueSourcesIndices = _a[1];
                    seriesInfoList[i].requiredValueSources = requiredValueSources, seriesInfoList[i].requiredValueSourcesIndices = requiredValueSourcesIndices, 
                    seriesHandlers[i].setSource(categoricals[i].values);
                    var seriesNodes = seriesHandlers[i].getSeriesDataPoints(requiredValueSources);
                    seriesInfoList[i].seriesNodes = seriesNodes;
                    var seriesGroups = seriesHandlers[i].getSeriesGroups(seriesNodes, requiredValueSourcesIndices.length);
                    seriesInfoList[i].seriesGroups = seriesGroups, seriesInfoList[i].valueGroups = Array(seriesGroups.length);
                }
                (0, _VisualsData_dataView_utils_dataViewMatrixUtils__WEBPACK_IMPORTED_MODULE_3__.y9)(this.hasCategories ? frameNode.children : [ frameNode ], function(categoryGroupLeafNode, categoryIndex, categoryHierarchicalGroupNodes) {
                    var _a;
                    if (!categoryGroupLeafNode.isSubtotal) {
                        _this.hasCategories && function(sourceCategoryHierarchicalGroupNodes, destinationCategories) {
                            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertNonEmpty(sourceCategoryHierarchicalGroupNodes, "sourceCategoryHierarchicalGroupNodes"), 
                            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertNonEmpty(destinationCategories, "destinationCategories"), 
                            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                                return _.every(sourceCategoryHierarchicalGroupNodes, function(node) {
                                    return 1 === node.levelValues.length;
                                }) && sourceCategoryHierarchicalGroupNodes.length === destinationCategories.length || 1 === sourceCategoryHierarchicalGroupNodes.length && sourceCategoryHierarchicalGroupNodes[0].levelValues.length === destinationCategories.length;
                            }, "pre-condition: there should be one category column per matrix row level/level source for Category.");
                            var identity, valueParts, objects = _.last(sourceCategoryHierarchicalGroupNodes).objects, node = sourceCategoryHierarchicalGroupNodes[0];
                            if (sourceCategoryHierarchicalGroupNodes.length > 1) {
                                (valueParts = new Array(sourceCategoryHierarchicalGroupNodes.length))[0] = node.levelValues[0].value;
                                for (var identityExpr = node.identity.expr, i = 1, iLen = sourceCategoryHierarchicalGroupNodes.length; i < iLen; i++) valueParts[i] = (node = sourceCategoryHierarchicalGroupNodes[i]).levelValues[0].value, 
                                identityExpr = (0, _VisualsData_semanticQuery_sqExpr__WEBPACK_IMPORTED_MODULE_9__.xD)(identityExpr, node.identity.expr);
                                identity = (0, _VisualsData_dataView_dataViewScopeIdentity__WEBPACK_IMPORTED_MODULE_10__.TZ)(identityExpr);
                            } else identity = node.identity, valueParts = _.map(node.levelValues, function(level) {
                                return level.value;
                            });
                            for (var j = 0, jLen = destinationCategories.length; j < jLen; j++) destinationCategories[j].identity.push(identity), 
                            destinationCategories[j].objects.push(objects), destinationCategories[j].values.push(valueParts[j]);
                        }(categoryHierarchicalGroupNodes, categories);
                        for (var dataPointsList = seriesInfoList.map(function(seriesInfo) {
                            return seriesInfo.shouldReadScopedValues ? (0, _VisualsData_dataView_utils_dataViewMatrixUtils__WEBPACK_IMPORTED_MODULE_3__.Lr)(categoryGroupLeafNode) : categoryGroupLeafNode.values;
                        }), categoricalIndex = 0; categoricalIndex < seriesInfoList.length; categoricalIndex++) for (var seriesInfo = seriesInfoList[categoricalIndex], seriesIndex = 0; seriesIndex < seriesInfo.seriesGroups.length; seriesIndex++) {
                            for (var seriesNode = seriesInfo.seriesNodes && seriesInfo.seriesNodes[seriesIndex], measuresCount = seriesInfo.seriesGroups[seriesIndex], valueGroup = seriesHandlers[categoricalIndex].ensureValueGroupAtSeriesIndex(seriesInfo.valueGroups, seriesIndex, seriesNode), valueColumns = [], measureIndex = 0; measureIndex < measuresCount; measureIndex++) {
                                var intersectionIndex = seriesIndex * measuresCount + measureIndex, valueColumn = seriesHandlers[categoricalIndex].createValueColumnForMeasure(seriesNode, categoricals[categoricalIndex].values, seriesInfo.requiredValueSources[seriesInfo.shouldReadScopedValues ? intersectionIndex : measureIndex], valueGroup.name, intersectionIndex);
                                _this.hasSeries || (intersectionIndex = seriesInfo.requiredValueSourcesIndices[intersectionIndex]);
                                var dataPoint = null === (_a = null == dataPointsList ? void 0 : dataPointsList[categoricalIndex]) || void 0 === _a ? void 0 : _a[intersectionIndex];
                                _.isEmpty(seriesInfo.requiredValueSources) || _this.readValues(dataPoint, valueColumn, categoryIndex), 
                                valueColumns.push(valueColumn);
                            }
                            valueGroup.values = valueColumns;
                        }
                    }
                });
                var preserveEmptyValuesForSeries = this.hasSeries && this.hasCategories && _.isEmpty(seriesInfoList.filter(function(seriesInfo) {
                    return !_.isEmpty(seriesInfo.requiredValueSources);
                }));
                for (i = 0; i < categoricals.length; i++) (0, _VisualsData_dataView_dataViewCategoricalEvaluateDataRepetition__WEBPACK_IMPORTED_MODULE_4__.PO)(categoricals[i].values, seriesInfoList[i].valueGroups), 
                _.isEmpty(seriesInfoList[i].requiredValueSources) && (isForColumnValuesList[i] ? preserveEmptyValuesForSeries || (categoricals[i].values = void 0) : categoricals[i] = void 0);
            }, DataViewMultipleReader.prototype.findUniqueFilteredValueSourcesAndIndices = function(columns, roles) {
                if (_.isEmpty(columns)) return [ [], [] ];
                for (var indices = [], filteredColumns = [], takenQueryNames = {}, _loop_1 = function(index) {
                    var column = columns[index];
                    return _.isEmpty(roles) || _.some(roles, function(role) {
                        return column.roles[role];
                    }) ? takenQueryNames[column.queryName] ? "continue" : (indices.push(index), filteredColumns.push(column), 
                    void (takenQueryNames[column.queryName] = !0)) : "continue";
                }, index = 0; index < columns.length; index++) _loop_1(index);
                return [ filteredColumns, indices ];
            }, DataViewMultipleReader.prototype.readCategories = function() {
                var rows = this.matrix.rows;
                if (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return rows.levels.length <= 1 || 2 === rows.levels.length && rows.levels[1].sources.length >= 1 || rows.levels.length >= 2 && _.every(rows.levels, function(level) {
                        return 1 === level.sources.length;
                    });
                }, "Incorrect Levels/Sources count."), this.hasCategories) {
                    var categories = [];
                    return this.fillCategoriesMetadata(categories), categories;
                }
            }, DataViewMultipleReader.prototype.fillCategoriesMetadata = function(categories) {
                var _this = this;
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return _this.hasCategories;
                }, "No categories");
                for (var levels = this.matrix.rows.levels, levelIdx = 1; levelIdx < levels.length; levelIdx++) for (var _i = 0, _a = levels[levelIdx].sources; _i < _a.length; _i++) categories.push({
                    source: _a[_i],
                    values: [],
                    identity: [],
                    objects: []
                });
            }, DataViewMultipleReader.prototype.convertComboFrame = function(frame) {
                var roleGroups = (0, _comboChart__WEBPACK_IMPORTED_MODULE_5__.on)();
                return this.convertFrameInternal(frame, roleGroups);
            }, DataViewMultipleReader.prototype.createEmptyCategorical = function(categorical) {
                var _a, metadataColumns;
                return (_a = categorical.values).push.apply(_a, (metadataColumns = this.matrix.valueSources, 
                (_.isEmpty(metadataColumns) ? [] : _.map(metadataColumns, function(metadataColumn) {
                    return {
                        identity: void 0,
                        values: [],
                        source: metadataColumn,
                        objects: []
                    };
                })) || [])), {
                    metadata: this.sourceDataView.metadata,
                    categorical
                };
            }, DataViewMultipleReader.prototype.convertFrame = function(frame) {
                return this.convertFrameInternal(frame)[0];
            }, DataViewMultipleReader.prototype.checkValueRolesInList = function(valueRoles, valueSources) {
                for (var _loop_2 = function(valueSource) {
                    if (_.some(valueRoles, function(role) {
                        return valueSource.roles[role];
                    })) return {
                        value: !0
                    };
                }, _i = 0, valueSources_1 = valueSources; _i < valueSources_1.length; _i++) {
                    var state_1 = _loop_2(valueSources_1[_i]);
                    if ("object" == typeof state_1) return state_1.value;
                }
                return !1;
            }, DataViewMultipleReader.prototype.validateValueRoles = function(valueRoles) {
                if (!_.isEmpty(valueRoles)) {
                    var isInMatrixValueSources = this.checkValueRolesInList(valueRoles, this.matrix.valueSources), scopedValueSources = this.getValueSources(!0), isInScopedValueSources = scopedValueSources && this.checkValueRolesInList(valueRoles, scopedValueSources);
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                        return !(isInMatrixValueSources && isInScopedValueSources);
                    }, "valueRoles cannot exist in both");
                }
            }, DataViewMultipleReader.prototype.isForColumnValues = function(valueRoles) {
                var columnRoles = (0, _comboChart__WEBPACK_IMPORTED_MODULE_5__.on)()[0];
                return _.isEmpty(valueRoles) || _.intersection(valueRoles, columnRoles).length > 0;
            }, DataViewMultipleReader.prototype.convertFrameInternal = function(frame, valueRolesList) {
                var _this = this, dataViews = [], matrix = this.matrix, isForColumnValuesList = [];
                _.isEmpty(valueRolesList) ? isForColumnValuesList.push(!0) : valueRolesList.forEach(function(valueRoles) {
                    _this.validateValueRoles(valueRoles), isForColumnValuesList.push(_this.isForColumnValues(valueRoles));
                }), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    var _a;
                    return _.size(null === (_a = null == matrix ? void 0 : matrix.rows) || void 0 === _a ? void 0 : _a.levels) >= 1;
                }, "matrix should have at least one level for Play fields");
                for (var categoricals = [], numberOfCategoricals = _.isEmpty(valueRolesList) ? 1 : valueRolesList.length, i = 0; i < numberOfCategoricals; i++) categoricals.push({
                    categories: void 0,
                    values: (0, _VisualsData_dataView_dataViewTransform__WEBPACK_IMPORTED_MODULE_6__.Yv)()
                });
                if (!this.hasCategories) {
                    var emptyDataViews = [], canReturnEmptyDataViews = !0;
                    for (i = 0; i < categoricals.length; i++) if (isForColumnValuesList[i]) {
                        if (!_.isEmpty(matrix.valueSources) && this.hasRowChildren) {
                            canReturnEmptyDataViews = !1;
                            break;
                        }
                        (this.hasSeries || 1 === categoricals.length) && (emptyDataViews[i] = this.createEmptyCategorical(categoricals[i]));
                    } else if (!_.isEmpty(this.getValueSources(this.hasSeries))) {
                        canReturnEmptyDataViews = !1;
                        break;
                    }
                    if (canReturnEmptyDataViews) return emptyDataViews;
                }
                var categories = this.readCategories();
                this.buildCategoricals(frame, categoricals, categories, valueRolesList, isForColumnValuesList);
                for (var _i = 0, categoricals_1 = categoricals; _i < categoricals_1.length; _i++) {
                    var categorical = categoricals_1[_i];
                    categorical && (categorical.categories = categories, dataViews.push({
                        metadata: this.sourceDataView.metadata,
                        categorical
                    }));
                }
                return dataViews;
            }, DataViewMultipleReader.prototype.readValues = function(intersection, valueColumn, categoryIndex) {
                valueColumn.values || (valueColumn.values = []), intersection ? (valueColumn.values[categoryIndex] = intersection.value ?? null, 
                void 0 !== intersection.highlight && (valueColumn.highlights || (valueColumn.highlights = []), 
                valueColumn.highlights[categoryIndex] = intersection.highlight), void 0 !== intersection.objects && (valueColumn.objects || (valueColumn.objects = []), 
                valueColumn.objects[categoryIndex] = intersection.objects), void 0 !== intersection.highlightObjects && (valueColumn.highlightObjects || (valueColumn.highlightObjects = []), 
                valueColumn.highlightObjects[categoryIndex] = intersection.highlightObjects)) : valueColumn.values[categoryIndex] = null;
            }, DataViewMultipleReader.prototype.getDisplayNameFromAllFrames = function() {
                for (var values = new Array(this.frameCount), i = 0; i < this.frameCount; i++) {
                    var formattedLevelValue = this.getDisplayNameForFrame(i);
                    values[i] = formattedLevelValue;
                }
                return values;
            }, DataViewMultipleReader.prototype.getDisplayNameForFrame = function(frame) {
                var _this = this, frameNode = this.getFrameNode(frame), metadataColumns = this.getFrameSourceColumns(), formattedLevelValue = new Array(metadataColumns.length);
                return metadataColumns.forEach(function(metadata, j) {
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_1__.fF.assertValue(frameNode.levelValues, "level values should be defined for non subTotal nodes");
                    var value = frameNode.levelValues && frameNode.levelValues[j].value, formatter = new _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_7__.g({
                        column: metadata,
                        formatStringPropId: _this.formatStringPropId,
                        nullsAreBlank: !0,
                        trailingZeroes: !0
                    });
                    formattedLevelValue[j] = formatter.format(value);
                }), formattedLevelValue;
            }, DataViewMultipleReader.prototype.getSubtotals = function() {
                var subtotalChild = _.find(this.matrix.rows.root.children, function(row) {
                    return row.isSubtotal;
                });
                if (subtotalChild) {
                    for (var totalValuesLength = _.size(subtotalChild.values), valueSourcesLength = _.size(this.matrix.valueSources), offset = totalValuesLength - valueSourcesLength, totals = {}, i = 0; i < valueSourcesLength; i++) {
                        var roles = this.matrix.valueSources[i].roles, total = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_8__.eT)(subtotalChild.values[offset + i].value);
                        for (var role in roles) totals[role] = total;
                    }
                    return totals;
                }
            }, DataViewMultipleReader.prototype.getTopLevelAggregates = function(aggregateRoles) {
                for (var aggregatesByRole = {}, _i = 0, sources_1 = this.sourceDataView.metadata.columns; _i < sources_1.length; _i++) {
                    var metadataColumn = sources_1[_i];
                    if (metadataColumn.roles && metadataColumn.aggregates) for (var _a = 0, aggregateRoles_1 = aggregateRoles; _a < aggregateRoles_1.length; _a++) {
                        var aggregateRole = aggregateRoles_1[_a];
                        metadataColumn.roles[aggregateRole] && (aggregatesByRole[aggregateRole] = aggregatesByRole[aggregateRole] || []).push(metadataColumn.aggregates);
                    }
                }
                return _.isEmpty(aggregatesByRole) ? void 0 : aggregatesByRole;
            }, DataViewMultipleReader;
        }();
    },
    67174: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            CT: function() {
                return PlayAxis;
            },
            Je: function() {
                return PlayChartAnimationSettings;
            },
            qR: function() {
                return PlayChartClassName;
            },
            vH: function() {
                return isDataViewPlayable;
            }
        });
        var _Externals_ThirdPartyIP_noUiSlider_noUiSlider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(45863), _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(22733), _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14599), _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(14577), _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(79154), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62458), _VisualsCommon_fontUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38265), _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32041), _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64329), _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(66001), _VisualsData_dataView_dataViewConcatenateCategoricalColumns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(42359), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(72489), _dataViewMultipleReader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(54365), PlayAxis = function() {
            function PlayAxis(interactivityService) {
                interactivityService && (this.interactivityService = interactivityService);
            }
            return PlayAxis.prototype.initData = function(options) {
                this.element = options.element, this.host = options.host, this.isMobileChart = options.interactivity && options.interactivity.mobileTileInteractive;
            }, PlayAxis.prototype.initRenderer = function(options) {
                var _this = this;
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_0__.fF.assertValue(options, "options"), 
                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_0__.fF.assert(function() {
                    return !_this.rendererInitialized;
                }, "renderer initialized multiple times"), this.svg = options.svg, this.interactivityService && (this.playControl = new PlayControl(this.element, function(frameIndex) {
                    return _this.moveToFrameAndRender(frameIndex);
                }, this.isMobileChart), this.playControl.onPlay(function() {
                    return _this.play();
                })), this.rendererInitialized = !0;
            }, PlayAxis.prototype.isRendererInitialized = function() {
                return this.rendererInitialized;
            }, PlayAxis.prototype.setData = function(dataView, visualConverter) {
                if (dataView) {
                    if (this.ridiculousFlagForPersistProperties && dataView.metadata) return this.ridiculousFlagForPersistProperties = !1, 
                    this.playData;
                    this.playData = dataView.matrix || dataView.categorical ? function(dataView, visualConverter) {
                        var _a, _b, convertedData, keySourceColumn, keys, keyColumn, allChartData = [], frameData = [], multipleReader = _dataViewMultipleReader__WEBPACK_IMPORTED_MODULE_9__.p.create(dataView, _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_7__.e0.formatString), rowChildrenLength = multipleReader.getFrameCount(), subtotals = multipleReader.getSubtotals();
                        if (multipleReader.hasFrames()) {
                            var keySourceColumns = multipleReader.getFrameSourceColumns(), formatString = (0, 
                            _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.EO)(keySourceColumn = keySourceColumns && keySourceColumns[0], _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_11__.il.general.formatString), keyFormatter = void 0;
                            if (keySourceColumn.type.numeric) {
                                var lastValue = null === (_a = multipleReader.getFrameNode(rowChildrenLength - 1)) || void 0 === _a ? void 0 : _a.value, firstValue = null === (_b = multipleReader.getFrameNode(0)) || void 0 === _b ? void 0 : _b.value, valueRange = Math.abs(lastValue - firstValue);
                                keyFormatter = (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.Ue)({
                                    format: formatString,
                                    value: valueRange,
                                    value2: 0,
                                    columnType: keySourceColumn.type
                                });
                            } else keyFormatter = (0, _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.E3)(formatString, !0);
                            for (var i = 0, len = rowChildrenLength; i < len; i++) {
                                var key = multipleReader.getFrameNode(i);
                                if (!key.isSubtotal) {
                                    var frameLabelText = keyFormatter.format(key.value), frameLabelHtml = $("<div></div>").text(frameLabelText).html();
                                    frameData.push({
                                        escapedText: frameLabelHtml,
                                        text: frameLabelText
                                    }), convertedData = visualConverter(convertFrame(i, multipleReader), {
                                        label: frameLabelHtml,
                                        column: keySourceColumn,
                                        identity: key.identity,
                                        value: key.value,
                                        formattedValue: frameLabelText
                                    }, subtotals), allChartData.push(convertedData);
                                }
                            }
                        } else convertedData = visualConverter(convertFrame(0, multipleReader), void 0, subtotals), 
                        allChartData.push(convertedData);
                        return {
                            allChartData,
                            chartData: convertedData,
                            frameData,
                            currentFrameIndex: frameData.length - 1,
                            labelData: (keys = frameData, keyColumn = keySourceColumn, {
                                labelInfo: keys.map(function(key) {
                                    return {
                                        label: key.escapedText,
                                        labelWidth: (0, _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_12__.bY)(key.escapedText, _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_3__.b.measureSvgTextWidth, {
                                            fontFamily: _VisualsCommon_fontUtils__WEBPACK_IMPORTED_MODULE_2__.Wn.regular.css,
                                            fontSize: _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__.FP.toString(14)
                                        })
                                    };
                                }),
                                anyWordBreaks: _.some(keys, function(key) {
                                    return (0, _VisualsCommon_Utility_wordBreaker__WEBPACK_IMPORTED_MODULE_12__.r)(key.escapedText) || key.escapedText.indexOf("-") > -1;
                                }),
                                labelFieldName: null == keyColumn ? void 0 : keyColumn.displayName
                            })
                        };
                    }(dataView, visualConverter) : {
                        frameData: [],
                        allChartData: [],
                        currentFrameIndex: 0,
                        chartData: void 0,
                        labelData: {
                            anyWordBreaks: !1,
                            labelInfo: []
                        }
                    };
                } else this.playData = {
                    frameData: [],
                    allChartData: [],
                    currentFrameIndex: 0,
                    chartData: void 0,
                    labelData: {
                        anyWordBreaks: !1,
                        labelInfo: []
                    }
                };
                return this.lastViewport = void 0, this.playData;
            }, PlayAxis.prototype.render = function(viewModel, viewport, margin) {
                var _a, _b, playData = this.playData, resized = !this.lastViewport || this.lastViewport.height !== viewport.height || this.lastViewport.width !== viewport.width;
                if (this.lastViewport = viewport, resized && this.stop(), playData) return null === (_a = this.interactivityService) || void 0 === _a || _a.applySelectionStateToData(playData.chartData.dataPoints), 
                this.updateCallout(viewport, margin), resized && (null === (_b = this.playControl) || void 0 === _b || _b.rebuild(playData, viewport, this.playControlWidth)), 
                {
                    allDataPoints: _.flatten(playData.allChartData.map(function(vm) {
                        return vm.dataPoints;
                    })),
                    viewModel: {
                        data: this.playData,
                        viewModel,
                        viewport
                    }
                };
            }, PlayAxis.prototype.updateCallout = function(viewport, margin) {
                var playData = this.playData, frameData = playData.frameData, currentFrameIndex = playData.currentFrameIndex, height = viewport.height, plotAreaHeight = height - margin.top - margin.bottom, width = viewport.width, plotAreaWidth = width - margin.left - margin.right, textHeight = 0, calloutDimension = Math.min(height, 1.3 * width), fontSize = Math.max(12, Math.round(calloutDimension / 7));
                fontSize = Math.min(fontSize, 70);
                var calloutData = [];
                if (currentFrameIndex < frameData.length && currentFrameIndex >= 0) {
                    var textProperties = {
                        fontSize: _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__.FP.toString(fontSize),
                        text: frameData[currentFrameIndex].text || "",
                        fontFamily: _VisualsCommon_fontUtils__WEBPACK_IMPORTED_MODULE_2__.Wn.regular.css
                    };
                    (textHeight = _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_3__.b.estimateSvgTextHeight(textProperties) - _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_3__.b.estimateSvgTextBaselineDelta(textProperties)) < plotAreaHeight && (calloutData = [ _VisualsCommon_services_textMeasurementService__WEBPACK_IMPORTED_MODULE_3__.b.getTailoredTextOrDefault(textProperties, plotAreaWidth - 2 * PlayAxis.calloutOffsetMultiplier * textHeight) ]);
                }
                this.svg.selectAll(PlayAxis.PlayCallout.selector).data(calloutData).join(function(enter) {
                    return enter.append("text").classed(PlayAxis.PlayCallout.class, !0);
                }).text(function(d) {
                    return d;
                }).attrs({
                    x: plotAreaWidth - PlayAxis.calloutOffsetMultiplier * textHeight,
                    y: function() {
                        return textHeight;
                    }
                }).styles({
                    "font-size": "".concat(fontSize, "px"),
                    "text-anchor": "end"
                });
            }, PlayAxis.prototype.play = function() {
                var playData = this.playData;
                if (this.isPlaying) this.stop(); else if (this.playControl) {
                    this.isPlaying = !0, this.playControl.play();
                    var indexToShow = this.playControl.getCurrentIndex();
                    if (null == indexToShow) return;
                    indexToShow = Math.round(indexToShow), playData.currentFrameIndex = indexToShow >= playData.allChartData.length - 1 ? -1 : indexToShow - 1, 
                    this.playNextFrame(playData);
                }
            }, PlayAxis.prototype.playNextFrame = function(playData, startFrame, endFrame) {
                var _this = this;
                if (this.isPlaying) {
                    var nextFrame = playData.currentFrameIndex + 1;
                    if (null != startFrame && null != endFrame && (nextFrame = Math.abs(endFrame - startFrame + 1), 
                    startFrame = nextFrame), nextFrame < playData.allChartData.length && nextFrame > -1) {
                        var tooltipService = this.host.tooltips();
                        tooltipService && tooltipService.hide({
                            immediately: !0,
                            isTouchEvent: !1
                        }), playData.currentFrameIndex = nextFrame, playData.chartData = playData.allChartData[nextFrame], 
                        this.renderDelegate(playData.chartData), this.playControl.setFrame(nextFrame), nextFrame < playData.allChartData.length && window.setTimeout(function() {
                            _this.playNextFrame(playData, startFrame, endFrame);
                        }, FrameStepDuration);
                    } else this.stop();
                } else this.stop();
            }, PlayAxis.prototype.stop = function() {
                var _a;
                null === (_a = this.playControl) || void 0 === _a || _a.pause(), this.isPlaying = !1;
            }, PlayAxis.prototype.remove = function() {
                var _a;
                null === (_a = this.playControl) || void 0 === _a || _a.remove(), d3.selectAll(PlayAxis.PlayCallout.selector).remove();
            }, PlayAxis.prototype.setRenderFunction = function(fn) {
                this.renderDelegate = fn;
            }, PlayAxis.prototype.getCartesianExtents = function(existingExtents, getExtents) {
                return !this.playData || _.isEmpty(this.playData.allChartData) || _.isEmpty(this.playData.frameData) ? existingExtents : function(playData, getExtents) {
                    for (var extents = {}, hasData = !1, _i = 0, _a = playData.allChartData || []; _i < _a.length; _i++) {
                        var data = _a[_i];
                        if (!_.isEmpty(null == data ? void 0 : data.dataPoints)) {
                            hasData = !0;
                            var e = getExtents(data);
                            extents = {
                                minY: d3.min([ e.minY, extents.minY ]),
                                maxY: d3.max([ e.maxY, extents.maxY ]),
                                minX: d3.min([ e.minX, extents.minX ]),
                                maxX: d3.max([ e.maxX, extents.maxX ]),
                                formatStringX: e.formatStringX || extents.formatStringX,
                                formatStringY: e.formatStringY || extents.formatStringY
                            };
                        }
                    }
                    return hasData ? extents : null;
                }(this.playData, getExtents) || existingExtents;
            }, PlayAxis.prototype.setPlayControlPosition = function(playControlLayout) {
                if (this.playControl) {
                    var container = this.playControl.getContainer();
                    container.css("left", playControlLayout.left ? "".concat(playControlLayout.left, "px") : ""), 
                    container.css("top", playControlLayout.top ? "".concat(playControlLayout.top, "px") : ""), 
                    container.css("width", playControlLayout.width ? "".concat(playControlLayout.width, "px") : ""), 
                    this.playControlWidth = playControlLayout.width;
                }
            }, PlayAxis.prototype.moveToFrameAndRender = function(frameIndex) {
                var playData = this.playData;
                if (this.isPlaying = !0, playData && frameIndex >= 0 && frameIndex < playData.allChartData.length && frameIndex !== playData.currentFrameIndex) {
                    playData.currentFrameIndex = frameIndex;
                    var data = playData.allChartData[frameIndex];
                    playData.chartData = data, this.renderDelegate(data);
                }
                this.isPlaying = !1;
            }, PlayAxis.prototype.isCurrentlyPlaying = function() {
                return this.isPlaying;
            }, PlayAxis.PlayCallout = (0, _VisualsCommon_CssConstants__WEBPACK_IMPORTED_MODULE_4__.CH)("play-callout"), 
            PlayAxis.calloutOffsetMultiplier = .3, PlayAxis;
        }(), PlayControl = function() {
            function PlayControl(element, renderDelegate, isMobileChart) {
                this.isMobileChart = isMobileChart, this.createSliderDOM(element), this.renderDelegate = renderDelegate;
            }
            return PlayControl.prototype.getContainer = function() {
                return this.playAxisContainer;
            }, PlayControl.prototype.remove = function() {
                this.playAxisContainer && this.playAxisContainer.remove();
            }, PlayControl.prototype.pause = function() {
                this.playButton.removeClass("pause").addClass("play");
            }, PlayControl.prototype.play = function() {
                this.playButton.removeClass("play").addClass("pause");
            }, PlayControl.prototype.getCurrentIndex = function() {
                if (this.noUiSlider) return Number(this.noUiSlider.get());
            }, PlayControl.prototype.onPlay = function(handler) {
                this.playButtonCircle.off("click"), this.playButtonCircle.on("click", handler);
            }, PlayControl.prototype.setFrame = function(frameIndex) {
                this.noUiSlider.set([ frameIndex ]);
            }, PlayControl.prototype.rebuild = function(playData, viewport, playControlWidth) {
                var _this = this;
                this.noUiSlider && this.noUiSlider.destroy();
                var labelData = playData.labelData, sliderSize = PlayControl.calculateSliderSize(labelData, playControlWidth), container = this.getContainer();
                sliderSize.marginLeft > PlayControl.SliderMarginLeft && (container.css("padding-left", "".concat(sliderSize.marginLeft - PlayControl.SliderMarginLeft, "px")), 
                container.css("box-sizing", "border-box"));
                var skipStep = this.updateSliderControl(playData, sliderSize.width), width = PlayControl.adjustWidthRegardingLastItem(labelData, skipStep, sliderSize.width);
                this.slider.css("width", "".concat(width, "px")), this.noUiSlider.on("slide", function() {
                    var indexToShow = _this.getCurrentIndex();
                    _this.renderDelegate(indexToShow);
                }), this.noUiSlider.on("update", function() {
                    return $(".noUi-target").removeClass("noUi-state-tap");
                });
            }, PlayControl.prototype.updateSliderControl = function(playData, sliderWidth) {
                var labelData = playData.labelData, sliderElement = this.slider.get(0), numFrames = playData.frameData.length, options = {
                    start: numFrames <= 1 ? 1 : playData.currentFrameIndex,
                    step: 1,
                    range: {
                        min: 0,
                        max: numFrames <= 1 ? 1 : numFrames - 1
                    },
                    animationDuration: FrameStepDuration
                }, pipOptions = null, skipMode = 0;
                if (numFrames > 1) {
                    var filterPipLabels = PlayControl.createPipsFilterFn(playData, sliderWidth, labelData);
                    skipMode = filterPipLabels.skipStep, pipOptions = {
                        mode: "steps",
                        density: Math.ceil(100 / numFrames),
                        format: {
                            to: function(index) {
                                return playData.frameData[index].escapedText;
                            },
                            from: function(value) {
                                return _.findIndex(playData.frameData, function(frameData) {
                                    return frameData.escapedText === value;
                                });
                            }
                        },
                        filter: filterPipLabels.filter
                    };
                }
                return options.pips = pipOptions, (0, _Externals_ThirdPartyIP_noUiSlider_noUiSlider__WEBPACK_IMPORTED_MODULE_5__.create)(sliderElement, options), 
                this.noUiSlider = sliderElement.noUiSlider, skipMode;
            }, PlayControl.createPipsFilterFn = function(playData, sliderWidth, labelData) {
                var maxLabelWidth = _.max(_.map(labelData.labelInfo, function(l) {
                    return l.labelWidth;
                })), pipSize = 1, skipStep = 1, widthRatio = maxLabelWidth / (playData.frameData.length > 1 ? sliderWidth / (playData.frameData.length - 1) : sliderWidth);
                return widthRatio > 1.25 ? (skipStep = Math.ceil(widthRatio), pipSize = 2) : (widthRatio > 1 || labelData.anyWordBreaks) && (pipSize = 2), 
                {
                    filter: function(index) {
                        return index % skipStep == 0 ? pipSize : 0;
                    },
                    skipStep
                };
            }, PlayControl.adjustWidthRegardingLastItem = function(labelData, skipMode, sliderWidth) {
                if (_.isEmpty(labelData.labelInfo) || labelData.labelInfo.length <= 1) return sliderWidth;
                var labelLength = labelData.labelInfo.length, lastVisibleItemIndex = Math.floor((labelLength - 1) / skipMode) * skipMode, requiredWidth = labelData.labelInfo[lastVisibleItemIndex].labelWidth / 2 - (sliderWidth + PlayControl.SliderMarginRight - sliderWidth / labelLength * (lastVisibleItemIndex + 1));
                if (requiredWidth > 0) {
                    var maxMargin = PlayControl.SliderMaxMargin - PlayControl.SliderMarginRight;
                    return sliderWidth - (requiredWidth > maxMargin ? maxMargin : requiredWidth);
                }
                return sliderWidth;
            }, PlayControl.prototype.createSliderDOM = function(element) {
                this.playAxisContainer = $('<div class="play-axis-container"></div>').appendTo(element).css("height", "".concat(PlayControl.PlayControlHeight, "px")), 
                this.playButtonCircle = $('<div class="button-container"></div>').appendTo(this.playAxisContainer), 
                this.isMobileChart && this.playButtonCircle.addClass("mobile-button-container"), 
                this.playButton = $('<div class="play"></div>').appendTo(this.playButtonCircle), 
                this.slider = $('<div class="sliders"></div>').attr("drag-resize-disabled", "true").attr("rtl", ("rtl" === document.dir).toString()).appendTo(this.playAxisContainer);
            }, PlayControl.calculateSliderSize = function(labelData, playControlWidth) {
                var leftMargin = 0;
                !_.isEmpty(labelData.labelInfo) && labelData.labelInfo.length > 1 && (leftMargin = _.head(labelData.labelInfo).labelWidth / 2);
                var sliderLeftMargin = Math.max(leftMargin, PlayControl.SliderMarginLeft);
                return sliderLeftMargin = Math.min(PlayControl.SliderMaxMargin, sliderLeftMargin), 
                {
                    width: Math.max(playControlWidth - sliderLeftMargin - PlayControl.SliderMarginRight, 1),
                    marginLeft: sliderLeftMargin
                };
            }, PlayControl.SliderMarginLeft = 44, PlayControl.SliderMarginRight = 20, PlayControl.SliderMaxMargin = 100, 
            PlayControl.PlayControlHeight = 80, PlayControl;
        }(), FrameStepDuration = 800, PlayChartAnimationSettings = {
            duration: 750,
            ease: d3.easeLinear
        }, PlayChartClassName = "playChart";
        function convertFrame(frame, multipleReader) {
            var dataView = multipleReader.convertFrame(frame);
            return (0, _VisualsData_dataView_dataViewConcatenateCategoricalColumns__WEBPACK_IMPORTED_MODULE_6__.eC)(dataView.metadata, _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_7__.e0.formatString, _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_8__.x.category, dataView.categorical);
        }
        function isDataViewPlayable(dataView, playRole) {
            var _a, _b, _c, _d, _e, _f, _g;
            return void 0 === playRole && (playRole = "Play"), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_0__.fF.assertValue(dataView, "dataView"), 
            null === (_g = null === (_f = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = dataView.matrix) || void 0 === _a ? void 0 : _a.rows) || void 0 === _b ? void 0 : _b.levels) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.sources) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.roles) || void 0 === _g ? void 0 : _g[playRole];
        }
    },
    79972: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            OQ: function() {
                return convert;
            },
            V2: function() {
                return MaximumScatterChartDataVolume;
            },
            jI: function() {
                return DefaultScatterChartDataVolume;
            },
            vN: function() {
                return getDefaultScatterChartData;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(81337), _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(22733), _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14577), _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(53197), _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90120), _Visuals_common_concatenateUtils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(95938), _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21181), _Visuals_common_gradientUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(52083), _Visuals_common_strokeStyle__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(2241), _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(86108), _Visuals_dataViewReaders_categorical_dataViewCategoricalReader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51129), _Visuals_formatting_formattingStrategy__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(43906), _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79811), _Visuals_tooltip__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(11305), _Visuals_types_axisType__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(48766), _Visuals_types_fillStyle__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(67165), _Visuals_common_marker_converter__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(94038), _Visuals_types_markerRangeType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90700), _Visuals_types_markerShape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61193), _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47316), _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(44783), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(62458), _VisualsCommon_Lazy__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(45034), _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(38958), _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(82755), _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(72489), _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(26543), DefaultScatterChartDataVolume = 3500, MaximumScatterChartDataVolume = 1e4;
        function convert(dataView, options, playFrameInfo, subtotals) {
            var _a;
            return options.useMatrixDV ? function(dataView, options, playFrameInfo) {
                var _a, _b, _c, _d;
                if (dataView && dataView.matrix && (0 !== _.size(dataView.matrix.valueSources) || 0 !== _.size(dataView.matrix.rows.levels))) {
                    for (var interactivityService = options.interactivityService, dataLabelsSettings = (0, 
                    _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_1__.vc)(options.style, "smallLightLabel"), staticObjProps = getObjectProperties(null === (_a = null == dataView ? void 0 : dataView.metadata) || void 0 === _a ? void 0 : _a.objects, dataLabelsSettings, options.style), scatterMetadata = function(dataView) {
                        var _a, _b, xCol, yCol, sizeCol, desc, matrix = dataView.matrix, valueSources = matrix.valueSources, hasXGroups = !1, hasYGroups = !1, xIndex = [ _.findIndex(valueSources, function(source) {
                            return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(source, "X");
                        }) ], yIndex = _.findIndex(valueSources, function(source) {
                            return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(source, "Y");
                        }), sizeIndex = _.findIndex(valueSources, function(source) {
                            return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(source, "Size");
                        }), xAxisLabel = "", yAxisLabel = "";
                        xIndex[0] >= 0 ? xAxisLabel = (xCol = valueSources[xIndex[0]]).displayName : (desc = tryFindGroupColumn(matrix.rows, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.x)) && (xIndex = desc.levelSourceIndices, 
                        xAxisLabel = (xCol = desc.column).displayName, hasXGroups = !0), yIndex >= 0 ? yAxisLabel = (yCol = valueSources[yIndex]).displayName : (desc = tryFindGroupColumn(matrix.rows, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.y)) && (yIndex = desc.levelSourceIndices[0], 
                        yAxisLabel = (yCol = desc.column).displayName, hasYGroups = !0), sizeIndex >= 0 && (sizeCol = valueSources[sizeIndex]);
                        var seriesNode, seriesLevel = _.find(matrix.rows.levels, function(level) {
                            return !_.isEmpty(level.sources) && (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(level.sources[0], _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.series);
                        });
                        seriesLevel ? seriesNode = matrix.rows.root : (seriesLevel = _.find(matrix.columns.levels, function(level) {
                            return !_.isEmpty(level.sources) && (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(level.sources[0], _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.series);
                        })) && (seriesNode = matrix.columns.root);
                        var objects = null !== (_b = null === (_a = null == dataView ? void 0 : dataView.metadata) || void 0 === _a ? void 0 : _a.objects) && void 0 !== _b ? _b : {}, isXScalarType = !1, isXCategoricalAxis = !1;
                        if (xCol) {
                            var xType = xCol.type;
                            isXScalarType = _.size(xIndex) <= 1 && !(!xType.integer && !xType.numeric), isXCategoricalAxis = (0, 
                            _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_cartesian_capabilities__WEBPACK_IMPORTED_MODULE_25__.p.categoryAxis.axisType) === _Visuals_types_axisType__WEBPACK_IMPORTED_MODULE_26__.w.categorical || !isXScalarType;
                        }
                        if (hasXGroups || hasYGroups) {
                            var hasCategoryLevel_1 = !!_.find(matrix.rows.levels, function(level) {
                                return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(level.sources[0], _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.category);
                            });
                            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                                return !hasCategoryLevel_1;
                            }, "not expecting to find category level with x/y grouping");
                        }
                        var categoryLevelRole = hasXGroups ? _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.x : hasYGroups ? _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.y : _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.category;
                        return {
                            idx: {
                                x: xIndex,
                                y: yIndex,
                                size: sizeIndex
                            },
                            xCol,
                            yCol,
                            size: sizeCol,
                            axesLabels: {
                                x: xAxisLabel,
                                y: yAxisLabel
                            },
                            xGroupMetadata: hasXGroups ? {
                                isCategoricalAxis: isXCategoricalAxis,
                                isScalarType: isXScalarType
                            } : void 0,
                            yGroupMetadata: hasYGroups ? {
                                isCategoricalAxis: !1,
                                isScalarType: !0
                            } : void 0,
                            seriesLevel,
                            seriesNode,
                            categoryLevel: _.find(matrix.rows.levels, function(level) {
                                return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(level.sources[0], categoryLevelRole);
                            }),
                            treatNullsAsZero: {
                                x: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.categoryAxis.treatNullsAsZero, !1),
                                y: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.valueAxis.treatNullsAsZero, !1)
                            }
                        };
                    }(dataView), sizeMetadata = scatterMetadata.size, valueSources = dataView.matrix.valueSources, tooltipValuesIndices = [], index = 0; index < valueSources.length; index++) (0, 
                    _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(valueSources[index], "Tooltips") && tooltipValuesIndices.push(index);
                    var converterContext = {
                        colorHelper: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.create(options.style, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.color, (0, 
                        _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.W7)(null === (_b = dataView.metadata) || void 0 === _b ? void 0 : _b.objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.dataPoint.defaultColor), (0, 
                        _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.W7)(null === (_c = dataView.metadata) || void 0 === _c ? void 0 : _c.objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.color)),
                        metadata: scatterMetadata,
                        hasDynamicSeries: (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.c5)(dataView, "Series"),
                        tooltipsEnabled: options.tooltipsEnabled,
                        sizeRange: (null == sizeMetadata ? void 0 : sizeMetadata.aggregates) ? {
                            min: sizeMetadata.aggregates.minLocal || sizeMetadata.aggregates.min || 0,
                            max: sizeMetadata.aggregates.maxLocal || sizeMetadata.aggregates.max
                        } : {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        },
                        dataLabelSettings: dataLabelsSettings,
                        playFrameInfo,
                        tooltipValuesIndices,
                        gradientIndex: _.findIndex(valueSources, function(valueSource) {
                            return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(valueSource, "Gradient");
                        }),
                        staticObjProps,
                        categoryMap: {},
                        categoryMapNextIndex: 0,
                        categoryIdentities: []
                    }, dataPointSeriesResult = function(dataView, converterContext) {
                        var _a, _b, _c, _d, dataPointSeries = [], matrix = dataView.matrix;
                        if (!matrix.rows.root || 0 === _.size(matrix.rows.root.children)) return {
                            dataPointSeries
                        };
                        var subtotals, metadata = converterContext.metadata, seriesHierarchyNode = metadata.seriesNode, sizeValues = -1 !== metadata.idx.size ? matrix.valueSources[metadata.idx.size] : void 0, valueColumnIds = getValueColumnIds(metadata);
                        if (seriesHierarchyNode) {
                            for (var _loop_3 = function(i) {
                                var seriesNode = seriesHierarchyNode.children[i];
                                if (seriesNode.isSubtotal) return "continue";
                                var seriesMarker = Object.create(converterContext.staticObjProps.marker);
                                seriesMarker.color = converterContext.colorHelper.getColorForSeriesValue(seriesNode.objects, seriesHierarchyNode.childIdentityFields, seriesNode.value, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA), 
                                _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                                    return 1 === _.size(metadata.seriesLevel.sources);
                                }, "Scatter should only have one series column");
                                var seriesColumnSources = metadata.seriesLevel.sources[0], valueDetails = seriesNode.levelValues.map(function(levelValue) {
                                    return {
                                        expr: seriesColumnSources.expr,
                                        formattedValue: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.WU(levelValue.value, seriesColumnSources.format),
                                        value: levelValue.value,
                                        identity: seriesNode.identity
                                    };
                                });
                                converterContext.staticObjProps.showSeries && (seriesMarker.shape = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(seriesNode.objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.shape, seriesMarker.shape));
                                var seriesOptions = {
                                    dataView,
                                    currentSeries: seriesNode,
                                    converterContext,
                                    seriesMarker,
                                    seriesIndex: i,
                                    valueColumnIds
                                }, seriesDataPoint = {
                                    identityKey: null !== (_c = null === (_b = seriesNode.identity) || void 0 === _b ? void 0 : _b.key) && void 0 !== _c ? _c : "",
                                    dataPoints: createDataPointsForSeries(seriesOptions),
                                    marker: seriesMarker,
                                    identity: (new _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_17__.dw).withColumnIdentity(seriesNode.identity, seriesColumnSources.queryName, valueDetails).createSelectionId(),
                                    name: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.WU(seriesNode.value, (0, 
                                    _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(seriesColumnSources.objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.formatString))
                                };
                                if (dataPointSeries.push(seriesDataPoint), !metadata.categoryLevel && 0 === _.size(seriesDataPoint.dataPoints)) {
                                    var dataPoint = createDataPoint({
                                        seriesOptions,
                                        category: seriesNode,
                                        categoryMetadataColumns: [ seriesColumnSources ],
                                        categoryIdentityFields: seriesNode.childIdentityFields,
                                        categoryFormatter: getCategoryFormatter(void 0, seriesColumnSources)
                                    });
                                    dataPoint && seriesDataPoint.dataPoints.push(dataPoint);
                                }
                            }, i = 0; i < (null === (_a = seriesHierarchyNode.children) || void 0 === _a ? void 0 : _a.length); i++) _loop_3(i);
                            var children = dataView.matrix.rows.root.children;
                            (subtotalChild = _.find(children, function(child) {
                                return child.isSubtotal;
                            })) && (subtotals = getAxisSubtotals(metadata, subtotalChild));
                        } else {
                            var subtotalChild, seriesMarker = Object.create(converterContext.staticObjProps.marker);
                            seriesMarker.color = converterContext.colorHelper.getColorForMeasure(null, null !== (_d = null == sizeValues ? void 0 : sizeValues.queryName) && void 0 !== _d ? _d : "", _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA), 
                            dataPointSeries.push({
                                identityKey: "",
                                dataPoints: createDataPointsForSeries({
                                    dataView,
                                    converterContext,
                                    currentSeries: matrix.rows.root,
                                    seriesMarker,
                                    valueColumnIds
                                }),
                                marker: seriesMarker
                            }), metadata.categoryLevel ? (children = dataView.matrix.rows.root.children, (subtotalChild = _.find(children, function(child) {
                                return child.isSubtotal;
                            })) && (subtotals = getAxisSubtotals(converterContext.metadata, subtotalChild))) : metadata.xGroupMetadata || metadata.yGroupMetadata || (subtotals = getAxisSubtotals(metadata, dataView.matrix.rows.root.children[0]));
                        }
                        return {
                            dataPointSeries,
                            xSubtotal: null == subtotals ? void 0 : subtotals.xSubtotal,
                            ySubtotal: null == subtotals ? void 0 : subtotals.ySubtotal
                        };
                    }(dataView, converterContext), dataPoints = finalizeDataPoints(dataPointSeriesResult.dataPointSeries, scatterMetadata), legendConversionOptions = {
                        dataView,
                        colorHelper: converterContext.colorHelper,
                        style: options.style,
                        formatStringProp: null,
                        showByDefault: !0,
                        markerShapePropIdentifier: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.shape,
                        markerShowSeriesPropIdentifier: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.bubbles.showSeries
                    }, legendData = converterContext.hasDynamicSeries ? (null === (_d = converterContext.metadata.xGroupMetadata) || void 0 === _d ? void 0 : _d.isCategoricalAxis) ? (0, 
                    _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__.Lk)(legendConversionOptions) : (0, 
                    _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__.PP)(legendConversionOptions) : (0, 
                    _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__.Fe)(options.style);
                    return interactivityService && (interactivityService.applySelectionStateToData(dataPoints), 
                    interactivityService.applySelectionStateToData(legendData.dataPoints)), (0, tslib__WEBPACK_IMPORTED_MODULE_11__.__assign)((0, 
                    tslib__WEBPACK_IMPORTED_MODULE_11__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_11__.__assign)({
                        xCol: scatterMetadata.xCol,
                        yCol: scatterMetadata.yCol,
                        axesLabels: scatterMetadata.axesLabels,
                        size: scatterMetadata.size,
                        hasCategory: !!(scatterMetadata.xGroupMetadata || scatterMetadata.yGroupMetadata || scatterMetadata.categoryLevel),
                        dataPoints
                    }, dataPointSeriesResult), {
                        legendData,
                        categoryIdentities: converterContext.categoryIdentities,
                        sizeRange: converterContext.sizeRange,
                        dataLabelsSettings,
                        hasDynamicSeries: converterContext.hasDynamicSeries,
                        xGroupMetadata: scatterMetadata.xGroupMetadata,
                        yGroupMetadata: scatterMetadata.yGroupMetadata,
                        treatNullsAsZero: scatterMetadata.treatNullsAsZero
                    }), staticObjProps);
                }
            }(dataView, options, playFrameInfo) : (null === (_a = dataView.categorical) || void 0 === _a ? void 0 : _a.values) ? function(dataView, options, playFrameInfo, subtotals) {
                var _a, _b, reader = (0, _Visuals_dataViewReaders_categorical_dataViewCategoricalReader__WEBPACK_IMPORTED_MODULE_7__.G)(dataView, {
                    colorOptions: {
                        valueRole: "Size",
                        visualStyle: options.style
                    },
                    formatStringProp: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.formatString
                }), style = options.style, interactivityService = options.interactivityService, categoryAxisProperties = options.categoryAxisProperties, valueAxisProperties = options.valueAxisProperties, dataViewCategorical = dataView.categorical, gradientValueColumn = (0, 
                _Visuals_common_gradientUtils__WEBPACK_IMPORTED_MODULE_9__.Rr)(dataViewCategorical), categoryValues = [ null ], categoryFormatter = _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.E3(null);
                (null === (_a = dataViewCategorical.categories) || void 0 === _a ? void 0 : _a.length) > 0 && (categoryValues = dataViewCategorical.categories[0].values, 
                categoryFormatter = _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.Ue({
                    format: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.EO(dataViewCategorical.categories[0].source, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.formatString),
                    value: categoryValues[0],
                    value2: categoryValues[categoryValues.length - 1],
                    columnType: reader.data.getCategoryType("Category")
                }));
                var dataViewValueGroups, sizeColumnIndex, result, dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), scatterMetadata = function(grouped) {
                    var xCol, yCol, sizeCol, xIndex = (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.a2)(grouped, "X"), yIndex = (0, 
                    _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.a2)(grouped, "Y"), sizeIndex = (0, 
                    _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.a2)(grouped, "Size"), xAxisLabel = "", yAxisLabel = "";
                    if (grouped && grouped.length) {
                        var firstGroup = grouped[0];
                        xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                        yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                        sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source);
                    }
                    return {
                        idx: {
                            x: [ xIndex ],
                            y: yIndex,
                            size: sizeIndex
                        },
                        xCol,
                        yCol,
                        size: sizeCol,
                        axesLabels: {
                            x: xAxisLabel,
                            y: yAxisLabel
                        }
                    };
                }(grouped), dataLabelsSettings = (0, _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_1__.vc)(style, "smallLightLabel"), staticObjProps = getObjectProperties(null === (_b = null == dataView ? void 0 : dataView.metadata) || void 0 === _b ? void 0 : _b.objects, dataLabelsSettings, style), dataPointSeries = function(reader, dataValues, metadata, categorical_, categoryValues, categoryFormatter, hasDynamicSeries, labelSettings, gradientValueColumn, staticObjProps, playFrameInfo, tooltipsEnabled) {
                    var _a, _b, _c, _d, _e, _f, hasX = reader.data.hasValues("X"), hasY = reader.data.hasValues("Y"), categories = categorical_.categories;
                    if (!hasX && !hasY) return [];
                    var dataPointSeries = [], indices = metadata.idx, formatStringProp = _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                        return _.size(indices.x) <= 1;
                    }, "Categorical X axis is not supported with categorical data view and hence there should not be more than 1 column on X role");
                    for (var categoryColumn = _.isEmpty(categories) ? null : categories[0], valueColumnIds = getValueColumnIds(metadata), _loop_1 = function(seriesIndex, len) {
                        var grouping = grouped[seriesIndex], seriesValues = grouping.values, measureSize = getMeasureValue(indices.size, seriesValues), marker = Object.create(staticObjProps.marker);
                        marker.color = hasDynamicSeries ? reader.colors.createBySeries(seriesIndex, void 0, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA) : void 0, 
                        reader.data.hasSeries() && staticObjProps.showSeries && (marker.shape = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(reader.objects.getSeriesDataObjects(seriesIndex), _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.shape, marker.shape));
                        var series = {
                            identityKey: null !== (_b = null === (_a = null == grouping ? void 0 : grouping.identity) || void 0 === _a ? void 0 : _a.key) && void 0 !== _b ? _b : "",
                            dataPoints: [],
                            marker,
                            identity: reader.identities.createForSeries(seriesIndex, [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.size ]),
                            name: hasDynamicSeries ? _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.WU(reader.data.getSeriesName(seriesIndex), reader.objects.getSeriesFormatString()) : void 0
                        };
                        dataPointSeries.push(series);
                        for (var _loop_2 = function(categoryIndex, iLen) {
                            var xVal = hasX ? (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(reader.data.getValue(_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.x, categoryIndex, seriesIndex)) : 0, yVal = hasY ? (0, 
                            _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(reader.data.getValue(_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.y, categoryIndex, seriesIndex)) : 0;
                            if (null == xVal || null == yVal) return "continue";
                            var withCategory = null !== (_c = categorical_.originalCategories) && void 0 !== _c ? _c : [ categoryColumn ], renderIdentityBuilder = _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_17__.dw.builder().withCategory(withCategory, categoryIndex, null === (_d = null == categoryColumn ? void 0 : categoryColumn.source) || void 0 === _d ? void 0 : _d.queryName, !0).withSeries(dataValues, grouping, !0).withMeasures(valueColumnIds), selectionIdentityBuilder = void 0;
                            playFrameInfo ? (selectionIdentityBuilder = renderIdentityBuilder.clone()).withColumnIdentity(playFrameInfo.identity, playFrameInfo.column.queryName, [ {
                                expr: playFrameInfo.column.expr,
                                formattedValue: playFrameInfo.formattedValue,
                                identity: playFrameInfo.identity,
                                value: playFrameInfo.value
                            } ]) : selectionIdentityBuilder = renderIdentityBuilder;
                            var identity = selectionIdentityBuilder.createSelectionId(), tooltipBuilder = new _Visuals_tooltip__WEBPACK_IMPORTED_MODULE_18__.Rm(reader.columns, formatStringProp);
                            if (tooltipsEnabled) {
                                var defaultFormatter = (0, _Visuals_formatting_formattingStrategy__WEBPACK_IMPORTED_MODULE_19__.F)(formatStringProp), fallbackFormatter = (0, 
                                _Visuals_formatting_formattingStrategy__WEBPACK_IMPORTED_MODULE_19__.S)(formatStringProp);
                                tooltipBuilder.withColumnValueByIndex(categoryColumn, categoryIndex, !0, defaultFormatter), 
                                hasDynamicSeries && tooltipBuilder.withColumnValue(dataValueSource, grouping.name, void 0, !0, defaultFormatter);
                                var measureX = getMeasureValue(_.first(indices.x), seriesValues), measureY = getMeasureValue(indices.y, seriesValues);
                                tooltipBuilder.withColumnValueByIndex(measureX, categoryIndex, !1, fallbackFormatter).withColumnValueByIndex(measureY, categoryIndex, !1, fallbackFormatter).withColumnValueByIndex(measureSize, categoryIndex, !1, fallbackFormatter).withColumnValueByIndex(gradientValueColumn, categoryIndex, !1, fallbackFormatter), 
                                playFrameInfo && tooltipBuilder.withValue(playFrameInfo.column.displayName, playFrameInfo.label), 
                                tooltipBuilder.withAllValuesForRole("Tooltips", categoryIndex, seriesIndex, !1, fallbackFormatter);
                            }
                            var dataPointMarker = Object.create(series.marker);
                            dataPointMarker.size = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(reader.data.getValue(_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.size, categoryIndex, seriesIndex)), 
                            dataPointMarker.color = staticObjProps.colorByCategory && !hasDynamicSeries ? reader.colors.createByCategory(categoryIndex, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA) : reader.colors.createBySeries(seriesIndex, categoryIndex, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA), 
                            series.dataPoints.push({
                                x: xVal,
                                y: yVal,
                                xFormatString: hasX ? reader.data.getFormatString(_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.x, categoryIndex, seriesIndex) : void 0,
                                yFormatString: hasY ? reader.data.getFormatString(_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.y, categoryIndex, seriesIndex) : void 0,
                                marker: dataPointMarker,
                                radius: null == measureSize ? void 0 : measureSize.values[categoryIndex],
                                sourceGroupName: null === (_e = null == measureSize ? void 0 : measureSize.source) || void 0 === _e ? void 0 : _e.groupName,
                                formattedCategory: new _VisualsCommon_Lazy__WEBPACK_IMPORTED_MODULE_20__.o(function() {
                                    return categoryFormatter.format(null != categories ? categoryValues[categoryIndex] : grouping.name);
                                }),
                                selected: !1,
                                identity,
                                renderIdentity: null !== (_f = null == renderIdentityBuilder ? void 0 : renderIdentityBuilder.createSelectionId()) && void 0 !== _f ? _f : identity,
                                tooltipInfo: function() {
                                    return tooltipBuilder.getTooltipItems();
                                },
                                labelFill: labelSettings.fontProperties.color,
                                categoryIndex,
                                seriesIndex
                            });
                        }, categoryIndex = 0, iLen = categoryValues.length; categoryIndex < iLen; categoryIndex++) _loop_2(categoryIndex);
                    }, seriesIndex = 0, len = grouped.length; seriesIndex < len; seriesIndex++) _loop_1(seriesIndex);
                    return dataPointSeries;
                }(reader, dataValues, scatterMetadata, dataViewCategorical, categoryValues, categoryFormatter, hasDynamicSeries, dataLabelsSettings, gradientValueColumn, staticObjProps, playFrameInfo, options.tooltipsEnabled), dataPoints = finalizeDataPoints(dataPointSeries, scatterMetadata), legendData = hasDynamicSeries ? (0, 
                _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__.pq)({
                    dataView,
                    style,
                    showByDefault: !0,
                    simpleMarkerProp: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.shape
                }) : (0, _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__.Fe)();
                return categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && !1 === categoryAxisProperties.showAxisTitle && (scatterMetadata.axesLabels.x = null), 
                valueAxisProperties && null !== valueAxisProperties.showAxisTitle && !1 === valueAxisProperties.showAxisTitle && (scatterMetadata.axesLabels.y = null), 
                interactivityService && (interactivityService.applySelectionStateToData(dataPoints), 
                interactivityService.applySelectionStateToData(legendData.dataPoints)), (0, tslib__WEBPACK_IMPORTED_MODULE_11__.__assign)({
                    xCol: scatterMetadata.xCol,
                    yCol: scatterMetadata.yCol,
                    axesLabels: scatterMetadata.axesLabels,
                    size: scatterMetadata.size,
                    hasCategory: reader.data.hasCategories(),
                    dataPoints,
                    dataPointSeries,
                    legendData,
                    sizeRange: (dataViewValueGroups = grouped, sizeColumnIndex = scatterMetadata.idx.size, 
                    result = {}, null == dataViewValueGroups || dataViewValueGroups.forEach(function(group) {
                        var currentRange = function(sizeColumn) {
                            var result = {};
                            return sizeColumn && (result.min = sizeColumn.min ?? sizeColumn.minLocal ?? d3.min(sizeColumn.values), 
                            result.max = sizeColumn.max ?? sizeColumn.maxLocal ?? d3.max(sizeColumn.values)), 
                            result;
                        }(getMeasureValue(sizeColumnIndex, group.values));
                        (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                        (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                    }), result),
                    dataLabelsSettings,
                    hasDynamicSeries,
                    xSubtotal: null == subtotals ? void 0 : subtotals[_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.x],
                    ySubtotal: null == subtotals ? void 0 : subtotals[_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.TL.y]
                }, staticObjProps);
            }(dataView, options, playFrameInfo, subtotals) : void 0;
        }
        var DefaultScatterRatioLineColorName = "foregroundDark";
        function getDefaultScatterChartData(style) {
            return {
                xCol: void 0,
                yCol: void 0,
                hasCategory: void 0,
                dataPoints: [],
                dataPointSeries: [],
                legendData: (0, _Visuals_common_legend_converter__WEBPACK_IMPORTED_MODULE_0__.Fe)(style),
                axesLabels: {
                    x: "",
                    y: ""
                },
                sizeRange: {
                    min: void 0,
                    max: void 0
                },
                dataLabelsSettings: (0, _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_1__.vc)(style, "smallLightLabel"),
                hasDynamicSeries: !1,
                plotAreaShadingSettings: {
                    show: !1,
                    upperShadingColor: {
                        solid: {
                            color: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getDataColorByIndex(style, 3)
                        }
                    },
                    lowerShadingColor: {
                        solid: {
                            color: _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getDataColorByIndex(style, 5)
                        }
                    },
                    transparency: 70
                },
                ratioLineSettings: {
                    strokeShow: !1,
                    strokeColor: style ? _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, DefaultScatterRatioLineColorName) : void 0,
                    strokeTransparency: 0,
                    strokeWidth: 3,
                    strokePattern: _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__.Dv.dashed,
                    strokeDashArray: _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__.YU,
                    strokeDashCap: _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__.xm,
                    strokeAutoScale: !1
                },
                marker: {
                    show: !0,
                    shape: _Visuals_types_markerShape__WEBPACK_IMPORTED_MODULE_4__.ZO.circle,
                    color: style.colorPalette.dataColors.getColorByIndex(0).value,
                    transparency: 0,
                    rotation: 0,
                    stroke: {
                        strokeShow: !1,
                        strokeColor: style ? _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.getThemeColor(style, DefaultScatterRatioLineColorName) : void 0,
                        strokeTransparency: 0,
                        strokeWidth: 1,
                        strokePattern: _Visuals_types_strokePattern__WEBPACK_IMPORTED_MODULE_3__.Dv.solid
                    },
                    rangeType: _Visuals_types_markerRangeType__WEBPACK_IMPORTED_MODULE_5__.Dl.deprecated,
                    multiplier: _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_6__.Kf.min
                },
                dataVolume: DefaultScatterChartDataVolume,
                colorBorder: !1,
                colorByCategory: !1
            };
        }
        function finalizeDataPoints(series, scatterMetadata) {
            var _a, dataPoints = _.reduce(series, function(a, s) {
                return a.concat(s.dataPoints);
            }, []);
            return Boolean(scatterMetadata.size) && !(null === (_a = scatterMetadata.xGroupMetadata) || void 0 === _a ? void 0 : _a.isCategoricalAxis) && dataPoints.sort(sortBubblesByRadius), 
            dataPoints;
        }
        function sortBubblesByRadius(a, b) {
            if (null != a.radius && null != b.radius) {
                var diff = b.radius - a.radius;
                if (0 !== diff) return diff;
            }
            return b.identity.getKey().localeCompare(a.identity.getKey());
        }
        function getAxisSubtotals(metadata, subtotalChild) {
            var xSubtotal;
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                return !metadata.xGroupMetadata && !metadata.yGroupMetadata;
            }, "Can not get subtotals when grouped on x/y");
            var xIndices = metadata.idx.x, yIndex = metadata.idx.y;
            _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                return _.size(xIndices) <= 1;
            }, "Categorical X is not supported without X groups and hence there should only be 1 X column");
            var ySubtotal, xIndex = _.first(xIndices);
            return -1 !== xIndex && (xSubtotal = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(subtotalChild.values[xIndex].value)), 
            -1 !== yIndex && (ySubtotal = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(subtotalChild.values[yIndex].value)), 
            {
                xSubtotal,
                ySubtotal
            };
        }
        function createDataPointsForSeries(options) {
            for (var dataPoints = [], _a = function(seriesCreationParams) {
                var _a, _b, _c, categories, categoryMetadataColumns, dataView = seriesCreationParams.dataView, converterContext = seriesCreationParams.converterContext, currentSeries = seriesCreationParams.currentSeries, currentSeriesMetadata = null !== (_b = null === (_a = converterContext.metadata.seriesLevel) || void 0 === _a ? void 0 : _a.sources[0]) && void 0 !== _b ? _b : void 0, formatter = _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.E3(null);
                if (null === (_c = converterContext.metadata.xGroupMetadata) || void 0 === _c ? void 0 : _c.isCategoricalAxis) {
                    var categoryRows = dataView.matrix.rows;
                    formatter = getCategoryFormatter((categories = categoryRows.root.children)[0], (categoryMetadataColumns = categoryRows.levels[0].sources)[0]);
                } else currentSeries.children ? (categories = currentSeries.children, categoryMetadataColumns = dataView.matrix.rows.levels.length > 0 ? dataView.matrix.rows.levels[categories[0].level].sources : void 0, 
                currentSeriesMetadata && (formatter = getCategoryFormatter(categories[0], categoryMetadataColumns[0]))) : currentSeriesMetadata && (0, 
                _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(currentSeriesMetadata, "Category") && (formatter = getCategoryFormatter((categories = [ currentSeries ])[0], (categoryMetadataColumns = [ currentSeriesMetadata ])[0]));
                return {
                    categories,
                    categoryMetadataColumns,
                    categoryFormatter: formatter
                };
            }(options), categories = _a.categories, categoryFormatter = _a.categoryFormatter, categoryMetadataColumns = _a.categoryMetadataColumns, _i = 0, _b = null != categories ? categories : []; _i < _b.length; _i++) {
                var dataPoint = createDataPoint({
                    seriesOptions: options,
                    category: _b[_i],
                    categoryMetadataColumns,
                    categoryIdentityFields: options.currentSeries.childIdentityFields,
                    categoryFormatter
                });
                dataPoint && dataPoints.push(dataPoint);
            }
            return dataPoints;
        }
        function getCategoryFormatter(category, categoryMetadata) {
            return (null == category ? void 0 : category.levelValues) ? _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.Ue({
                format: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.EO(categoryMetadata, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.formatString),
                value: category.levelValues[0],
                value2: category.levelValues[_.size(category.values) - 1],
                columnType: null
            }) : _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.E3(null);
        }
        function createDataPoint(creationParams) {
            var _a, _b, _c, _d, _e, _f;
            if (!creationParams.category.isSubtotal) {
                var xFormatString, _g = creationParams.seriesOptions, converterContext = _g.converterContext, seriesIndex = _g.seriesIndex, currentSeries = _g.currentSeries, seriesMarker = _g.seriesMarker, metadata = converterContext.metadata, matrix = _g.dataView.matrix, xIndices = metadata.idx.x, yIndex = metadata.idx.y, sizeIndex = metadata.idx.size, seriesStride = _.size(matrix.valueSources), hasXGroups = metadata.xGroupMetadata, hasYGroups = metadata.yGroupMetadata, firstXIndex = _.first(xIndices), value = 0, formatStringProp = _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.formatString;
                hasXGroups || -1 === firstXIndex || (value = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(creationParams.category.values[firstXIndex].value), 
                value = (null === (_a = metadata.treatNullsAsZero) || void 0 === _a ? void 0 : _a.x) && null == value ? 0 : value, 
                xFormatString = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(creationParams.category.values[firstXIndex].objects, formatStringProp));
                var xValues = null == value ? null : [ value ];
                hasXGroups && (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                    return -1 !== firstXIndex;
                }, "a found grouped-X should not have an unknown index"), xValues = _.map(xIndices, function(i) {
                    var _a, _b;
                    return null !== (_b = null === (_a = creationParams.category.levelValues[i]) || void 0 === _a ? void 0 : _a.value) && void 0 !== _b ? _b : void 0;
                }));
                var yFormatString, yVal = 0, isXCategoricalAxis = null === (_b = metadata.xGroupMetadata) || void 0 === _b ? void 0 : _b.isCategoricalAxis;
                if (hasYGroups || -1 === yIndex) hasYGroups && (_VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_14__.fF.assert(function() {
                    return -1 !== yIndex;
                }, "a found grouped-Y should not have an unknown index"), yVal = creationParams.category.levelValues[yIndex].value); else {
                    var index = getValueIndex(isXCategoricalAxis, seriesIndex, seriesStride, yIndex);
                    yVal = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(creationParams.category.values[index].value), 
                    yVal = (null === (_c = metadata.treatNullsAsZero) || void 0 === _c ? void 0 : _c.y) && null == yVal ? 0 : yVal, 
                    yFormatString = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(creationParams.category.values[index].objects, formatStringProp);
                }
                if (null != xValues && null != yVal) {
                    var sizeFormatString, marker = Object.create(seriesMarker);
                    -1 !== sizeIndex && (index = getValueIndex(isXCategoricalAxis, seriesIndex, seriesStride, sizeIndex), 
                    marker.size = (0, _Visuals_common_axisHelper__WEBPACK_IMPORTED_MODULE_16__.eT)(creationParams.category.values[index].value), 
                    sizeFormatString = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(creationParams.category.values[index].objects, formatStringProp));
                    var renderIdentityBuilder, identityBuilder = _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_17__.dw.builder();
                    if (!_.isEmpty(creationParams.categoryMetadataColumns)) {
                        for (var categoryColumn = _.last(creationParams.categoryMetadataColumns), valueDetails = [], _i = 0, _h = creationParams.category.levelValues; _i < _h.length; _i++) {
                            var levelValue = _h[_i], levelSource = creationParams.categoryMetadataColumns[levelValue.levelSourceIndex];
                            valueDetails.push({
                                expr: levelSource.expr,
                                formattedValue: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.WU(levelValue.value, levelSource.format),
                                value: levelValue.value,
                                identity: creationParams.category.identity
                            });
                        }
                        identityBuilder.withColumnIdentity(creationParams.category.identity, categoryColumn.queryName, valueDetails);
                    }
                    var currentSeriesMetadata = null !== (_e = null === (_d = converterContext.metadata.seriesLevel) || void 0 === _d ? void 0 : _d.sources[0]) && void 0 !== _e ? _e : void 0;
                    currentSeriesMetadata && (valueDetails = currentSeries.levelValues.map(function(levelValue) {
                        return {
                            expr: currentSeriesMetadata.expr,
                            formattedValue: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.WU(levelValue.value, currentSeriesMetadata.format),
                            value: levelValue.value,
                            identity: currentSeries.identity
                        };
                    }), identityBuilder.withColumnIdentity(currentSeries.identity, currentSeriesMetadata.queryName, valueDetails));
                    var valueColumnIds = creationParams.seriesOptions.valueColumnIds;
                    if (_.isEmpty(valueColumnIds) || identityBuilder.withMeasures(valueColumnIds), converterContext.playFrameInfo) {
                        var playFrameInfo = converterContext.playFrameInfo;
                        renderIdentityBuilder = identityBuilder.clone(), identityBuilder.withColumnIdentity(playFrameInfo.identity, playFrameInfo.column.queryName, [ valueDetails = {
                            expr: playFrameInfo.column.expr,
                            formattedValue: playFrameInfo.formattedValue,
                            identity: playFrameInfo.identity,
                            value: playFrameInfo.value
                        } ]);
                    }
                    var identity = identityBuilder.createSelectionId(), sizeRange = converterContext.sizeRange;
                    sizeRange.min > marker.size && (sizeRange.min = marker.size), sizeRange.max < marker.size && (sizeRange.max = marker.size), 
                    converterContext.hasDynamicSeries || (converterContext.staticObjProps.colorByCategory ? marker.color = converterContext.colorHelper.getColorForSeriesValue(creationParams.category.objects, creationParams.categoryIdentityFields, creationParams.category.value, _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA) : creationParams.category.objects && (marker.color = converterContext.colorHelper.getColorForMeasure(creationParams.category.objects, null != converterContext.metadata.size ? converterContext.metadata.size.queryName : "", _VisualsCommon_colorHelper__WEBPACK_IMPORTED_MODULE_15__.fA)));
                    var defaultFormatter = (0, _Visuals_formatting_formattingStrategy__WEBPACK_IMPORTED_MODULE_19__.F)(formatStringProp), lazyCategoryValueCalc = function() {
                        var categoryLevelValues = creationParams.category.levelValues;
                        return _.isEmpty(categoryLevelValues) ? currentSeries.value : _.size(categoryLevelValues) > 1 ? (0, 
                        _Visuals_common_concatenateUtils__WEBPACK_IMPORTED_MODULE_21__.ML)(_.map(categoryLevelValues, function(levelValue, index) {
                            return defaultFormatter(levelValue.value, creationParams.categoryMetadataColumns[index]);
                        })) : categoryLevelValues[0].value;
                    }, tooltipBuilder = new _Visuals_tooltip__WEBPACK_IMPORTED_MODULE_18__.E4;
                    if (converterContext.tooltipsEnabled) {
                        var fallbackFormatter = (0, _Visuals_formatting_formattingStrategy__WEBPACK_IMPORTED_MODULE_19__.S)(formatStringProp), categoryLevelValues = creationParams.category.levelValues, needsConcatenation = _.size(creationParams.categoryMetadataColumns) > 1;
                        hasXGroups || hasYGroups || (needsConcatenation ? tooltipBuilder.withMultipleColumnAndValues(creationParams.categoryMetadataColumns, _.map(categoryLevelValues, function(levelValue) {
                            return levelValue.value;
                        }), !0, defaultFormatter) : categoryLevelValues && tooltipBuilder.withColumnValue(_.head(creationParams.categoryMetadataColumns), categoryLevelValues[0].value, void 0, !0, defaultFormatter)), 
                        converterContext.hasDynamicSeries && tooltipBuilder.withColumnValue(currentSeriesMetadata, currentSeries.value, void 0, !0, defaultFormatter), 
                        hasXGroups && converterContext.metadata.xGroupMetadata.isCategoricalAxis ? tooltipBuilder.withMultipleColumnAndValues(creationParams.categoryMetadataColumns, xValues, !0, defaultFormatter) : tooltipBuilder.withColumnValue(metadata.xCol, xValues[0], xFormatString, !1, fallbackFormatter), 
                        tooltipBuilder.withColumnValue(metadata.yCol, yVal, yFormatString, !1, fallbackFormatter).withColumnValue(metadata.size, marker.size, sizeFormatString, !1, fallbackFormatter);
                        var gradientIndex = converterContext.gradientIndex, valueSources = matrix.valueSources;
                        if (gradientIndex >= 0) {
                            var formatString = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(creationParams.category.values[gradientIndex].objects, formatStringProp);
                            tooltipBuilder.withColumnValue(valueSources[gradientIndex], creationParams.category.values[gradientIndex].value, formatString, !1, fallbackFormatter);
                        }
                        (playFrameInfo = converterContext.playFrameInfo) && tooltipBuilder.withValue(playFrameInfo.column.displayName, playFrameInfo.label);
                        for (var _j = 0, _k = converterContext.tooltipValuesIndices; _j < _k.length; _j++) {
                            var tooltipIndex = _k[_j], valueIndex = (formatString = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(creationParams.category.values[tooltipIndex].objects, formatStringProp), 
                            getValueIndex(isXCategoricalAxis, seriesIndex, seriesStride, tooltipIndex));
                            tooltipBuilder.withColumnValue(valueSources[tooltipIndex], creationParams.category.values[valueIndex].value, formatString, !1, fallbackFormatter);
                        }
                    }
                    var xVal = _.size(xValues) > 1 ? xValues.join(" ") : xValues[0], categoryValue = isXCategoricalAxis ? xVal : lazyCategoryValueCalc(), categoryMap = converterContext.categoryMap, categoryValueString = String(categoryValue), categoryIndex = categoryMap[categoryValueString];
                    if (void 0 === categoryIndex) {
                        categoryMap[categoryValueString] = categoryIndex = converterContext.categoryMapNextIndex, 
                        converterContext.categoryMapNextIndex = categoryIndex + 1;
                        var categoryIdentities = converterContext.categoryIdentities;
                        categoryIdentities && (categoryIdentities[categoryIndex] = function() {
                            var categoryIdentityBuilder = _VisualsData_selection_selectionId__WEBPACK_IMPORTED_MODULE_17__.dw.builder();
                            if (!_.isEmpty(creationParams.categoryMetadataColumns)) for (var _loop_4 = function(column) {
                                var valueDetails = creationParams.category.levelValues.map(function(levelValue) {
                                    return {
                                        expr: column.expr,
                                        formattedValue: _VisualsData_formatting_valueFormatter__WEBPACK_IMPORTED_MODULE_10__.WU(levelValue.value, column.format),
                                        value: levelValue.value,
                                        identity: creationParams.category.identity
                                    };
                                });
                                categoryIdentityBuilder.withColumnIdentity(creationParams.category.identity, column.queryName, valueDetails);
                            }, _i = 0, _a = creationParams.categoryMetadataColumns; _i < _a.length; _i++) _loop_4(_a[_i]);
                            return categoryIdentityBuilder.withMeasures(valueColumnIds).createSelectionId();
                        });
                    }
                    return {
                        x: xVal,
                        y: yVal,
                        marker,
                        radius: marker.size,
                        xFormatString,
                        yFormatString,
                        formattedCategory: new _VisualsCommon_Lazy__WEBPACK_IMPORTED_MODULE_20__.o(function() {
                            return creationParams.categoryFormatter.format(lazyCategoryValueCalc());
                        }),
                        selected: !1,
                        identity,
                        renderIdentity: null !== (_f = null == renderIdentityBuilder ? void 0 : renderIdentityBuilder.createSelectionId()) && void 0 !== _f ? _f : identity,
                        tooltipInfo: function() {
                            return tooltipBuilder.getTooltipItems();
                        },
                        labelFill: converterContext.dataLabelSettings.fontProperties.color,
                        categoryIndex,
                        seriesIndex: seriesIndex || 0
                    };
                }
            }
        }
        function getValueIndex(isXCategoricalAxis, currentSeriesIndex, seriesStride, measureIndex) {
            return isXCategoricalAxis && null != currentSeriesIndex ? currentSeriesIndex * seriesStride + measureIndex : measureIndex;
        }
        function getObjectProperties(objects, dataLabelsSettings, style) {
            null != objects || (objects = {});
            var colorHelper = _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_2__.v.create(style), defaultData = getDefaultScatterChartData(style), defaultColor = (0, 
            _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.W7)(objects, {
                objectName: "dataPoint",
                propertyName: "defaultColor"
            });
            defaultColor && (defaultData.marker.color = defaultColor);
            var marker = (0, _Visuals_common_marker_converter__WEBPACK_IMPORTED_MODULE_22__.JO)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers, defaultData.marker);
            marker.rangeType = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.markers.rangeType, defaultData.marker.rangeType), 
            marker.multiplier = (0, _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_6__.HN)((0, 
            _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.bubbles.bubbleSize));
            var objectProperties = {
                fillPointStyle: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.fillPoint.style, _Visuals_types_fillStyle__WEBPACK_IMPORTED_MODULE_23__.f.fillOnly),
                colorBorder: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.colorBorder.show, defaultData.colorBorder),
                colorByCategory: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.colorByCategory.show, defaultData.colorByCategory),
                marker,
                plotAreaShadingSettings: {
                    show: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.plotAreaShading.show, defaultData.plotAreaShadingSettings.show),
                    upperShadingColor: getFillForProperty(colorHelper, objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.plotAreaShading.upperShadingColor, defaultData.plotAreaShadingSettings.upperShadingColor),
                    lowerShadingColor: getFillForProperty(colorHelper, objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.plotAreaShading.lowerShadingColor, defaultData.plotAreaShadingSettings.lowerShadingColor),
                    transparency: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.plotAreaShading.transparency, defaultData.plotAreaShadingSettings.transparency)
                },
                ratioLineSettings: (0, tslib__WEBPACK_IMPORTED_MODULE_11__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_11__.__assign)({}, (0, 
                _Visuals_common_strokeStyle__WEBPACK_IMPORTED_MODULE_24__.QI)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.ratioLine, defaultData.ratioLineSettings)), {
                    strokeColor: colorHelper.getColorForPropertyWithDefaultColor(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.ratioLine.strokeColor, defaultData.ratioLineSettings.strokeColor)
                }),
                dataVolume: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.general.dataVolume, DefaultScatterChartDataVolume),
                showSeries: (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_13__.NA)(objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_8__.il.bubbles.showSeries, !0)
            }, labelsObj = objects.categoryLabels;
            return labelsObj && dataLabelsSettings && (0, _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_1__.ww)(labelsObj, dataLabelsSettings, void 0, style), 
            objectProperties;
        }
        function getFillForProperty(colorHelper, objects, id, defaultColor) {
            return {
                solid: {
                    color: colorHelper.getColorForPropertyWithDefaultColor(objects, id, null == defaultColor ? void 0 : defaultColor.solid.color)
                }
            };
        }
        function tryFindGroupColumn(rows, role) {
            for (var levelIndex = 0, numRows = rows.levels.length; levelIndex < numRows; levelIndex++) {
                var level = rows.levels[levelIndex], levelSourceIndices = _.chain(level.sources).map(function(l, i) {
                    return {
                        levelSource: l,
                        index: i
                    };
                }).filter(function(o) {
                    return (0, _VisualsData_dataView_dataRoleHelper__WEBPACK_IMPORTED_MODULE_12__.nu)(o.levelSource, role);
                }).map(function(o) {
                    return o.index;
                }).value();
                if (!_.isEmpty(levelSourceIndices)) return {
                    levelIndex,
                    levelSourceIndices,
                    column: level.sources[_.first(levelSourceIndices)]
                };
            }
        }
        function getValueColumnIds(metadata) {
            var ids = [];
            return !metadata.xGroupMetadata && metadata.xCol && ids.push(metadata.xCol.queryName), 
            !metadata.yGroupMetadata && metadata.yCol && ids.push(metadata.yCol.queryName), 
            metadata.size && ids.push(metadata.size.queryName), ids;
        }
        function getMeasureValue(measureIndex, seriesValues) {
            return measureIndex >= 0 ? seriesValues[measureIndex] : null;
        }
    },
    15458: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            In: function() {
                return getDataViewObjectLayerChanges;
            },
            PH: function() {
                return getSubSelectionCustomOutlines;
            },
            aD: function() {
                return customizeFormattingCard;
            },
            ke: function() {
                return onMarkerSubSelection;
            },
            l5: function() {
                return getSelectorsByColumnFromSubselectedElement;
            },
            mv: function() {
                return getSubSelectionStyles;
            },
            nZ: function() {
                return getFormattingCards;
            },
            qo: function() {
                return enumerateObjectInstances;
            },
            u$: function() {
                return resolveFormattingPlaceholder;
            },
            yV: function() {
                return getSubSelectionShortcuts;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(81337), _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14577), _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(14599), _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21181), _Visuals_common_onObjectUtil__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(80065), _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(86108), _Visuals_common_subSelectionHelper_htmlSubSelectionHelper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(52287), _Visuals_common_dataViewObjectChangeHelper_dataViewObjectBehaviors_topLevelToggleBehavior__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(23465), _Visuals_common_dataViewObjectChangeHelper_dataViewObjectChangeHelper__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(51650), _Visuals_common_dataViewObjectChangeHelper_dataViewObjectChanges_addDataViewObjectChange__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(57622), _Visuals_common_strokeStyle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(2241), _Visuals_types_markerRangeType__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(90700), _Visuals_types_markerShape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(61193), _Visuals_types_fillStyle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67165), _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56578), _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32379), _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82755), _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(96915), _cartesianChart_formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3128), _scatterChart_converter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(79972), MARKERS_MAX_COUNT_THRESHOLD = 7, MIN_OUTLINE_SIZE = 10;
        function getFormattingCards(formattingCardOptions) {
            var _a, _b;
            return {
                type: 2,
                card: [ getMarkersCard.call(this, formattingCardOptions), this.isXAxisCategorical() ? void 0 : (0, 
                _Visuals_common_dataLabelViewModel1__WEBPACK_IMPORTED_MODULE_0__.Zu)({
                    cardName: "Visual_CategoryLabel",
                    dataLabelSettings: null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.dataLabelsSettings) && void 0 !== _b ? _b : null,
                    isShowCategory: void 0,
                    localize: this.localizer,
                    props: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels,
                    revertToDefaultProps: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels,
                    showBackground: !0,
                    showValueColor: !0,
                    style: this.style
                }) ].filter(function(card) {
                    return card;
                })
            };
        }
        function getMarkersCard(cartesianCardOptions) {
            var _a, _b, _c, _d, _this = this, data = this.originalData;
            if (data) {
                var seriesCount = null !== (_b = null === (_a = data.dataPointSeries) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0;
                if (0 !== seriesCount) {
                    var showSeries = (0, _VisualsData_dataView_dataViewObject2__WEBPACK_IMPORTED_MODULE_2__.NA)(null === (_d = null === (_c = this.dataView) || void 0 === _c ? void 0 : _c.metadata) || void 0 === _d ? void 0 : _d.objects, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.bubbles.showSeries, !0), cardBuilder = new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.CQ(new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.lg("markers"), "Visual_Markers", Object.values(_Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers).concat([ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.bubbles.bubbleSize, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.bubbles.showSeries, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.fillPoint.style, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.dataPoint.showAllDataPoints, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.dataPoint.defaultColor, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.colorByCategory.show, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryAxis.innerPadding, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.colorBorder.show ]), this.localizer);
                    return cardBuilder.addGroup("applySettingsTo", function(groupBuilder) {
                        return groupBuilder.withContainerDisabled(!showSeries).withDisplayName("Apply_Settings_To").withCollapsible(!1).addContainer("series", function(containerBuilder) {
                            if (containerBuilder.withDisplayName(seriesCount > 1 ? "Series" : "Visual_Categories").addContainerItem("all", _this.localizer("All"), function(containerItemBuilder) {
                                addScatterChartMarkersFormattingContainers.call(_this, {
                                    containerItemBuilder,
                                    marker: data.marker,
                                    selector: null,
                                    listType: "static"
                                }), showSeries || containerItemBuilder.addSimpleSlice("showSeriesLink", function() {
                                    return new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.ob({
                                        descriptor: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.bubbles.showSeries,
                                        value: function() {},
                                        ariaLabel: "Enable_This_Setting",
                                        type: "SeriesDialogLink",
                                        resetToDefaultDescriptors: [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.shape ],
                                        warningIcon: !0
                                    }).build();
                                }, function(sliceBuilder) {
                                    return sliceBuilder.withCustomDisplayName("Enable_This_Setting").withSuppressDisplayName(!0);
                                });
                            }), 1 === seriesCount) {
                                var topNDataPoints = data.dataPoints.slice(0, _cartesianChart_formatter__WEBPACK_IMPORTED_MODULE_4__.Rl);
                                if (topNDataPoints.length < 2) return;
                                for (var _loop_1 = function(dataPoint) {
                                    var label = dataPoint.formattedCategory.getValue();
                                    containerBuilder.addContainerItem(label, label, function(containerItemBuilder) {
                                        return addScatterChartMarkersFormattingContainers.call(_this, {
                                            containerItemBuilder,
                                            marker: dataPoint.marker,
                                            selector: (0, _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.fd)(dataPoint.identity.getSelector()),
                                            listType: "perCategory"
                                        });
                                    });
                                }, _i = 0, topNDataPoints_1 = topNDataPoints; _i < topNDataPoints_1.length; _i++) _loop_1(topNDataPoints_1[_i]);
                            }
                            if (seriesCount > 1) for (var _loop_2 = function(series) {
                                containerBuilder.addContainerItem(series.name, series.name, function(containerItemBuilder) {
                                    return addScatterChartMarkersFormattingContainers.call(_this, {
                                        containerItemBuilder,
                                        marker: series.marker,
                                        selector: (0, _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.fd)(series.identity.getSelector()),
                                        listType: "perSeries"
                                    });
                                });
                            }, _a = 0, _b = data.dataPointSeries; _a < _b.length; _a++) _loop_2(_b[_a]);
                        });
                    }), this.isXAxisCategorical() && cardBuilder.addGroup("spacing", function(groupBuilder) {
                        return groupBuilder.withDisplayName("Visual_Spacing").addSimpleSlice("innerPadding", (0, 
                        _cartesianChart_formatter__WEBPACK_IMPORTED_MODULE_4__.Gf)(cartesianCardOptions.categoryAxisData, _this.localizer));
                    }), cardBuilder.build();
                }
            }
        }
        function getSubSelectionStyles(subSelections) {
            var visualObject, selector, visualObjects = _.first(subSelections).visualObjects;
            if (visualObjects.length > 0) {
                (visualObject = visualObjects[0]) && visualObject.selectorsByColumn && (selector = (0, 
                _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.fd)((0, _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.tV)(visualObject.selectorsByColumn)));
                var fill = this.originalData.fillPointStyle === _Visuals_types_fillStyle__WEBPACK_IMPORTED_MODULE_6__.f.fillOnly, singleSeries = 1 === this.data.dataPointSeries.length;
                switch (visualObject.objectName) {
                  case "markers":
                    var wildCardSelector = {
                        data: [ (0, _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_7__.Ue)(1) ]
                    };
                    selector = singleSeries ? wildCardSelector : selector;
                    var formattingId = (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.dataPoint.fill), {
                        selector
                    });
                    return (0, _Visuals_common_onObjectUtil__WEBPACK_IMPORTED_MODULE_9__.w3)(this.hostService, fill ? void 0 : formattingId, fill ? formattingId : void 0);

                  case "category-labels":
                    return (0, _Visuals_common_onObjectUtil__WEBPACK_IMPORTED_MODULE_9__.un)(this.hostService, {
                        fontFamilyReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.fontFamily,
                        fontSizeReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.fontSize,
                        boldReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.bold,
                        italicReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.italic,
                        underlineReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.underline,
                        fontColorReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.color,
                        backgroundReference: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.backgroundColor
                    });

                  default:
                    return;
                }
            }
        }
        function resolveFormattingPlaceholder(placeholder) {
            if ((0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.n$)(placeholder)) return "dataVolume" === placeholder.name ? getDataVolumeSlice.call(this) : void 0;
        }
        function getDataVolumeSlice() {
            if (this.originalData && !this.playAxis && !this.isXAxisCategorical()) return {
                item: new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.vi({
                    uidBuilder: new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.IN(new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.SS(new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.lg("visualPlaceholderCard"), "visualPlaceholderGroup"), "dataVolume"),
                    control: new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.mu({
                        descriptor: _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.general.dataVolume,
                        value: this.originalData.dataVolume,
                        options: {
                            minValue: {
                                type: 0,
                                value: _scatterChart_converter__WEBPACK_IMPORTED_MODULE_10__.jI
                            },
                            maxValue: {
                                type: 1,
                                value: _scatterChart_converter__WEBPACK_IMPORTED_MODULE_10__.V2
                            }
                        }
                    }).build(),
                    localize: this.localizer
                }).withCustomDisplayName("Visual_DataVolumeModern").build(),
                revertToDefaultDescriptors: [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.general.dataVolume ]
            };
        }
        function customizeFormattingCard(card) {
            if (!(0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(card)) return "categoryAxis" === card.uid ? getCustomizedCategoryAxisCard.call(this, card) : "valueAxis" === card.uid ? getCustomizedValueAxisCard.call(this, card) : void 0;
        }
        function getCustomizedCategoryAxisCard(card) {
            var _this = this, groups = (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], card.groups, !0);
            return groups.forEach(function(group, index) {
                (0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(group) || group.uid === "".concat("categoryAxis", "-").concat("valuesScalar") && (groups[index] = getNewValuesGroup.call(_this, group, !0));
            }), (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, card), {
                revertToDefaultDescriptors: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], card.revertToDefaultDescriptors, !0), [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.categoryAxis.treatNullsAsZero ], !1),
                groups
            });
        }
        function getCustomizedValueAxisCard(card) {
            var _this = this, groups = (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], card.groups, !0);
            return groups.forEach(function(group, index) {
                (0, _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qu)(group) || group.uid === "".concat("valueAxis", "-").concat("values") && (groups[index] = getNewValuesGroup.call(_this, group, !1));
            }), (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, card), {
                revertToDefaultDescriptors: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], card.revertToDefaultDescriptors, !0), [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.valueAxis.treatNullsAsZero ], !1),
                groups
            });
        }
        function getNewValuesGroup(group, isCategoryAxis) {
            var slices = (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], group.slices, !0), groupUidBuilder = (0, 
            _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.Qs)(group), showBlankValuesSlice = getShowBlankValuesSlice.call(this, groupUidBuilder, isCategoryAxis);
            return showBlankValuesSlice && slices.push(showBlankValuesSlice), (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, 
            tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, group), {
                slices
            });
        }
        function getShowBlankValuesSlice(uidBuilder, isCategoryAxis) {
            var _a, _b, data = this.originalData;
            if (data && !(isCategoryAxis ? data.xGroupMetadata : data.yGroupMetadata)) return new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.vi({
                control: {
                    type: "ToggleSwitch",
                    properties: {
                        descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, isCategoryAxis ? _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.categoryAxis.treatNullsAsZero : _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.valueAxis.treatNullsAsZero), {
                            selector: null
                        }),
                        value: !!(isCategoryAxis ? null === (_a = data.treatNullsAsZero) || void 0 === _a ? void 0 : _a.x : null === (_b = data.treatNullsAsZero) || void 0 === _b ? void 0 : _b.y)
                    }
                },
                localize: this.localizer,
                uidBuilder: uidBuilder.withSlice("showblankvalues")
            }).build();
        }
        function addScatterChartMarkersFormattingContainers(options) {
            var _this = this, selector = options.selector, marker = options.marker, staticData = this.originalData, hasSize = Boolean(staticData.size), getLocalizedString = {
                get: this.localizer,
                getOptional: this.localizer,
                format: this.localizer
            }, items = _.map(_Visuals_types_markerRangeType__WEBPACK_IMPORTED_MODULE_11__.Yu, function(enumValue) {
                return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, enumValue), {
                    displayName: enumValue.displayName(getLocalizedString)
                });
            });
            options.containerItemBuilder.addGroup("shape", function(groupBuilder) {
                var _a;
                return groupBuilder.withDisplayName("Visual_Shape").addSimpleSlice("markerShape", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.uY({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.shape), {
                        selector
                    }),
                    value: marker.shape
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled("perCategory" === options.listType);
                }).addSimpleSlice("fillStyle", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.uY({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.fillPoint.style), {
                        selector
                    }),
                    value: staticData.fillPointStyle
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled(hasSize || "static" !== options.listType).withHidden(_this.featureSwitches.newMarkerProperties).withCustomDescriptionIf(function() {
                        return hasSize || !!selector;
                    }, "Visual_Scatter_Size_FormatOption_DisabledReason_FillPoint");
                }).addSimpleSlice("markerRangeType", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.uY({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.rangeType), {
                        selector
                    }),
                    items,
                    value: null !== (_a = items.find(function(item) {
                        return item.value === staticData.marker.rangeType;
                    })) && void 0 !== _a ? _a : {
                        value: _Visuals_types_markerRangeType__WEBPACK_IMPORTED_MODULE_11__.Dl.deprecated,
                        displayName: _this.localizer("Visual_MarkerRangeType_Deprecated")
                    }
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled(!hasSize || "static" !== options.listType);
                }).addSimpleSlice("markerSize", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.JN({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.bubbles.bubbleSize), {
                        selector
                    }),
                    value: (0, _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_12__.yn)(staticData.marker.multiplier),
                    options: {
                        minValue: {
                            type: 0,
                            value: _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_12__.Ad.min
                        },
                        maxValue: {
                            type: 1,
                            value: _Visuals_common_shapeUtil__WEBPACK_IMPORTED_MODULE_12__.Ad.max
                        }
                    },
                    localize: _this.localizer
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled("static" !== options.listType);
                }).addSimpleSlice("markerRotation", _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.JN.getRotationSliderBuilder({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.rotation), {
                        selector
                    }),
                    value: marker.rotation,
                    localize: _this.localizer
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withHidden(!_this.featureSwitches.newMarkerProperties || !(0, 
                    _Visuals_types_markerShape__WEBPACK_IMPORTED_MODULE_13__.Cd)(marker.shape));
                });
            }).addGroup("colors", function(groupBuilder) {
                return groupBuilder.withDisplayName("Generic_Color").addSimpleSlice("colorByCategory", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.bd({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.colorByCategory.show), {
                        selector: null
                    }),
                    value: staticData.colorByCategory
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withCustomDisplayName("Visual_ColorByCategory").withHidden(staticData.hasDynamicSeries).withDisabled("static" !== options.listType, "Visual_DisabledReason_AllSeriesOnly_Singular");
                }).addSimpleSlice("markerColor", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.BT({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, 
                    tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.color), {
                        selector: "static" === options.listType ? {
                            data: [ (0, _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_7__.Ue)(1) ]
                        } : selector,
                        instanceKind: staticData.hasDynamicSeries || "perCategory" === options.listType ? 1 : 3
                    }), "static" === options.listType && {
                        altConstantValueSelector: null
                    }),
                    value: {
                        value: marker.color
                    }
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withCustomDisplayName("Generic_Color").withDisabled(staticData.hasDynamicSeries && "static" === options.listType, "Visual_Color_AllSeries_DisabledReason");
                }).addSimpleSlice("markerTransparency", _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.JN.getTransparencySliderBuilder({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.transparency), {
                        selector
                    }),
                    value: marker.transparency,
                    localize: _this.localizer
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withDisabled(staticData.hasDynamicSeries && "static" === options.listType, "Visual_Color_AllSeries_DisabledReason").withHidden(!_this.featureSwitches.newMarkerProperties);
                });
            }).addGroup("border", function(groupBuilder) {
                groupBuilder.withDisplayName("Visual_Border").withDisabled(!(0, _Visuals_types_markerShape__WEBPACK_IMPORTED_MODULE_13__.nK)(marker.shape)), 
                _this.featureSwitches.newMarkerProperties ? groupBuilder.withDisabled(!(0, _Visuals_types_markerShape__WEBPACK_IMPORTED_MODULE_13__.nK)(marker.shape) || "static" !== options.listType).addSlices((0, 
                _Visuals_common_strokeStyle__WEBPACK_IMPORTED_MODULE_14__.Iq)({
                    containerItemBuilder: groupBuilder,
                    descriptors: _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_15__.$9,
                    strokeData: null == marker ? void 0 : marker.stroke,
                    selector,
                    featureSwitches: _this.featureSwitches,
                    localize: _this.localizer
                }).map(function(slice) {
                    return slice.build();
                })) : groupBuilder.addSimpleSlice("colorBorder", new _VisualsCommon_Utility_build_control_util__WEBPACK_IMPORTED_MODULE_3__.bd({
                    descriptor: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.colorBorder.show), {
                        selector: null
                    }),
                    value: staticData.colorBorder
                }).build(), function(sliceBuilder) {
                    return sliceBuilder.withCustomDisplayName("Visual_ColorBorder").withCustomDescriptionIf(function() {
                        return !hasSize;
                    }, "Visual_Scatter_Size_FormatOption_DisabledReason").withDisabled(!hasSize || "static" !== options.listType).withHidden(_this.featureSwitches.newMarkerProperties);
                });
            });
        }
        function enumerateObjectInstances(enumeration, options) {
            var _a, _b, data = this.originalData;
            if (data) switch (options.objectName) {
              case "plotAreaShading":
                this.isPlotSymmetryShadingSupported() ? enumeration.pushInstance({
                    selector: null,
                    objectName: "plotAreaShading",
                    properties: {
                        show: data.plotAreaShadingSettings.show,
                        upperShadingColor: data.plotAreaShadingSettings.upperShadingColor,
                        lowerShadingColor: data.plotAreaShadingSettings.lowerShadingColor,
                        transparency: data.plotAreaShadingSettings.transparency
                    }
                }) : enumeration.pushInstance({
                    selector: null,
                    objectName: "plotAreaShading",
                    properties: {},
                    disabledReason: this.localizer("Visual_Scatter_SymmetryShadingNotSupported")
                });
                break;

              case "ratioLine":
                (null === (_a = data.xCol) || void 0 === _a ? void 0 : _a.isMeasure) && (null === (_b = data.yCol) || void 0 === _b ? void 0 : _b.isMeasure) && enumeration.pushInstance({
                    selector: null,
                    objectName: "ratioLine",
                    properties: (0, _Visuals_common_strokeStyle__WEBPACK_IMPORTED_MODULE_14__.HM)(data.ratioLineSettings, _Visuals_capabilities_dataViewObjectProperties__WEBPACK_IMPORTED_MODULE_15__.vi)
                });
                break;

              case "general":
                this.playAxis || this.isXAxisCategorical() || enumeration.pushInstance({
                    selector: null,
                    objectName: "general",
                    properties: {
                        dataVolume: data.dataVolume
                    },
                    validValues: {
                        dataVolume: {
                            numberRange: {
                                min: _scatterChart_converter__WEBPACK_IMPORTED_MODULE_10__.jI,
                                max: _scatterChart_converter__WEBPACK_IMPORTED_MODULE_10__.V2
                            }
                        }
                    }
                });
            }
        }
        function getSubSelectionCustomOutlines(subSelection) {
            for (var metadata = subSelection.metadata, outlineFragments = [], _i = 0, _a = subSelection.visualObjects; _i < _a.length; _i++) {
                var marker = null == metadata ? void 0 : metadata.visualObject;
                if (marker && "markers" === _a[_i].objectName) {
                    var datum = d3.select(marker).datum(), series = this.data.dataPointSeries[datum.seriesIndex];
                    if (series.dataPoints.length <= MARKERS_MAX_COUNT_THRESHOLD) return getSubselectionDefaultOutlines.call(this, series);
                    var markerSeries = this.getGroupBoundingRect(series.dataPoints, this.currentViewport.scale, this.renderer.mainGraphicsContext), markerBoundingRect = marker.getBoundingClientRect(), height = Math.max(markerBoundingRect.height, MIN_OUTLINE_SIZE), width = Math.max(markerBoundingRect.width, MIN_OUTLINE_SIZE);
                    outlineFragments.push(getMarkerOutlinesForSeries([ markerSeries, {
                        x: markerBoundingRect.x,
                        y: markerBoundingRect.y,
                        height,
                        width
                    } ], series.identityKey, this.renderer.mainGraphicsContext, this.currentViewport, this.margin));
                }
            }
            return outlineFragments;
        }
        function getSubselectionDefaultOutlines(series) {
            var outlineFragments = [], mainGraphicsPositionOverlay = this.renderer.mainGraphicsContext, scale = this.currentViewport.scale, _a = mainGraphicsPositionOverlay.node().getBoundingClientRect(), screenLeft = _a.left, screenTop = _a.top, _b = mainGraphicsPositionOverlay.node().getBBox(), x0 = _b.x, y0 = _b.y, clipPath = {
                type: 1,
                x: screenLeft - x0,
                y: screenTop - y0,
                height: this.availableHeight * scale,
                width: this.availableWidth * scale
            }, outlines = series.dataPoints.map(function(point) {
                var size = Math.max(2 * point.geometry.size * scale, MIN_OUTLINE_SIZE);
                return {
                    x: (point.geometry.x - x0) * scale - size / 2 + screenLeft,
                    y: (point.geometry.y - y0) * scale - size / 2 + screenTop,
                    width: size,
                    height: size,
                    type: 1,
                    clipPath
                };
            });
            return outlineFragments.push({
                id: series.identityKey,
                outline: {
                    type: 0,
                    outlines
                }
            }), outlineFragments;
        }
        function getMarkerOutlinesForSeries(rectangles, identityKey, mainGraphicsContext, currentViewport, margin) {
            for (var _a = mainGraphicsContext.node().getBoundingClientRect(), screenLeft = _a.left, screenTop = _a.top, outlineRectangles = [], _b = mainGraphicsContext.node().getBBox(), scale = currentViewport.scale, clipPath = {
                type: 1,
                x: screenLeft - _b.x,
                y: screenTop - _b.y,
                height: (currentViewport.height - margin.top - margin.bottom) * scale,
                width: (currentViewport.width - margin.left - margin.right) * scale
            }, _i = 0, rectangles_1 = rectangles; _i < rectangles_1.length; _i++) {
                var point = rectangles_1[_i];
                outlineRectangles.push({
                    x: point.x,
                    y: point.y,
                    width: point.width,
                    height: point.height,
                    type: 1,
                    clipPath
                });
            }
            return {
                id: identityKey,
                outline: {
                    type: 0,
                    outlines: outlineRectangles
                }
            };
        }
        function onMarkerSubSelection(_a) {
            var _b, _c, element = _a.element, series = _a.series, subSelectionHelper = _a.subSelectionHelper, d3Event = _a.d3Event, hostServices = _a.hostServices, showUI = _a.showUI, selectorsByColumn = null === (_b = series.identity) || void 0 === _b ? void 0 : _b.getSelectorsByColumn(), displayName = hostServices.getLocalizedString("MiniToolbar_Markers", null !== (_c = series.name) && void 0 !== _c ? _c : hostServices.getLocalizedString("All")), visualSubSelection = subSelectionHelper.createVisualSubSelectionForSingleObject((0, 
            tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({
                objectName: "markers",
                subSelectionType: 3,
                displayName,
                showUI,
                selectorsByColumn,
                selectionOrigin: {
                    x: d3Event.clientX,
                    y: d3Event.clientY,
                    offset: {
                        x: 15,
                        y: 15
                    }
                }
            }, element ? {
                metadata: {
                    visualObject: element
                }
            } : {}));
            subSelectionHelper.subSelect(visualSubSelection);
        }
        function getSubSelectionShortcuts(subSelections) {
            var visualObject, selector, visualObjects = _.first(subSelections).visualObjects;
            if (visualObjects.length > 0) switch (visualObject = visualObjects[0], _.isEmpty(visualObject.selectorsByColumn) || (selector = (0, 
            _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.fd)((0, _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_5__.tV)(visualObject.selectorsByColumn))), 
            visualObject.objectName) {
              case "markers":
                return [ {
                    type: 0,
                    excludedResetFormattingIds: [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.show ]
                }, (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({
                    type: 2
                }, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.show), {
                    enabledLabel: this.localizer("Visual_Add_CategoryLabel")
                }), (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({
                    type: 3
                }, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.shape), {
                    label: this.localizer("Visual_MarkerShape"),
                    selector
                }), (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({
                    type: 3
                }, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.fillPoint.style), {
                    label: this.localizer("Visual_MarkerStyle"),
                    selector: void 0
                }), {
                    type: 1,
                    destinationInfo: (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({}, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.il.markers.shape), {
                        selector
                    }),
                    label: this.localizer("Format_Markers")
                } ];

              case "category-labels":
                var cardUid = "".concat("Visual", "-").concat("categoryLabels");
                return [ (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__assign)({
                    type: 2
                }, _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.show), {
                    disabledLabel: this.localizer("Delete"),
                    selector: void 0,
                    keyboardShortcuts: [ {
                        key: "Delete",
                        nextValue: !1
                    } ]
                }), {
                    type: 0,
                    relatedResetFormattingIds: [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.enableBackground ],
                    excludedResetFormattingIds: [ _Visuals_capabilities_scatterChart_capabilities__WEBPACK_IMPORTED_MODULE_1__.CS.categoryLabels.show ]
                }, {
                    type: 1,
                    destinationInfo: {
                        cardUid,
                        groupUid: "".concat("categoryLabels", "-").concat("values")
                    },
                    label: this.localizer("Format_Category_Labels")
                } ];

              default:
                return;
            }
        }
        function getSelectorsByColumnFromSubselectedElement(e) {
            var _a;
            switch (d3.select(e).attr(_Visuals_common_subSelectionHelper_htmlSubSelectionHelper__WEBPACK_IMPORTED_MODULE_16__.Ez)) {
              case "markers":
              case "category-labels":
                var markerDatum = d3.select(e).datum(), markerSeries = this.data.dataPointSeries[markerDatum.seriesIndex], selectorsByColumn = null === (_a = null == markerSeries ? void 0 : markerSeries.identity) || void 0 === _a ? void 0 : _a.getSelectorsByColumn();
                if (selectorsByColumn) return selectorsByColumn;
            }
        }
        function getDataViewObjectLayerChanges(propertySaveObjects, sourceType) {
            if (!this.featureSwitches.onObject || 1 !== sourceType) return [];
            var behaviorChangeObjects = [ _Visuals_common_dataViewObjectChangeHelper_dataViewObjectBehaviors_topLevelToggleBehavior__WEBPACK_IMPORTED_MODULE_17__.$.create({
                objectName: "categoryLabels",
                propertyName: "backgroundColor"
            }, this.data.dataLabelsSettings.enableBackground).onToggleEnabled(_Visuals_common_dataViewObjectChangeHelper_dataViewObjectChanges_addDataViewObjectChange__WEBPACK_IMPORTED_MODULE_18__.W.createBooleanDataViewObjectChange({
                objectName: "categoryLabels",
                propertyName: "enableBackground"
            }, !0)) ];
            return _Visuals_common_dataViewObjectChangeHelper_dataViewObjectChangeHelper__WEBPACK_IMPORTED_MODULE_19__.o.getDataViewObjectsBehaviorChanges(propertySaveObjects, behaviorChangeObjects);
        }
    },
    56914: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            WG: function() {
                return ScatterChartRenderer;
            },
            oz: function() {
                return ScatterTraceLineRenderer;
            }
        });
        var marker_renderer = __webpack_require__(51995), renderUtil = __webpack_require__(60066), strokeStyle = __webpack_require__(2241), htmlSubSelectionHelper = __webpack_require__(52287), interactivityService = __webpack_require__(72902), markerRangeType = __webpack_require__(90700), color = __webpack_require__(64067), CssConstants = __webpack_require__(79154), debug = __webpack_require__(62458), d3Helper = __webpack_require__(34644), browserUtils = __webpack_require__(59107), svgUtil = __webpack_require__(10389), playChart = __webpack_require__(67174), scatterChart_formatter = __webpack_require__(15458), plotAreaLassoManager = __webpack_require__(11745), Double = __webpack_require__(41640), markerShape = __webpack_require__(61193), shapes6 = __webpack_require__(80758), shapes7 = __webpack_require__(92379), ScatterChartHitTester = function() {
            function ScatterChartHitTester(options) {
                this.dataPoints = options.dataPoints, this.margin = options.margin;
            }
            return ScatterChartHitTester.prototype.queryRegion = function(rect) {
                var _this = this, boundingRect = (0, plotAreaLassoManager.g6)(rect, !1);
                return this.adjustPositionRelativeToRoot(boundingRect), _.filter(this.dataPoints, function(point) {
                    if (void 0 === point.marker.size) return _this.isPointInRect(boundingRect, point.geometry);
                    var result;
                    switch (point.geometry.markerShape) {
                      case markerShape.ZO.circle:
                        result = shapes7.m.circleRectangleOverlap(boundingRect, {
                            x: point.geometry.x,
                            y: point.geometry.y
                        }, point.geometry.size);
                        break;

                      case markerShape.ZO.square:
                        result = _this.isSquareMarkerIntersect(point.geometry, boundingRect);
                        break;

                      case markerShape.ZO.diamond:
                        result = _this.isDiamondMarkerIntersect(point.geometry, boundingRect);
                        break;

                      case markerShape.ZO.triangle:
                        result = _this.isTriangleMarkerIntersect(point.geometry, boundingRect);
                        break;

                      default:
                        debug.fF.assertFail("markers does not have this shape"), result = !1;
                    }
                    return result;
                });
            }, ScatterChartHitTester.prototype.isSquareMarkerIntersect = function(geometry, boundingRect) {
                var squareCoordinates = {
                    left: geometry.x - geometry.size,
                    right: geometry.x + geometry.size,
                    top: geometry.y - geometry.size,
                    bottom: geometry.y + geometry.size
                };
                return (0, shapes6.WN)(squareCoordinates.left, squareCoordinates.right, boundingRect.left, boundingRect.right) && (0, 
                shapes6.WN)(squareCoordinates.top, squareCoordinates.bottom, boundingRect.top, boundingRect.bottom);
            }, ScatterChartHitTester.prototype.isDiamondMarkerIntersect = function(geometry, boundingRect) {
                if (!this.isSquareMarkerIntersect(geometry, boundingRect)) return !1;
                if (this.isPointInRect(boundingRect, geometry)) return !0;
                for (var diamondPoints = [ {
                    x: geometry.x - geometry.size,
                    y: geometry.y
                }, {
                    x: geometry.x,
                    y: geometry.y - geometry.size
                }, {
                    x: geometry.x + geometry.size,
                    y: geometry.y
                }, {
                    x: geometry.x,
                    y: geometry.y + geometry.size
                } ], rectPoints = [ {
                    x: boundingRect.left,
                    y: boundingRect.top
                }, {
                    x: boundingRect.right,
                    y: boundingRect.top
                }, {
                    x: boundingRect.right,
                    y: boundingRect.bottom
                }, {
                    x: boundingRect.left,
                    y: boundingRect.bottom
                } ], rectSegments = [ [ rectPoints[0], rectPoints[1] ], [ rectPoints[1], rectPoints[2] ], [ rectPoints[3], rectPoints[2] ], [ rectPoints[0], rectPoints[3] ] ], _i = 0, diamondSegments_1 = [ [ diamondPoints[0], diamondPoints[1] ], [ diamondPoints[1], diamondPoints[2] ], [ diamondPoints[0], diamondPoints[3] ], [ diamondPoints[3], diamondPoints[2] ] ]; _i < diamondSegments_1.length; _i++) for (var diamondSegment = diamondSegments_1[_i], _a = 0, rectSegments_1 = rectSegments; _a < rectSegments_1.length; _a++) {
                    var rectSegment = rectSegments_1[_a];
                    if (shapes7.m.linesIntersect(diamondSegment[0], diamondSegment[1], rectSegment[0], rectSegment[1], !1)) return !0;
                }
                return this.isLassoInShape(geometry, boundingRect);
            }, ScatterChartHitTester.prototype.isPointInRect = function(boundingRect, geometry) {
                return (0, Double.bl)(boundingRect.left, geometry.x) && (0, Double.bl)(geometry.x, boundingRect.right) && (0, 
                Double.bl)(boundingRect.top, geometry.y) && (0, Double.bl)(geometry.y, boundingRect.bottom);
            }, ScatterChartHitTester.prototype.isLassoInShape = function(geometry, boundingRect) {
                var squareCoordinates = {
                    left: geometry.x - geometry.size,
                    right: geometry.x + geometry.size,
                    top: geometry.y - geometry.size,
                    bottom: geometry.y + geometry.size
                };
                return (0, shapes6.WN)(boundingRect.left, boundingRect.right, squareCoordinates.left, squareCoordinates.right) && (0, 
                shapes6.WN)(boundingRect.top, boundingRect.bottom, squareCoordinates.top, squareCoordinates.bottom);
            }, ScatterChartHitTester.prototype.isTriangleMarkerIntersect = function(geometry, boundingRect) {
                if (!this.isSquareMarkerIntersect(geometry, boundingRect)) return !1;
                if (this.isPointInRect(boundingRect, geometry)) return !0;
                for (var trianglePoints = [ {
                    x: geometry.x - geometry.size,
                    y: geometry.y + geometry.size
                }, {
                    x: geometry.x,
                    y: geometry.y - geometry.size
                }, {
                    x: geometry.x + geometry.size,
                    y: geometry.y + geometry.size
                } ], rectPoints = [ {
                    x: boundingRect.left,
                    y: boundingRect.top
                }, {
                    x: boundingRect.right,
                    y: boundingRect.top
                }, {
                    x: boundingRect.right,
                    y: boundingRect.bottom
                }, {
                    x: boundingRect.left,
                    y: boundingRect.bottom
                } ], rectSegments = [ [ rectPoints[0], rectPoints[1] ], [ rectPoints[1], rectPoints[2] ], [ rectPoints[3], rectPoints[2] ], [ rectPoints[0], rectPoints[3] ] ], _i = 0, triangleSegments_1 = [ [ trianglePoints[0], trianglePoints[1] ], [ trianglePoints[1], trianglePoints[2] ], [ trianglePoints[0], trianglePoints[2] ] ]; _i < triangleSegments_1.length; _i++) for (var triangleSegment = triangleSegments_1[_i], _a = 0, rectSegments_2 = rectSegments; _a < rectSegments_2.length; _a++) {
                    var rectSegment = rectSegments_2[_a];
                    if (shapes7.m.linesIntersect(triangleSegment[0], triangleSegment[1], rectSegment[0], rectSegment[1], !1)) return !0;
                }
                return this.isLassoInShape(geometry, boundingRect);
            }, ScatterChartHitTester.prototype.adjustPositionRelativeToRoot = function(rect) {
                rect.left -= this.margin.left, rect.top -= this.margin.top, rect.right -= this.margin.left, 
                rect.bottom -= this.margin.top;
            }, ScatterChartHitTester;
        }(), ScatterChartRenderer = function() {
            function ScatterChartRenderer(hostChart, eventManager) {
                var _this = this;
                this.hostChart = hostChart, this.eventManager = eventManager, this.mainGraphicsG = this.hostChart.svg.append("g").classed(ScatterChartRenderer.MainGraphicsContext.class, !0).call(function(mainGraphicsG) {
                    return hostChart.mobileTileInteractive && mainGraphicsG.append("rect").classed("backgroundRect", !0).attrs({
                        width: "100%",
                        height: "100%"
                    });
                }), this.mainGraphicsContext = this.mainGraphicsG.append("svg").attr("stroke-width", "1").call(function(mainGraphicsContext) {
                    return _this.hostChart.interactivityService && mainGraphicsContext.attrs({
                        tabindex: 0,
                        role: "listbox",
                        "aria-multiselectable": "true",
                        focusable: "true",
                        "aria-label": _this.hostChart.localizer("Visual_Plot")
                    }).classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge());
                });
            }
            return ScatterChartRenderer.prototype.markerShapesHaveChanged = function(viewModel) {
                var currentMarkers = _.map(viewModel.data.dataPointSeries, function(series) {
                    return series.marker.shape;
                }), previousMarkers = this.previousMarkers;
                if (previousMarkers) for (var i = 0, iLen = Math.min(currentMarkers.length, previousMarkers.length); i < iLen; i++) if (currentMarkers[i] !== previousMarkers[i]) return this.previousMarkers = currentMarkers, 
                !0;
                return this.previousMarkers = currentMarkers, !1;
            }, ScatterChartRenderer.calculateRadius = function(value, valueRange, plotArea, rangeType, multiplier) {
                var _a, _b;
                void 0 === multiplier && (multiplier = 1);
                var chartDimRatio = Math.min(plotArea.height, plotArea.width) / this.MarkerRefChartDim;
                if (null == value || null == valueRange) return multiplier * ScatterChartRenderer.MarkerRadiusDefault;
                if (rangeType === markerRangeType.Dl.deprecated) {
                    var chartAreaRatio = chartDimRatio * chartDimRatio, pixelAreaRange = {
                        min: this.MarkerRefChartMinPixels * chartAreaRatio,
                        max: this.MarkerRefChartMaxPixels * chartAreaRatio
                    }, valueRangeDelta_1 = (valueRange = {
                        min: Math.min(valueRange.min || 0, 0),
                        max: Math.max(valueRange.max || 0, 0)
                    }).max - valueRange.min, pixelAreaRangeDelta = pixelAreaRange.max - pixelAreaRange.min, valueRatio_1 = ((value = Math.min(Math.max(value, valueRange.min), valueRange.max)) - valueRange.min) / (valueRangeDelta_1 || 1);
                    return debug.fF.assert(function() {
                        return valueRatio_1 >= 0 && valueRatio_1 <= 1;
                    }, "valueRatio must be between 0 and 1"), multiplier * Math.sqrt((pixelAreaRange.min + valueRatio_1 * pixelAreaRangeDelta) / Math.PI);
                }
                rangeType === markerRangeType.Dl.auto && (rangeType = valueRange.min >= 0 || valueRange.max <= 0 ? markerRangeType.Dl.magnitude : markerRangeType.Dl.dataRange), 
                rangeType === markerRangeType.Dl.magnitude && (value && (value = Math.abs(value)), 
                valueRange = {
                    min: 0,
                    max: Math.max(null !== (_a = Math.abs(valueRange.max)) && void 0 !== _a ? _a : 0, null !== (_b = Math.abs(valueRange.min)) && void 0 !== _b ? _b : 0)
                });
                var valueRatio = ((value = Math.min(Math.max(value, valueRange.min), valueRange.max)) - valueRange.min) / (valueRange.max - valueRange.min || 1);
                return debug.fF.assert(function() {
                    return valueRatio >= 0 && valueRatio <= 1;
                }, "valueRatio must be between 0 and 1"), multiplier * ((ScatterChartRenderer.MarkerRadiusMax - ScatterChartRenderer.MarkerRadiusMin) * Math.sqrt(valueRatio) + ScatterChartRenderer.MarkerRadiusMin) * chartDimRatio;
            }, ScatterChartRenderer.prototype.render = function(viewModel, interactivityService, hostServices, formatMode) {
                var scatterMarkers, plotArea = viewModel.plotArea;
                if (this.mainGraphicsContext.attrs({
                    width: plotArea.width,
                    height: plotArea.height
                }).classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge() && !!interactivityService), 
                this.drawRatioLine(viewModel), this.drawShadedBackground(viewModel), viewModel.suppressDataPointRendering) this.mainGraphicsContext.selectAll(ScatterChartRenderer.MarkerSeriesGroupCS.selector).remove(), 
                scatterMarkers = this.mainGraphicsContext.selectAll(ScatterChartRenderer.MarkerCS.selector); else {
                    var xOffset_1 = ScatterChartRenderer.getXOfFirstCategory(viewModel), animate_1 = !this.markerShapesHaveChanged(viewModel) && viewModel.animation.duration > 0, groupPoints_1 = viewModel.drawBubbles || animate_1;
                    scatterMarkers = this.mainGraphicsContext.selectAll(ScatterChartRenderer.MarkerSeriesGroupCS.selector).data(groupPoints_1 ? [ {
                        identityKey: "",
                        dataPoints: viewModel.data.dataPoints,
                        marker: {
                            show: !0,
                            color: void 0,
                            shape: void 0
                        }
                    } ] : viewModel.data.dataPointSeries, function(s) {
                        return s.identityKey;
                    }).join(function(enter) {
                        return enter.append("g").classed(ScatterChartRenderer.MarkerSeriesGroupCS.class, !0).attr("role", "group");
                    }).styles(function(s) {
                        return groupPoints_1 ? {} : {
                            "stroke-opacity": ScatterChartRenderer.getMarkerStrokeOpacity(!!viewModel.data.size, viewModel.data.colorBorder, viewModel.hasSelection, !1),
                            fill: s.marker.color,
                            "fill-opacity": ScatterChartRenderer.getMarkerFillOpacity(!!viewModel.data.size, viewModel.fillMarkers, viewModel.hasSelection, !1)
                        };
                    }).selectAll(ScatterChartRenderer.MarkerCS.selector).data(function(s) {
                        return s.dataPoints;
                    }, function(d) {
                        return d.renderIdentity.getKey();
                    }).join(function(enter) {
                        var _a;
                        return enter.append("path").classed(ScatterChartRenderer.MarkerCS.class, !0).classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge() && !!interactivityService).classed(htmlSubSelectionHelper.cy, !0).attrs((_a = {}, 
                        _a[htmlSubSelectionHelper.Ez] = "markers", _a[htmlSubSelectionHelper.QZ] = 3, _a.transform = function(d) {
                            var xTranslate = viewModel.xAxisProperties.scale(viewModel.hasCategoricalAxis ? d.categoryIndex : d.x) + xOffset_1, yTranslate = viewModel.yAxisProperties.scale(d.y);
                            return "translate(".concat(xTranslate, ",").concat(yTranslate, ")");
                        }, _a.tabindex = interactivityService ? 0 : null, _a.focusable = !!interactivityService || null, 
                        _a.role = "option", _a)).style("opacity", 0);
                    }, function(update) {
                        return animate_1 ? update : update.interrupt();
                    }, function(exit) {
                        return (animate_1 ? exit.transition().ease(viewModel.animation.ease).duration(viewModel.animation.duration).style("opacity", 0).attr("r", 0) : exit).remove();
                    }).attrs(function(d) {
                        return ScatterChartRenderer.updateMarkerGeometry(d, viewModel, xOffset_1), {
                            d: (0, marker_renderer.jM)(d.marker.shape, d.geometry.size),
                            transform: "translate(".concat(d.geometry.x, ",").concat(d.geometry.y, ")"),
                            "aria-selected": d.selected
                        };
                    }).styles({
                        "stroke-opacity": function(d) {
                            return ScatterChartRenderer.getMarkerStrokeOpacity(null != d.marker.size, viewModel.data.colorBorder, viewModel.hasSelection, d.selected);
                        },
                        stroke: function(d) {
                            return ScatterChartRenderer.getMarkerStrokeFill(d.marker, viewModel.data.colorBorder);
                        },
                        fill: function(d, i, nodes) {
                            var seriesData = d3.select(nodes[i].parentElement).datum();
                            return groupPoints_1 || seriesData.marker.color !== d.marker.color ? d.marker.color : null;
                        },
                        "fill-opacity": function(d) {
                            return ScatterChartRenderer.getMarkerFillOpacity(null != d.marker.size, viewModel.fillMarkers, viewModel.hasSelection, d.selected);
                        },
                        opacity: animate_1 ? void 0 : null
                    }).call(function(selection) {
                        return (animate_1 ? selection.transition().ease(viewModel.animation.ease).duration(viewModel.animation.duration) : selection).style("opacity", 1);
                    }).each(function(d, index, markerPaths) {
                        var _a, _b;
                        if (formatMode) {
                            var displayName = hostServices.getLocalizedString("MiniToolbar_Markers", null !== (_b = null === (_a = viewModel.data.dataPointSeries[d.seriesIndex]) || void 0 === _a ? void 0 : _a.name) && void 0 !== _b ? _b : hostServices.getLocalizedString("All"));
                            htmlSubSelectionHelper.O5.setDataForElement(markerPaths[index], {
                                getDisplayName: function() {
                                    return displayName;
                                }
                            });
                        }
                    });
                }
                return this.hostChart.tooltipsEnabled && this.hostChart.tooltipService.addTooltip(this.mainGraphicsContext, function(args) {
                    var _a;
                    return null === (_a = args.data) || void 0 === _a ? void 0 : _a.tooltipInfo();
                }, function(args) {
                    var _a;
                    return (null === (_a = args.data) || void 0 === _a ? void 0 : _a.identity) && [ args.data.identity ];
                }), (0, svgUtil.bL)(viewModel.animationOptions), debug.fF.assert(function() {
                    return null != viewModel.data.dataPointSeries;
                }, "dataPointSeries must be defined"), this.numSeries = viewModel.data.dataPointSeries.length, 
                this.scatterChartDataPoints = viewModel.allData.dataPoints, {
                    dataPointsSelection: scatterMarkers,
                    eventGroup: this.mainGraphicsG,
                    data: viewModel.data,
                    fillMarkers: viewModel.fillMarkers,
                    root: this.mainGraphicsContext,
                    visualInstanceId: hostServices.instanceId,
                    eventManager: this.eventManager,
                    onMarkerSubSelection: function(element, point, subSelectionHelper, d3Event, showUI) {
                        (0, scatterChart_formatter.ke)({
                            element,
                            series: viewModel.allData.dataPointSeries[point.seriesIndex],
                            subSelectionHelper,
                            d3Event,
                            hostServices,
                            showUI
                        });
                    },
                    hitTester: new ScatterChartHitTester({
                        dataPoints: viewModel.data.dataPoints,
                        margin: viewModel.margin
                    })
                };
            }, ScatterChartRenderer.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var _a, _b, currentGroupPointData, indexModifier, points = this.mainGraphicsContext.selectAll(ScatterChartRenderer.MarkerCS.selector), pointData = this.scatterChartDataPoints, nextCategory = categoryIndex, nextSeries = seriesIndex;
                switch (direction) {
                  case interactivityService.x0.PreviousCategory:
                  case interactivityService.x0.NextCategory:
                    indexModifier = direction === interactivityService.x0.PreviousCategory ? -1 : 1, 
                    currentGroupPointData = _.sortBy(_.filter(pointData, function(point) {
                        return point.seriesIndex === seriesIndex;
                    }), "categoryIndex");
                    var indexNextCategory = indexModifier + _.findIndex(currentGroupPointData, function(point) {
                        return point.categoryIndex === categoryIndex;
                    });
                    indexNextCategory >= currentGroupPointData.length || indexNextCategory < 0 ? (_a = this.rollToNextSeries(pointData, seriesIndex, direction), 
                    nextCategory = _a[0], nextSeries = _a[1]) : nextCategory = currentGroupPointData[indexNextCategory].categoryIndex;
                    break;

                  case interactivityService.x0.PreviousSeries:
                  case interactivityService.x0.NextSeries:
                    indexModifier = direction === interactivityService.x0.PreviousSeries ? -1 : 1, currentGroupPointData = _.sortBy(_.filter(pointData, function(point) {
                        return point.categoryIndex === categoryIndex;
                    }), "seriesIndex");
                    var indexNextSeries = indexModifier + _.findIndex(currentGroupPointData, function(point) {
                        return point.seriesIndex === seriesIndex;
                    });
                    indexNextSeries >= currentGroupPointData.length || indexNextSeries < 0 ? (_b = this.rollToNextCategory(pointData, categoryIndex, direction), 
                    nextCategory = _b[0], nextSeries = _b[1]) : nextSeries = currentGroupPointData[indexNextSeries].seriesIndex;
                }
                return {
                    element: points.filter(function(d) {
                        return d.seriesIndex === nextSeries && d.categoryIndex === nextCategory;
                    }).node(),
                    targetCategoryIndex: nextCategory
                };
            }, ScatterChartRenderer.prototype.rollToNextSeries = function(pointData, seriesIndex, direction) {
                debug.fF.assert(function() {
                    return direction === interactivityService.x0.PreviousCategory || direction === interactivityService.x0.NextCategory;
                }, "expected a direction having to do with category");
                for (var nextSeriesPoints, indexModifier = direction === interactivityService.x0.PreviousCategory ? -1 : 1, findFunc = direction === interactivityService.x0.PreviousCategory ? _.last : _.first; _.isEmpty(nextSeriesPoints); ) (seriesIndex += indexModifier) >= this.numSeries ? seriesIndex = 0 : seriesIndex < 0 && (seriesIndex = this.numSeries - 1), 
                nextSeriesPoints = _.sortBy(_.filter(pointData, function(point) {
                    return point.seriesIndex === seriesIndex;
                }), function(d) {
                    return d.categoryIndex;
                });
                return [ findFunc(nextSeriesPoints).categoryIndex, seriesIndex ];
            }, ScatterChartRenderer.prototype.rollToNextCategory = function(pointData, categoryIndex, direction) {
                debug.fF.assert(function() {
                    return direction === interactivityService.x0.PreviousSeries || direction === interactivityService.x0.NextSeries;
                }, "expected a direction having to do with series");
                for (var nextCategoryPoints, numCategories = d3.max(pointData, function(datum) {
                    return datum.categoryIndex;
                }) + 1, indexModifier = direction === interactivityService.x0.PreviousSeries ? -1 : 1, findFunc = direction === interactivityService.x0.PreviousSeries ? _.last : _.first; _.isEmpty(nextCategoryPoints); ) (categoryIndex += indexModifier) >= numCategories ? categoryIndex = 0 : categoryIndex < 0 && (categoryIndex = numCategories - 1), 
                nextCategoryPoints = _.sortBy(_.filter(pointData, function(point) {
                    return point.categoryIndex === categoryIndex;
                }), function(d) {
                    return d.seriesIndex;
                });
                var seriesIndex = findFunc(nextCategoryPoints).seriesIndex;
                return [ categoryIndex, seriesIndex ];
            }, ScatterChartRenderer.prototype.getFirstElement = function() {
                return {
                    element: this.mainGraphicsContext.selectAll(ScatterChartRenderer.MarkerCS.selector).node()
                };
            }, ScatterChartRenderer.prototype.drawShadedBackground = function(viewModel) {
                var settings = viewModel.data.plotAreaShadingSettings, hasSymmetryShading = settings.show && viewModel.supportsPlotAreaSymmetryShading, layer = this.hostChart.svg.selectAll(ScatterChartRenderer.PlotAreaShadingLayerCS.selector).data(hasSymmetryShading ? [ 1 ] : []).join(function(enter) {
                    return enter.insert("svg", ":first-child").classed(ScatterChartRenderer.PlotAreaShadingLayerCS.class, !0).style("pointer-events", "none");
                }).attrs({
                    height: viewModel.plotArea.height,
                    width: viewModel.plotArea.width
                });
                if (hasSymmetryShading) {
                    var xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, xDomain = xScale.domain(), yDomain = yScale.domain(), domain = [ Math.min(xDomain[0], yDomain[0]), Math.max(xDomain[1], yDomain[1]) ], lineData = [ {
                        x: xScale(domain[0]),
                        y: yScale(domain[0])
                    }, {
                        x: xScale(domain[1]),
                        y: yScale(domain[1])
                    } ];
                    this.drawArea(ScatterChartRenderer.UpperShadingAreaCS, layer, settings.show ? [ [ {
                        x: lineData[0].x,
                        y: lineData[0].y
                    }, {
                        x: lineData[0].x,
                        y: lineData[1].y
                    } ], [ {
                        x: lineData[1].x,
                        y: lineData[1].y
                    }, {
                        x: lineData[1].x,
                        y: lineData[1].y
                    } ] ] : [], settings.upperShadingColor, settings.transparency), this.drawArea(ScatterChartRenderer.LowerShadingAreaCS, layer, settings.show ? [ [ {
                        x: lineData[0].x,
                        y: lineData[0].y
                    }, {
                        x: lineData[0].x,
                        y: lineData[0].y
                    } ], [ {
                        x: lineData[1].x,
                        y: lineData[0].y
                    }, {
                        x: lineData[1].x,
                        y: lineData[1].y
                    } ] ] : [], settings.lowerShadingColor, settings.transparency);
                }
            }, ScatterChartRenderer.prototype.drawRatioLine = function(viewModel) {
                var settings = viewModel.data.ratioLineSettings, layer = this.hostChart.svg.selectAll(ScatterChartRenderer.RatioLineLayerCS.selector).data((null == settings ? void 0 : settings.strokeShow) ? [ 1 ] : []).join(function(enter) {
                    return enter.append("svg").classed(ScatterChartRenderer.RatioLineLayerCS.class, !0);
                }).attrs({
                    height: viewModel.plotArea.height,
                    width: viewModel.plotArea.width
                });
                if (null == settings ? void 0 : settings.strokeShow) {
                    var xScale = viewModel.xAxisProperties.scale, yScale = viewModel.yAxisProperties.scale, xDomain = xScale.domain(), yDomain = yScale.domain(), xTotal = viewModel.data.xSubtotal, yTotal = viewModel.data.ySubtotal, data = [];
                    if (_.isFinite(xTotal) && _.isFinite(yTotal)) if (0 !== xTotal && 0 !== yTotal) {
                        var incline = yTotal / xTotal;
                        data = [ {
                            x: xScale(xDomain[0]),
                            y: yScale(xDomain[0] * incline)
                        }, {
                            x: xScale(xDomain[1]),
                            y: yScale(xDomain[1] * incline)
                        } ];
                    } else 0 !== yTotal ? data = [ {
                        x: xScale(0),
                        y: yScale(yDomain[0])
                    }, {
                        x: xScale(0),
                        y: yScale(yDomain[1])
                    } ] : 0 !== xTotal && (data = [ {
                        x: xScale(xDomain[0]),
                        y: yScale(0)
                    }, {
                        x: xScale(xDomain[1]),
                        y: yScale(0)
                    } ]);
                    var pathGen = d3.line().x(function(point) {
                        return point.x;
                    }).y(function(point) {
                        return point.y;
                    });
                    layer.selectAll(ScatterChartRenderer.RatioLineCS.selector).data([ data ]).join(function(enter) {
                        return enter.append("path").classed(ScatterChartRenderer.RatioLineCS.class, !0);
                    }).attr("d", function(d) {
                        return pathGen(d);
                    }).style("fill", "none").styles((0, strokeStyle.bc)(settings));
                }
            }, ScatterChartRenderer.getXOfFirstCategory = function(viewModel) {
                if (viewModel.hasCategoricalAxis) {
                    var xScale = viewModel.xAxisProperties.scale;
                    if ((0, d3Helper._9)(xScale)) return xScale.bandwidth() / 2;
                }
                return 0;
            }, ScatterChartRenderer.getMarkerFillOpacity = function(hasSize, shouldEnableFill, hasSelection, isSelected) {
                return hasSize || shouldEnableFill ? hasSelection && !isSelected ? .4 : .85 : 0;
            }, ScatterChartRenderer.getMarkerStrokeOpacity = function(hasSize, colorBorder, hasSelection, isSelected) {
                return hasSize && colorBorder ? 1 : hasSelection && !isSelected ? .4 : .85;
            }, ScatterChartRenderer.getMarkerStrokeFill = function(marker, colorBorder) {
                if (null != marker.size && colorBorder) {
                    var colorRgb = (0, color.WV)(marker.color);
                    return colorRgb ? (0, color.Bx)((0, color._j)(colorRgb, 63.75)) : marker.color;
                }
                return marker.color;
            }, ScatterChartRenderer.updateMarkerGeometry = function(d, viewModel, xOffset) {
                d.geometry = {
                    size: ScatterChartRenderer.calculateRadius(d.radius, viewModel.data.sizeRange, viewModel.plotArea, viewModel.data.marker.rangeType, viewModel.data.marker.multiplier),
                    markerShape: viewModel.data.marker.shape,
                    x: viewModel.xAxisProperties.scale(viewModel.hasCategoricalAxis ? d.categoryIndex : d.x) + xOffset,
                    y: viewModel.yAxisProperties.scale(d.y)
                };
            }, ScatterChartRenderer.prototype.drawArea = function(areaClassAndSelector, layer, data, fill, transparency) {
                var pathGen = d3.area().x0(function(point) {
                    return point[0].x;
                }).y0(function(point) {
                    return point[0].y;
                }).x1(function(point) {
                    return point[1].x;
                }).y1(function(point) {
                    return point[1].y;
                });
                layer.selectAll(areaClassAndSelector.selector).data([ data ]).join(function(enter) {
                    return enter.append("path").classed(areaClassAndSelector.class, !0);
                }).attr("d", function(d) {
                    return pathGen(d);
                }).styles({
                    fill: fill.solid.color,
                    "fill-opacity": (0, color.TD)(transparency)
                });
            }, ScatterChartRenderer.MarkerCS = (0, CssConstants.CH)("scatterMarker"), ScatterChartRenderer.MainGraphicsContext = (0, 
            CssConstants.CH)("mainGraphicsContext"), ScatterChartRenderer.MarkerSeriesGroupCS = (0, 
            CssConstants.CH)("scatterMarkerSeriesGroup"), ScatterChartRenderer.PlotAreaShadingLayerCS = (0, 
            CssConstants.CH)("plotAreaShadingLayer"), ScatterChartRenderer.UpperShadingAreaCS = (0, 
            CssConstants.CH)("upperShadingArea"), ScatterChartRenderer.LowerShadingAreaCS = (0, 
            CssConstants.CH)("lowerShadingArea"), ScatterChartRenderer.RatioLineLayerCS = (0, 
            CssConstants.CH)("ratioLineLayer"), ScatterChartRenderer.RatioLineCS = (0, CssConstants.CH)("ratioLine"), 
            ScatterChartRenderer.MarkerRefChartDim = 300, ScatterChartRenderer.MarkerRefChartMinPixels = 4, 
            ScatterChartRenderer.MarkerRefChartMaxPixels = 3e3, ScatterChartRenderer.MarkerRadiusDefault = 6, 
            ScatterChartRenderer.MarkerRadiusMax = 30, ScatterChartRenderer.MarkerRadiusMin = 2, 
            ScatterChartRenderer;
        }(), ScatterTraceLineRenderer = function() {
            function ScatterTraceLineRenderer(viewModel, hostChart) {
                this.viewModel = viewModel, this.hostChart = hostChart;
            }
            return ScatterTraceLineRenderer.prototype.remove = function() {
                this.hostChart.svg.selectAll(ScatterTraceLineRenderer.TraceLineCS.selector).remove(), 
                this.hostChart.svg.selectAll(ScatterTraceLineRenderer.TraceBubbleCS.selector).remove();
            }, ScatterTraceLineRenderer.prototype.render = function(selectedPoints, shouldAnimate) {
                var viewModel = this.viewModel, scatterViewModel = viewModel.viewModel, seriesPoints = [];
                if (_.isEmpty(selectedPoints) || scatterViewModel.suppressDataPointRendering) this.remove(); else {
                    for (var currentFrameIndex = viewModel.data.currentFrameIndex, hasBubbleAtCurrentFrame = [], selectedIndex = 0, selectedLen = selectedPoints.length; selectedIndex < selectedLen; selectedIndex++) {
                        seriesPoints[selectedIndex] = [], hasBubbleAtCurrentFrame[selectedIndex] = !1;
                        for (var frameIndex = 0, frameLen = viewModel.data.allChartData.length; frameIndex < frameLen && frameIndex <= currentFrameIndex; frameIndex++) {
                            var value = _.find(viewModel.data.allChartData[frameIndex].dataPoints, function(dataPoint) {
                                var selectedScatterDataPoint = selectedPoints[selectedIndex];
                                return selectedScatterDataPoint.renderIdentity ? dataPoint.renderIdentity.getKey() === selectedScatterDataPoint.renderIdentity.getKey() : dataPoint.identity.getKey() === selectedPoints[selectedIndex].identity.getKey();
                            });
                            null != value && (value.frameIndex = frameIndex, seriesPoints[selectedIndex].push(value), 
                            frameIndex === currentFrameIndex && (hasBubbleAtCurrentFrame[selectedIndex] = !0));
                        }
                    }
                    var xScale = scatterViewModel.xAxisProperties.scale, yScale = scatterViewModel.yAxisProperties.scale, line = d3.line().x(function(d) {
                        return xScale(d.x);
                    }).y(function(d) {
                        return yScale(d.y);
                    }).defined(function(d) {
                        return null !== d.x && null !== d.y;
                    }), previousLengths = [], newLengths = [], reverse = !1, traceLinesUpdate = this.hostChart.svg.selectAll(ScatterTraceLineRenderer.TraceLineCS.selector).data(selectedPoints, function(sp) {
                        return sp.renderIdentity.getKey();
                    }).join(function(enter) {
                        return enter.append("path").classed(ScatterTraceLineRenderer.TraceLineCS.class, !0);
                    }).each(function(_d, i, pathNodes) {
                        var existingPath = pathNodes[i], previousLength = existingPath.hasAttribute("d") ? existingPath.getTotalLength() : 0;
                        previousLengths.push(previousLength);
                        var tempSvgPath = $("<svg><path></path></svg>"), tempPath = $("path", tempSvgPath);
                        tempPath.attr("d", line(seriesPoints[i]));
                        var newLength = seriesPoints[i].length > 0 ? tempPath.get()[0].getTotalLength() : 0;
                        newLengths.push(newLength), reverse || (reverse = newLength < previousLength);
                    });
                    reverse ? shouldAnimate ? traceLinesUpdate.transition().ease(playChart.Je.ease).duration(playChart.Je.duration).attr("stroke-dashoffset", function(_d, i) {
                        return previousLengths[i] - newLengths[i];
                    }).transition().ease(playChart.Je.ease).duration(1).delay(0).style("stroke", function(d) {
                        return ScatterChartRenderer.getMarkerStrokeFill(d.marker, !0);
                    }).attrs({
                        d: function(_d, i) {
                            return line(seriesPoints[i]);
                        },
                        "stroke-dasharray": function(_d, i) {
                            return "".concat(newLengths[i], " ").concat(newLengths[i]);
                        },
                        "stroke-dashoffset": 0
                    }) : traceLinesUpdate.style("stroke", function(d) {
                        return ScatterChartRenderer.getMarkerStrokeFill(d.marker, !0);
                    }).attrs({
                        d: function(_d, i) {
                            return line(seriesPoints[i]);
                        },
                        "stroke-dasharray": function(_d, i) {
                            return "".concat(newLengths[i], " ").concat(newLengths[i]);
                        },
                        "stroke-dashoffset": 0
                    }) : traceLinesUpdate.style("stroke", function(d) {
                        return ScatterChartRenderer.getMarkerStrokeFill(d.marker, !0);
                    }).attrs({
                        d: function(_d, i) {
                            return line(seriesPoints[i]);
                        },
                        "stroke-dasharray": function(_d, i) {
                            return "".concat(newLengths[i], " ").concat(newLengths[i]);
                        },
                        "stroke-dashoffset": function(_d, i) {
                            return newLengths[i] - previousLengths[i];
                        }
                    }).call(function(update) {
                        return shouldAnimate ? update.transition().ease(playChart.Je.ease).duration(playChart.Je.duration) : update;
                    }).attr("stroke-dashoffset", 0);
                    for (var shapePoints = [], index = 0; index < seriesPoints.length; index++) {
                        var points = seriesPoints[index], newPoints = hasBubbleAtCurrentFrame[index] ? points.slice(0, points.length - 1) : points;
                        shapePoints = shapePoints.concat(newPoints);
                    }
                    var xOffset = ScatterChartRenderer.getXOfFirstCategory(scatterViewModel), shapesUpdate = this.hostChart.svg.selectAll(ScatterTraceLineRenderer.TraceBubbleCS.selector).data(shapePoints.sort(function(d1, d2) {
                        return d2.marker.size - d1.marker.size;
                    }), function(d) {
                        return d.renderIdentity.getKey() + d.x + d.y + d.marker.size;
                    }).join(function(enter) {
                        return enter.append("path").classed(ScatterTraceLineRenderer.TraceBubbleCS.class, !0).style("opacity", 0);
                    }, function(update) {
                        return update;
                    }, function(exit) {
                        return exit.transition().ease(playChart.Je.ease).duration(playChart.Je.duration).style("opacity", 0).remove();
                    }).attrs(function(d) {
                        return ScatterChartRenderer.updateMarkerGeometry(d, scatterViewModel, xOffset), 
                        {
                            d: (0, marker_renderer.jM)(d.marker.shape, d.geometry.size),
                            transform: "translate(".concat(d.geometry.x, ",").concat(d.geometry.y, ")")
                        };
                    }).styles({
                        "stroke-opacity": function(d) {
                            return d.selected ? .85 : .4;
                        },
                        stroke: function(d) {
                            return ScatterChartRenderer.getMarkerStrokeFill(d.marker, viewModel.data.chartData.colorBorder);
                        },
                        fill: function(d) {
                            return d.marker.color;
                        },
                        "fill-opacity": function(d) {
                            return null != d.marker.size ? .2 + d.frameIndex / currentFrameIndex * .6 : 0;
                        }
                    }).call(function(update) {
                        return update.transition().ease(playChart.Je.ease).duration(playChart.Je.duration).style("opacity", 1);
                    });
                    this.hostChart.tooltipsEnabled && this.hostChart.tooltipService.addTooltip(shapesUpdate, function(args) {
                        var _a;
                        return null === (_a = args.data) || void 0 === _a ? void 0 : _a.tooltipInfo();
                    }, function(args) {
                        var _a;
                        return (null === (_a = args.data) || void 0 === _a ? void 0 : _a.identity) && [ args.data.identity ];
                    });
                }
            }, ScatterTraceLineRenderer.TraceLineCS = (0, CssConstants.CH)("traceLine"), ScatterTraceLineRenderer.TraceBubbleCS = (0, 
            CssConstants.CH)("traceBubble"), ScatterTraceLineRenderer;
        }();
    },
    58778: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            B: function() {
                return BubblingEventManager;
            }
        });
        var _debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62458), _Utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38078), listenersKey = "BubblingEventListeners", managerKey = "BubblingEventManager", BubblingEventManager = function() {
            function BubblingEventManager(root) {
                this.root = root, this.registeredBubblingEvents = {}, this.registeredCapturedEvents = {}, 
                this.rootNode = root.node(), (0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(this.rootNode, managerKey, this);
            }
            return BubblingEventManager.prototype.ensureEventRegistered = function(eventType, capture) {
                var _this = this, registeredEvents = capture ? this.registeredCapturedEvents : this.registeredBubblingEvents;
                if (!registeredEvents[eventType]) {
                    registeredEvents[eventType] = !0;
                    var handler = capture ? handleCapturedEvent : handleBubblingEvent, eventName = "".concat(eventType, ".").concat(managerKey);
                    capture && (eventName += "Capture"), this.root.on(eventName, function() {
                        handler(_this.root);
                    }, capture);
                }
            }, BubblingEventManager.prototype.on = function(element, eventName, listener, capture) {
                var eventType = function(eventName) {
                    var dot = eventName.indexOf(".");
                    return -1 === dot ? eventName : eventName.substr(0, dot);
                }(eventName);
                this.ensureEventRegistered(eventType, !!capture);
                var listeners = getListeners(element, !0);
                if (listeners) {
                    var typeListeners = listeners[eventType];
                    typeListeners || (listeners[eventType] = typeListeners = {
                        bubbling: {},
                        captured: {}
                    }), (capture ? typeListeners.captured : typeListeners.bubbling)[eventName] = listener;
                }
            }, BubblingEventManager;
        }();
        function getListeners(element, create) {
            var listeners = (0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(element, listenersKey);
            if (!listeners) {
                if (!create) return;
                (0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(element, listenersKey, listeners = {});
            }
            return listeners;
        }
        function dispatch(eventListeners) {
            for (var eventName in eventListeners) {
                var eventListener = eventListeners[eventName];
                eventListener && eventListener();
            }
        }
        function visitListeners(root, visit) {
            for (var rootNode = root.node(), event = d3.event, target = event.target; target; ) {
                var listeners = getListeners(target, !1);
                if (listeners) {
                    var typeListeners = listeners[event.type];
                    typeListeners && visit(typeListeners);
                }
                if (target === rootNode) break;
                _debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return !(0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(target, managerKey);
                }, "BubblingEventManagers cannot overlap"), target = target.parentElement;
            }
        }
        function handleCapturedEvent(root) {
            var captureListeners = [];
            visitListeners(root, function(listeners) {
                var captured = listeners.captured;
                captured && captureListeners.push(captured);
            });
            for (var i = captureListeners.length; i-- > 0; ) dispatch(captureListeners[i]);
        }
        function handleBubblingEvent(root) {
            visitListeners(root, function(listeners) {
                var bubbling = listeners.bubbling;
                bubbling && dispatch(bubbling);
            });
        }
    },
    60810: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            G: function() {
                return LoadMoreDataStatus;
            },
            J: function() {
                return SimpleLoadMoreDataHandler;
            }
        });
        var LoadMoreDataStatus = function(LoadMoreDataStatus) {
            return LoadMoreDataStatus[LoadMoreDataStatus.NoOperation = 0] = "NoOperation", LoadMoreDataStatus[LoadMoreDataStatus.WaitingForData = 1] = "WaitingForData", 
            LoadMoreDataStatus[LoadMoreDataStatus.TriggeredLoadMore = 2] = "TriggeredLoadMore", 
            LoadMoreDataStatus;
        }({}), SimpleLoadMoreDataHandler = function() {
            function SimpleLoadMoreDataHandler(hostServices) {
                this.hostServices = hostServices, this.waitingForData = !1;
            }
            return SimpleLoadMoreDataHandler.prototype.shouldLoadMoreData = function() {
                return this.shouldLoadMoreDataInternal() === LoadMoreDataStatus.TriggeredLoadMore;
            }, SimpleLoadMoreDataHandler.prototype.isLoadingMoreData = function() {
                return this.waitingForData;
            }, SimpleLoadMoreDataHandler.prototype.updateDataView = function(dataView) {
                this.dataView = dataView;
            }, SimpleLoadMoreDataHandler.prototype.loadMoreData = function() {
                var status = this.shouldLoadMoreDataInternal();
                return status === LoadMoreDataStatus.TriggeredLoadMore && (this.hostServices.loadMoreData(), 
                this.waitingForData = !0), status;
            }, SimpleLoadMoreDataHandler.prototype.onLoadMoreDataCompleted = function() {
                this.waitingForData = !1;
            }, SimpleLoadMoreDataHandler.prototype.shouldLoadMoreDataInternal = function() {
                if (!this.dataView) return LoadMoreDataStatus.NoOperation;
                var dataViewMetadata = this.dataView.metadata;
                return this.waitingForData ? LoadMoreDataStatus.WaitingForData : dataViewMetadata && dataViewMetadata.segment ? LoadMoreDataStatus.TriggeredLoadMore : LoadMoreDataStatus.NoOperation;
            }, SimpleLoadMoreDataHandler;
        }();
    },
    81551: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            E: function() {
                return Point;
            }
        });
        var Point = function() {
            return function(x, y) {
                this.x = x || 0, this.y = y || 0;
            };
        }();
    },
    34644: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            Ad: function() {
                return easeCompat;
            },
            LL: function() {
                return orderShapesByClass;
            },
            _9: function() {
                return isScaleBand;
            }
        });
        var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62458);
        function easeCompat(easeString) {
            switch (easeString) {
              case "linear":
                return d3.easeLinear;

              case "cubic-in-out":
                return d3.easeCubicInOut;

              case "cubic-out":
                return d3.easeCubicOut;

              case "back":
                return d3.easeBack;

              default:
                _debug__WEBPACK_IMPORTED_MODULE_0__.fF.assertNever(easeString);
            }
            return d3.easeCubicInOut;
        }
        function isScaleBand(scale) {
            return !!scale.bandwidth;
        }
        function orderShapesByClass(context, renderOrder) {
            var renderOrderableElements = context.selectAll(_.map(renderOrder, function(r) {
                return r.selector;
            }).join(", ")).nodes();
            renderOrderableElements.sort(function(a, b) {
                for (var result = 0, i = 0; i < renderOrder.length; i++) result += +d3.select(a).classed(renderOrder[i].class) * i, 
                result -= +d3.select(b).classed(renderOrder[i].class) * i;
                return result;
            }), d3.selectAll(renderOrderableElements).order();
        }
    }
} ]);