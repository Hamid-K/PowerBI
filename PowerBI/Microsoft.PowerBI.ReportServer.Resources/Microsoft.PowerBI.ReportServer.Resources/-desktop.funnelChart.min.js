"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "funnelChart" ], {
    10182: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            FunnelChart: function() {
                return FunnelChart;
            },
            FunnelWebBehavior: function() {
                return FunnelWebBehavior;
            },
            WebFunnelAnimator: function() {
                return WebFunnelAnimator;
            }
        });
        var tslib_es6 = __webpack_require__(81337), addDataViewObjectChange = __webpack_require__(57622), tooltip = __webpack_require__(11305), visualWarnings = __webpack_require__(45296), interactivityService = __webpack_require__(72902), colorHelper = __webpack_require__(44783), browserUtils = __webpack_require__(59107), common_colorHelper = __webpack_require__(90120), dataLabelViewModel1 = __webpack_require__(21181), dataViewCategoricalReader = __webpack_require__(51129), tooltipService = __webpack_require__(40739), funnelLabelStyle = __webpack_require__(80708), dataViewObjectChangeHelper = __webpack_require__(51650), debug = __webpack_require__(62458), renderUtil = __webpack_require__(60066), dataLabelUtil = __webpack_require__(46769), dataLabelRendererEnhanced = __webpack_require__(5381), colorEnumerationHelper2 = __webpack_require__(32554), valueFormatter = __webpack_require__(72489), converterHelper = __webpack_require__(54522), build_control_util = __webpack_require__(56578), formattingService = __webpack_require__(28326), tooltipUtils = __webpack_require__(38400), funnelChart_capabilities = __webpack_require__(99653), onObjectUtil = __webpack_require__(80065), gradientUtils = __webpack_require__(52083), invalidDataValuesChecker = __webpack_require__(33777), Double = __webpack_require__(41640), htmlSubSelectionHelper = __webpack_require__(52287), Prototype = __webpack_require__(39681), labelPosition1 = __webpack_require__(382), textMeasurementService = __webpack_require__(32041), labelLayout1 = __webpack_require__(63972), selectionId = __webpack_require__(26543), visualBorderUtil = __webpack_require__(34021), subSelectionOutlineRenderer = __webpack_require__(86900), topLevelToggleBehavior = __webpack_require__(23465), common_fontProperties = __webpack_require__(18664), svgUtil = __webpack_require__(10389), enums = __webpack_require__(46135), axisHelper = __webpack_require__(53197), CssConstants = __webpack_require__(79154);
        function drawDefaultFunnelAxis(graphicsContext, axisOptions, isHidingPercentBars) {
            var indices = d3.range(0, axisOptions.categoryLabels.length), xScaleForAxis = d3.scaleBand().domain(indices).range([ axisOptions.rangeStart, axisOptions.rangeEnd ]).paddingInner(axisOptions.barToSpaceRatio).paddingOuter(isHidingPercentBars ? axisOptions.barToSpaceRatio : .75), xAxis = d3.axisRight(xScaleForAxis).tickPadding(0).tickSizeInner(0).ticks(indices.length).tickValues(indices).tickFormat(function(i) {
                return axisOptions.categoryLabels[i];
            });
            graphicsContext.attr("class", "axis hideLinesOnAxis").attr("transform", (0, svgUtil.Iu)(0, axisOptions.margin.top)).call(xAxis).select("path").attr("stroke", null), 
            graphicsContext.selectAll(".tick").call(tooltipUtils.Q, axisOptions.categoryLabels);
            var leftRightMarginLimit = axisOptions.margin.left - 6;
            graphicsContext.selectAll(".tick text").call(axisHelper.oq, leftRightMarginLimit, textMeasurementService.b.svgEllipsis).styles((0, 
            common_fontProperties.E_)(axisOptions.labelFontProperties));
        }
        function getValueFromFunnelDataPoint(dataPoint, asOriginal) {
            return void 0 === asOriginal && (asOriginal = !1), asOriginal ? dataPoint.highlight ? dataPoint.originalHighlightValue : dataPoint.originalValue : dataPoint.highlight ? dataPoint.highlightValue : dataPoint.value;
        }
        var FunnelSelectors = {
            funnel: {
                bars: (0, CssConstants.CH)("funnelBar"),
                highlights: (0, CssConstants.CH)("highlight"),
                interactors: (0, CssConstants.CH)("funnelBarInteractor")
            },
            percentBar: {
                root: (0, CssConstants.CH)("percentBars"),
                mainLine: (0, CssConstants.CH)("mainLine"),
                leftTick: (0, CssConstants.CH)("leftTick"),
                rightTick: (0, CssConstants.CH)("rightTick"),
                text: (0, CssConstants.CH)("value")
            }
        }, FunnelBarHighlightClass = [ FunnelSelectors.funnel.bars.class, FunnelSelectors.funnel.highlights.class ].join(" "), dataLabelViewModel1Consts = __webpack_require__(56707), dataViewWildcard = __webpack_require__(96915), WebFunnelAnimator = function(_super) {
            function WebFunnelAnimator(options) {
                return _super.call(this, options) || this;
            }
            return (0, tslib_es6.__extends)(WebFunnelAnimator, _super), WebFunnelAnimator.prototype.animate = function(options) {
                var result = {
                    failed: !0,
                    shapes: null,
                    dataLabels: null
                }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                this.previousViewModel = viewModel, result;
            }, WebFunnelAnimator.prototype.animateNormalToHighlighted = function(options) {
                var data = options.viewModel, layout = options.layout, hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                drawDefaultFunnelAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(FunnelSelectors.funnel.bars.selector).data(data.dataPoints, function(d) {
                    return d.key;
                }), shapesEnterUpdate = shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? FunnelBarHighlightClass : FunnelSelectors.funnel.bars.class;
                }).attrs(layout.shapeLayoutWithoutHighlights).merge(shapes);
                shapesEnterUpdate.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, !0);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, !0);
                }).transition().duration(this.animationDuration).attrs(layout.shapeLayout), shapes.exit().remove(), 
                this.animatePercentBars(options);
                var dataLabels = (0, dataLabelRendererEnhanced.Xc)(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
                return (0, svgUtil.bL)(options.visualInitOptions, shapesEnterUpdate), {
                    failed: !1,
                    shapes: shapesEnterUpdate,
                    dataLabels
                };
            }, WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                drawDefaultFunnelAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = this.animateDefaultShapes(options);
                return this.animatePercentBars(options), {
                    failed: !1,
                    shapes,
                    dataLabels: (0, dataLabelRendererEnhanced.Xc)(options.labelGraphicsContext, options.labelLayout, this.animationDuration)
                };
            }, WebFunnelAnimator.prototype.animateHighlightedToNormal = function(options) {
                var data = options.viewModel, layout = options.layout, hasSelection = !!options.interactivityService && options.interactivityService.hasSelection();
                drawDefaultFunnelAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(FunnelSelectors.funnel.bars.selector).data(data.dataPoints, function(d) {
                    return d.key;
                }), shapesEnterUpdate = shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? FunnelBarHighlightClass : FunnelSelectors.funnel.bars.class;
                }).merge(shapes);
                shapesEnterUpdate.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, !d.selected);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, !d.selected);
                }).transition().duration(this.animationDuration).attrs(layout.shapeLayoutWithoutHighlights).transition().duration(0).delay(0).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, !1);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, !1);
                }), shapes.exit().transition().duration(this.animationDuration).attrs(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights).remove(), 
                this.animatePercentBars(options);
                var dataLabels = (0, dataLabelRendererEnhanced.Xc)(options.labelGraphicsContext, options.labelLayout, this.animationDuration);
                return (0, svgUtil.bL)(options.visualInitOptions, shapesEnterUpdate, shapes.exit()), 
                {
                    failed: !1,
                    shapes: shapesEnterUpdate,
                    dataLabels
                };
            }, WebFunnelAnimator.prototype.animateDefaultShapes = function(options) {
                var data = options.viewModel, dataPoints = data.dataPoints, layout = options.layout, hasHighlights = data.hasHighlights, hasSelection = !!options.interactivityService && options.interactivityService.hasSelection(), shapes = options.shapeGraphicsContext.selectAll(FunnelSelectors.funnel.bars.selector).data(dataPoints, function(d) {
                    return d.key;
                }), shapesEnterUpdate = shapes.enter().append("rect").attr("class", function(d) {
                    return d.highlight ? FunnelBarHighlightClass : FunnelSelectors.funnel.bars.class;
                }).merge(shapes);
                return shapesEnterUpdate.style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, hasHighlights);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, hasHighlights);
                }).transition().duration(this.animationDuration).attrs(layout.shapeLayout), shapes.exit().remove(), 
                (0, svgUtil.bL)(options.visualInitOptions, shapesEnterUpdate), shapesEnterUpdate;
            }, WebFunnelAnimator.prototype.animatePercentBars = function(options) {
                var data = options.viewModel;
                if (options.isHidingPercentBars || !data.dataPoints || (data.hasHighlights ? data.dataPoints.length / 2 : data.dataPoints.length) < 2) this.animatePercentBarComponents([], options); else {
                    var dataPoints = [ data.dataPoints[data.hasHighlights ? 1 : 0], data.dataPoints[data.dataPoints.length - 1] ], baseline = getValueFromFunnelDataPoint(dataPoints[0]);
                    if (baseline <= 0) this.animatePercentBarComponents([], options); else {
                        var percentData = dataPoints.map(function(dataPoint, i) {
                            return {
                                value: getValueFromFunnelDataPoint(dataPoint),
                                percent: 0 === i ? 1 : getValueFromFunnelDataPoint(dataPoint) / baseline,
                                isTop: 0 === i
                            };
                        });
                        this.animatePercentBarComponents(percentData, options);
                    }
                }
            }, WebFunnelAnimator.prototype.animateToFunnelPercent = function(context, targetData, layoutAttr) {
                return context.data(targetData).transition().duration(this.animationDuration).attrs(layoutAttr);
            }, WebFunnelAnimator.prototype.animatePercentBarComponents = function(data, options) {
                var graphicsContext = options.percentGraphicsContext, layout = options.layout, zeroData = [ {
                    percent: 0,
                    value: 0,
                    isTop: !0
                }, {
                    percent: 0,
                    value: 0,
                    isTop: !1
                } ], mainLine = graphicsContext.selectAll(FunnelSelectors.percentBar.mainLine.selector).data(data);
                this.animateToFunnelPercent(mainLine.exit(), zeroData, layout.percentBarLayout.mainLine).remove();
                var mainLineEnterUpdate = mainLine.enter().append("line").classed(FunnelSelectors.percentBar.mainLine.class, !0).data(zeroData).attrs(layout.percentBarLayout.mainLine).merge(mainLine);
                this.animateToFunnelPercent(mainLineEnterUpdate, data, layout.percentBarLayout.mainLine);
                var leftTick = graphicsContext.selectAll(FunnelSelectors.percentBar.leftTick.selector).data(data);
                this.animateToFunnelPercent(leftTick.exit(), zeroData, layout.percentBarLayout.leftTick).remove();
                var leftTickEnterUpdate = leftTick.enter().append("line").classed(FunnelSelectors.percentBar.leftTick.class, !0).data(zeroData).attrs(layout.percentBarLayout.leftTick).merge(leftTick);
                this.animateToFunnelPercent(leftTickEnterUpdate, data, layout.percentBarLayout.leftTick);
                var rightTick = graphicsContext.selectAll(FunnelSelectors.percentBar.rightTick.selector).data(data);
                this.animateToFunnelPercent(rightTick.exit(), zeroData, layout.percentBarLayout.rightTick).remove();
                var rightTickEnterUpdate = rightTick.enter().append("line").classed(FunnelSelectors.percentBar.rightTick.class, !0).data(zeroData).attrs(layout.percentBarLayout.rightTick).merge(rightTick);
                this.animateToFunnelPercent(rightTickEnterUpdate, data, layout.percentBarLayout.rightTick);
                var text = graphicsContext.selectAll(FunnelSelectors.percentBar.text.selector).data(data);
                this.animateToFunnelPercent(text.exit(), zeroData, layout.percentBarLayout.text.attr).remove();
                var textEnterUpdate = text.enter().append("text").classed(FunnelSelectors.percentBar.text.class, !0).data(zeroData).attrs(layout.percentBarLayout.text.attr).styles(layout.percentBarLayout.text.style).merge(text);
                this.animateToFunnelPercent(textEnterUpdate, data, layout.percentBarLayout.text.attr).text(function(fp) {
                    return formattingService.dx.formatValue(fp.percent, (0, valueFormatter.Z)("Percentage1"));
                }), (0, svgUtil.bL)(options.visualInitOptions, mainLineEnterUpdate, mainLine.exit(), leftTickEnterUpdate, leftTick.exit(), rightTickEnterUpdate, rightTick.exit(), textEnterUpdate);
            }, WebFunnelAnimator;
        }(__webpack_require__(94478).r5), interactivityUtils = __webpack_require__(30237), FunnelWebBehavior = function() {
            function FunnelWebBehavior() {}
            return FunnelWebBehavior.prototype.bindEvents = function(options, selectionHandler, dataPointNavigationManagerWithKey, formatMode) {
                var bars = this.bars = options.bars, interactors = options.interactors, clearCatcher = options.clearCatcher, root = options.root;
                if (this.hasHighlights = options.hasHighlights, formatMode ? ((0, interactivityUtils.FO)(bars), 
                (0, interactivityUtils.FO)(interactors), (0, interactivityUtils.to)(root)) : ((0, 
                interactivityUtils.a0)(bars, selectionHandler), (0, interactivityUtils.a0)(interactors, selectionHandler), 
                (0, interactivityUtils.lt)(root, selectionHandler)), dataPointNavigationManagerWithKey) {
                    var dataPointNavigationManager = dataPointNavigationManagerWithKey.dataPointNavigationManager, pointSourceKey = dataPointNavigationManagerWithKey.pointSourceKey;
                    dataPointNavigationManager.isEmpty(pointSourceKey) || ((0, interactivityUtils.W3)(root, dataPointNavigationManager, pointSourceKey), 
                    (0, interactivityUtils.I8)(root, dataPointNavigationManager, pointSourceKey));
                }
                clearCatcher.on("click", function() {
                    browserUtils.M.isCtrlOrMeta(d3.event) || selectionHandler.handleClearSelection();
                });
            }, FunnelWebBehavior.prototype.renderSelection = function(hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.bars.attr("aria-selected", function(d) {
                    return d.selected;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, hasHighlights);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, hasHighlights);
                });
            }, FunnelWebBehavior.prototype.renderFocus = function(newFocus) {
                newFocus && browserUtils.M.focus(newFocus);
            }, FunnelWebBehavior;
        }(), FunnelChart = function() {
            function FunnelChart(options) {
                this.labelPositionObjects = [ labelPosition1.h.outsideEnd, labelPosition1.h.insideCenter ], 
                options && (this.tooltipsEnabled = options.tooltipsEnabled, options.funnelSmallViewPortProperties && (this.funnelSmallViewPortProperties = options.funnelSmallViewPortProperties), 
                options.animator && (this.animator = options.animator), options.behavior && (this.behavior = options.behavior));
            }
            return FunnelChart.converter = function(dataView, style, hostServices, tooltipsEnabled) {
                var _a;
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                for (var formatStringProp = funnelChart_capabilities.jP.general.formatString, reader = (0, 
                dataViewCategoricalReader.G)(dataView, {
                    staticSeriesRoleNames: [ "Y" ],
                    colorOptions: {
                        valueRole: "Y",
                        visualStyle: style
                    },
                    formatStringProp
                }), dataReader = reader.data, columnReader = reader.columns, dataPoints = [], categorical = dataView.categorical, hasHighlights = dataReader.hasHighlights(), valueMetaData = [], seriesIndex = 0, seriesCount = dataReader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) valueMetaData.push(columnReader.getValueMetadataColumn("Y", seriesIndex));
                var firstValue, firstHighlight, previousValue, previousHighlight, highlightsOverflow = !1, hasNegativeValues = !1, allValuesAreNegative = !1, categoryLabels = [], dataLabelsSettings = this.getDefaultLabelSettings(style), percentBarLabelSettings = this.getDefaultPercentLabelSettings(style), categoryAxisSettings = this.getDefaultCategoryLabelSettings(style), gradientValueColumn = (0, 
                gradientUtils.Rr)(categorical), hasCategories = !1;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects.labels;
                    labelsObj && (0, dataLabelViewModel1.ww)(labelsObj, dataLabelsSettings, void 0, style);
                    var percentLabelsObj = dataView.metadata.objects.percentBarLabel;
                    percentLabelsObj && (0, dataLabelViewModel1.ww)(percentLabelsObj, percentBarLabelSettings, void 0, style);
                    var categoryAxisObj = dataView.metadata.objects.categoryAxis;
                    categoryAxisObj && (0, dataLabelViewModel1.ww)(categoryAxisObj, categoryAxisSettings, void 0, style);
                }
                if (!dataReader.hasValues("Y")) return {
                    allValuesAreNegative,
                    canShowDataLabels: !0,
                    categoryAxisSettings,
                    categoryCount: 0,
                    categoryLabels,
                    dataLabelsSettings,
                    dataPoints,
                    hasCategories,
                    hasHighlights,
                    hasNegativeValues,
                    highlightsOverflow,
                    percentBarLabelSettings,
                    valuesMetadata: valueMetaData
                };
                firstValue = dataReader.getValue("Y", 0, 0), hasHighlights && (firstHighlight = dataReader.getHighlight("Y", 0, 0));
                var pctFormatString = (0, valueFormatter.Z)("Percentage"), defaultLabelColor = dataLabelsSettings.fontProperties.color;
                if (dataReader.hasCategories()) {
                    hasCategories = !0;
                    for (var categoryIndex = 0, categoryCount = dataReader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                        var categoryColumn = columnReader.getCategoryColumn("Category"), categoryValue = dataReader.getCategoryValue("Category", categoryIndex), valueMetadataColumn = columnReader.getValueMetadataColumn("Y"), identity = selectionId.dw.builder().withCategory([ categoryColumn ], categoryIndex, null === (_a = null == categoryColumn ? void 0 : categoryColumn.source) || void 0 === _a ? void 0 : _a.queryName, !0).withMeasure(valueMetadataColumn.queryName, columnReader.getValueColumn("Y"), categoryIndex).createSelectionId(), value = dataReader.getValue("Y", categoryIndex), formatString = dataReader.getFormatString("Y", categoryIndex), formattedCategoryValue = (0, 
                        converterHelper.xq)(categoryValue, categoryColumn.source, formatStringProp), percentOfFirst_1 = void 0, percentOfPrevious_1 = void 0, highlightValue = void 0, highlightFormatString = void 0;
                        hasHighlights ? (highlightValue = dataReader.getHighlight("Y", categoryIndex), highlightFormatString = dataReader.getHighlightFormatString("Y", categoryIndex), 
                        percentOfFirst_1 = firstHighlight ? highlightValue / firstHighlight : null, percentOfPrevious_1 = previousHighlight ? highlightValue / previousHighlight : null) : (percentOfFirst_1 = firstValue ? value / firstValue : null, 
                        percentOfPrevious_1 = previousValue ? value / previousValue : null);
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            (tooltipInfo = []).push({
                                displayName: categoryColumn.source.displayName,
                                value: formattedCategoryValue
                            }), null != value && tooltipInfo.push({
                                displayName: valueMetadataColumn.displayName,
                                value: (0, converterHelper.xq)(value, valueMetadataColumn, formatStringProp, !1, formatString)
                            }), null != highlightValue && tooltipInfo.push({
                                displayName: tooltip.I6.localizationOptions.highlightedValueDisplayName,
                                value: (0, converterHelper.xq)(highlightValue, valueMetadataColumn, formatStringProp, !1, highlightFormatString)
                            });
                            var gradientColumnMetadata = gradientValueColumn ? gradientValueColumn.source : void 0;
                            gradientColumnMetadata && gradientColumnMetadata !== valueMetadataColumn && null != gradientValueColumn.values[categoryIndex] && tooltipInfo.push({
                                displayName: gradientColumnMetadata.displayName,
                                value: (0, converterHelper.xq)(dataReader.getValue("Gradient", categoryIndex), gradientColumnMetadata, formatStringProp, !1, dataReader.getFormatString("Gradient", categoryIndex))
                            }), FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, percentOfFirst_1, percentOfPrevious_1, hasHighlights), 
                            (0, tooltip.VT)(reader, tooltipInfo, categoryIndex, void 0, formatStringProp);
                        }
                        var labelColor = (0, dataLabelUtil.t$)({
                            defaultColor: defaultLabelColor,
                            categoricalDataReader: reader,
                            categoryIndex
                        }), fontPropColor = (0, dataLabelUtil.B8)(labelColor) ? labelColor.color : defaultLabelColor;
                        dataLabelsSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropColor, dataLabelsSettings.fontProperties);
                        var color = reader.colors.createBySeries(0, categoryIndex);
                        if (dataPoints.push({
                            label: formattedCategoryValue,
                            value,
                            formatString,
                            originalValue: value,
                            percentOfFirst: percentOfFirst_1,
                            percentOfPrevious: percentOfPrevious_1,
                            categoryIndex,
                            seriesIndex: null,
                            identity,
                            selected: !1,
                            key: identity.getKey(),
                            tooltipInfo,
                            formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                            color,
                            labelFill: labelColor.color
                        }), hasHighlights) {
                            var highlightIdentity = selectionId.l0.createWithHighlight(identity), highlightValue_1 = dataReader.getHighlight("Y", categoryIndex), highlightFormatString_1 = dataReader.getHighlightFormatString("Y", categoryIndex);
                            dataPoints.push({
                                label: formattedCategoryValue,
                                value,
                                formatString,
                                originalValue: value,
                                percentOfFirst: percentOfFirst_1,
                                percentOfPrevious: percentOfPrevious_1,
                                categoryIndex,
                                seriesIndex: null,
                                identity: highlightIdentity,
                                selected: !1,
                                key: highlightIdentity.getKey(),
                                highlight: !0,
                                highlightValue: highlightValue_1,
                                highlightFormatString: highlightFormatString_1,
                                originalHighlightValue: highlightValue_1,
                                tooltipInfo,
                                formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                                color
                            }), previousHighlight = highlightValue_1;
                        }
                        previousValue = value;
                    }
                } else for (hasCategories = !1, categoryIndex = 0, seriesIndex = 0, seriesCount = dataReader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                    value = dataReader.getValue("Y", categoryIndex, seriesIndex), formatString = dataReader.getFormatString("Y", categoryIndex, seriesIndex), 
                    valueMetadataColumn = columnReader.getValueMetadataColumn("Y", seriesIndex), identity = selectionId.l0.createWithMeasure(valueMetadataColumn.queryName), 
                    color = reader.colors.createByValue(seriesIndex), labelColor = (0, dataLabelUtil.t$)({
                        seriesColor: null == dataLabelsSettings ? void 0 : dataLabelsSettings.fontProperties.color,
                        defaultColor: defaultLabelColor,
                        categoricalDataReader: reader,
                        categoryIndex,
                        seriesIndex
                    }), fontPropColor = (0, dataLabelUtil.B8)(labelColor) ? labelColor.color : defaultLabelColor, 
                    dataLabelsSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropColor, dataLabelsSettings.fontProperties);
                    var percentOfFirst_2 = void 0, percentOfPrevious_2 = void 0;
                    if (highlightValue = void 0, highlightFormatString = void 0, hasHighlights ? (highlightValue = dataReader.getHighlight("Y", categoryIndex, seriesIndex), 
                    highlightFormatString = dataReader.getHighlightFormatString("Y", categoryIndex, seriesIndex), 
                    percentOfFirst_2 = firstHighlight ? highlightValue / firstHighlight : null, percentOfPrevious_2 = previousHighlight ? highlightValue / previousHighlight : null) : (percentOfFirst_2 = firstValue ? value / firstValue : null, 
                    percentOfPrevious_2 = previousValue ? value / previousValue : null), tooltipInfo = void 0, 
                    tooltipsEnabled && (tooltipInfo = [], null != value && tooltipInfo.push({
                        displayName: valueMetadataColumn.displayName,
                        value: (0, converterHelper.xq)(value, valueMetadataColumn, formatStringProp, !1, formatString)
                    }), null != highlightValue && tooltipInfo.push({
                        displayName: tooltip.I6.localizationOptions.highlightedValueDisplayName,
                        value: (0, converterHelper.xq)(highlightValue, valueMetadataColumn, formatStringProp, !1, highlightFormatString)
                    }), FunnelChart.addFunnelPercentsToTooltip(pctFormatString, tooltipInfo, hostServices, percentOfFirst_2, percentOfPrevious_2, hasHighlights), 
                    (0, tooltip.VT)(reader, tooltipInfo, categoryIndex, void 0, formatStringProp)), 
                    dataPoints.push({
                        label: valueMetadataColumn.displayName,
                        value,
                        formatString,
                        originalValue: value,
                        percentOfFirst: percentOfFirst_2,
                        percentOfPrevious: percentOfPrevious_2,
                        categoryIndex: seriesIndex,
                        seriesIndex: null,
                        identity,
                        selected: !1,
                        key: identity.getKey(),
                        tooltipInfo,
                        formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                        color,
                        labelFill: labelColor.color
                    }), hasHighlights) {
                        highlightIdentity = selectionId.l0.createWithHighlight(identity);
                        var highlight = dataReader.getHighlight("Y", categoryIndex, seriesIndex), highlightFormatString_2 = dataReader.getHighlightFormatString("Y", categoryIndex, seriesIndex);
                        dataPoints.push({
                            label: valueMetadataColumn.displayName,
                            value,
                            formatString,
                            originalValue: value,
                            percentOfFirst: percentOfFirst_2,
                            percentOfPrevious: percentOfPrevious_2,
                            categoryIndex: seriesIndex,
                            seriesIndex: null,
                            identity: highlightIdentity,
                            key: highlightIdentity.getKey(),
                            selected: !1,
                            highlight: !0,
                            originalHighlightValue: highlight,
                            highlightValue: highlight,
                            highlightFormatString: highlightFormatString_2,
                            tooltipInfo,
                            formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                            color
                        }), previousHighlight = highlight;
                    }
                    previousValue = value;
                }
                for (var i = 0; i < dataPoints.length; i += hasHighlights ? 2 : 1) categoryLabels.push((dataPoint = dataPoints[i]).label);
                allValuesAreNegative = dataPoints.length > 0 && _.every(dataPoints, function(dataPoint) {
                    return (!dataPoint.highlight || dataPoint.highlightValue <= 0) && dataPoint.value < 0;
                });
                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i];
                    if (allValuesAreNegative) dataPoint.value = Math.abs(dataPoint.value), dataPoint.highlight && (dataPoint.highlightValue = Math.abs(dataPoint.highlightValue)); else {
                        var isValueNegative = (value = dataPoint.value) < 0;
                        isValueNegative && (dataPoint.value = 0);
                        var isHighlightValueNegative = !1;
                        dataPoint.highlight && (dataPoint.highlightValue = (isHighlightValueNegative = (highlightValue = dataPoint.highlightValue) < 0) ? 0 : highlightValue), 
                        hasNegativeValues || (hasNegativeValues = isValueNegative || isHighlightValueNegative);
                    }
                    (0, Double.aP)(dataPoint.highlightValue, dataPoint.value) && (highlightsOverflow = !0);
                }
                return {
                    allValuesAreNegative,
                    canShowDataLabels: !0,
                    categoryAxisSettings,
                    categoryCount: categoryLabels.length,
                    categoryLabels,
                    dataLabelsSettings,
                    dataPoints,
                    hasCategories,
                    hasHighlights,
                    hasNegativeValues,
                    highlightsOverflow,
                    percentBarLabelSettings,
                    strokeSettings: (0, visualBorderUtil.kG)(style),
                    valuesMetadata: valueMetaData
                };
            }, FunnelChart.prototype.getFormattingModel = function() {
                var _this = this;
                return new build_control_util.Nq(function() {
                    return _this.getColorsCard();
                }, function() {
                    return _this.getDataLabelsCard();
                }, function() {
                    return _this.getCategoryLabelsCard();
                }, function() {
                    return _this.getConversionRateLabelsCard();
                }).build();
            }, FunnelChart.prototype.hasGradientCategorical = function() {
                var _a;
                return (0, gradientUtils.Q1)(null === (_a = _.first(this.dataViews)) || void 0 === _a ? void 0 : _a.categorical);
            }, FunnelChart.prototype.getColorsCard = function() {
                var data = this.data;
                if (data && this.dataViews && this.dataViews.length) return this.hasGradientCategorical() ? void 0 : (0, 
                colorEnumerationHelper2.k2)({
                    dataView: this.dataViews[0],
                    categories: _.map(data.dataPoints, function(category) {
                        return {
                            color: category.color,
                            displayName: category.label,
                            identity: category.identity
                        };
                    }),
                    style: this.style,
                    fillInstanceKind: 3
                }, this.featureSwitches, this.hostServices);
            }, FunnelChart.prototype.getDataLabelsCard = function() {
                var _this = this, data = this.data;
                if (data && this.dataViews && this.dataViews.length) {
                    var labelSettingsOptions = FunnelChart.getLabelSettingsOptions(void 0, this.data.dataLabelsSettings || FunnelChart.getDefaultLabelSettings(this.style), !0, this.style, this.labelPositionObjects);
                    labelSettingsOptions.funnelLabelStyle = !0, debug.fF.assertValue(labelSettingsOptions, "options");
                    var dataLabelsSettings = labelSettingsOptions.dataLabelsSettings;
                    dataLabelsSettings.position && this.labelPositionObjects.indexOf(dataLabelsSettings.position) < 0 && (dataLabelsSettings.position = labelPosition1.h.outsideEnd);
                    var dataLabelsProps = (0, dataLabelViewModel1.kL)("labels");
                    dataLabelsProps.labelStyle = funnelChart_capabilities.jP.labels.funnelLabelStyle, 
                    dataLabelsProps.enableBackground = funnelChart_capabilities.jP.labels.enableBackground, 
                    dataLabelsProps.backgroundColor = funnelChart_capabilities.jP.labels.backgroundColor, 
                    dataLabelsProps.backgroundTransparency = funnelChart_capabilities.jP.labels.backgroundTransparency;
                    var formatCardOptions = {
                        cardBuilder: new build_control_util.CQ(new build_control_util.lg("labels"), "Visual_DataPointsLabels", dataLabelsProps, function(key) {
                            return _this.hostServices.getLocalizedString(key);
                        }),
                        dataLabelsProps,
                        featureSwitches: this.featureSwitches,
                        hostServices: this.hostServices,
                        options: labelSettingsOptions,
                        instanceKind: data.hasCategories ? void 0 : 3,
                        individualSelector: (0, dataLabelViewModel1.WD)({
                            featureSwitches: this.featureSwitches,
                            hasCategories: data.hasCategories,
                            hasDynamicSeries: !1,
                            hasSeriesSelector: !1
                        })
                    };
                    return (0, dataLabelViewModel1.XQ)(formatCardOptions);
                }
            }, FunnelChart.prototype.getCategoryLabelsCard = function() {
                var _this = this;
                if (this.data && this.dataViews && this.dataViews.length) {
                    var groupSettingOptions = FunnelChart.getLabelSettingsOptions(void 0, this.data.categoryAxisSettings || FunnelChart.getDefaultCategoryLabelSettings(this.style), !0, this.style, void 0), dataLabelsProps = {
                        color: funnelChart_capabilities.jP.categoryAxis.color,
                        fontFamily: funnelChart_capabilities.jP.categoryAxis.fontFamily,
                        fontSize: funnelChart_capabilities.jP.categoryAxis.fontSize,
                        show: funnelChart_capabilities.jP.categoryAxis.show,
                        bold: funnelChart_capabilities.jP.categoryAxis.bold,
                        italic: funnelChart_capabilities.jP.categoryAxis.italic,
                        underline: funnelChart_capabilities.jP.categoryAxis.underline
                    }, cardBuilder = new build_control_util.CQ(new build_control_util.lg("categoryAxis"), "Visual_CategoryLabels", dataLabelsProps, function(key) {
                        return _this.hostServices.getLocalizedString(key);
                    });
                    return (0, dataLabelViewModel1.XQ)({
                        cardBuilder,
                        dataLabelsProps,
                        featureSwitches: this.featureSwitches,
                        hostServices: this.hostServices,
                        options: groupSettingOptions,
                        customDescription: "Visual_CategoryLabelOptionsDescription",
                        instanceKind: 3
                    });
                }
            }, FunnelChart.prototype.getConversionRateLabelsCard = function() {
                var _this = this;
                if (this.data && this.dataViews && this.dataViews.length) {
                    var percentLabelSettingOptions = FunnelChart.getLabelSettingsOptions(void 0, this.data.percentBarLabelSettings || FunnelChart.getDefaultPercentLabelSettings(this.style), !1, this.style, void 0), dataLabelsProps = {
                        color: funnelChart_capabilities.jP.percentBarLabel.color,
                        fontFamily: funnelChart_capabilities.jP.percentBarLabel.fontFamily,
                        fontSize: funnelChart_capabilities.jP.percentBarLabel.fontSize,
                        show: funnelChart_capabilities.jP.percentBarLabel.show,
                        bold: funnelChart_capabilities.jP.percentBarLabel.bold,
                        italic: funnelChart_capabilities.jP.percentBarLabel.italic,
                        underline: funnelChart_capabilities.jP.percentBarLabel.underline
                    }, cardBuilder = new build_control_util.CQ(new build_control_util.lg("percentBarLabel"), "Visual_PercentBarLabel", dataLabelsProps, function(key) {
                        return _this.hostServices.getLocalizedString(key);
                    });
                    return (0, dataLabelViewModel1.XQ)({
                        cardBuilder,
                        dataLabelsProps,
                        featureSwitches: this.featureSwitches,
                        hostServices: this.hostServices,
                        options: percentLabelSettingOptions,
                        customDescription: "Visual_PercentBarLabelDescription",
                        instanceKind: 3
                    });
                }
            }, FunnelChart.getLabelSettingsOptions = function(enumeration, labelSettings, isDataLabels, style, positionObject) {
                var enableBackground = labelSettings && labelSettings.enableBackground;
                return {
                    enumeration,
                    dataLabelsSettings: labelSettings,
                    show: !0,
                    displayUnits: isDataLabels,
                    precision: isDataLabels,
                    percentagePrecision: isDataLabels,
                    position: isDataLabels,
                    positionObject,
                    enableBackground,
                    backgroundColor: enableBackground ? labelSettings.backgroundColor : void 0,
                    backgroundTransparency: enableBackground ? labelSettings.backgroundTransparency : void 0,
                    fontSize: !0,
                    fontFamily: !0,
                    style,
                    bold: !0,
                    italic: !0,
                    underline: !0
                };
            }, FunnelChart.prototype.init = function(options) {
                var _a, _this = this;
                this.options = options, this.featureSwitches = options.featureSwitches;
                var svg = this.svg = d3.select(options.element.get(0)).append("svg").classed(FunnelChart.VisualClassName, !0);
                if (this.tooltipService = (0, tooltipService.r)(options.host), this.behavior && (this.clearCatcher = (0, 
                interactivityService.EX)(this.svg)), this.currentViewport = options.viewport, this.margin = (0, 
                Prototype.ED)(FunnelChart.DefaultMargin), this.style = options.style, this.hostServices = options.host, 
                this.behavior) {
                    this.interactivityService = (0, interactivityService.ub)(this.hostServices, this.featureSwitches);
                    var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                    this.svg.attr("tabindex", 0).attr("focusable", !0).attr("role", "listbox").attr("aria-multiselectable", !0).attr("aria-label", this.hostServices.getLocalizedString("Visual_Plot")).classed(renderUtil.Pg, !isEdgeOrIE);
                }
                if (this.featureSwitches.onObject) {
                    var subSelectionHostService = null === (_a = this.hostServices) || void 0 === _a ? void 0 : _a.getSubSelectionService(), renderer = null != subSelectionHostService ? subSelectionHostService : subSelectionOutlineRenderer.D.createWithDefaultHost();
                    this.subSelectionHelper = htmlSubSelectionHelper.O5.createHtmlSubselectionHelper({
                        hostElement: options.element.get(0),
                        hostServices: this.hostServices,
                        renderer,
                        targetSource: "format",
                        scale: function() {
                            return _this.currentViewport.scale;
                        }
                    }), this.interactivityService.setSubSelectionHelper(this.subSelectionHelper);
                }
                this.percentGraphicsContext = svg.append("g").classed(FunnelSelectors.percentBar.root.class, !0), 
                this.funnelGraphicsContext = svg.append("g"), this.axisGraphicsContext = svg.append("g"), 
                this.labelBackgroundContext = svg.append("g").classed(dataLabelViewModel1Consts.u9.class, !0), 
                this.labelGraphicsContext = svg.append("g").classed(dataLabelViewModel1Consts.ZL.class, !0), 
                this.updateViewportProperties();
            }, FunnelChart.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                var deleteKeyboardShortcut = {
                    key: "Delete",
                    nextValue: !1
                };
                switch ((0, onObjectUtil.dF)(subSelections).objectName) {
                  case "bars":
                    return [ {
                        type: 0
                    }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                        type: 2
                    }, funnelChart_capabilities.jP.labels.show), {
                        enabledLabel: this.hostServices.getLocalizedString("Format_AddDataLabels")
                    }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                        type: 2
                    }, funnelChart_capabilities.jP.categoryAxis.show), {
                        enabledLabel: this.hostServices.getLocalizedString("Visual_Add_CategoryLabel")
                    }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                        type: 2
                    }, funnelChart_capabilities.jP.percentBarLabel.show), {
                        enabledLabel: this.hostServices.getLocalizedString("Visual_PercentBarLabel_Add")
                    }), {
                        type: 1,
                        destinationInfo: {
                            cardUid: "".concat("Visual", "-").concat("colors"),
                            groupUid: "".concat("colors", "-").concat("colors")
                        },
                        label: this.hostServices.getLocalizedString("Format")
                    } ];

                  case "category-labels":
                    return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                        type: 2
                    }, funnelChart_capabilities.jP.categoryAxis.show), {
                        disabledLabel: this.hostServices.getLocalizedString("Delete"),
                        keyboardShortcuts: [ deleteKeyboardShortcut ]
                    }), {
                        type: 0,
                        excludedResetFormattingIds: [ funnelChart_capabilities.jP.categoryAxis.show ]
                    }, {
                        type: 1,
                        destinationInfo: {
                            cardUid: "".concat("Visual", "-").concat("categoryAxis"),
                            groupUid: "".concat("categoryAxis", "-").concat("values")
                        },
                        label: this.hostServices.getLocalizedString("Format_Category_Labels")
                    } ];

                  case "data-labels":
                    return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                        type: 2
                    }, funnelChart_capabilities.jP.labels.show), {
                        disabledLabel: this.hostServices.getLocalizedString("Delete"),
                        keyboardShortcuts: [ deleteKeyboardShortcut ]
                    }), {
                        type: 0,
                        excludedResetFormattingIds: [ funnelChart_capabilities.jP.labels.show ]
                    }, {
                        type: 1,
                        destinationInfo: {
                            cardUid: "".concat("Visual", "-").concat("labels")
                        },
                        label: this.hostServices.getLocalizedString("Format_Data_Labels")
                    } ];

                  case "percents":
                    return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                        type: 2
                    }, funnelChart_capabilities.jP.percentBarLabel.show), {
                        disabledLabel: this.hostServices.getLocalizedString("Delete"),
                        keyboardShortcuts: [ deleteKeyboardShortcut ]
                    }), {
                        type: 0,
                        excludedResetFormattingIds: [ funnelChart_capabilities.jP.percentBarLabel.show ]
                    }, {
                        type: 1,
                        destinationInfo: {
                            cardUid: "".concat("Visual", "-").concat("percentBarLabel")
                        },
                        label: this.hostServices.getLocalizedString("Format_Conversion_Rate")
                    } ];

                  default:
                    return;
                }
            }, FunnelChart.prototype.getSubSelectionStyles = function(subSelections) {
                var selector, visualObjects = _.first(subSelections).visualObjects, visualObject = (0, 
                onObjectUtil.dF)(subSelections);
                if (visualObjects.length > 0) switch (selector = {
                    data: [ (0, dataViewWildcard.Ue)(1) ]
                }, visualObject.objectName) {
                  case "bars":
                    return (0, onObjectUtil.w3)(this.hostServices, void 0, (0, tslib_es6.__assign)((0, 
                    tslib_es6.__assign)({}, funnelChart_capabilities.jP.dataPoint.fill), {
                        selector
                    }));

                  case "data-labels":
                    if (0 === this.data.dataPoints.length) return;
                    return (0, onObjectUtil.Jf)({
                        hostServices: this.hostServices,
                        omitSelectorForSingleSeries: !0,
                        individualSelector: !0,
                        selector,
                        repetitionSelector: void 0
                    }, {
                        fontFamilyReference: funnelChart_capabilities.jP.labels.fontFamily,
                        fontSizeReference: funnelChart_capabilities.jP.labels.fontSize,
                        boldReference: funnelChart_capabilities.jP.labels.bold,
                        italicReference: funnelChart_capabilities.jP.labels.italic,
                        underlineReference: funnelChart_capabilities.jP.labels.underline,
                        fontColorReference: funnelChart_capabilities.jP.labels.color,
                        backgroundReference: funnelChart_capabilities.jP.labels.backgroundColor
                    });

                  case "category-labels":
                    return (0, onObjectUtil.un)(this.hostServices, {
                        fontFamilyReference: funnelChart_capabilities.jP.categoryAxis.fontFamily,
                        fontSizeReference: funnelChart_capabilities.jP.categoryAxis.fontSize,
                        boldReference: funnelChart_capabilities.jP.categoryAxis.bold,
                        italicReference: funnelChart_capabilities.jP.categoryAxis.italic,
                        underlineReference: funnelChart_capabilities.jP.categoryAxis.underline,
                        fontColorReference: funnelChart_capabilities.jP.categoryAxis.color
                    });

                  case "percents":
                    return (0, onObjectUtil.un)(this.hostServices, {
                        fontFamilyReference: funnelChart_capabilities.jP.percentBarLabel.fontFamily,
                        fontSizeReference: funnelChart_capabilities.jP.percentBarLabel.fontSize,
                        boldReference: funnelChart_capabilities.jP.percentBarLabel.bold,
                        italicReference: funnelChart_capabilities.jP.percentBarLabel.italic,
                        underlineReference: funnelChart_capabilities.jP.percentBarLabel.underline,
                        fontColorReference: funnelChart_capabilities.jP.percentBarLabel.color
                    });

                  default:
                    return;
                }
            }, FunnelChart.prototype.getNextSubSelectable = function(currentSubSelectable, backwards) {
                return this.subSelectionHelper.getNextSubSelectable(currentSubSelectable, backwards);
            }, FunnelChart.prototype.getSubSelectables = function(filterType) {
                return this.subSelectionHelper.getAllSubSelectables(filterType);
            }, FunnelChart.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                return this.featureSwitches.onObject && 1 === sourceType ? dataViewObjectChangeHelper.o.applyDataViewObjectsBehaviorChanges(propertySaveObjects, this.getDataViewObjectLayerChanges(propertySaveObjects)) : propertySaveObjects;
            }, FunnelChart.prototype.getDataViewObjectLayerChanges = function(propertySaveObjects) {
                if (!this.featureSwitches.onObject) return [];
                var behaviorChangeObjects = [ topLevelToggleBehavior.$.create({
                    objectName: "labels",
                    propertyName: "backgroundColor"
                }, this.data.dataLabelsSettings.enableBackground).onToggleEnabled(addDataViewObjectChange.W.createBooleanDataViewObjectChange({
                    objectName: "labels",
                    propertyName: "enableBackground"
                }, !0)) ];
                return dataViewObjectChangeHelper.o.getDataViewObjectsBehaviorChanges(propertySaveObjects, behaviorChangeObjects);
            }, FunnelChart.prototype.updateViewportProperties = function() {
                var viewport = this.currentViewport;
                this.svg.attr("width", viewport.width).attr("height", viewport.height);
            }, FunnelChart.prototype.update = function(options) {
                debug.fF.assertValue(options, "options"), this.data = {
                    dataPoints: [],
                    categoryLabels: [],
                    valuesMetadata: [],
                    hasHighlights: !1,
                    highlightsOverflow: !1,
                    canShowDataLabels: !0,
                    dataLabelsSettings: FunnelChart.getDefaultLabelSettings(this.style),
                    hasNegativeValues: !1,
                    allValuesAreNegative: !1,
                    percentBarLabelSettings: FunnelChart.getDefaultPercentLabelSettings(this.style),
                    categoryAxisSettings: FunnelChart.getDefaultCategoryLabelSettings(this.style),
                    categoryCount: 0,
                    hasCategories: !1
                };
                var dataViews = this.dataViews = options.dataViews;
                if (this.currentViewport = options.viewport, this.featureSwitches.onObject && options.formatMode !== this.formatMode && (this.subSelectionHelper.setFormatMode(options.formatMode), 
                this.interactivityService.setFormatMode(options.formatMode), this.formatMode = options.formatMode), 
                dataViews && dataViews.length > 0) {
                    var dataView = dataViews[0];
                    dataView.categorical && (this.data = FunnelChart.converter(dataView, this.style, this.hostServices, this.tooltipsEnabled), 
                    this.interactivityService && this.interactivityService.applySelectionStateToData(this.data.dataPoints));
                    var warnings = (0, invalidDataValuesChecker.b)(dataViews, !1, !1, !1, [ "Tooltips" ]);
                    this.data.allValuesAreNegative ? warnings.push(new visualWarnings.fi) : this.data.hasNegativeValues && warnings.push(new visualWarnings.v3), 
                    this.hostServices.setWarnings(warnings);
                }
                var subSelections = this.subSelectionHelper && (options.type & enums.EP.Data || options.type & enums.EP.FormattingSubSelectionChange) ? options.subSelections : null;
                this.updateViewportProperties(), this.updateInternal(options.suppressAnimations, subSelections);
            }, FunnelChart.prototype.onDataChanged = function(options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            }, FunnelChart.prototype.onResizing = function(viewport) {
                this.currentViewport = viewport, this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: !0,
                    viewport: this.currentViewport
                });
            }, FunnelChart.prototype.getMaxLabelLength = function(labels, properties) {
                for (var max = 0, textMeasurer = textMeasurementService.b.measureSvgTextWidth, i = 0, len = labels.length; i < len; i++) properties.text = labels[i], 
                max = Math.max(max, textMeasurer(properties));
                return max + 6;
            }, FunnelChart.prototype.updateInternal = function(suppressAnimations, subSelections) {
                var _a;
                if (null != this.data) {
                    var data = this.data, dataPoints = data.dataPoints, dataPointsWithoutHighlights = dataPoints.filter(function(d) {
                        return !d.highlight;
                    }), isHidingPercentBars = this.isHidingPercentBars(), axisOptions = this.setUpAxis(), margin = axisOptions.margin, funnelContext = this.funnelGraphicsContext.attr("transform", (0, 
                    svgUtil.Iu)(margin.left, margin.top)), backgroundContext = this.labelBackgroundContext.attr("transform", (0, 
                    svgUtil.Iu)(margin.left, margin.top)), labelContext = this.labelGraphicsContext.attr("transform", (0, 
                    svgUtil.Iu)(margin.left, margin.top));
                    this.percentGraphicsContext.attr("transform", (0, svgUtil.Iu)(margin.left, margin.top)), 
                    this.svg.style("font-family", dataLabelViewModel1Consts.Pq);
                    var dataLabels, result, shapes, layout = FunnelChart.getFunnelLayout(data, axisOptions), labels = this.getLabels(layout, margin);
                    if (this.animator && !suppressAnimations && (shapes = (result = this.animator.animate({
                        viewModel: data,
                        interactivityService: this.interactivityService,
                        layout,
                        axisGraphicsContext: this.axisGraphicsContext,
                        shapeGraphicsContext: funnelContext,
                        percentGraphicsContext: this.percentGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        axisOptions,
                        dataPointsWithoutHighlights,
                        labelLayout: labels,
                        isHidingPercentBars,
                        visualInitOptions: this.options
                    })).shapes), (!this.animator || suppressAnimations || result.failed) && (drawDefaultFunnelAxis(this.axisGraphicsContext, axisOptions, isHidingPercentBars), 
                    shapes = FunnelChart.drawDefaultShapes(data, dataPoints, funnelContext, layout, this.interactivityService, this.featureSwitches.onObject), 
                    FunnelChart.drawPercentBars(data, this.percentGraphicsContext, layout, isHidingPercentBars, this.style), 
                    dataLabels = (0, dataLabelRendererEnhanced.gm)({
                        labelContext,
                        dataLabels: labels,
                        formatMode: !1,
                        onObject: null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.onObject,
                        backgroundContext
                    })), subSelections && this.subSelectionHelper.updateOutlinesFromSubSelections(subSelections, !0), 
                    this.interactivityService) {
                        var interactors = FunnelChart.drawInteractorShapes(dataPoints, funnelContext, layout);
                        this.interactivityService.bind(dataPoints, this.behavior, {
                            root: this.svg,
                            bars: shapes,
                            interactors,
                            clearCatcher: this.clearCatcher,
                            hasHighlights: data.hasHighlights
                        }, {
                            navigationOptions: {
                                helper: this,
                                navigationStrategy: interactivityService.jN.CategoryOnly
                            },
                            pointSourceKey: "funnel"
                        }), this.tooltipsEnabled && this.tooltipService.addTooltip(interactors, function(args) {
                            return args.data && args.data.tooltipInfo;
                        }, function(args) {
                            return args.data && args.data.identity && [ args.data.identity ];
                        });
                    }
                    if (this.featureSwitches.onObject) {
                        var labelsHaveBackground = labels.every(function(label) {
                            return label.hasBackground;
                        });
                        !function(labels) {
                            labels.selectAll(".tick text").classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "category-labels").attr(htmlSubSelectionHelper.QZ, 1).attr(htmlSubSelectionHelper.CK, "Visual_CategoryLabels").style("pointer-events", "bounding-box");
                        }(this.axisGraphicsContext), labelsHaveBackground || function(labels) {
                            labels.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "data-labels").attr(htmlSubSelectionHelper.QZ, 1).attr(htmlSubSelectionHelper.CK, "Visual_DataPointsLabels").style("pointer-events", "bounding-box");
                        }(dataLabels), this.percentGraphicsContext.selectAll(FunnelSelectors.percentBar.text.selector).classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "percents").attr(htmlSubSelectionHelper.QZ, 1).attr(htmlSubSelectionHelper.CK, "Visual_PercentBarLabel").style("pointer-events", "bounding-box");
                    }
                    this.tooltipsEnabled && this.tooltipService.addTooltip(shapes, function(args) {
                        return args.data && args.data.tooltipInfo;
                    }, function(args) {
                        return args.data && args.data.identity && [ args.data.identity ];
                    });
                }
            }, FunnelChart.prototype.getFirstElement = function() {
                return {
                    element: this.getHTMLElementFromCategoryIndex(0)
                };
            }, FunnelChart.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var numCategories = this.data.categoryCount, startCategoryIndex = categoryIndex;
                do {
                    switch (direction) {
                      case interactivityService.x0.NextCategory:
                        (categoryIndex += 1) >= numCategories && (categoryIndex = 0);
                        break;

                      case interactivityService.x0.PreviousCategory:
                        (categoryIndex -= 1) < 0 && (categoryIndex = numCategories - 1);
                        break;

                      case interactivityService.x0.NextSeries:
                      case interactivityService.x0.PreviousSeries:
                        break;

                      default:
                        debug.fF.assertNever(direction);
                    }
                } while (0 === this.data.dataPoints[categoryIndex].value && categoryIndex !== startCategoryIndex);
                return {
                    element: this.getHTMLElementFromCategoryIndex(categoryIndex)
                };
            }, FunnelChart.prototype.getHTMLElementFromCategoryIndex = function(categoryIndex) {
                return this.svg.selectAll(FunnelSelectors.funnel.bars.selector).filter(function(d) {
                    return d.categoryIndex === categoryIndex;
                }).node();
            }, FunnelChart.prototype.getUsableVerticalSpace = function() {
                var margin = this.margin;
                return this.currentViewport.height - (margin.top + margin.bottom) - FunnelChart.MinBarThickness * this.data.categoryCount;
            }, FunnelChart.prototype.isHidingPercentBars = function() {
                if (this.data.percentBarLabelSettings.show) {
                    var percentBarTextHeight = this.getPercentBarTextHeight();
                    return this.getUsableVerticalSpace() - 2 * FunnelChart.MinBarThickness * .75 - 2 * percentBarTextHeight <= 0;
                }
                return !0;
            }, FunnelChart.prototype.isSparklines = function() {
                return this.getUsableVerticalSpace() <= 0;
            }, FunnelChart.prototype.setUpAxis = function() {
                var data = this.data, dataPoints = data.dataPoints, categoryLabels = data.categoryLabels, viewport = this.currentViewport, margin = (0, 
                Prototype.ED)(FunnelChart.DefaultMargin), isSparklines = this.isSparklines(), isHidingPercentBars = this.isHidingPercentBars(), percentBarTextHeight = isHidingPercentBars ? 0 : this.getPercentBarTextHeight(), verticalRange = viewport.height - (margin.top + margin.bottom) - 2 * percentBarTextHeight, maxMarginFactor = FunnelChart.MaxMarginFactor, fontProperties = data.categoryAxisSettings.fontProperties;
                if (categoryLabels.length > 0 && isSparklines) categoryLabels = [], data.canShowDataLabels = !1; else if (this.showCategoryLabels()) {
                    var textProperties = (0, common_fontProperties.qk)(fontProperties), longestLabelLength = this.getMaxLabelLength(categoryLabels, textProperties), labelLength = Math.min(longestLabelLength, viewport.width * maxMarginFactor);
                    margin.left = labelLength + FunnelChart.YAxisPadding;
                } else categoryLabels = [];
                var horizontalRange = viewport.width - (margin.left + margin.right), barToSpaceRatio = FunnelChart.BarToSpaceRatio, maxScore = d3.max(dataPoints.map(function(d) {
                    return d.value;
                }));
                if (data.hasHighlights) {
                    var maxHighlight = d3.max(dataPoints.map(function(d) {
                        return d.highlightValue;
                    }));
                    maxScore = d3.max([ maxScore, maxHighlight ]);
                }
                var delta, rangeStart = 0, rangeEnd = verticalRange;
                return delta = isHidingPercentBars ? verticalRange - data.categoryCount * FunnelChart.MaxBarHeight : verticalRange - data.categoryCount * FunnelChart.MaxBarHeight - 2 * FunnelChart.MaxBarHeight * .75, 
                data.categoryCount > 0 && delta > 0 && (rangeStart = Math.ceil(delta / 2), rangeEnd = Math.ceil(verticalRange - delta / 2)), 
                isHidingPercentBars || (rangeStart += percentBarTextHeight, rangeEnd += percentBarTextHeight), 
                {
                    margin,
                    valueScale: d3.scaleLinear().domain([ 0, maxScore ]).range([ horizontalRange, 0 ]),
                    categoryScale: d3.scaleBand().domain(d3.range(0, data.categoryCount)).range([ rangeStart, rangeEnd ]).paddingInner(barToSpaceRatio).paddingOuter(isHidingPercentBars ? barToSpaceRatio : .75),
                    maxScore,
                    maxWidth: horizontalRange,
                    rangeStart,
                    rangeEnd,
                    barToSpaceRatio,
                    categoryLabels,
                    labelFontProperties: fontProperties
                };
            }, FunnelChart.prototype.getPercentBarTextHeight = function() {
                var percentBarTextProperties = (0, common_fontProperties.qk)(this.data.percentBarLabelSettings.fontProperties);
                return textMeasurementService.b.estimateSvgTextHeight(percentBarTextProperties);
            }, FunnelChart.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, FunnelChart.prototype.onRestoreSelection = function(options) {
                return !!this.interactivityService && this.interactivityService.restoreSelection(options.selection);
            }, FunnelChart.getFunnelLayout = function(data, axisOptions) {
                var highlightsOverflow = data.highlightsOverflow, categoryScale = axisOptions.categoryScale, valueScale = axisOptions.valueScale, maxScore = axisOptions.maxScore, columnHeight = categoryScale.bandwidth(), percentBarTickHeight = Math.ceil(columnHeight / 2), overFlowHighlightColumnWidth = columnHeight * FunnelChart.OverflowingHighlightWidthRatio, overFlowHighlightOffset = overFlowHighlightColumnWidth / 2, lastCategoryIndex = data.categoryCount - 1, horizontalDistance = Math.abs(valueScale(maxScore) - valueScale(0)), emptyHorizontalSpace = function(value) {
                    return (horizontalDistance - Math.abs(valueScale(value) - valueScale(0))) / 2;
                }, getMinimumShapeSize = function(value) {
                    return Math.max(FunnelChart.MinimumInteractorSize, Math.abs(valueScale(value) - valueScale(0)));
                }, percentBarTextProperties = (0, common_fontProperties.qk)(data.percentBarLabelSettings.fontProperties), baselineDelta = textMeasurementService.b.estimateSvgTextBaselineDelta(percentBarTextProperties), percentBarYOffset = textMeasurementService.b.estimateSvgTextHeight(percentBarTextProperties) - baselineDelta;
                return {
                    percentBarLayout: {
                        mainLine: {
                            x2: function(d) {
                                return Math.abs(valueScale(d.value) - valueScale(0));
                            },
                            transform: function(d) {
                                var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value), yOffset = d.isTop ? categoryScale(0) - percentBarTickHeight : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight;
                                return (0, svgUtil.Iu)(xOffset, yOffset);
                            }
                        },
                        leftTick: {
                            y2: function(d) {
                                return percentBarTickHeight;
                            },
                            transform: function(d) {
                                var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value), yOffset = d.isTop ? categoryScale(0) - percentBarTickHeight - percentBarTickHeight / 2 : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight - percentBarTickHeight / 2;
                                return (0, svgUtil.Iu)(xOffset, yOffset);
                            }
                        },
                        rightTick: {
                            y2: function(d) {
                                return percentBarTickHeight;
                            },
                            transform: function(d) {
                                var xOffset = valueScale(d.value) - emptyHorizontalSpace(d.value) + Math.abs(valueScale(d.value) - valueScale(0)), yOffset = d.isTop ? categoryScale(0) - percentBarTickHeight - percentBarTickHeight / 2 : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight - percentBarTickHeight / 2;
                                return (0, svgUtil.Iu)(xOffset, yOffset);
                            }
                        },
                        text: {
                            attr: {
                                x: function(d) {
                                    return Math.ceil(Math.abs(valueScale(maxScore) - valueScale(0)) / 2);
                                },
                                y: function(d) {
                                    return d.isTop ? -percentBarTickHeight / 2 - baselineDelta : percentBarYOffset + percentBarTickHeight / 2;
                                },
                                transform: function(d) {
                                    var xOffset = d.isTop ? categoryScale(0) - percentBarTickHeight : categoryScale(lastCategoryIndex) + columnHeight + percentBarTickHeight;
                                    return (0, svgUtil.Iu)(0, xOffset);
                                }
                            },
                            style: (0, common_fontProperties.E_)(data.percentBarLabelSettings.fontProperties),
                            maxWidth: horizontalDistance
                        }
                    },
                    shapeLayout: {
                        height: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight;
                        },
                        width: function(d) {
                            return Math.abs(valueScale(getValueFromFunnelDataPoint(d)) - valueScale(0));
                        },
                        y: function(d) {
                            return categoryScale(d.categoryIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        x: function(d) {
                            var value = getValueFromFunnelDataPoint(d);
                            return valueScale(value) - emptyHorizontalSpace(value);
                        }
                    },
                    shapeLayoutWithoutHighlights: {
                        height: function(d) {
                            return columnHeight;
                        },
                        width: function(d) {
                            return Math.abs(valueScale(d.value) - valueScale(0));
                        },
                        y: function(d) {
                            return categoryScale(d.categoryIndex) + 0;
                        },
                        x: function(d) {
                            return valueScale(d.value) - emptyHorizontalSpace(d.value);
                        }
                    },
                    zeroShapeLayout: {
                        height: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight;
                        },
                        width: function(d) {
                            return 0;
                        },
                        y: function(d) {
                            return categoryScale(d.categoryIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        x: function(d) {
                            return valueScale((valueScale.domain()[0] + valueScale.domain()[1]) / 2);
                        }
                    },
                    interactorLayout: {
                        height: function(d) {
                            return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnHeight;
                        },
                        width: function(d) {
                            return getMinimumShapeSize(getValueFromFunnelDataPoint(d));
                        },
                        y: function(d) {
                            return categoryScale(d.categoryIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        x: function(d) {
                            var size = getMinimumShapeSize(getValueFromFunnelDataPoint(d));
                            return (horizontalDistance - size) / 2;
                        }
                    }
                };
            }, FunnelChart.drawDefaultShapes = function(data, dataPoints, graphicsContext, layout, interactivityService, onObject) {
                (0, visualBorderUtil.H4)(graphicsContext, data.strokeSettings);
                var hasHighlights = data.hasHighlights, isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge(), hasSelection = interactivityService && interactivityService.hasSelection(), columnsEnterUpdate = graphicsContext.selectAll(FunnelSelectors.funnel.bars.selector).data(dataPoints, function(d) {
                    return d.key;
                }).join(function(enter) {
                    return enter.append("rect").attr("role", "option").attr("aria-label", function(d) {
                        return d.formattedTooltip;
                    }).attr("aria-selected", function(d) {
                        return d.selected;
                    }).attr("class", function(d) {
                        return d.highlight ? FunnelBarHighlightClass : FunnelSelectors.funnel.bars.class;
                    });
                }).style("fill", function(d) {
                    return d.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, d.highlight, hasSelection, hasHighlights);
                }).attrs(layout.shapeLayout);
                return interactivityService && columnsEnterUpdate.attr("tabindex", 0).attr("focusable", !0).classed(renderUtil.Pg, !isEdgeOrIE), 
                onObject && columnsEnterUpdate.classed(htmlSubSelectionHelper.cy, !0).attr(htmlSubSelectionHelper.Ez, "bars").attr(htmlSubSelectionHelper.QZ, 3).attr(htmlSubSelectionHelper.CK, "MiniToolbar_All_Bars"), 
                columnsEnterUpdate;
            }, FunnelChart.getFormatStringFromDataPoint = function(dataPoint) {
                return null != dataPoint.highlight ? dataPoint.highlightFormatString : dataPoint.formatString;
            }, FunnelChart.drawInteractorShapes = function(dataPoints, graphicsContext, layout) {
                var interactorsData = dataPoints.filter(function(d) {
                    return !d.highlight && layout.interactorLayout.width(d) === FunnelChart.MinimumInteractorSize;
                }), columns = graphicsContext.selectAll(FunnelSelectors.funnel.interactors.selector).data(interactorsData, function(d) {
                    return d.key;
                }), columnsEnterUpdate = columns.enter().append("rect").attr("class", FunnelSelectors.funnel.interactors.class).merge(columns);
                return columnsEnterUpdate.style("fill-opacity", 0).attrs(layout.interactorLayout), 
                columns.exit().remove(), columnsEnterUpdate;
            }, FunnelChart.drawPercentBarComponents = function(graphicsContext, data, layout, percentLabelSettings, style) {
                graphicsContext.style("stroke", common_colorHelper.v.getThemeColor(style, FunnelChart.DefaultPercentBarStrokeColorName));
                var mainLine = graphicsContext.selectAll(FunnelSelectors.percentBar.mainLine.selector).data(data);
                mainLine.exit().remove(), mainLine.enter().append("line").classed(FunnelSelectors.percentBar.mainLine.class, !0).merge(mainLine).attrs(layout.percentBarLayout.mainLine);
                var leftTick = graphicsContext.selectAll(FunnelSelectors.percentBar.leftTick.selector).data(data);
                leftTick.exit().remove(), leftTick.enter().append("line").classed(FunnelSelectors.percentBar.leftTick.class, !0).merge(leftTick).attrs(layout.percentBarLayout.leftTick);
                var rightTick = graphicsContext.selectAll(FunnelSelectors.percentBar.rightTick.selector).data(data);
                rightTick.exit().remove(), rightTick.enter().append("line").classed(FunnelSelectors.percentBar.rightTick.class, !0).merge(rightTick).attrs(layout.percentBarLayout.rightTick);
                var text = graphicsContext.selectAll(FunnelSelectors.percentBar.text.selector).data(data), localizedString = (0, 
                valueFormatter.Z)("Percentage1");
                text.exit().remove(), text.enter().append("text").classed(FunnelSelectors.percentBar.text.class, !0).merge(text).attrs(layout.percentBarLayout.text.attr).styles(layout.percentBarLayout.text.style).text(function(fp) {
                    return (0, dataLabelViewModel1.Gv)({
                        label: fp.percent,
                        format: localizedString,
                        fontProperties: percentLabelSettings.fontProperties,
                        maxWidth: layout.percentBarLayout.text.maxWidth
                    });
                }).append("title").text(function(d) {
                    return formattingService.dx.formatValue(d.percent, localizedString);
                });
            }, FunnelChart.drawPercentBars = function(data, graphicsContext, layout, isHidingPercentBars, style) {
                if (isHidingPercentBars || !data.dataPoints || data.categoryCount < 2) FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings, style); else {
                    var dataPoints = [ data.dataPoints[data.hasHighlights ? 1 : 0], data.dataPoints[data.dataPoints.length - 1] ], baseline = getValueFromFunnelDataPoint(dataPoints[0]);
                    if (baseline <= 0) FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings, style); else {
                        var percentData = [ {
                            value: getValueFromFunnelDataPoint(dataPoints[0]),
                            percent: 1,
                            isTop: !0
                        }, {
                            value: getValueFromFunnelDataPoint(dataPoints[1]),
                            percent: getValueFromFunnelDataPoint(dataPoints[1]) / baseline,
                            isTop: !1
                        } ];
                        FunnelChart.drawPercentBarComponents(graphicsContext, percentData, layout, data.percentBarLabelSettings, style);
                    }
                }
            }, FunnelChart.prototype.showCategoryLabels = function() {
                return !(this.funnelSmallViewPortProperties && this.funnelSmallViewPortProperties.hideFunnelCategoryLabelsOnSmallViewPort && this.currentViewport.height < this.funnelSmallViewPortProperties.minHeightFunnelCategoryLabelsVisible) && this.data && this.data.categoryAxisSettings && this.data.categoryAxisSettings.show;
            }, FunnelChart.addFunnelPercentsToTooltip = function(pctFormatString, tooltipInfo, hostServices, percentOfFirst, percentOfPrevious, highlight) {
                null != percentOfFirst && tooltipInfo.push({
                    displayName: hostServices.getLocalizedString("Funnel_PercentOfFirst" + (highlight ? "_Highlight" : "")),
                    value: (0, valueFormatter.WU)(percentOfFirst, pctFormatString)
                }), null != percentOfPrevious && tooltipInfo.push({
                    displayName: hostServices.getLocalizedString("Funnel_PercentOfPrevious" + (highlight ? "_Highlight" : "")),
                    value: (0, valueFormatter.WU)(percentOfPrevious, pctFormatString)
                });
            }, FunnelChart.getDefaultLabelSettings = function(style) {
                return {
                    show: !0,
                    position: labelPosition1.h.insideCenter,
                    displayUnits: 0,
                    fontProperties: (0, dataLabelViewModel1.bT)({
                        style,
                        textClassName: "lightLabel",
                        noColor: !0
                    }).fontProperties,
                    labelStyle: funnelLabelStyle.aT,
                    enableBackground: !1,
                    backgroundColor: common_colorHelper.v.getThemeColor(style, colorHelper.U),
                    backgroundTransparency: .5,
                    percentagePrecision: dataLabelViewModel1Consts.Qc,
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, FunnelChart.getDefaultPercentLabelSettings = function(style) {
                return {
                    show: !0,
                    position: 0,
                    displayUnits: 0,
                    fontProperties: (0, dataLabelViewModel1.bT)({
                        labelColor: common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ),
                        style,
                        textClassName: "lightLabel"
                    }).fontProperties,
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, FunnelChart.getDefaultCategoryLabelSettings = function(style) {
                return {
                    show: !0,
                    fontProperties: (0, dataLabelViewModel1.bT)({
                        labelColor: common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.uQ),
                        style,
                        textClassName: "lightLabel"
                    }).fontProperties,
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, FunnelChart.prototype.getLabels = function(layout, margin) {
                var labels = [];
                if (this.data.dataLabelsSettings.show && this.data.canShowDataLabels) {
                    var labelDataPoints = this.createLabelDataPoints(layout.shapeLayout, this.data.dataLabelsSettings);
                    labels = new labelLayout1.nu({
                        maximumOffset: dataLabelViewModel1Consts.wh,
                        startingOffset: dataLabelViewModel1Consts.ki
                    }).layout([ {
                        labelDataPoints,
                        maxNumberOfLabels: labelDataPoints.length
                    } ], {
                        width: this.currentViewport.width - margin.left,
                        height: this.currentViewport.height - margin.top
                    });
                }
                return labels;
            }, FunnelChart.prototype.createLabelDataPoints = function(shapeLayout, visualSettings) {
                var _a, _b, data = this.data, dataPoints = data.dataPoints;
                if (_.isEmpty(dataPoints)) return [];
                var points = new Array, generalSettings = dataPoints[0], validPositions = FunnelChart.LabelInsidePosition, height = shapeLayout.height(generalSettings);
                visualSettings.position && visualSettings.position === labelPosition1.h.outsideEnd && (validPositions = FunnelChart.LabelOutsidePosition);
                var maxAbsoluteValue = null;
                0 === visualSettings.displayUnits && (maxAbsoluteValue = data.dataPoints.reduce(function(memo, value) {
                    return Math.abs(memo.value) > Math.abs(value.value) ? memo : value;
                }).value);
                var columnFormatString = (0, valueFormatter.EO)(data.valuesMetadata[0], funnelChart_capabilities.jP.general.formatString), formattersCache = (0, 
                dataLabelViewModel1.fI)(), dataLabelsSettings = data.dataLabelsSettings, dataLabelStyle = dataLabelsSettings.labelStyle, fontProperties = dataLabelsSettings.fontProperties;
                _.isEmpty(fontProperties) && (fontProperties = dataLabelViewModel1Consts.bL);
                var percentFormatter, properties = (0, common_fontProperties.qk)(fontProperties), pctFormatString = (0, 
                valueFormatter.Z)("Percentage"), measureFormatterCache = (0, dataLabelViewModel1.fI)(), percentLabelSettings = _.clone(dataLabelsSettings), precision = percentLabelSettings.percentagePrecision;
                percentLabelSettings.displayUnits = 0, _.isFinite(precision) && (percentFormatter = measureFormatterCache.getOrCreate(pctFormatString, percentLabelSettings, null, percentLabelSettings.percentagePrecision));
                for (var outsideFillDefault = common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.uQ), insideFillDefault = common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.pl), isFirstLabel = !0, _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var dataPoint = dataPoints_2[_i], value = getValueFromFunnelDataPoint(dataPoint, !0), formatString = FunnelChart.getFormatStringFromDataPoint(dataPoint);
                    if (null != value && (!data.hasHighlights || dataPoint.highlight)) {
                        var valueText = formattersCache.getOrCreate(formatString || columnFormatString || generalSettings.labelFormatString, visualSettings, maxAbsoluteValue).format(value), labelText = void 0;
                        if (isFirstLabel) labelText = valueText, isFirstLabel = !1; else {
                            var percentOfFirstText = percentFormatter ? percentFormatter.format(dataPoint.percentOfFirst) : (0, 
                            valueFormatter.WU)(dataPoint.percentOfFirst, pctFormatString), percentOfPreviousText = percentFormatter ? percentFormatter.format(dataPoint.percentOfPrevious) : (0, 
                            valueFormatter.WU)(dataPoint.percentOfPrevious, pctFormatString);
                            switch (dataLabelStyle) {
                              case funnelLabelStyle.oN:
                                labelText = percentOfFirstText;
                                break;

                              case funnelLabelStyle.r2:
                                labelText = percentOfPreviousText;
                                break;

                              case funnelLabelStyle.MS:
                                labelText = valueText + " (" + percentOfFirstText + ")";
                                break;

                              case funnelLabelStyle.mN:
                                labelText = valueText + " (" + percentOfPreviousText + ")";
                                break;

                              default:
                                labelText = valueText;
                            }
                        }
                        properties.text = labelText;
                        var textWidth = textMeasurementService.b.measureSvgTextWidth(properties), textHeight = textMeasurementService.b.estimateSvgTextHeight(properties), parentType = 1, shape = {
                            rect: {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint)
                            },
                            orientation: FunnelChart.LabelOrientation,
                            validPositions
                        }, hasBackground = dataLabelsSettings.enableBackground, point = {
                            isPreferred: !0,
                            text: labelText,
                            textSize: {
                                width: textWidth,
                                height: textHeight
                            },
                            fontProperties,
                            parentType,
                            parentShape: shape,
                            insideFill: null !== (_a = dataPoint.labelFill) && void 0 !== _a ? _a : insideFillDefault,
                            outsideFill: null !== (_b = dataPoint.labelFill) && void 0 !== _b ? _b : outsideFillDefault,
                            identity: dataPoint.identity,
                            backgroundColor: hasBackground ? dataLabelsSettings.backgroundColor : void 0,
                            backgroundTransparency: hasBackground ? dataLabelsSettings.backgroundTransparency : void 0,
                            hasBackground
                        };
                        0 === dataPoint.value && (shape = {
                            validPositions: [ 256 ],
                            point: {
                                x: shapeLayout.x(dataPoint),
                                y: shapeLayout.y(dataPoint) + height / 2
                            }
                        }, parentType = 0, point.parentShape = shape, point.parentType = parentType, point.insideFill = point.outsideFill), 
                        points.push(point);
                    }
                }
                return points;
            }, FunnelChart.LabelInsidePosition = [ 1, 16 ], FunnelChart.LabelOutsidePosition = [ 16, 4 ], 
            FunnelChart.LabelOrientation = 3, FunnelChart.DefaultPercentBarStrokeColorName = "foregroundNeutralTertiary", 
            FunnelChart.DefaultBarOpacity = 1, FunnelChart.DimmedBarOpacity = .4, FunnelChart.MinimumInteractorSize = 15, 
            FunnelChart.InnerTextClassName = "labelSeries", FunnelChart.YAxisPadding = 10, FunnelChart.VisualClassName = "funnelChart", 
            FunnelChart.BarToSpaceRatio = .1, FunnelChart.MaxBarHeight = 60, FunnelChart.MinBarThickness = 12, 
            FunnelChart.OverflowingHighlightWidthRatio = .5, FunnelChart.MaxMarginFactor = .25, 
            FunnelChart.DefaultMargin = {
                left: 5,
                right: 5,
                top: 0,
                bottom: 0
            }, FunnelChart;
        }();
    }
} ]);