"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "map" ], {
    74591: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            Map: function() {
                return Map;
            },
            callSafely: function() {
                return callSafely;
            },
            mapsModule: function() {
                return mapsModule;
            },
            timeoutWrapped: function() {
                return timeoutWrapped;
            },
            unwrap: function() {
                return unwrap;
            },
            wrap: function() {
                return wrap;
            },
            wrappedSetInterval: function() {
                return wrappedSetInterval;
            },
            wrappedSetTimeout: function() {
                return wrappedSetTimeout;
            }
        });
        var tslib_es6 = __webpack_require__(81337), filledMap_capabilities = __webpack_require__(61160), map_capabilities = __webpack_require__(98755), colorEnumerationHelper2 = __webpack_require__(32554), common_colorHelper = __webpack_require__(90120), dataLabelViewModel1Consts = __webpack_require__(56707), converterHelper = __webpack_require__(54522), dataLabelViewModel1 = __webpack_require__(21181), common_fontProperties = __webpack_require__(18664), mapUtil = __webpack_require__(5962), plotAreaLassoManager = __webpack_require__(11745), shapeUtil = __webpack_require__(86108), visualLocKeys = __webpack_require__(33024), dataViewCategoricalReader = __webpack_require__(51129), legend_converter = __webpack_require__(79811), legend_formatting = __webpack_require__(86727), legend_util = __webpack_require__(77686), legend = __webpack_require__(65741), interactivityService = __webpack_require__(72902), tooltipService = __webpack_require__(40739), tooltip = __webpack_require__(11305), bingMapTheme1 = __webpack_require__(34002), bingMapTheme2 = __webpack_require__(74988), geocodingCulture = __webpack_require__(56919), markerRangeType = __webpack_require__(90700), visualWarnings = __webpack_require__(45296), VisualsCommon_color = __webpack_require__(64067), colorHelper = __webpack_require__(44783), DomFactory = __webpack_require__(38308), debug = __webpack_require__(62458), geoTaggingAnalyzerService = __webpack_require__(15621), jqueryPromiseFactory = __webpack_require__(88987), trace = __webpack_require__(12913), bubblingEventManager = __webpack_require__(58778), build_control_util = __webpack_require__(56578), Utility = __webpack_require__(38078), dataRoleHelper = __webpack_require__(38958), dataViewObject2 = __webpack_require__(82755), valueFormatter = __webpack_require__(72489), selectionId = __webpack_require__(26543), renderUtil = __webpack_require__(60066), dataLabelRendererEnhanced = __webpack_require__(5381), navigationUtils = __webpack_require__(49203), labelLayout1 = __webpack_require__(63972), shapes7 = __webpack_require__(92379), textMeasurementService = __webpack_require__(32041), browserUtils = __webpack_require__(59107), svgUtil = __webpack_require__(10389), eventBubblingUtil = __webpack_require__(66232), inertia = __webpack_require__(57952), CssConstants = __webpack_require__(79154), MapItemMouseEventHandler = function() {
            function MapItemMouseEventHandler(mapControl, tooltipService, enableInertia) {
                void 0 === enableInertia && (enableInertia = !0), this.mapControl = mapControl, 
                this.tooltipService = tooltipService, this.inertia = new inertia.r(null, enableInertia), 
                this.inertia.callback = function(deltaX, deltaY) {
                    return (0, mapUtil.M_)(mapControl, deltaX, deltaY);
                };
            }
            return MapItemMouseEventHandler.prototype.onMouseDown = function(target) {
                var _this = this, previousMousePosition = this.getMousePosition(), element = d3.select(target), dragging = !1, totalDelta = 0, inertia = this.inertia;
                inertia.hasStarted() && inertia.stop();
                var documentSelection = d3.select(window).on(MapItemMouseEventHandler.Events.mouseMove, function() {
                    var _a, newMousePosition = _this.getMousePosition(), deltaX = (_a = MapItemMouseEventHandler.getDelta(previousMousePosition, newMousePosition))[0], deltaY = _a[1];
                    dragging || (totalDelta += Math.abs(deltaX) + Math.abs(deltaY)) > MapItemMouseEventHandler.DragPixelThreshold && (dragging = !0, 
                    element.classed(MapItemMouseEventHandler.DraggingCSS.class, !0), _this.tooltipService.hide()), 
                    inertia.addPoint(newMousePosition[0], newMousePosition[1]), (0, mapUtil.M_)(_this.mapControl, deltaX, deltaY), 
                    previousMousePosition = newMousePosition;
                }).on(MapItemMouseEventHandler.Events.mouseup, function() {
                    if (documentSelection.on(MapItemMouseEventHandler.Events.mouseMove, null).on(MapItemMouseEventHandler.Events.mouseup, null), 
                    dragging) {
                        var newMousePosition = _this.getMousePosition();
                        inertia.addPoint(newMousePosition[0], newMousePosition[1]), element.classed(MapItemMouseEventHandler.DraggingCSS.class, !1);
                        var d3Event_1 = d3.event;
                        d3Event_1.target === element.node() && element.on(MapItemMouseEventHandler.Events.click, function() {
                            (0, eventBubblingUtil.n)(d3Event_1), element.on(MapItemMouseEventHandler.Events.click, null);
                        }), inertia.start();
                    }
                });
            }, MapItemMouseEventHandler.prototype.getMousePosition = function() {
                var bodyNode = MapItemMouseEventHandler.BodyNode = MapItemMouseEventHandler.BodyNode || d3.select("body").node();
                return d3.mouse(bodyNode);
            }, MapItemMouseEventHandler.getDelta = function(previous, current) {
                return [ current[0] - previous[0], current[1] - previous[1] ];
            }, MapItemMouseEventHandler.DragPixelThreshold = 5, MapItemMouseEventHandler.Events = {
                mouseDown: "mousedown.mapDrag",
                mouseMove: "mousemove.mapDrag",
                mouseup: "mouseup.mapDrag",
                click: "click.mapDrag"
            }, MapItemMouseEventHandler.DraggingCSS = (0, CssConstants.CH)("dragging-cursor"), 
            MapItemMouseEventHandler;
        }(), MapBubbleDataPointRenderer = function() {
            function MapBubbleDataPointRenderer(tooltipsEnabled) {
                this.navigationStrategy = interactivityService.jN.CategoryFirst, this.tooltipsEnabled = tooltipsEnabled;
            }
            return MapBubbleDataPointRenderer.prototype.init = function(mapControl, mapDiv, setClearCapture, tooltipService, style, interactivityService, host, eventManager) {
                this.host = host, this.mapControl = mapControl, this.eventManager = eventManager, 
                this.pointLabelText = this.host.getLocalizedString("Generic_Point");
                var root = this.root = d3.select(mapDiv[0]);
                root.attr("drag-resize-disabled", "true").style("display", "inline-block").attr("tabindex", -1).attr("focusable", !1);
                var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge(), svg = this.svg = root.append("svg").style("position", "absolute").style("pointer-events", "none").classed(mapUtil.nv, !isEdgeOrIE);
                interactivityService && svg.attr("tabindex", 0).attr("focusable", !0).attr("aria-label", host.getLocalizedString("Visual_Plot")).attr("focus-nav-mode", "Hierarchy").attr("aria-multiselectable", "true").attr("role", "listbox").classed(renderUtil.Pg, !isEdgeOrIE), 
                setClearCapture && (this.clearCapture = root), this.bubbleGraphicsContext = svg.append("g").classed("mapBubbles", !0), 
                this.sliceGraphicsContext = svg.append("g").classed("mapSlices", !0), this.labelBackgroundGraphicsContext = svg.append("g").classed(dataLabelViewModel1Consts.u9.class, !0), 
                this.labelGraphicsContext = svg.append("g").classed(dataLabelViewModel1Consts.ZL.class, !0), 
                this.sliceLayout = d3.pie().value(function(d) {
                    return d.value;
                }), this.arc = d3.arc(), this.style = style, this.clearMaxDataPointRadius(), this.dataLabelsSettings = (0, 
                mapUtil.BP)(this.style), this.tooltipService = tooltipService;
            }, MapBubbleDataPointRenderer.prototype.clearHeatMap = function() {
                this.mapControl && this.mapControl.layers.clear(), this.heatMapLayer && (this.heatMapLayer.clear(), 
                this.heatMapLayer.dispose(), this.heatMapLayer = void 0);
            }, MapBubbleDataPointRenderer.prototype.setData = function(data) {
                this.mapData = data;
            }, MapBubbleDataPointRenderer.prototype.clearDataPoints = function() {
                this.style && (this.mapData = (0, mapUtil.IG)(this.style), this.clearHeatMap());
            }, MapBubbleDataPointRenderer.prototype.hideDataPoints = function() {
                this.svg.style("display", "none");
            }, MapBubbleDataPointRenderer.prototype.showDataPoints = function() {
                this.svg.style("display", "");
            }, MapBubbleDataPointRenderer.prototype.getDataPointCount = function() {
                return this.mapData ? _.filter(this.mapData.dataPoints, function(value) {
                    return !!value.location;
                }).length : 0;
            }, MapBubbleDataPointRenderer.prototype.getDataPointPadding = function() {
                return 2 * this.maxDataPointRadius;
            }, MapBubbleDataPointRenderer.prototype.clearMaxDataPointRadius = function() {
                this.maxDataPointRadius = 0;
            }, MapBubbleDataPointRenderer.prototype.setMaxDataPointRadius = function(dataPointRadius) {
                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
            }, MapBubbleDataPointRenderer.prototype.converter = function(viewport, labelSettings, interactivityService, tooltipsEnabled) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var mapControl = this.mapControl, widthOverTwo = viewport.width / 2, heightOverTwo = viewport.height / 2;
                this.dataLabelsSettings = labelSettings;
                var radiusScale = Math.min(viewport.width, viewport.height) / 384;
                this.clearMaxDataPointRadius();
                var bubbleData = [], sliceData = [], dataPoints = this.mapData ? this.mapData.dataPoints : [], hasSize = this.mapData && this.mapData.hasSize;
                this.navigableDataPoints = void 0;
                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var dataPoint = dataPoints[categoryIndex], categoryValue = dataPoint.categoryValue, location_1 = dataPoint.location;
                    if (location_1) {
                        if ((0, mapUtil.N2)(location_1, !0)) continue;
                        var xy = mapControl.tryLocationToPixel(new Microsoft.Maps.Location(location_1.latitude, location_1.longitude));
                        if (!xy) {
                            debug.fF.assertFail("tryLocationToPixel failed with the following location: " + JSON.stringify(location_1));
                            continue;
                        }
                        var x = xy.x + widthOverTwo, y = xy.y + heightOverTwo, radius = dataPoint.radius * radiusScale;
                        this.setMaxDataPointRadius(radius);
                        var subDataPoints = dataPoint.subDataPoints, subsliceCount = subDataPoints.length;
                        if (1 === subsliceCount) bubbleData.push({
                            x,
                            y,
                            labeltext: categoryValue,
                            radius,
                            fill: (subDataPoint = subDataPoints[0]).fill,
                            stroke: subDataPoint.stroke,
                            strokeWidth: 1,
                            tooltipInfo: subDataPoint.tooltipInfo,
                            identity: subDataPoint.identity,
                            selected: !1,
                            labelFill: labelSettings.fontProperties.color,
                            categoryIndex,
                            seriesIndex: subDataPoint.seriesIndex
                        }); else {
                            for (var slices = [], subsliceIndex = 0; subsliceIndex < subsliceCount; subsliceIndex++) {
                                var subDataPoint;
                                debug.fF.assertValue(subDataPoint = subDataPoints[subsliceIndex], "Map's subdataPoint array should not be sparse."), 
                                slices.push({
                                    x,
                                    y,
                                    labeltext: categoryValue,
                                    radius,
                                    fill: subDataPoint.fill,
                                    stroke: subDataPoint.stroke,
                                    strokeWidth: 1,
                                    value: hasSize ? subDataPoint.value : 1,
                                    tooltipInfo: subDataPoint.tooltipInfo,
                                    identity: subDataPoint.identity,
                                    selected: !1,
                                    labelFill: labelSettings.fontProperties.color,
                                    categoryIndex,
                                    seriesIndex: subDataPoint.seriesIndex
                                });
                            }
                            interactivityService && interactivityService.applySelectionStateToData(slices), 
                            sliceData.push(slices);
                        }
                    }
                }
                return interactivityService && interactivityService.applySelectionStateToData(bubbleData), 
                {
                    bubbleData,
                    sliceData
                };
            }, MapBubbleDataPointRenderer.prototype.updateInternal = function(data, viewport, dataChanged, interactivityService, redrawDataLabels, behavior) {
                return debug.fF.assertValue(viewport, "viewport"), this.mapRendererData = data, 
                this.svg && this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                this.mapData && this.mapData.properties.showHeatMap ? this.renderHeatMapLayer(data) : this.render(data, viewport, dataChanged, interactivityService, redrawDataLabels);
            }, MapBubbleDataPointRenderer.getHeatMapLocations = function(dataPoints, heatMapOptions) {
                var locs = [], multiplied = !1, nonNullDataPoints = _.filter(dataPoints, function(dp) {
                    return null != dp.value;
                });
                if (!_.isEmpty(nonNullDataPoints)) {
                    var values = _.map(nonNullDataPoints, function(dp) {
                        return dp.value;
                    }), minSize_1 = _.min(values), range_1 = _.max(values) - minSize_1;
                    if (range_1 > 0) {
                        heatMapOptions.intensity = .1;
                        for (var dpMultipliers = _.map(nonNullDataPoints, function(dp) {
                            return Math.round((dp.value - minSize_1) / range_1 * 9 + 1);
                        }), i = 0; i < nonNullDataPoints.length; i++) for (var dp = nonNullDataPoints[i], mult = dpMultipliers[i], j = 0; j < mult; j++) locs.push(new Microsoft.Maps.Location(dp.location.latitude, dp.location.longitude));
                        multiplied = !0;
                    }
                }
                return multiplied || (locs = _.map(dataPoints, function(dp) {
                    return new Microsoft.Maps.Location(dp.location.latitude, dp.location.longitude);
                })), locs;
            }, MapBubbleDataPointRenderer.prototype.getPlotAreaLassoSurface = function() {
                return this.svg;
            }, MapBubbleDataPointRenderer.prototype.renderHeatMapLayer = function(data) {
                var heatMapOptions, _this = this;
                this.hideDataPoints(), this.mapData.properties.heatMapOptions && ((heatMapOptions = _.clone(this.mapData.properties.heatMapOptions)).intensity = .5);
                var dpWithLocation = _.filter(this.mapData.dataPoints, function(dp) {
                    return null != dp.location;
                }), locs = MapBubbleDataPointRenderer.getHeatMapLocations(dpWithLocation, heatMapOptions);
                return Microsoft.Maps.loadModule("Microsoft.Maps.HeatMap", function() {
                    _this.heatMapLayer ? (_this.heatMapLayer.clear(), _this.heatMapLayer.setLocations(locs), 
                    _this.heatMapLayer.setOptions(heatMapOptions)) : (_this.heatMapLayer = new Microsoft.Maps.HeatMapLayer(locs, heatMapOptions), 
                    _this.mapControl.layers.insert(_this.heatMapLayer));
                }), {
                    bubbleEventGroup: this.bubbleGraphicsContext,
                    sliceEventGroup: this.sliceGraphicsContext,
                    bubbles: null,
                    slices: null,
                    clearCapture: this.clearCapture,
                    dataPoints: null,
                    root: this.root,
                    navigationEntry: this.clearCapture && this.clearCapture[0] ? this.clearCapture[0][0] : null,
                    visualInstanceId: this.host.instanceId,
                    eventManager: this.eventManager,
                    hostServices: this.host
                };
            }, MapBubbleDataPointRenderer.prototype.render = function(data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                var arc = this.arc, hasSelection = interactivityService && interactivityService.hasSelection(), isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                this.heatMapLayer && this.heatMapLayer.clear(), this.showDataPoints();
                var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function(d) {
                    return d.identity.getKey();
                }), mouseEventHandler = new MapItemMouseEventHandler(this.mapControl, this.tooltipService), bubbleUpdate = bubbles.enter().append("circle").classed("bubble", !0).merge(bubbles);
                bubbleUpdate.classed(renderUtil.Pg, !isEdgeOrIE && !!interactivityService).attr("cx", function(d) {
                    return d.x;
                }).attr("cy", function(d) {
                    return d.y;
                }).attr("r", function(d) {
                    return d.radius;
                }).attr("tabindex", interactivityService ? 0 : null).attr("focusable", !!interactivityService).attr("aria-selected", function(d) {
                    return d.selected;
                }).attr("role", "option").attr("aria-label", this.pointLabelText).style("fill", function(d) {
                    return d.fill;
                }).style("stroke", function(d) {
                    return d.stroke;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, !1, hasSelection, !1);
                }).style("strokeWidth", function(d) {
                    return d.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, !1, hasSelection, !1);
                }).on("mousedown.drag", function() {
                    return mouseEventHandler.onMouseDown(d3.event.target);
                }), bubbles.exit().remove(), this.tooltipsEnabled && (this.tooltipService.addTooltip(this.bubbleGraphicsContext, function(args) {
                    return debug.fF.assertValue(args.data, "Bubble map data for tooltip"), args.data && args.data.tooltipInfo;
                }, function(args) {
                    return args.data && args.data.identity && [ args.data.identity ];
                }), bubbleUpdate.style("pointer-events", "all"));
                var sliceData = data.sliceData, sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData), sliceContainerUpdate = sliceContainers.enter().append("g").classed("sliceContainer", !0).merge(sliceContainers);
                sliceContainers.exit().remove();
                var sliceLayout = this.sliceLayout, slices = sliceContainerUpdate.selectAll(".slice").data(function(d) {
                    return sliceLayout(d);
                }, function(d) {
                    return d.data.identity.getKey();
                }), sliceUpdate = slices.enter().append("path").classed("slice", !0).merge(slices);
                sliceUpdate.classed(renderUtil.Pg, !isEdgeOrIE && !!interactivityService).style("fill", function(t) {
                    return t.data.fill;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, hasSelection, !1);
                }).style("stroke", function(t) {
                    return t.data.stroke;
                }).style("strokeWidth", function(t) {
                    return t.data.strokeWidth;
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, hasSelection, !1);
                }).style("cursor", "default").attr("transform", function(t) {
                    return (0, svgUtil.Iu)(t.data.x, t.data.y);
                }).attr("d", function(t) {
                    return arc.innerRadius(0).outerRadius(function(t) {
                        return t.data.radius;
                    })(t);
                }).attr("tabindex", interactivityService ? 0 : null).attr("focusable", !!interactivityService).on("mousedown.drag", function() {
                    return mouseEventHandler.onMouseDown(d3.event.target);
                }), slices.exit().remove(), this.updateInternalDataLabels(viewport, redrawDataLabels), 
                this.tooltipsEnabled && (this.tooltipService.addTooltip(this.sliceGraphicsContext, function(args) {
                    return debug.fF.assertValue(args.data, "Bubble map slice data for tooltip"), args.data && args.data.data && args.data.data.tooltipInfo;
                }, function(args) {
                    return args.data && args.data.data && [ args.data.data.identity ];
                }), sliceUpdate.style("pointer-events", "all"));
                for (var allData = data.bubbleData.slice(), i = 0, ilen = sliceData.length; i < ilen; i++) allData.push.apply(allData, sliceData[i]);
                return {
                    root: this.root,
                    bubbleEventGroup: this.bubbleGraphicsContext,
                    sliceEventGroup: this.sliceGraphicsContext,
                    bubbles: _.isEmpty(data.bubbleData) ? null : bubbleUpdate,
                    slices: _.isEmpty(data.sliceData) ? null : sliceUpdate,
                    clearCapture: this.clearCapture,
                    dataPoints: allData,
                    navigationEntry: this.clearCapture && this.clearCapture[0] ? this.clearCapture[0][0] : null,
                    visualInstanceId: this.host.instanceId,
                    hitTester: new MapBubbleHitTester({
                        dataPoints: allData
                    }),
                    eventManager: this.eventManager,
                    hostServices: this.host
                };
            }, MapBubbleDataPointRenderer.prototype.updateInternalDataLabels = function(viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings, dataLabels = [];
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    dataLabels = new labelLayout1.nu({
                        maximumOffset: dataLabelViewModel1Consts.wh,
                        startingOffset: dataLabelViewModel1Consts.ki
                    }).layout([ {
                        labelDataPoints,
                        maxNumberOfLabels: labelDataPoints.length
                    } ], {
                        width: viewport.width,
                        height: viewport.height
                    });
                }
                (0, dataLabelRendererEnhanced.gm)({
                    labelContext: this.labelGraphicsContext,
                    dataLabels,
                    backgroundContext: this.labelBackgroundGraphicsContext,
                    numeric: !1,
                    formatMode: !1,
                    onObject: !1
                });
            }, MapBubbleDataPointRenderer.prototype.createLabelDataPoints = function() {
                var data = this.mapRendererData, labelDataPoints = [], dataPoints = data.bubbleData;
                dataPoints = dataPoints.concat(_.map(data.sliceData, function(value) {
                    return value[0];
                }));
                for (var labelSettings = this.dataLabelsSettings, defaultInsideLabelColor = common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.pl), _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i];
                    debug.fF.assertValue(dataPoint, "dataPoint should never be null/undefined");
                    var text = dataPoint.labeltext, fontProperties = labelSettings.fontProperties, properties = (0, 
                    common_fontProperties.qk)(fontProperties, text), textWidth = textMeasurementService.b.measureSvgTextWidth(properties), textHeight = textMeasurementService.b.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: !0,
                        text,
                        textSize: {
                            width: textWidth,
                            height: textHeight
                        },
                        outsideFill: fontProperties.color ? fontProperties.color : defaultInsideLabelColor,
                        insideFill: fontProperties.color ? fontProperties.color : defaultInsideLabelColor,
                        parentType: 0,
                        parentShape: {
                            point: {
                                x: dataPoint.x,
                                y: dataPoint.y
                            },
                            radius: dataPoint.radius,
                            validPositions: MapBubbleDataPointRenderer.validLabelPositions
                        },
                        fontProperties,
                        identity: void 0,
                        hasBackground: labelSettings.enableBackground,
                        backgroundColor: labelSettings.backgroundColor,
                        backgroundTransparency: labelSettings.backgroundTransparency
                    });
                }
                return labelDataPoints;
            }, MapBubbleDataPointRenderer.prototype.getNavigationOptions = function() {
                return {
                    helper: this,
                    navigationStrategy: this.navigationStrategy
                };
            }, MapBubbleDataPointRenderer.prototype.getFirstElement = function() {
                this.navigableDataPoints = this.flattenViewModel();
                var firstDataPoint = _.find(this.navigableDataPoints, function(d) {
                    return !!d;
                });
                return {
                    element: this.getHtmlElementFromDataPoint(firstDataPoint)
                };
            }, MapBubbleDataPointRenderer.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                _.isEmpty(this.navigableDataPoints) && (this.navigableDataPoints = this.flattenViewModel());
                var nextDataPoint = (0, navigationUtils.R)(this.navigableDataPoints, categoryIndex, seriesIndex, interactivityService.jN.CategoryFirst, direction);
                return {
                    element: this.getHtmlElementFromDataPoint(nextDataPoint)
                };
            }, MapBubbleDataPointRenderer.prototype.flattenViewModel = function() {
                var dataPoints = [];
                if (this.mapRendererData.bubbleData && !_.isEmpty(this.mapRendererData.bubbleData)) {
                    for (var _i = 0, _a = this.mapRendererData.bubbleData; _i < _a.length; _i++) {
                        var mapBubble = _a[_i];
                        dataPoints.push({
                            categoryIndex: mapBubble.categoryIndex,
                            seriesIndex: mapBubble.seriesIndex
                        });
                    }
                    return dataPoints;
                }
                if (this.mapRendererData.sliceData && !_.isEmpty(this.mapRendererData.sliceData)) {
                    for (var _b = 0, _c = this.mapRendererData.sliceData; _b < _c.length; _b++) for (var _d = 0, mapSlices_1 = _c[_b]; _d < mapSlices_1.length; _d++) {
                        var mapSlice = mapSlices_1[_d];
                        dataPoints.push({
                            categoryIndex: mapSlice.categoryIndex,
                            seriesIndex: mapSlice.seriesIndex
                        });
                    }
                    return dataPoints;
                }
            }, MapBubbleDataPointRenderer.prototype.getHtmlElementFromDataPoint = function(dataPoint) {
                return this.bubbleGraphicsContext.selectAll(".bubble").filter(function(d) {
                    return d.seriesIndex === dataPoint.seriesIndex && d.categoryIndex === dataPoint.categoryIndex;
                }).node() || this.sliceGraphicsContext.selectAll(".slice").filter(function(d) {
                    return d.data.seriesIndex === dataPoint.seriesIndex && d.data.categoryIndex === dataPoint.categoryIndex;
                }).node() || (debug.fF.assertFail("An html element couldn't be found for the given data point in MapBubbleDataPointRenderer.getHtmlElementFromDataPoint()."), 
                null);
            }, MapBubbleDataPointRenderer.validLabelPositions = [ 1, 2, 4, 8 ], MapBubbleDataPointRenderer;
        }(), MapBubbleHitTester = function() {
            function MapBubbleHitTester(options) {
                this.dataPoints = options.dataPoints;
            }
            return MapBubbleHitTester.prototype.queryRegion = function(rect) {
                return _.filter(this.dataPoints, function(point) {
                    return shapes7.m.circleRectangleOverlap(rect, {
                        x: point.x,
                        y: point.y
                    }, point.radius);
                });
            }, MapBubbleHitTester;
        }(), common_transform = __webpack_require__(65673), filledMapLabelLayout = __webpack_require__(72494), strokePattern = __webpack_require__(47316);
        function generatePointsFromBounds(rect, generatorFunction, pointArray, adjustmentArray) {
            debug.fF.assert(function() {
                return 8 === pointArray.length;
            }, "Array length should be 8 to match a rectangular shape"), debug.fF.assert(function() {
                return !adjustmentArray || 8 === adjustmentArray.length;
            }, "Array length should be 8 to match a rectangular shape");
            for (var success = !0, xBounds = [ rect.left, rect.right ], yBounds = [ rect.top, rect.bottom ], getCurrentVerticalPosition = function(xIndex, yIndex) {
                return 0 === xIndex ? yIndex : 1 - yIndex;
            }, xIndex = 0; xIndex < xBounds.length; xIndex++) for (var yIndex = 0; yIndex < yBounds.length; yIndex++) {
                var arrayPositionStart = 4 * xIndex + 2 * yIndex;
                generatorFunction(xBounds[xIndex], yBounds[getCurrentVerticalPosition(xIndex, yIndex)], arrayPositionStart, pointArray, adjustmentArray) || (success = !1);
            }
            return success;
        }
        function getPolygonFromBoundingRect(rect) {
            var pointArray = new Float64Array(8);
            return generatePointsFromBounds(rect, function(x, y, currentIndex, pointArray) {
                return pointArray[currentIndex] = x, pointArray[currentIndex + 1] = y, !0;
            }, pointArray), new shapes7.m(pointArray);
        }
        var MapShapeDataPointRenderer = function() {
            function MapShapeDataPointRenderer(fillMapDataLabelsEnabled, tooltipsEnabled) {
                this.navigationStrategy = interactivityService.jN.CategoryFirst, this.filledMapDataLabelsEnabled = fillMapDataLabelsEnabled, 
                this.tooltipsEnabled = tooltipsEnabled;
            }
            return MapShapeDataPointRenderer.buildPaths = function(locations) {
                var paths = [];
                if (!_.isEmpty(locations)) for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
                    var location_1 = locations_1[_i], polygon = location_1.geographic;
                    polygon && polygon.length > 2 && paths.push(location_1);
                }
                return paths;
            }, MapShapeDataPointRenderer.prototype.init = function(mapControl, mapDiv, setClearCapture, tooltipService, style, interactivityService, host, eventManager) {
                this.host = host, this.mapControl = mapControl, this.polygonInfo = new mapUtil.n9;
                var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                this.eventManager = eventManager, this.pointLabelText = this.host.getLocalizedString("Generic_Point");
                var root = this.root = d3.select(mapDiv[0]);
                root.attr("drag-resize-disabled", "true").attr("tabindex", -1).attr("focusable", !1);
                var svg = this.svg = root.append("svg").style("position", "absolute").style("pointer-events", "none").classed(mapUtil.nv, !isEdgeOrIE);
                interactivityService && svg.attr("tabindex", 0).attr("focusable", !0).attr("aria-label", host.getLocalizedString("Visual_Plot")).attr("focus-nav-mode", "Hierarchy").attr("aria-multiselectable", "true").attr("role", "listbox").classed(renderUtil.Pg, !isEdgeOrIE), 
                setClearCapture && (this.clearCapture = root), this.shapeGraphicsContext = svg.append("g").classed("mapShapes", !0), 
                this.labelGraphicsContext = svg.append("g").classed(dataLabelViewModel1Consts.ZL.class, !0), 
                this.style = style, this.clearMaxShapeDimension(), this.dataLabelsSettings = (0, 
                mapUtil.BP)(this.style), this.tooltipService = tooltipService;
            }, MapShapeDataPointRenderer.prototype.setData = function(data) {
                this.mapData = data;
            }, MapShapeDataPointRenderer.prototype.clearDataPoints = function() {
                this.style && (this.mapData = (0, mapUtil.IG)(this.style));
            }, MapShapeDataPointRenderer.prototype.hideDataPoints = function() {
                this.svg.style("display", "none");
            }, MapShapeDataPointRenderer.prototype.showDataPoints = function() {
                this.svg.style("display", "");
            }, MapShapeDataPointRenderer.prototype.getDataPointCount = function() {
                return this.mapData ? _.filter(this.mapData.dataPoints, function(value) {
                    return !!value.paths;
                }).length : 0;
            }, MapShapeDataPointRenderer.prototype.converter = function(viewport, labelSettings, interactivityService, tooltipsEnabled, dataChanged) {
                if (void 0 === tooltipsEnabled && (tooltipsEnabled = !0), void 0 === dataChanged && (dataChanged = !0), 
                !dataChanged && this.mapRendererData) return this.mapRendererData;
                this.navigableDataPoints = void 0, this.clearMaxShapeDimension(), this.dataLabelsSettings = labelSettings;
                for (var shapeData = [], dataPoints = this.mapData ? this.mapData.dataPoints : [], categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var dataPoint = dataPoints[categoryIndex], subDataPoint = dataPoint.subDataPoints[0], paths = dataPoint.paths;
                    if (!_.isEmpty(paths)) {
                        for (var value = dataPoint.value, categoryValue = dataPoint.categoryValue, identity = subDataPoint.identity, idKey = identity.getKey(), globalBoundingRect = void 0, pathsWithBounds = void 0, pathIndex = paths.length; pathIndex-- > 0; ) {
                            var path = paths[pathIndex];
                            if (path && path.absoluteBounds) {
                                this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                                var currentBoundingRect = {
                                    left: path.absoluteBounds.left,
                                    top: path.absoluteBounds.top,
                                    right: path.absoluteBounds.left + path.absoluteBounds.width,
                                    bottom: path.absoluteBounds.top + path.absoluteBounds.height
                                };
                                globalBoundingRect ? (currentBoundingRect.left < globalBoundingRect.left && (globalBoundingRect.left = currentBoundingRect.left), 
                                currentBoundingRect.top < globalBoundingRect.top && (globalBoundingRect.top = currentBoundingRect.top), 
                                currentBoundingRect.right > globalBoundingRect.right && (globalBoundingRect.right = currentBoundingRect.right), 
                                currentBoundingRect.bottom > globalBoundingRect.bottom && (globalBoundingRect.bottom = currentBoundingRect.bottom)) : (globalBoundingRect = {
                                    left: currentBoundingRect.left,
                                    top: currentBoundingRect.top,
                                    right: currentBoundingRect.right,
                                    bottom: currentBoundingRect.bottom
                                }, pathsWithBounds = []), pathsWithBounds.push({
                                    boundingRect: currentBoundingRect,
                                    path: path.absolute
                                });
                            } else debug.fF.assertFail("MapShapeRenderer.converter encountered an invalid path"), 
                            paths.splice(pathIndex, 1);
                        }
                        if (_.isEmpty(paths)) continue;
                        var mainShape = paths[MapShapeDataPointRenderer.getIndexOfLargestShape(paths)].absolute, combinedPath = _.map(paths, function(path) {
                            return (0, svgUtil.Ay)(path.absolute);
                        }).join(" "), reducedPath = void 0;
                        this.mapData.properties.showStroke && (reducedPath = _.map(paths, function(path) {
                            return (0, svgUtil.fg)(path.absolute, MapShapeDataPointRenderer.ReducedPathScale);
                        }).join(" ")), shapeData.push({
                            mainShapePointArray: mainShape,
                            path: combinedPath,
                            reducedPath,
                            fill: subDataPoint.fill,
                            stroke: subDataPoint.stroke,
                            strokeWidth: 1,
                            tooltipInfo: subDataPoint.tooltipInfo,
                            identity,
                            selected: !1,
                            key: JSON.stringify({
                                id: idKey
                            }),
                            labeltext: categoryValue,
                            catagoryLabeltext: null != value ? value.toString() : void 0,
                            categoryIndex,
                            seriesIndex: subDataPoint.seriesIndex,
                            absoluteCenter: {
                                x: (globalBoundingRect.left + globalBoundingRect.right) / 2,
                                y: (globalBoundingRect.top + globalBoundingRect.bottom) / 2
                            },
                            globalBoundingRect,
                            pathsWithBounds
                        });
                    }
                }
                return interactivityService && interactivityService.applySelectionStateToData(shapeData), 
                {
                    shapeData
                };
            }, MapShapeDataPointRenderer.prototype.useReducedPaths = function(scale) {
                return this.mapData.properties.showStroke && scale < MapShapeDataPointRenderer.ReducedPathScaleLimit;
            }, MapShapeDataPointRenderer.prototype.updateInternal = function(data, viewport, dataChanged, interactivityService, redrawDataLabels, behavior) {
                debug.fF.assertValue(viewport, "viewport"), this.mapRendererData = data, this.svg && this.svg.style("width", viewport.width.toString() + "px").style("height", viewport.height.toString() + "px"), 
                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
                var zoomScale = this.polygonInfo.scale, absTransform = this.polygonInfo.transform, absMapSize = (0, 
                mapUtil.oT)(), transform = absTransform, mapSize = absMapSize, useReducedPaths = this.useReducedPaths(zoomScale);
                if (useReducedPaths) {
                    var mtx = _.clone(transform.matrix);
                    mtx.m00 = mtx.m11 = zoomScale / MapShapeDataPointRenderer.ReducedPathScale, transform = new common_transform.wx(mtx), 
                    mapSize = (0, mapUtil.x6)(MapShapeDataPointRenderer.ReducedPathZoomLevel);
                }
                this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(transform));
                var applyOffset = function(subCondition, addCondition, offset) {
                    return subCondition ? -offset : addCondition ? offset : 0;
                }, viewCenterX = viewport.width / 2, translateX = function(d, absMapSize, offset) {
                    var center = absTransform.applyToPoint(d.absoluteCenter), centerLeft = absTransform.applyToPoint({
                        x: d.absoluteCenter.x - absMapSize,
                        y: d.absoluteCenter.y
                    }), centerRight = absTransform.applyToPoint({
                        x: d.absoluteCenter.x + absMapSize,
                        y: d.absoluteCenter.y
                    }), diff = Math.abs(center.x - viewCenterX), diffLeft = Math.abs(centerLeft.x - viewCenterX), diffRight = Math.abs(centerRight.x - viewCenterX);
                    return applyOffset(diffLeft < diff, diffRight < diff, offset);
                }, shapes = this.shapeGraphicsContext.selectAll("path").data(data.shapeData, function(d) {
                    return d.key;
                }).style("transform", function(d) {
                    return "translateX(".concat(translateX(d, absMapSize, mapSize), "px)");
                }), pathsToUse = useReducedPaths ? function(d) {
                    return d.reducedPath;
                } : function(d) {
                    return d.path;
                }, mouseEventHandler = new MapItemMouseEventHandler(this.mapControl, this.tooltipService), shapeUpdate = shapes.enter().append("path").classed("shape", !0).attr("aria-selected", function(d) {
                    return d.selected;
                }).attr("role", "option").attr("aria-label", this.pointLabelText).attr("d", pathsToUse).on("mousedown.drag", function() {
                    return mouseEventHandler.onMouseDown(d3.event.target);
                }).merge(shapes), widthDivisor = useReducedPaths ? zoomScale / MapShapeDataPointRenderer.ReducedPathScale : this.polygonInfo.scale, hasSelection = interactivityService && interactivityService.hasSelection();
                shapeUpdate.classed(renderUtil.Pg, !!interactivityService).attr("tabindex", interactivityService ? 0 : null).attr("focusable", !!interactivityService).style("fill", function(d) {
                    return d.fill;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.selected, !1, hasSelection, !1);
                }).style("outline-width", "".concat(1 / widthDivisor, "px"));
                var strokeFn, strokeWidthFn, strokeColor = this.mapData.properties.strokeColor, strokeWidth = this.mapData.properties.strokeWidth;
                this.style.isHighContrast ? (strokeFn = function(d) {
                    return d.stroke;
                }, strokeWidthFn = function(d) {
                    return d.strokeWidth / widthDivisor;
                }) : this.mapData.properties.showStroke ? (strokeFn = function(d) {
                    return strokeColor || d.stroke;
                }, strokeWidthFn = function(d) {
                    return (strokeWidth || d.strokeWidth) / widthDivisor;
                }) : (strokeFn = null, strokeWidthFn = null), shapeUpdate.style("stroke", strokeFn).style("stroke-width", strokeWidthFn), 
                (dataChanged || this.lastRenderUsedReducedPaths !== useReducedPaths) && shapeUpdate.attr("d", pathsToUse), 
                this.lastRenderUsedReducedPaths = useReducedPaths, shapes.exit().remove(), this.updateInternalDataLabels(viewport, redrawDataLabels);
                var hitTester = new MapShapeHitTester({
                    absMapSize,
                    applyOffset,
                    dataPoints: data.shapeData,
                    mapControl: this.mapControl,
                    offset: mapSize,
                    transform,
                    translateX,
                    viewport
                });
                if (dataChanged) return this.tooltipsEnabled && (this.tooltipService.addTooltip(this.shapeGraphicsContext, function(args) {
                    return debug.fF.assertValue(args.data, "Filled map data for tooltip"), args.data && args.data.tooltipInfo;
                }, function(args) {
                    return args.data && args.data.identity && [ args.data.identity ];
                }), shapeUpdate.style("pointer-events", "all")), {
                    root: this.root,
                    shapeEventGroup: this.shapeGraphicsContext,
                    shapes: shapeUpdate,
                    clearCapture: this.clearCapture,
                    dataPoints: data.shapeData,
                    navigationEntry: this.clearCapture && this.clearCapture[0] ? this.clearCapture[0][0] : null,
                    visualInstanceId: this.host.instanceId,
                    hitTester,
                    eventManager: this.eventManager,
                    hostServices: this.host,
                    widthDivisor
                };
                behavior && behavior.bindHitTester(hitTester);
            }, MapShapeDataPointRenderer.prototype.getDataPointPadding = function() {
                return 12;
            }, MapShapeDataPointRenderer.prototype.getEnclosingBounds = function() {
                var enclosing, dataPoints = this.mapData && this.mapData.dataPoints;
                if (!_.isEmpty(dataPoints)) for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var paths = dataPoints_1[_i].paths;
                    if (!_.isEmpty(paths)) for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
                        var path = paths_1[_a];
                        path.geographic && (enclosing = (0, mapUtil.wu)(enclosing, path.adjustedBounds));
                    }
                }
                return enclosing;
            }, MapShapeDataPointRenderer.getIndexOfLargestShape = function(paths) {
                for (var largestShapeIndex = 0, largestShapeArea = 0, pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                    var polygon = new shapes7.m(paths[pathIndex].absolute), currentShapeArea = Math.abs(shapes7.m.calculateAbsolutePolygonArea(polygon.polygonPoints));
                    currentShapeArea > largestShapeArea && (largestShapeIndex = pathIndex, largestShapeArea = currentShapeArea);
                }
                return largestShapeIndex;
            }, MapShapeDataPointRenderer.prototype.updateInternalDataLabels = function(viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings, labels = [];
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    void 0 === this.labelLayout && (this.labelLayout = new filledMapLabelLayout.Q), 
                    labels = this.labelLayout.layout(labelDataPoints, {
                        width: viewport.width,
                        height: viewport.height
                    }, this.polygonInfo.transform, redrawDataLabels);
                }
                this.drawLabelStems(this.labelGraphicsContext, labels), (0, dataLabelRendererEnhanced.ng)({
                    context: this.labelGraphicsContext,
                    dataLabels: labels,
                    onObject: !1
                }), (0, dataLabelRendererEnhanced.x5)({
                    labelContext: this.labelGraphicsContext,
                    dataLabels: labels,
                    twoRows: labelSettings.show && labelSettings.showCategory,
                    formatMode: !1,
                    onObject: !1
                });
            }, MapShapeDataPointRenderer.prototype.getPlotAreaLassoSurface = function() {
                return this.svg;
            }, MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function() {
                this.maxShapeDimension = 0;
            }, MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function(width, height) {
                this.maxShapeDimension = Math.max(width, this.maxShapeDimension), this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
            }, MapShapeDataPointRenderer.prototype.createLabelDataPoints = function() {
                var labelDataPoints = [];
                if (this.filledMapDataLabelsEnabled) for (var labelSettings = this.dataLabelsSettings, _i = 0, dataShapes_1 = this.mapRendererData.shapeData; _i < dataShapes_1.length; _i++) {
                    var dataShape = dataShapes_1[_i], text = void 0, secondRowText = void 0, secondRowTextWidth = 0, hasSecondRow = !1;
                    if (this.dataLabelsSettings.show && !this.dataLabelsSettings.showCategory) {
                        if (void 0 === (text = dataShape.catagoryLabeltext)) continue;
                    } else if (this.dataLabelsSettings.showCategory && !this.dataLabelsSettings.show) {
                        if (void 0 === (text = dataShape.labeltext)) continue;
                    } else if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) {
                        if (secondRowText = dataShape.labeltext, void 0 === (text = dataShape.catagoryLabeltext) && void 0 === secondRowText) continue;
                        hasSecondRow = !0;
                    }
                    var defaultFontProperties = (0, dataLabelViewModel1.bT)({
                        style: this.style,
                        textClassName: "smallLightLabel",
                        noColor: !0
                    }).fontProperties;
                    if (hasSecondRow) {
                        var secondRowProperties = (0, common_fontProperties.qk)(defaultFontProperties, secondRowText);
                        secondRowTextWidth = textMeasurementService.b.measureSvgTextWidth(secondRowProperties);
                    }
                    var firstRowProperties = (0, common_fontProperties.qk)(defaultFontProperties, text), textWidth = textMeasurementService.b.measureSvgTextWidth(firstRowProperties), textHeight = textMeasurementService.b.estimateSvgTextHeight(firstRowProperties);
                    secondRowText && void 0 !== dataShape.labeltext && void 0 !== dataShape.catagoryLabeltext && (textHeight *= 2);
                    var defaultInsideLabelColor = common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.pl), labelDataPoint = {
                        parentType: 2,
                        parentShape: {
                            polygon: new shapes7.m(dataShape.mainShapePointArray),
                            validPositions: MapShapeDataPointRenderer.validLabelPolygonPositions
                        },
                        text,
                        secondRowText,
                        textSize: {
                            width: Math.max(textWidth, secondRowTextWidth),
                            height: textHeight
                        },
                        insideFill: labelSettings.fontProperties.color,
                        outsideFill: labelSettings.fontProperties.color ? labelSettings.fontProperties.color : defaultInsideLabelColor,
                        isPreferred: !1,
                        identity: void 0,
                        hasBackground: !0,
                        fontProperties: labelSettings.fontProperties
                    };
                    labelDataPoints.push(labelDataPoint);
                }
                return labelDataPoints;
            }, MapShapeDataPointRenderer.prototype.drawLabelStems = function(labelsContext, dataLabels) {
                var leaderColor = common_colorHelper.v.getThemeColor(this.style, mapUtil.jj);
                dataLabels.map(function(labelDataPoint) {
                    labelDataPoint.leaderLine = {
                        strokeShow: !0,
                        strokeColor: leaderColor,
                        strokeWidth: 1,
                        strokeTransparency: 50,
                        strokePattern: strokePattern.Dv.solid,
                        strokeAutoScale: !1,
                        strokeDashCap: strokePattern.qH.none,
                        strokeDashArray: null
                    };
                }), (0, dataLabelRendererEnhanced.z8)(labelsContext, dataLabels, function(d, index) {
                    return d.identity ? d.identity.getKeyWithoutHighlight() : index;
                });
            }, MapShapeDataPointRenderer.prototype.getNavigationOptions = function() {
                return {
                    helper: this,
                    navigationStrategy: this.navigationStrategy
                };
            }, MapShapeDataPointRenderer.prototype.getFirstElement = function() {
                this.navigableDataPoints = this.flattenViewModel();
                var firstDataPoint = _.find(this.navigableDataPoints, function(d) {
                    return !!d;
                });
                return {
                    element: this.getHtmlElementFromDataPoint(firstDataPoint)
                };
            }, MapShapeDataPointRenderer.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                _.isEmpty(this.navigableDataPoints) && (this.navigableDataPoints = this.flattenViewModel());
                var nextDataPoint = (0, navigationUtils.R)(this.navigableDataPoints, categoryIndex, seriesIndex, interactivityService.jN.CategoryFirst, direction);
                return {
                    element: this.getHtmlElementFromDataPoint(nextDataPoint)
                };
            }, MapShapeDataPointRenderer.prototype.flattenViewModel = function() {
                var dataPoints = [];
                if (this.mapRendererData.shapeData) for (var _i = 0, _a = this.mapRendererData.shapeData; _i < _a.length; _i++) {
                    var mapShape = _a[_i];
                    dataPoints.push({
                        categoryIndex: mapShape.categoryIndex,
                        seriesIndex: mapShape.seriesIndex
                    });
                }
                return dataPoints;
            }, MapShapeDataPointRenderer.prototype.getHtmlElementFromDataPoint = function(dataPoint) {
                return this.shapeGraphicsContext.selectAll(".shape").filter(function(d) {
                    return d.categoryIndex === dataPoint.categoryIndex && d.seriesIndex === dataPoint.seriesIndex;
                }).node() || (debug.fF.assertFail("An html element couldn't be found for the given data point in MapShapeDataPointRenderer.getHtmlElementFromDataPoint()."), 
                null);
            }, MapShapeDataPointRenderer.validLabelPolygonPositions = [ 256, 2, 1, 8, 4, 16, 32, 64, 128 ], 
            MapShapeDataPointRenderer.ReducedPathScale = .0078125, MapShapeDataPointRenderer.ReducedPathScaleLimit = .03125, 
            MapShapeDataPointRenderer.ReducedPathZoomLevel = 4, MapShapeDataPointRenderer;
        }(), MapShapeHitTester = function() {
            function MapShapeHitTester(options) {
                this.absMapSize = options.absMapSize, this.applyOffset = options.applyOffset, this.lazyCalculateTranslations = !1, 
                this.mapControl = options.mapControl, this.offset = options.offset, this.originalDataPoints = options.dataPoints, 
                this.transform = options.transform, this.translateX = options.translateX, this.viewport = options.viewport;
            }
            return MapShapeHitTester.prototype.queryRegion = function(rect) {
                var rectPolygon = this.transformAndTranslateSelectionRectangle(rect);
                if (!rectPolygon) return [];
                this.lazyCalculateTranslations || (this.dataPoints = this.calculateTranslations(this.originalDataPoints), 
                this.lazyCalculateTranslations = !0);
                for (var selectedDataPoints = [], _i = 0, _a = this.dataPoints; _i < _a.length; _i++) {
                    var dataPoint = _a[_i], translatedSelect = shapes7.m.translateX(rectPolygon, -dataPoint.translation);
                    if (shapes7.m.polygonBoundsOverlap(translatedSelect, getPolygonFromBoundingRect(dataPoint.mapShape.globalBoundingRect))) for (var _b = 0, _c = dataPoint.mapShape.pathsWithBounds; _b < _c.length; _b++) {
                        var pathWithBounds = _c[_b];
                        if (shapes7.m.polygonBoundsOverlap(translatedSelect, getPolygonFromBoundingRect(pathWithBounds.boundingRect)) && translatedSelect.overlapPath(pathWithBounds.path)) {
                            selectedDataPoints.push(dataPoint.mapShape);
                            break;
                        }
                    }
                }
                return selectedDataPoints;
            }, MapShapeHitTester.prototype.transformAndTranslateSelectionRectangle = function(rect) {
                var _this = this, locationArray = new Float64Array(8), adjustmentArray = new Float64Array(8), dateLinePoint = {
                    x: 0,
                    y: 0
                }, dateLinePixelX = this.transform.applyToPoint(dateLinePoint).x;
                dateLinePoint.x += this.absMapSize;
                var nextDateLinePixelX = this.transform.applyToPoint(dateLinePoint).x;
                if (!generatePointsFromBounds(rect, function(x, y, currentIndex, pointArray, adjustmentArray) {
                    var point = new Microsoft.Maps.Point(x - _this.viewport.width / 2, y - _this.viewport.height / 2), location = _this.mapControl.tryPixelToLocation(point, Microsoft.Maps.PixelReference.viewport);
                    if (!location) return !1;
                    locationArray[currentIndex] = location.latitude, locationArray[currentIndex + 1] = location.longitude;
                    var translationAdjustment = _this.applyOffset(x < dateLinePixelX, x > nextDateLinePixelX, _this.offset);
                    return adjustmentArray[currentIndex] = translationAdjustment, adjustmentArray[currentIndex + 1] = 0, 
                    !0;
                }, locationArray, adjustmentArray)) return null;
                for (var absoluteRectArray = (0, mapUtil.Sc)(locationArray, this.absMapSize), index = 0; index < absoluteRectArray.length; index++) absoluteRectArray[index] += adjustmentArray[index];
                return new shapes7.m(absoluteRectArray);
            }, MapShapeHitTester.prototype.calculateTranslations = function(dataPoints) {
                for (var dataPointsWithTranslations = [], _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var dataPoint = dataPoints_2[_i];
                    dataPointsWithTranslations.push({
                        mapShape: dataPoint,
                        translation: this.translateX(dataPoint, this.absMapSize, this.offset)
                    });
                }
                return dataPointsWithTranslations;
            }, MapShapeHitTester;
        }(), parseNumber = Utility.b$.parseNumber, Map = function() {
            function Map(options) {
                this.isDestroyed = !1, this.warnings = [], this.maxLevelOfDetail = mapUtil.Ch, this.minLevelOfDetail = mapUtil.z8, 
                options.filledMap ? (this.dataPointRenderer = new MapShapeDataPointRenderer(options.filledMapDataLabelsEnabled, options.tooltipsEnabled), 
                this.filledMapDataLabelsEnabled = options.filledMapDataLabelsEnabled, this.isFilledMap = !0) : (this.dataPointRenderer = new MapBubbleDataPointRenderer(options.tooltipsEnabled), 
                this.isFilledMap = !1), this.mapCredentials = mapUtil.Zr.BingKey, this.mapControlFactory = options.mapControlFactory, 
                this.behavior = options.behavior, this.tooltipsEnabled = options.tooltipsEnabled, 
                this.disableZooming = options.disableZooming, this.disablePanning = options.disablePanning, 
                this.isLegendScrollable = !!options.behavior, this.viewChangeThrottleInterval = options.viewChangeThrottleInterval, 
                this.boundsHaveBeenUpdated = !1, this.rescaleMap = options.rescaleMap, this.shouldSetSavedLocation = !0, 
                this.dataPointLassoSelect = options.dataPointLassoSelect;
            }
            return Map.prototype.init = function(options) {
                debug.fF.assertValue(options, "options");
                var element = this.element = options.element;
                this.pendingGeocodingRender = 0, this.eventManager = new bubblingEventManager.B(d3.select(element.get(0))), 
                this.featureSwitches = options.featureSwitches, this.currentViewport = options.viewport, 
                this.currentViewport.scale = this.currentViewport.scale || 1, options.style || trace.f.assertFail("Map style is missing"), 
                this.style = options.style, this.host = options.host, this.behavior && (this.interactivityService = (0, 
                interactivityService.ub)(this.host, this.featureSwitches)), this.legend = (0, legend.OG)(element, !1, this.interactivityService, this.isLegendScrollable, void 0, this.style, this.host), 
                this.geoTaggingAnalyzerService = (0, geoTaggingAnalyzerService.P)().create(options.host.getLocalizedString.bind(options.host)), 
                this.tooltipService = (0, tooltipService.r)(this.host), this.host.locale && (this.locale = this.host.locale()), 
                this.geocoder = this.host.geocoder(), this.promiseFactory = this.host.promiseFactory(), 
                this.mapTheme = bingMapTheme1.uH, this.resetBounds(), this.isDestroyed = !1;
            }, Map.prototype.destroy = function() {
                this.isDestroyed = !0;
                var mapControl = this.mapControl;
                mapControl && (this.mapControl = void 0, setTimeout(function() {
                    return mapControl.dispose();
                }, Map.MapControlDisposeDelay)), this.geocodingContext && this.geocodingContext.timeout && this.geocodingContext.timeout.resolve(null);
            }, Map.prototype.addDataPoint = function(geocodingContext, dataPoint) {
                if (geocodingContext === this.geocodingContext) {
                    var bounds;
                    if (--geocodingContext.dataPointsRemaining, !_.isEmpty(dataPoint.paths)) for (var _i = 0, _a = dataPoint.paths; _i < _a.length; _i++) bounds = (0, 
                    mapUtil.wu)(bounds, _a[_i].adjustedBounds);
                    if (!bounds) {
                        var location_1 = dataPoint.location;
                        bounds = {
                            west: location_1.longitude,
                            east: location_1.longitude,
                            north: location_1.latitude,
                            south: location_1.latitude
                        };
                    }
                    this.updateBounds(bounds), this.scheduleRedraw();
                }
            }, Map.prototype.geocodingFailed = function(geocodingContext) {
                this.isDestroyed || geocodingContext !== this.geocodingContext || --geocodingContext.dataPointsRemaining <= 0 && this.scheduleRedraw();
            }, Map.prototype.scheduleRedraw = function() {
                var _this = this;
                debug.fF.assert(function() {
                    return _this.geocodingContext.dataPointsRemaining >= 0;
                }, "geocodingContext.dataPointsRemaining underflow"), this.pendingGeocodingRender && this.geocodingContext.dataPointsRemaining <= 0 && (clearTimeout(this.pendingGeocodingRender), 
                this.pendingGeocodingRender = 0), !this.pendingGeocodingRender && this.mapControl && (this.pendingGeocodingRender = setTimeout(function() {
                    _this.updateInternal(!0, !0), _this.pendingGeocodingRender = 0;
                }, this.geocodingContext.dataPointsRemaining <= 0 ? 0 : Map.ScheduleRedrawInterval));
            }, Map.prototype.enqueueGeoCode = function(geocodingContext, dataPoint, data) {
                var _this = this, completionFunction = function(location) {
                    _this.completeGeoCode(geocodingContext, dataPoint, location);
                };
                this.geocoder.tryGeocodeImmediate(dataPoint.queryLocation, 0, !!this.featureSwitches.bingGeocoderIndexedDB, this.host.geocoderIndexedDB()).then(function(location) {
                    _this.initiateGeocoding(location, completionFunction, dataPoint, geocodingContext, data);
                }, function(_error) {
                    _this.initiateGeocoding(void 0, completionFunction, dataPoint, geocodingContext, data);
                });
            }, Map.prototype.completeGeoCode = function(geocodingContext, dataPoint, location) {
                dataPoint.location = location, this.addDataPoint(geocodingContext, dataPoint);
            }, Map.prototype.enqueueGeoCodeAndGeoShape = function(geocodingContext, dataPoint, params, data) {
                var _this = this, completionFunction = function(location) {
                    _this.completeGeoCodeAndGeoShape(geocodingContext, dataPoint, params, location);
                };
                this.geocoder.tryGeocodeImmediate(dataPoint.queryLocation, 0, !!this.featureSwitches.bingGeocoderIndexedDB, this.host.geocoderIndexedDB()).then(function(location) {
                    _this.initiateGeocoding(location, completionFunction, dataPoint, geocodingContext, data);
                }, function(_error) {
                    _this.initiateGeocoding(void 0, completionFunction, dataPoint, geocodingContext, data);
                });
            }, Map.prototype.completeGeoCodeAndGeoShape = function(geocodingContext, dataPoint, params, location) {
                dataPoint.location = location, this.enqueueGeoShape(geocodingContext, dataPoint, params);
            }, Map.prototype.initiateGeocoding = function(location, completionFunction, dataPoint, geocodingContext, data) {
                var _this = this;
                location ? void 0 === location.latitude || void 0 === location.longitude ? this.geocodingFailed(geocodingContext) : completionFunction(location) : this.geocoder.geocode(dataPoint.queryLocation, 0, !!this.featureSwitches.bingGeocoderIndexedDB, this.host.geocoderIndexedDB(), {
                    timeout: geocodingContext.timeout.promise,
                    credentials: this.mapCredentials
                }).then(function(location) {
                    _this.isDestroyed || geocodingContext !== _this.geocodingContext || ((0, mapUtil.N2)(location, !0) ? (_this.warningsSet && !data.invalidLatLongCoordinatesFound && (_this.warnings.push(new visualWarnings.zI), 
                    _this.host.setWarnings(_this.warnings)), data.invalidLatLongCoordinatesFound = !0, 
                    _this.geocodingFailed(geocodingContext)) : completionFunction(location));
                }, function(_reason) {
                    return _this.geocodingFailed(geocodingContext);
                });
            }, Map.prototype.enqueueGeoShape = function(geocodingContext, dataPoint, params) {
                var _this = this;
                debug.fF.assertValue(dataPoint.location, "cachedLocation"), this.geocoder.tryGeocodeBoundaryImmediate({
                    latitude: dataPoint.location.latitude,
                    longitude: dataPoint.location.longitude,
                    category: this.geocodingCategory,
                    levelOfDetail: params.level,
                    maxGeoData: params.maxPolygons,
                    entityType: dataPoint.location.entityType
                }, 0, !!this.featureSwitches.bingGeocoderIndexedDB, this.host.geocoderIndexedDB()).then(function(result) {
                    _this.initiateGeoboundary(result, dataPoint, geocodingContext, params);
                }, function(_error) {
                    _this.initiateGeoboundary(void 0, dataPoint, geocodingContext, params);
                });
            }, Map.prototype.initiateGeoboundary = function(result, dataPoint, geocodingContext, params) {
                var _this = this;
                result ? this.completeGeoShape(geocodingContext, dataPoint, params, result) : this.geocoder.geocodeBoundary({
                    latitude: dataPoint.location.latitude,
                    longitude: dataPoint.location.longitude,
                    category: this.geocodingCategory,
                    levelOfDetail: params.level,
                    maxGeoData: params.maxPolygons,
                    entityType: dataPoint.location.entityType
                }, 0, !!this.featureSwitches.bingGeocoderIndexedDB, this.host.geocoderIndexedDB(), {
                    timeout: geocodingContext.timeout.promise,
                    credentials: this.mapCredentials
                }).then(function(result) {
                    !_this.isDestroyed && result && geocodingContext === _this.geocodingContext && _this.completeGeoShape(geocodingContext, dataPoint, params, result);
                }, function(_reason) {
                    return _this.geocodingFailed(geocodingContext);
                });
            }, Map.prototype.completeGeoShape = function(geocodingContext, dataPoint, params, result) {
                (0, mapUtil.Yb)(result.locations), dataPoint.paths = MapShapeDataPointRenderer.buildPaths(result.locations), 
                this.addDataPoint(geocodingContext, dataPoint);
            }, Map.prototype.getOptimumLevelOfDetail = function(width, height, range) {
                var dataPointCount = this.dataPointRenderer.getDataPointCount();
                if (0 === dataPointCount) return this.minLevelOfDetail;
                var threshold = this.dataPointRenderer.getDataPointPadding(), enclosingBounds = this.dataPointRenderer.getEnclosingBounds && this.dataPointRenderer.getEnclosingBounds();
                if (enclosingBounds) enclosingBounds.west = range.west, enclosingBounds.east = range.east; else if (1 === dataPointCount) {
                    var width_1;
                    switch (this.geocodingCategory) {
                      case mapUtil.yV.Continent:
                        width_1 = 130;
                        break;

                      case mapUtil.yV.CountryRegion:
                        width_1 = 90;
                        break;

                      case mapUtil.yV.StateOrProvince:
                        width_1 = 25;
                        break;

                      case mapUtil.yV.County:
                        width_1 = 3;
                        break;

                      case mapUtil.yV.City:
                        width_1 = .7;
                        break;

                      case mapUtil.yV.PostalCode:
                        width_1 = .3;
                        break;

                      case mapUtil.yV.Place:
                        width_1 = .1;
                        break;

                      default:
                        width_1 = .04;
                    }
                    enclosingBounds = {
                        west: range.west - width_1 / 2,
                        north: this.maxLatitude,
                        east: range.east + width_1 / 2,
                        south: this.minLatitude
                    };
                } else enclosingBounds = {
                    west: range.west,
                    north: this.maxLatitude,
                    east: range.east,
                    south: this.minLatitude
                };
                for (var levelOfDetail = mapUtil.Ch; levelOfDetail >= mapUtil.z8; levelOfDetail--) {
                    var minXmaxY = (0, mapUtil.Jy)(enclosingBounds.north, enclosingBounds.west, levelOfDetail, {
                        unconstrained: !0
                    }), maxXminY = (0, mapUtil.Jy)(enclosingBounds.south, enclosingBounds.east, levelOfDetail, {
                        unconstrained: !0
                    });
                    if (Math.abs(maxXminY.x - minXmaxY.x) + threshold <= width && Math.abs(minXmaxY.y - maxXminY.y) + threshold <= height) return levelOfDetail;
                }
                return this.minLevelOfDetail;
            }, Map.prototype.getMapView = function(width, height) {
                var longitudeRange = this.getSmallestEnclosingLongitudeRange(), midLongitude = (0, 
                mapUtil.q1)((longitudeRange.west + longitudeRange.east) / 2), levelOfDetail = this.getOptimumLevelOfDetail(width, height, longitudeRange);
                levelOfDetail <= mapUtil.z8 && (midLongitude = 0);
                var minXmaxY = (0, mapUtil.Jy)(this.maxLatitude, midLongitude, levelOfDetail), maxXminY = (0, 
                mapUtil.Jy)(this.minLatitude, midLongitude, levelOfDetail);
                return {
                    center: (0, mapUtil.n8)((minXmaxY.x + maxXminY.x) / 2, (maxXminY.y + minXmaxY.y) / 2, levelOfDetail),
                    levelOfDetail
                };
            }, Map.prototype.getSmallestEnclosingLongitudeRange = function() {
                var longitudes = this.longitudes;
                if (_.isEmpty(longitudes)) return {
                    west: 0,
                    east: 0
                };
                if (1 === longitudes.length) return {
                    west: longitudes[0].west,
                    east: longitudes[0].east
                };
                longitudes.sort(function(a, b) {
                    return a.west - b.west;
                });
                var minWest = longitudes[0].west, maxEast = _.maxBy(longitudes, function(longitude) {
                    return longitude.east;
                }).east;
                if (maxEast - minWest <= 180) return {
                    west: minWest,
                    east: maxEast
                };
                for (var bestWest = minWest, bestEast = maxEast, bestSize = bestEast - bestWest, i = 1; i < longitudes.length; ++i) {
                    minWest = longitudes[i].west;
                    var width = (maxEast = Math.max(maxEast, longitudes[i - 1].east + 360)) - minWest;
                    width < bestSize && (bestWest = minWest, bestEast = maxEast, bestSize = width);
                }
                return {
                    west: bestWest,
                    east: bestEast
                };
            }, Map.prototype.resetBounds = function() {
                this.boundsHaveBeenUpdated = !1, this.minLatitude = mapUtil.w6, this.maxLatitude = mapUtil.jv, 
                this.longitudes = [];
            }, Map.prototype.updateBounds = function(bounds) {
                var west = bounds.west, east = bounds.east, south = bounds.south, north = bounds.north, width = east - west;
                west = (0, mapUtil.q1)(west), this.longitudes.push({
                    west,
                    east: east = west + width
                }), this.boundsHaveBeenUpdated = !0, south < this.minLatitude && (this.minLatitude = south), 
                north > this.maxLatitude && (this.maxLatitude = north);
            }, Map.prototype.renderLegend = function(legendData) {
                this.legend.setPosition(legendData.position), this.legend.drawLegend({
                    data: legendData,
                    parentViewport: this.currentViewport
                });
            }, Map.calculateGroupSizes = function(categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                for (var seriesCount = grouped.length, i = 0, len = categorical.values[0].values.length; i < len; ++i) {
                    var groupTotal = null;
                    if (sizeMeasureIndex >= 0) for (var j = 0; j < seriesCount; ++j) {
                        var value = grouped[j].values[sizeMeasureIndex].values[i];
                        value && (null === groupTotal ? groupTotal = value : groupTotal += value);
                    }
                    groupSizeTotals.push(groupTotal), groupTotal && (currentValueScale ? (currentValueScale.min = Math.min(currentValueScale.min, groupTotal), 
                    currentValueScale.max = Math.max(currentValueScale.max, groupTotal)) : currentValueScale = {
                        min: groupTotal,
                        max: groupTotal
                    });
                }
                return currentValueScale;
            }, Map.calculateRadius = function(value, valueRange, rangeType, multiplier) {
                var _a, _b;
                if (void 0 === multiplier && (multiplier = 1), null == value || null == valueRange) return multiplier * Map.MarkerRadiusDefault;
                var minRadius = rangeType === markerRangeType.Dl.deprecated ? Map.MarkerRadiusDefault : Map.MarkerRadiusMin;
                rangeType === markerRangeType.Dl.auto && (rangeType = valueRange.min >= 0 || valueRange.max <= 0 ? markerRangeType.Dl.magnitude : markerRangeType.Dl.dataRange), 
                rangeType === markerRangeType.Dl.magnitude && (value && (value = Math.abs(value)), 
                valueRange = {
                    min: 0,
                    max: Math.max(null !== (_a = Math.abs(valueRange.max)) && void 0 !== _a ? _a : 0, null !== (_b = Math.abs(valueRange.min)) && void 0 !== _b ? _b : 0)
                });
                var valueRatio = ((value = Math.min(Math.max(value, valueRange.min), valueRange.max)) - valueRange.min) / (valueRange.max - valueRange.min || 1);
                return debug.fF.assert(function() {
                    return valueRatio >= 0 && valueRatio <= 1;
                }, "valueRatio must be between 0 and 1"), multiplier * ((Map.MarkerRadiusMax - minRadius) * Math.sqrt(valueRatio) + minRadius);
            }, Map.getGeocodingCategory = function(column, geoTaggingAnalyzerService) {
                var geotaggedResult;
                if (geotaggedResult = geoTaggingAnalyzerService.getFieldTypeFromDescriptor(column.type)) return geotaggedResult;
                if (geotaggedResult = geoTaggingAnalyzerService.getFieldType(column.displayName)) return geotaggedResult;
                var roles = column.roles;
                if (roles) for (var roleNames = Object.keys(roles), i = 0, len = roleNames.length; i < len; ++i) {
                    var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                    if (typeFromRoleName) return typeFromRoleName;
                }
            }, Map.hasSizeField = function(values, defaultIndexIfNoRole) {
                if (_.isEmpty(values)) return !1;
                for (var i = 0, ilen = values.length; i < ilen; i++) {
                    var roles = values[i].source.roles;
                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric) return !0;
                    if (roles) for (var roleNames = Object.keys(roles), j = 0, jlen = roleNames.length; j < jlen; j++) if ("Size" === roleNames[j]) return !0;
                }
                return !1;
            }, Map.shouldEnumerateDataPoints = function(dataView, usesSizeForGradient, mapProperties) {
                var hasSeries = (0, dataRoleHelper.c5)(dataView, "Series"), hasGradientRole = (0, 
                dataRoleHelper.c5)(dataView, usesSizeForGradient ? "Size" : "Gradient");
                return (hasSeries || !hasGradientRole) && !(mapProperties && mapProperties.showHeatMap);
            }, Map.shouldEnumerateHeatMap = function(legendData, isFilledMap) {
                return !(legendData && legendData.dataPoints && legendData.dataPoints.length > 1 || isFilledMap);
            }, Map.shouldEnumerateCategoryLabels = function(isFilledMap, filledMapDataLabelsEnabled, mapProperties) {
                return (!isFilledMap || filledMapDataLabelsEnabled) && !(mapProperties && mapProperties.showHeatMap);
            }, Map.prototype.getMapSettingsCard = function(hostService, mapProperties) {
                var _this = this, mapStylesProps = map_capabilities.jM.mapStyles, mapSettingsProps = (0, 
                tslib_es6.__assign)((0, tslib_es6.__assign)({}, map_capabilities.jM.mapControls), mapStylesProps), cardBuilder = new build_control_util.CQ(new build_control_util.lg("mapSettings"), "Visual_AzureMapsMapSettings", mapSettingsProps, function(key) {
                    return hostService.getLocalizedString(key);
                });
                return cardBuilder.addGroup("style", function(groupBuilder) {
                    groupBuilder.withDisplayName("Style"), groupBuilder.addSimpleSlice("style", new build_control_util.uY({
                        descriptor: mapSettingsProps.mapTheme,
                        value: mapProperties.mapTheme
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withCustomDisplayName("Style");
                    }).addSimpleSlice("showLabels", new build_control_util.bd({
                        descriptor: mapSettingsProps.showLabels,
                        value: mapProperties.showLabels
                    }).build());
                }), cardBuilder.addGroup("controls", function(groupBuilder) {
                    groupBuilder.withDisplayName("Controls"), groupBuilder.addSimpleSlice("autoZoom", new build_control_util.bd({
                        descriptor: mapSettingsProps.autoZoom,
                        value: mapProperties.autoZoomEnabled
                    }).build()).addSimpleSlice("showZoomButtons", new build_control_util.bd({
                        descriptor: mapSettingsProps.showZoomButtons,
                        value: mapProperties.showZoomButtons
                    }).build());
                    var shouldEnumerateHeatMap = Map.shouldEnumerateHeatMap(_this.data && _this.data.legendData, _this.isFilledMap);
                    !_this.plotLassoManager || shouldEnumerateHeatMap && mapProperties.showHeatMap || groupBuilder.addSimpleSlice("showLassoButton", new build_control_util.bd({
                        descriptor: mapSettingsProps.showLassoButton,
                        value: mapProperties.showLassoButton
                    }).build()), groupBuilder.addSimpleSlice("geocodingCulture", new build_control_util.uY({
                        descriptor: mapSettingsProps.geocodingCulture,
                        value: mapProperties.geocodingCulture || geocodingCulture.gA
                    }).build());
                }), cardBuilder.build();
            }, Map.prototype.getLegendCard = function(hostService, legendData, hasSeries, featureSwitches) {
                return (0, legend_formatting.ZF)({
                    legendData
                }, hostService, featureSwitches, !hasSeries);
            }, Map.prototype.getBubblesCard = function(mapProperties) {
                var _this = this, localize = function(key) {
                    return _this.host.getLocalizedString(key);
                }, bubbleProps = map_capabilities.jM.bubbles, dataPointProps = map_capabilities.jM.dataPoint, bubbleProperties = [ dataPointProps.fill, dataPointProps.showAllDataPoints, dataPointProps.defaultColor, bubbleProps.bubbleSize, bubbleProps.markerRangeType ], cardBuilder = new build_control_util.CQ(new build_control_util.lg("bubbles"), "Visual_Bubbles", bubbleProperties, localize);
                return cardBuilder.withDescription("Visual_BubblesDescription"), mapProperties && !mapProperties.showHeatMap && cardBuilder.addGroup("size", function(groupBuilder) {
                    var _a;
                    groupBuilder.withDisplayName("Role_DisplayName_Size");
                    var getLocalizedString = {
                        get: function(key) {
                            return _this.host.getLocalizedString(key);
                        },
                        getOptional: function(key) {
                            return _this.host.getLocalizedString(key);
                        },
                        format: function(key) {
                            return _this.host.getLocalizedString(key);
                        }
                    }, items = _.map(markerRangeType.Yu, function(enumValue) {
                        return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, enumValue), {
                            displayName: enumValue.displayName(getLocalizedString)
                        });
                    }), value = null !== (_a = items.find(function(item) {
                        return item.value === mapProperties.markerRangeType;
                    })) && void 0 !== _a ? _a : {
                        value: markerRangeType.Dl.deprecated,
                        displayName: _this.host.getLocalizedString("Visual_MarkerRangeType_Deprecated")
                    };
                    groupBuilder.addSimpleSlice("markerRangeType", new build_control_util.uY({
                        descriptor: bubbleProps.markerRangeType,
                        items,
                        value
                    }).build(), function(sliceBuilder) {
                        var _a;
                        return sliceBuilder.withDisabled(!(null === (_a = _this.data) || void 0 === _a ? void 0 : _a.hasSize));
                    }), groupBuilder.addSimpleSlice("size", new build_control_util.JN({
                        descriptor: bubbleProps.bubbleSize,
                        value: (0, shapeUtil.yn)(mapProperties.bubbleSizeMultiplier),
                        localize,
                        options: {
                            minValue: {
                                type: 0,
                                value: shapeUtil.Ad.min
                            },
                            maxValue: {
                                type: 1,
                                value: shapeUtil.Ad.max
                            }
                        }
                    }).build());
                }), this.addDataPointsDetails(mapProperties, cardBuilder, localize), cardBuilder.build();
            }, Map.prototype.getFillColorsCard = function(mapProperties) {
                var _this = this, localize = function(key) {
                    return _this.host.getLocalizedString(key);
                }, dataPointProps = map_capabilities.jM.dataPoint, dataPointProperties = [ dataPointProps.fill, dataPointProps.showAllDataPoints, dataPointProps.defaultColor ], cardBuilder = new build_control_util.CQ(new build_control_util.lg("fillcolors"), "Visual_FillColors", dataPointProperties, localize);
                return this.addDataPointsDetails(mapProperties, cardBuilder, localize), cardBuilder.build();
            }, Map.prototype.addDataPointsDetails = function(mapProperties, cardBuilder, localize) {
                var _this = this, data = this.data;
                data && Map.shouldEnumerateDataPoints(this.dataView, this.isFilledMap, mapProperties) && cardBuilder.addGroup("colors", function(groupBuilder) {
                    if (groupBuilder.withDisplayName("Visual_Colors"), data.hasSeries) {
                        var formatOptions = {
                            groupBuilder,
                            dataPoints: (0, legend_formatting.l3)(data.legendData),
                            seriesColorProps: map_capabilities.jM.dataPoint,
                            localize,
                            featureSwitches: _this.featureSwitches
                        };
                        return (0, colorEnumerationHelper2.y0)(formatOptions);
                    }
                    var formatCardOptions = {
                        groupBuilder,
                        colorProps: map_capabilities.jM.dataPoint,
                        featureSwitches: _this.featureSwitches,
                        hostService: _this.host,
                        options: {
                            dataView: _this.dataView,
                            style: _this.style,
                            categories: _.map(data.dataPoints, function(category) {
                                var subDataPoint = category.subDataPoints[0];
                                return {
                                    color: (0, VisualsCommon_color.ci)(subDataPoint.fill),
                                    displayName: category.categoryValue,
                                    identity: subDataPoint.identity
                                };
                            }),
                            fillInstanceKind: 3
                        }
                    };
                    (0, colorEnumerationHelper2.jN)(formatCardOptions);
                });
            }, Map.prototype.getCategoryLabelCard = function(hostService, dataLabelsSettings, mapProperties, style) {
                if (Map.shouldEnumerateCategoryLabels(this.isFilledMap, this.filledMapDataLabelsEnabled, mapProperties)) {
                    var categoryLabelsProps = map_capabilities.jM.categoryLabels;
                    return (0, dataLabelViewModel1.Zu)({
                        cardName: "Visual_CategoryLabels",
                        dataLabelSettings: dataLabelsSettings,
                        isShowCategory: !1,
                        localize: function(key) {
                            return hostService.getLocalizedString(key);
                        },
                        props: categoryLabelsProps,
                        revertToDefaultProps: categoryLabelsProps,
                        showBackground: !0,
                        showValueColor: !0,
                        style
                    });
                }
            }, Map.prototype.getHeatMapCard = function() {
                var _a, _this = this;
                if (this.data && Map.shouldEnumerateHeatMap(this.data.legendData, this.isFilledMap) && (!this.data.legendData || _.isEmpty(this.data.legendData.dataPoints))) {
                    var properties = this.data.properties, localize = function(key) {
                        return _this.host.getLocalizedString(key);
                    }, heatMapProps = map_capabilities.jM.heatMap, cardBuilder = new build_control_util.CQ(new build_control_util.lg("heatmap"), "Visual_HeatMap", heatMapProps, localize), radiusMax = bingMapTheme2.XT;
                    return (null === (_a = properties.heatMapOptions) || void 0 === _a ? void 0 : _a.unit) && properties.heatMapOptions.unit === bingMapTheme2.zH && (radiusMax = bingMapTheme2.dw), 
                    cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.show), {
                                selector: null
                            }),
                            value: properties.showHeatMap
                        }).build();
                    }).addGroup("colors", function(groupBuilder) {
                        var _a, _b, _c;
                        groupBuilder.withDisplayName("Visual_Colors").addSimpleSlice("color0", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.color0), {
                                selector: null,
                                instanceKind: 1
                            }),
                            value: {
                                value: null === (_a = properties.heatMapOptions) || void 0 === _a ? void 0 : _a.colorGradient["0.20"]
                            }
                        }).build()).addSimpleSlice("color50", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.color50), {
                                selector: null,
                                instanceKind: 1
                            }),
                            value: {
                                value: null === (_b = properties.heatMapOptions) || void 0 === _b ? void 0 : _b.colorGradient[.65]
                            }
                        }).build()).addSimpleSlice("color100", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.color100), {
                                selector: null,
                                instanceKind: 1
                            }),
                            value: {
                                value: null === (_c = properties.heatMapOptions) || void 0 === _c ? void 0 : _c.colorGradient["1.00"]
                            }
                        }).build());
                    }).addGroup("options", function(groupBuilder) {
                        var _a, _b;
                        groupBuilder.withDisplayName("Desktop_FileMenu_Options").addSimpleSlice("radius", new build_control_util.JN({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.filterRadius), {
                                selector: null
                            }),
                            value: null === (_a = properties.heatMapOptions) || void 0 === _a ? void 0 : _a.radius,
                            localize,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: 1
                                },
                                maxValue: {
                                    type: 1,
                                    value: radiusMax
                                },
                                unitSymbol: visualLocKeys.e_
                            }
                        }).build()).addSimpleSlice("displayUnits", new build_control_util.uY({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.unit), {
                                selector: null
                            }),
                            value: null === (_b = properties.heatMapOptions) || void 0 === _b ? void 0 : _b.unit
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_DisplayUnits").withAliasName("Decimal");
                        }).addSimpleSlice("transparency", build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, heatMapProps.transparency), {
                                selector: null
                            }),
                            value: properties.heatMapOptions && Math.round(100 * (1 - properties.heatMapOptions.opacity)),
                            localize
                        }).build());
                    }), cardBuilder.build();
                }
            }, Map.prototype.getFormattingModel = function() {
                var _this = this, dataLabelSettings = this.data ? this.data.dataLabelSettings : (0, 
                mapUtil.BP)(this.style), mapProperties = this.data ? this.data.properties : (0, 
                mapUtil.IG)(this.style).properties;
                return new build_control_util.Nq(function() {
                    return _this.getMapSettingsCard(_this.host, mapProperties);
                }, function() {
                    return _this.getLegendCard(_this.host, _this.data && _this.data.legendData, _this.hasSeries, _this.featureSwitches);
                }, function() {
                    return _this.isFilledMap ? _this.getFillColorsCard(mapProperties) : _this.getBubblesCard(mapProperties);
                }, function() {
                    return _this.getCategoryLabelCard(_this.host, dataLabelSettings, mapProperties, _this.style);
                }, function() {
                    return _this.getHeatMapCard();
                }).build();
            }, Map.prototype.update = function(options) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        switch (_a.label) {
                          case 0:
                            return null == options.resizeMode ? [ 3, 1 ] : (this.onResizingInternal(options), 
                            [ 3, 3 ]);

                          case 1:
                            return [ 4, this.onDataChangedInternal(options) ];

                          case 2:
                            _a.sent(), _a.label = 3;

                          case 3:
                            return [ 2 ];
                        }
                    });
                });
            }, Map.prototype.onDataChangedInternal = function(options, allowRecursion) {
                return void 0 === allowRecursion && (allowRecursion = !0), (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var geocodingContext, dataView, isFilledMap, data, mapTheme, mapOptions, mapControl, params, _i, _a, dataPoint, categoryValue, _this = this;
                    return (0, tslib_es6.__generator)(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return debug.fF.assertValue(options, "options"), this.viewMode = options && options.viewMode, 
                            this.resetBounds(), this.geocodingContext && this.geocodingContext.timeout && this.geocodingContext.timeout.resolve(null), 
                            this.geocodingContext = {
                                timeout: this.promiseFactory.defer(),
                                dataPointsRemaining: 0
                            }, geocodingContext = this.geocodingContext, this.behavior && this.behavior.resetZoomPan(), 
                            dataView = this.dataView = options && options.dataViews && options.dataViews[0], 
                            isFilledMap = this.isFilledMap, this.warnings = [], this.warningsSet = !1, data = (0, 
                            mapUtil.IG)(this.style), dataView ? (data = this.data = Map.converter({
                                dataView,
                                geoTaggingAnalyzerService: this.geoTaggingAnalyzerService,
                                isFilledMap,
                                style: this.style,
                                warnings: this.warnings
                            }), this.dataPointRenderer.setData(data), this.hasSeries = data.hasSeries, [ 4, this.ensureMap() ]) : [ 3, 2 ];

                          case 1:
                            if (_b.sent(), this.isDestroyed) return [ 2 ];
                            if (this.mapControl) {
                                if ((mapTheme = data.properties.mapTheme) !== this.mapTheme && (this.mapControl.setMapType((0, 
                                mapUtil.N0)(mapTheme)), this.mapTheme = mapTheme), (mapOptions = this.mapControl.getOptions()).showZoomButtons !== data.properties.showZoomButtons || data.properties.minZoom && mapOptions.minZoom !== data.properties.minZoom || data.properties.maxZoom && mapOptions.maxZoom !== data.properties.maxZoom) return mapControl = this.mapControl, 
                                this.mapControl = void 0, this.dataPointRenderer.clearDataPoints(), mapControl.dispose(), 
                                setTimeout(function() {
                                    _this.root.empty(), _this.initializeMapControl(), allowRecursion && setTimeout(function() {
                                        return _this.onDataChangedInternal(options, !1);
                                    }, 250);
                                }, Map.MapControlDisposeDelay), [ 2 ];
                                if (data.properties.autoZoomEnabled && !this.autoZoomWasEnabled ? (data.properties.savedLatitude = void 0, 
                                data.properties.savedLongitude = void 0, data.properties.savedZoomLevel = void 0, 
                                this.persistZoomPanState(!0)) : !data.properties.autoZoomEnabled && this.autoZoomWasEnabled && (this.updateZoomPanStateFromControl(), 
                                this.persistZoomPanState(!0)), this.autoZoomWasEnabled = data.properties.autoZoomEnabled, 
                                this.renderLegend(this.data.legendData), this.geocodingCategory = data.geocodingCategory, 
                                this.isDestroyed || geocodingContext !== this.geocodingContext) return [ 2 ];
                                for (params = void 0, isFilledMap && (params = (0, mapUtil.o)(this.geocodingCategory, data.dataPoints.length)), 
                                geocodingContext.dataPointsRemaining = data.dataPoints.length, _i = 0, _a = data.dataPoints; _i < _a.length; _i++) (dataPoint = _a[_i]).location ? isFilledMap && !dataPoint.paths ? this.enqueueGeoShape(geocodingContext, dataPoint, params) : this.addDataPoint(geocodingContext, dataPoint) : null != (categoryValue = dataPoint.categoryValue) && "" !== categoryValue ? isFilledMap ? this.enqueueGeoCodeAndGeoShape(geocodingContext, dataPoint, params, data) : this.enqueueGeoCode(geocodingContext, dataPoint, data) : this.geocodingFailed(geocodingContext);
                                this.updateInternal(!0, !0);
                            }
                            return isFilledMap && (this.geocodingCategory && this.geoTaggingAnalyzerService.isGeoshapable(this.geocodingCategory) || this.warnings.push(new visualWarnings.Gh)), 
                            data.invalidLatLongCoordinatesFound && this.warnings.push(new visualWarnings.zI), 
                            [ 3, 3 ];

                          case 2:
                            this.clearDataPoints(), this.renderLegend((0, legend_converter.Fe)(this.style)), 
                            this.dataPointRenderer.setData(data), this.updateInternal(!0, !0), _b.label = 3;

                          case 3:
                            return this.host.setWarnings(this.warnings), this.warningsSet = !0, [ 2 ];
                        }
                    });
                });
            }, Map.converter = function(options) {
                if (Map.isMatrixCase(options.dataView)) return Map.convertMatrix(options);
                var style = options.style, formatStringProp = map_capabilities.jM.general.formatString, reader = (0, 
                dataViewCategoricalReader.G)(options.dataView, {
                    colorOptions: {
                        valueRole: "Size",
                        visualStyle: style
                    },
                    formatStringProp
                }), dataReader = reader.data, objectReader = reader.objects, dataPoints = [], hasSeries = dataReader.hasSeries(), hasSize = dataReader.hasValues("Size"), geocodingCategory = null, staticObjects = reader.objects.getStaticObjects(), dataPointAlpha = (100 - (0, 
                dataViewObject2.NA)(staticObjects, map_capabilities.jM.dataPoint.transparency, 100 * (1 - Map.innerGeometryAlpha))) / 100, isFilledMap = options.isFilledMap, invalidLatLongCoordinatesFound = !1, properties = Map.getMapPropertiesFromObjects(staticObjects, style, !hasSeries, options);
                if (dataReader.hasCategories()) {
                    var categoryTotals = [], categoryTotalRange = void 0;
                    if (hasSize) {
                        for (var categoryMin = void 0, categoryMax = void 0, categoryIndex = 0, categoryCount = dataReader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                            for (var categoryTotal = void 0, seriesIndex = 0, seriesCount = dataReader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                                var currentValue = dataReader.getValue("Size", categoryIndex, seriesIndex);
                                null == categoryTotal && null != currentValue && (categoryTotal = 0), null != categoryTotal && (categoryTotal += currentValue);
                            }
                            categoryTotals.push(categoryTotal), null != categoryTotal && ((void 0 === categoryMin || categoryTotal < categoryMin) && (categoryMin = categoryTotal), 
                            (void 0 === categoryMax || categoryTotal > categoryMax) && (categoryMax = categoryTotal));
                        }
                        categoryTotalRange = void 0 !== categoryMin && void 0 !== categoryMax ? {
                            max: categoryMax,
                            min: categoryMin
                        } : void 0;
                    }
                    var hasLatLongGroup = dataReader.hasCompositeCategories() && dataReader.hasCategoryWithRole("X") && dataReader.hasCategoryWithRole("Y"), hasCategoryGroup = dataReader.hasCategoryWithRole("Category");
                    if (hasCategoryGroup && (geocodingCategory = Map.getGeocodingCategory(_.last(options.dataView.categorical.categories).source, options.geoTaggingAnalyzerService)), 
                    hasLatLongGroup || hasCategoryGroup) for (categoryIndex = 0, categoryCount = dataReader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                        var queryLocation = {
                            components: [],
                            culture: properties.geocodingCulture
                        }, categoryValue = void 0, location_2 = void 0, categoryTooltipItems = [], latitudeTooltipItem = void 0, longitudeTooltipItem = void 0, seriesTooltipItem = void 0, sizeTooltipItem = void 0, gradientTooltipItem = void 0;
                        if (hasCategoryGroup) {
                            for (var categoryDisplayNames = dataReader.getAllCategoryDisplayNamesForRole("Category"), unformattedCategoryValues = dataReader.getAllCategoryValuesForRole("Category", categoryIndex), categoryFormatStrings = objectReader.getAllCategoryFormatStringsForRole("Category"), geocodingCategories = _.map(options.dataView.categorical.categories, function(category) {
                                return Map.getGeocodingCategory(category.source, options.geoTaggingAnalyzerService);
                            }), formattedCategoryValues = [], i = 0; i < unformattedCategoryValues.length; ++i) {
                                var categoryDisplayName = categoryDisplayNames[i], unformattedCategoryValue = unformattedCategoryValues[i], geocodingCategory_1 = geocodingCategories[i], formattedCategoryValue = (0, 
                                valueFormatter.WU)(unformattedCategoryValue, categoryFormatStrings[i]);
                                formattedCategoryValues.unshift(formattedCategoryValue), queryLocation.components.push({
                                    query: unformattedCategoryValue && formattedCategoryValue,
                                    category: geocodingCategory_1
                                }), categoryTooltipItems.push({
                                    displayName: categoryDisplayName,
                                    value: formattedCategoryValue
                                });
                            }
                            if (categoryValue = formattedCategoryValues.join(", "), dataReader.hasValues("Y") && dataReader.hasValues("X")) {
                                var latitude = parseNumber(dataReader.getFirstNonNullValueForCategory("Y", categoryIndex)), longitude = parseNumber(dataReader.getFirstNonNullValueForCategory("X", categoryIndex));
                                null != latitude && _.isFinite(latitude) && null != longitude && _.isFinite(longitude) && (location_2 = {
                                    latitude,
                                    longitude
                                }), latitudeTooltipItem = {
                                    displayName: dataReader.getValueDisplayName("Y"),
                                    value: (0, valueFormatter.WU)(latitude, objectReader.getValueFormatString("Y"))
                                }, longitudeTooltipItem = {
                                    displayName: dataReader.getValueDisplayName("X"),
                                    value: (0, valueFormatter.WU)(longitude, objectReader.getValueFormatString("X"))
                                };
                            }
                        } else {
                            latitude = parseNumber(dataReader.getCategoryValue("Y", categoryIndex));
                            var formattedLatitude = (0, valueFormatter.WU)(latitude, objectReader.getCategoryFormatString("Y")), formattedLongitude = (longitude = parseNumber(dataReader.getCategoryValue("X", categoryIndex)), 
                            (0, valueFormatter.WU)(longitude, objectReader.getCategoryFormatString("X")));
                            areLatLongNumeric(latitude, longitude) && (categoryValue = formattedLatitude + ", " + formattedLongitude, 
                            location_2 = {
                                latitude,
                                longitude
                            }, latitudeTooltipItem = {
                                displayName: dataReader.getCategoryDisplayName("Y"),
                                value: formattedLatitude
                            }, longitudeTooltipItem = {
                                displayName: dataReader.getCategoryDisplayName("X"),
                                value: formattedLongitude
                            });
                        }
                        var value = hasSize ? categoryTotals[categoryIndex] : void 0;
                        if ((0, mapUtil.N2)(location_2, hasLatLongGroup)) invalidLatLongCoordinatesFound = !0; else {
                            var subDataPoints = [];
                            for (seriesCount = dataReader.getSeriesCount(), hasSize || hasSeries || (seriesCount = 1), 
                            seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var seriesKey = hasSeries ? dataReader.getSeriesName(seriesIndex) : void 0;
                                if (!hasSeries || hasSize || !Map.hasNoValuesAtInteresection(reader, [ "Tooltips", "X", "Y" ], categoryIndex, seriesIndex)) {
                                    var color = reader.colors.createBySeries(seriesIndex, categoryIndex), colorRgb = (0, 
                                    VisualsCommon_color.WV)(color);
                                    colorRgb || (color = reader.colors.createBySeries(seriesIndex, categoryIndex, void 0, !0), 
                                    colorRgb = (0, VisualsCommon_color.WV)(color));
                                    var stroke = Map.getSubDataPointStrokeColor(colorRgb, style), fill = (0, VisualsCommon_color.U8)(Map.adjustSubDataPointFillColor(colorRgb, style, dataPointAlpha));
                                    hasSeries && (seriesTooltipItem = {
                                        displayName: dataReader.getSeriesDisplayName(),
                                        value: (0, valueFormatter.WU)(seriesKey, objectReader.getSeriesFormatString())
                                    });
                                    var subsliceValue = void 0;
                                    if (hasSize) {
                                        subsliceValue = dataReader.getValue("Size", categoryIndex, seriesIndex);
                                        var sizeFormat = dataReader.getFormatString("Size", categoryIndex, seriesIndex) || reader.objects.getValueFormatString("Size");
                                        sizeTooltipItem = {
                                            displayName: dataReader.getValueDisplayName("Size"),
                                            value: (0, valueFormatter.WU)(subsliceValue, sizeFormat)
                                        };
                                    }
                                    if (dataReader.hasValues("Gradient")) {
                                        var gradientValue = dataReader.getValue("Gradient", categoryIndex, seriesIndex), gradientFormat = reader.objects.getValueFormatString("Gradient");
                                        gradientTooltipItem = {
                                            displayName: dataReader.getValueDisplayName("Gradient"),
                                            value: (0, valueFormatter.WU)(gradientValue, gradientFormat)
                                        };
                                    }
                                    var tooltipInfo = [];
                                    _.isEmpty(categoryTooltipItems) || tooltipInfo.push.apply(tooltipInfo, categoryTooltipItems || []), 
                                    seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), latitudeTooltipItem && tooltipInfo.push(latitudeTooltipItem), 
                                    longitudeTooltipItem && tooltipInfo.push(longitudeTooltipItem), sizeTooltipItem && tooltipInfo.push(sizeTooltipItem), 
                                    gradientTooltipItem && tooltipInfo.push(gradientTooltipItem), (0, tooltip.VT)(reader, tooltipInfo, categoryIndex, seriesIndex, formatStringProp);
                                    var identity = reader.identities.createForDataPoint(categoryIndex, seriesIndex, hasSize ? [ "Size" ] : void 0);
                                    (subsliceValue || !hasSize || 0 === subsliceValue && isFilledMap) && subDataPoints.push({
                                        value: subsliceValue,
                                        fill,
                                        stroke,
                                        identity,
                                        tooltipInfo,
                                        seriesIndex
                                    });
                                }
                            }
                            (value || !hasSize || 0 === value && isFilledMap) && subDataPoints.length > 0 && dataPoints.push({
                                queryLocation,
                                value,
                                categoryValue,
                                subDataPoints,
                                radius: Map.calculateRadius(value, categoryTotalRange, properties.markerRangeType, properties.bubbleSizeMultiplier),
                                location: location_2
                            });
                        }
                    }
                }
                var mapData = {
                    dataPoints,
                    geocodingCategory,
                    hasSeries,
                    hasSize,
                    properties,
                    dataLabelSettings: Map.calculateDataLabelSettings(options.dataView, isFilledMap, style),
                    legendData: (0, legend_converter.pq)({
                        dataView: options.dataView,
                        style,
                        showByDefault: !0
                    }),
                    invalidLatLongCoordinatesFound
                }, firstColor = common_colorHelper.v.getDataColorByIndex(style, 0), defaultColorGradientScale = (0, 
                VisualsCommon_color.X6)(firstColor, .33);
                return mapData.properties.heatMapOptions = {
                    opacity: 1 - (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.heatMap.transparency, 0) / 100,
                    radius: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.heatMap.filterRadius, 10),
                    unit: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.heatMap.unit, bingMapTheme2.aA),
                    colorGradient: {
                        "0.20": (0, dataViewObject2.W7)(staticObjects, map_capabilities.jM.heatMap.color0, defaultColorGradientScale(0)),
                        .65: (0, dataViewObject2.W7)(staticObjects, map_capabilities.jM.heatMap.color50, defaultColorGradientScale(.5)),
                        "1.00": (0, dataViewObject2.W7)(staticObjects, map_capabilities.jM.heatMap.color100, defaultColorGradientScale(1))
                    }
                }, mapData.properties.heatMapOptions.radius = "meters" === mapData.properties.heatMapOptions.unit ? Math.min(mapData.properties.heatMapOptions.radius, bingMapTheme2.dw) : Math.min(mapData.properties.heatMapOptions.radius, bingMapTheme2.XT), 
                mapData;
            }, Map.getMapPropertiesFromObjects = function(staticObjects, style, heatMapAllowed, options) {
                var properties = {
                    bubbleSizeMultiplier: (0, shapeUtil.HN)((0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.bubbles.bubbleSize, 1)),
                    markerRangeType: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.bubbles.markerRangeType, markerRangeType.Dl.deprecated),
                    autoZoomEnabled: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.autoZoom, !0),
                    savedLatitude: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.centerLatitude),
                    savedLongitude: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.centerLongitude),
                    savedZoomLevel: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.zoomLevel),
                    defaultDataPointColor: (0, dataViewObject2.W7)(staticObjects, map_capabilities.jM.dataPoint.defaultColor, style.colorPalette.dataColors.getColorByIndex(0).value),
                    fill: (0, dataViewObject2.W7)(staticObjects, map_capabilities.jM.dataPoint.fill, style.colorPalette.dataColors.getColorByIndex(0).value),
                    mapTheme: Map.getMapThemeFromObjects(staticObjects, style),
                    showHeatMap: heatMapAllowed && (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.heatMap.show),
                    showZoomButtons: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.showZoomButtons, !1),
                    showLassoButton: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.showLassoButton, !1),
                    minZoom: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.minZoom, void 0),
                    maxZoom: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.maxZoom, void 0),
                    showLabels: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapStyles.showLabels, !0),
                    showStroke: (0, dataViewObject2.NA)(staticObjects, filledMap_capabilities.Vh.stroke.show, !1),
                    strokeColor: (0, dataViewObject2.W7)(staticObjects, filledMap_capabilities.Vh.stroke.color, void 0),
                    strokeWidth: (0, dataViewObject2.NA)(staticObjects, filledMap_capabilities.Vh.stroke.width, void 0),
                    geocodingCulture: (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapControls.geocodingCulture, void 0)
                };
                return properties.geocodingCulture && !(0, geocodingCulture._h)(properties.geocodingCulture) && (properties.geocodingCulture = void 0, 
                options.warnings.push(new visualWarnings.aV)), properties;
            }, Map.convertMatrix = function(options) {
                var staticObjects = options.dataView.metadata.objects, matrix = options.dataView.matrix, style = options.style, dataPoints = [], series = matrix.rows.root.children;
                if (!series) return (0, mapUtil.IG)(style);
                var tooltipFields, categoryMetadatas, xMetadata, yMetadata, xCompositeIndex, yCompositeIndex, dataPointAlpha = (100 - (0, 
                dataViewObject2.NA)(staticObjects, map_capabilities.jM.dataPoint.transparency, 100 * (1 - Map.innerGeometryAlpha))) / 100, seriesCount = series.length, categoryIndexByValueMap = {}, nextCategoryIndex = 0, seriesIdentitiesFields = matrix.rows.root.childIdentityFields, seriesMetadata = matrix.rows.levels[0].sources[0], formatStringProp = map_capabilities.jM.general.formatString, colorHelper = common_colorHelper.v.create(style, map_capabilities.jM.dataPoint.fill), invalidLatLongCoordinatesFound = !1, properties = Map.getMapPropertiesFromObjects(staticObjects, style, !1, options), radius = Map.calculateRadius(void 0, void 0, properties.markerRangeType, properties.bubbleSizeMultiplier);
                if (!_.isEmpty(matrix.valueSources)) {
                    tooltipFields = [];
                    for (var index = 0; index < matrix.valueSources.length; ++index) {
                        var valueSource = matrix.valueSources[index];
                        valueSource.roles.Tooltips && tooltipFields.push({
                            displayName: valueSource.displayName,
                            valueIndex: index
                        });
                    }
                }
                var geocodingCategory, secondLevel = matrix.rows.levels[1];
                if (null != secondLevel && !_.isEmpty(secondLevel.sources) && (categoryMetadatas = secondLevel.sources, 
                secondLevel.sources.length >= 2)) {
                    var firstCategoryMetadata = secondLevel.sources[0], secondCategoryMetadata = secondLevel.sources[1];
                    firstCategoryMetadata && firstCategoryMetadata.roles.X ? (xMetadata = firstCategoryMetadata, 
                    xCompositeIndex = 0) : firstCategoryMetadata && firstCategoryMetadata.roles.Y && (yMetadata = firstCategoryMetadata, 
                    yCompositeIndex = 0), secondCategoryMetadata && secondCategoryMetadata.roles.X ? (xMetadata = secondCategoryMetadata, 
                    xCompositeIndex = 1) : secondCategoryMetadata && secondCategoryMetadata.roles.Y && (yMetadata = secondCategoryMetadata, 
                    yCompositeIndex = 1);
                }
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var currentSeries = series[seriesIndex], children = currentSeries.children, seriesKey = currentSeries.value, seriesName = (0, 
                    converterHelper.xq)(seriesKey, seriesMetadata, map_capabilities.jM.general.formatString), color = colorHelper.getColorForSeriesValue(currentSeries.objects, seriesIdentitiesFields, seriesKey), colorRgb = (0, 
                    VisualsCommon_color.WV)(color);
                    colorRgb || (color = colorHelper.getColorForSeriesValue(currentSeries.objects, seriesIdentitiesFields, seriesKey, void 0, !0), 
                    colorRgb = (0, VisualsCommon_color.WV)(color));
                    var stroke = Map.getSubDataPointStrokeColor(colorRgb, style), fill = (0, VisualsCommon_color.U8)(Map.adjustSubDataPointFillColor(colorRgb, style, dataPointAlpha)), seriesTooltipItem = {
                        displayName: seriesMetadata.displayName,
                        value: seriesName
                    };
                    if (categoryMetadatas && categoryMetadatas[0].roles.Category) {
                        var lastCategoryMetadata = categoryMetadatas[categoryMetadatas.length - 1];
                        geocodingCategory = Map.getGeocodingCategory(lastCategoryMetadata, options.geoTaggingAnalyzerService);
                        for (var childIndex = 0, childCount = children.length; childIndex < childCount; childIndex++) {
                            var category = children[childIndex], categoryIdentityKey = (idBuilder = (new selectionId.dw).withColumnIdentity(category.identity, lastCategoryMetadata.queryName)).createSelectionId().getKey(), identity = idBuilder.withColumnIdentity(currentSeries.identity, seriesMetadata.queryName).createSelectionId();
                            null == (categoryIndex = categoryIndexByValueMap[categoryIdentityKey]) && (categoryIndex = nextCategoryIndex++, 
                            categoryIndexByValueMap[categoryIdentityKey] = categoryIndex);
                            var tooltipInfo = [], queryLocation = {
                                components: [],
                                culture: properties.geocodingCulture
                            }, categoryValue = void 0;
                            if (category.levelValues && 1 !== category.levelValues.length) {
                                for (var categoryDisplayNames = _.map(categoryMetadatas, function(categoryMetadata) {
                                    return categoryMetadata.displayName;
                                }), unformattedCategoryValues = _.map(category.levelValues, function(levelValue) {
                                    return levelValue.value;
                                }), categoryFormatStrings = _.map(categoryMetadatas, function(categoryColumn) {
                                    return (0, dataViewObject2.NA)(categoryColumn.objects, {
                                        objectName: "general",
                                        propertyName: "formatString"
                                    });
                                }), geocodingCategories = _.map(categoryMetadatas, function(categoryMetadata) {
                                    return Map.getGeocodingCategory(categoryMetadata, options.geoTaggingAnalyzerService);
                                }), formattedCategoryValues = [], i = 0; i < unformattedCategoryValues.length; ++i) {
                                    var categoryDisplayName = categoryDisplayNames[i], geocodingCategory_2 = geocodingCategories[i], formattedCategoryValue = (0, 
                                    valueFormatter.WU)(unformattedCategoryValues[i], categoryFormatStrings[i]);
                                    formattedCategoryValues.unshift(formattedCategoryValue), queryLocation.components.push({
                                        query: formattedCategoryValue,
                                        category: geocodingCategory_2
                                    }), tooltipInfo.push({
                                        displayName: categoryDisplayName,
                                        value: formattedCategoryValue
                                    });
                                }
                                categoryValue = formattedCategoryValues.join(", ");
                            } else categoryValue = (0, converterHelper.xq)(category.value, lastCategoryMetadata, formatStringProp), 
                            tooltipInfo.push({
                                displayName: lastCategoryMetadata.displayName,
                                value: categoryValue
                            }), queryLocation.components.push({
                                query: categoryValue,
                                category: geocodingCategory
                            });
                            (dataPoint = dataPoints[categoryIndex]) || (dataPoints[categoryIndex] = dataPoint = {
                                categoryValue,
                                queryLocation,
                                radius,
                                subDataPoints: [],
                                value: void 0
                            }), seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), dataPoint.subDataPoints.push({
                                fill,
                                stroke,
                                identity,
                                value: void 0,
                                tooltipInfo,
                                seriesIndex
                            });
                        }
                    } else if (seriesMetadata && seriesMetadata.roles.Category && seriesMetadata.roles.Series) {
                        geocodingCategory = Map.getGeocodingCategory(seriesMetadata, options.geoTaggingAnalyzerService);
                        var key = (identity = (new selectionId.dw).withColumnIdentity(currentSeries.identity, seriesMetadata.queryName).createSelectionId()).getKey();
                        null == (categoryIndex = categoryIndexByValueMap[key]) && (categoryIndex = nextCategoryIndex++, 
                        categoryIndexByValueMap[key] = categoryIndex), (dataPoint = dataPoints[categoryIndex]) || (dataPoints[categoryIndex] = dataPoint = {
                            categoryValue: seriesName,
                            queryLocation: {
                                components: [ {
                                    query: seriesName,
                                    category: geocodingCategory
                                } ]
                            },
                            radius,
                            subDataPoints: [],
                            value: void 0
                        }), tooltipInfo = [], seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), 
                        dataPoint.subDataPoints.push({
                            fill,
                            stroke,
                            identity,
                            value: void 0,
                            tooltipInfo,
                            seriesIndex
                        });
                    } else {
                        if (!(xMetadata && xMetadata.roles.X && yMetadata && yMetadata.roles.Y)) return (0, 
                        mapUtil.IG)(style);
                        for (var xIndex = 0, xCount = children.length; xIndex < xCount; xIndex++) {
                            var childNode = children[xIndex], longitude = parseNumber(childNode.levelValues[xCompositeIndex].value), latitude = parseNumber(childNode.levelValues[yCompositeIndex].value);
                            if (areLatLongNumeric(latitude, longitude)) {
                                var latitudeTooltipItem, longitudeTooltipItem, location_3, idBuilder, formattedLongitude = (0, 
                                converterHelper.xq)(longitude, xMetadata, formatStringProp), formattedLatitude = (0, 
                                converterHelper.xq)(latitude, yMetadata, formatStringProp), latLongIdentityKey = (tooltipInfo = [], 
                                categoryValue = formattedLatitude + ", " + formattedLongitude, (idBuilder = (new selectionId.dw).withColumnIdentity(childNode.identity, yMetadata.queryName)).createSelectionId().getKey());
                                if (identity = idBuilder.withColumnIdentity(currentSeries.identity, seriesMetadata.queryName).createSelectionId(), 
                                (0, mapUtil.N2)(location_3 = {
                                    latitude,
                                    longitude
                                }, !0)) invalidLatLongCoordinatesFound = !0; else {
                                    var categoryIndex, dataPoint;
                                    if (latitudeTooltipItem = {
                                        displayName: yMetadata.displayName,
                                        value: formattedLatitude
                                    }, longitudeTooltipItem = {
                                        displayName: xMetadata.displayName,
                                        value: formattedLongitude
                                    }, null == (categoryIndex = categoryIndexByValueMap[latLongIdentityKey]) && (categoryIndex = nextCategoryIndex++, 
                                    categoryIndexByValueMap[latLongIdentityKey] = categoryIndex), (dataPoint = dataPoints[categoryIndex]) || (dataPoints[categoryIndex] = dataPoint = {
                                        categoryValue,
                                        queryLocation: {
                                            components: [ {
                                                query: categoryValue,
                                                category: geocodingCategory
                                            } ]
                                        },
                                        radius,
                                        subDataPoints: [],
                                        value: void 0,
                                        location: location_3
                                    }), seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), latitudeTooltipItem && tooltipInfo.push(latitudeTooltipItem), 
                                    longitudeTooltipItem && tooltipInfo.push(longitudeTooltipItem), !_.isEmpty(tooltipFields)) for (var _i = 0, tooltipFields_1 = tooltipFields; _i < tooltipFields_1.length; _i++) {
                                        var tooltipField = tooltipFields_1[_i];
                                        tooltipInfo.push({
                                            displayName: tooltipField.displayName,
                                            value: (0, valueFormatter.WU)(childNode.values[tooltipField.valueIndex].value)
                                        });
                                    }
                                    dataPoint.subDataPoints.push({
                                        fill,
                                        stroke,
                                        identity,
                                        value: void 0,
                                        tooltipInfo,
                                        seriesIndex
                                    });
                                }
                            }
                        }
                    }
                }
                return {
                    dataPoints,
                    hasSeries: !0,
                    geocodingCategory,
                    hasSize: !1,
                    properties,
                    dataLabelSettings: Map.calculateDataLabelSettings(options.dataView, options.isFilledMap, style),
                    legendData: (0, legend_converter.PP)({
                        dataView: options.dataView,
                        colorHelper,
                        style,
                        formatStringProp,
                        showByDefault: !0
                    }),
                    invalidLatLongCoordinatesFound
                };
            }, Map.getMapThemeFromObjects = function(staticObjects, style) {
                return style.isHighContrast ? bingMapTheme1.IZ : (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.mapStyles.mapTheme, bingMapTheme1.uH);
            }, Map.adjustSubDataPointFillColor = function(colorRgb, style, alpha) {
                return void 0 === alpha && (alpha = Map.innerGeometryAlpha), colorRgb.A = style.isHighContrast ? void 0 : alpha, 
                colorRgb;
            }, Map.getSubDataPointStrokeColor = function(colorRgb, style) {
                return style.isHighContrast ? common_colorHelper.v.getThemeColor(style, colorHelper.fA) : (0, 
                VisualsCommon_color.Bx)((0, VisualsCommon_color._j)(colorRgb, Map.StrokeDarkenColorValue));
            }, Map.isMatrixCase = function(dataView) {
                return dataView.matrix && !dataView.categorical;
            }, Map.calculateDataLabelSettings = function(dataView, isFilledMap, style) {
                var dataLabelSettings = (0, mapUtil.BP)(style), staticObjects = dataView.metadata && dataView.metadata.objects;
                if (!staticObjects) return dataLabelSettings;
                if (dataLabelSettings.showCategory = (0, dataViewObject2.NA)(staticObjects, filledMap_capabilities.Vh.categoryLabels.show, dataLabelSettings.showCategory), 
                isFilledMap) {
                    dataLabelSettings.precision = (0, dataViewObject2.NA)(staticObjects, filledMap_capabilities.Vh.labels.labelPrecision, dataLabelSettings.precision), 
                    dataLabelSettings.precision = dataLabelSettings.precision !== dataLabelViewModel1Consts.NZ && dataLabelSettings.precision < 0 ? 0 : dataLabelSettings.precision, 
                    dataLabelSettings.displayUnits = (0, dataViewObject2.NA)(staticObjects, filledMap_capabilities.Vh.labels.labelDisplayUnits, dataLabelSettings.displayUnits);
                    var datalabelsObj = staticObjects.labels;
                    datalabelsObj && (dataLabelSettings.show = void 0 !== datalabelsObj.show ? datalabelsObj.show : dataLabelSettings.show, 
                    void 0 !== datalabelsObj.color && (dataLabelSettings.fontProperties = (0, common_fontProperties.ED)(dataLabelSettings.fontProperties, {
                        color: datalabelsObj.color.solid.color
                    })));
                } else {
                    var categoryLabelsObj = staticObjects.categoryLabels;
                    categoryLabelsObj && (0, dataLabelViewModel1.ww)(categoryLabelsObj, dataLabelSettings, void 0, style);
                }
                var colorHelper = common_colorHelper.v.create(style);
                return dataLabelSettings.enableBackground = (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.categoryLabels.enableBackground, !0), 
                dataLabelSettings.backgroundColor = colorHelper.getColorForProperty(staticObjects, map_capabilities.jM.categoryLabels.backgroundColor, dataLabelViewModel1Consts.lp), 
                dataLabelSettings.backgroundTransparency = (0, dataViewObject2.NA)(staticObjects, map_capabilities.jM.categoryLabels.backgroundTransparency, 100 * mapUtil.Bz) / 100, 
                dataLabelSettings;
            }, Map.hasNoValuesAtInteresection = function(reader, roles, categoryIndex, seriesIndex) {
                for (var roleFound = !1, _i = 0, roles_1 = roles; _i < roles_1.length; _i++) {
                    var role = roles_1[_i];
                    if (reader.data.hasValues(role) && (roleFound = !0, !_.every(reader.data.getAllValuesForRole(role, categoryIndex, seriesIndex), function(value) {
                        return null == value;
                    }))) return !1;
                }
                return roleFound;
            }, Map.prototype.swapLogoContainerChildElement = function() {
                var logoContainer = this.element.find(".LogoContainer");
                if (logoContainer) {
                    var aNode = logoContainer.find("a");
                    if (null == aNode) return;
                    var divNode = $("<div>");
                    aNode.children().clone().appendTo(divNode), aNode.remove(), divNode.appendTo(logoContainer);
                }
            }, Map.prototype.onResizingInternal = function(options) {
                var newScaleViewport = options.viewport;
                newScaleViewport.scale = newScaleViewport.scale || 1, this.currentViewport.width === newScaleViewport.width && this.currentViewport.height === newScaleViewport.height && this.currentViewport.scale === newScaleViewport.scale || (this.currentViewport = newScaleViewport, 
                this.data && this.data.legendData && this.mapControl && (this.renderLegend(this.data.legendData), 
                this.updateInternal(!1, !1), (0, mapUtil.ml)(this.mapControl)));
            }, Map.prototype.ensureMap = function() {
                var _this = this;
                return this.ensuringMap ? this.ensuringMap.promise : (this.ensuringMap = (0, jqueryPromiseFactory.p)().defer(), 
                this.mapControlFactory || (this.mapControlFactory = (0, mapUtil.$f)(this.promiseFactory, this.host.loader())), 
                this.mapControlFactory.ensureMap(this.locale).then(function() {
                    _this.isDestroyed || (wrap(), _this.initializeMapControl());
                }));
            }, Map.prototype.createMapControl = function(element, extraOptions) {
                var mapOptions = {
                    credentials: mapUtil.Zr.BingKey,
                    mapTypeId: (0, mapUtil.N0)(this.mapTheme),
                    disableZooming: this.disableZooming,
                    disablePanning: this.disablePanning,
                    enableClickableLogo: !1,
                    showDashboard: !0,
                    showMapTypeSelector: !1,
                    showLocateMeButton: !1,
                    showZoomButtons: !1,
                    showScalebar: !1,
                    showTrafficButton: !1,
                    allowHidingLabelsOfRoad: !0,
                    enableInertia: !1
                };
                extraOptions && (mapOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, mapOptions), extraOptions));
                var control = this.mapControlFactory.createMapControl(element, mapOptions), zoomLimits = control.getZoomRange();
                return zoomLimits && (null != zoomLimits.min && zoomLimits.min > this.minLevelOfDetail && (this.minLevelOfDetail = zoomLimits.min), 
                null != zoomLimits.max && zoomLimits.max < this.maxLevelOfDetail && (this.maxLevelOfDetail = zoomLimits.max)), 
                control;
            }, Map.prototype.initializeMapControl = function() {
                var _a, _this = this, mapProperties = null === (_a = this.data) || void 0 === _a ? void 0 : _a.properties, extraMapOptions = this.data ? {
                    showZoomButtons: mapProperties.showZoomButtons,
                    mapTypeId: (0, mapUtil.N0)(mapProperties.mapTheme),
                    minZoom: mapProperties.minZoom,
                    maxZoom: mapProperties.maxZoom
                } : null;
                if (!this.root && (this.root = (0, DomFactory.hi)().addClass(Map.MapContainer.cssClass).css("position", "absolute").appendTo(this.element[0]), 
                !this.disableZooming)) {
                    var zoomEnableTimeout_1, zoomDisabled_1 = !1, reenableZoom_1 = function() {
                        zoomDisabled_1 && (_this.mapControl.setOptions({
                            disableZooming: !1
                        }), zoomDisabled_1 = !1);
                    }, mapControlDiv = this.root[0];
                    mapControlDiv.addEventListener("mouseup", function(event) {
                        0 !== _this.viewMode && event.target.classList.contains("MicrosoftMap") && (_this.mapControl.setOptions({
                            disableZooming: !0
                        }), zoomDisabled_1 = !0, zoomEnableTimeout_1 || (zoomEnableTimeout_1 = setTimeout(function() {
                            zoomEnableTimeout_1 = void 0, reenableZoom_1();
                        })));
                    }, !0), mapControlDiv.addEventListener("mouseup", reenableZoom_1, !1);
                }
                var divQuery = this.root, mapControl = this.createMapControl(divQuery[0], extraMapOptions);
                if (this.data && mapProperties.mapTheme && (this.mapTheme = mapProperties.mapTheme), 
                this.data && null != mapProperties.autoZoomEnabled && (this.autoZoomWasEnabled = mapProperties.autoZoomEnabled), 
                this.mapControl = mapControl, this.streetsideManager = new StreetsideModeManager(mapControl, function(streetsideMode) {
                    if (streetsideMode) _this.dataPointRenderer.hideDataPoints(); else {
                        _this.updateInternal(!0, !0), _this.dataPointRenderer.showDataPoints(), _this.updateZoomPanStateFromControl();
                        var mapProps_1 = _this.data.properties;
                        mapProps_1 && _this.updateMapView(new Microsoft.Maps.Location(mapProps_1.savedLatitude, mapProps_1.savedLongitude), mapProps_1.savedZoomLevel);
                    }
                }), this.dataPointRenderer.init(mapControl, divQuery, !!this.behavior, this.tooltipService, this.style, this.interactivityService, this.host, this.eventManager), 
                this.behavior && this.dataPointLassoSelect && this.dataPointRenderer.getPlotAreaLassoSurface) {
                    var svg = this.dataPointRenderer.getPlotAreaLassoSurface(), root = d3.select(divQuery[0]);
                    this.plotLassoManager = new plotAreaLassoManager.oW(!0), this.plotLassoManager.init([ svg, root ], svg, this.host, this.featureSwitches), 
                    this.lassoSelectionBehavior = new plotAreaLassoManager.lk(this.behavior), this.plotLassoManager.behaviors.push(this.lassoSelectionBehavior), 
                    this.plotLassoManager.setUiScale(this.currentViewport.scale);
                }
                this.updateMapView(new Microsoft.Maps.Location(25, 0), this.minLevelOfDetail), void 0 !== this.viewChangeThrottleInterval ? Microsoft.Maps.Events.addThrottledHandler(mapControl, "viewchange", function() {
                    _this.onViewChanged();
                }, this.viewChangeThrottleInterval) : Microsoft.Maps.Events.addHandler(mapControl, "viewchange", function() {
                    _this.onViewChanged();
                }), Microsoft.Maps.Events.addHandler(mapControl, "viewchangeend", function() {
                    _this.onViewChangeEnded();
                }), this.streetsideManager.start(), this.pendingGeocodingRender || this.updateInternal(!0, !0), 
                this.ensuringMap.resolve();
            }, Map.prototype.onViewChanged = function() {
                !this.mapControl || this.streetsideManager.InStreetsideMode || this.data && this.data.properties.showHeatMap || (this.updateOffsets(!1, !1), 
                this.behavior && this.behavior.viewChanged(), this.swapLogoContainerChildElement());
            }, Map.prototype.onViewChangeEnded = function() {
                this.mapControl && !this.streetsideManager.InStreetsideMode && (this.onViewChanged(), 
                this.data && !1 === this.data.properties.autoZoomEnabled && (this.updateZoomPanStateFromControl(), 
                this.persistZoomPanState(!1)), this.dataPointRenderer.updateInternalDataLabels(this.currentViewport, !0));
            }, Map.prototype.getMapViewPort = function() {
                var currentViewport = this.currentViewport, legendMargins = this.legend.getMargins();
                if (this.rescaleMap) {
                    var scale = this.currentViewport.scale;
                    if (scale) return {
                        width: (currentViewport.width - legendMargins.width) * scale,
                        height: (currentViewport.height - legendMargins.height) * scale
                    };
                }
                return {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height
                };
            }, Map.prototype.updateInternal = function(dataChanged, redrawDataLabels) {
                var _a, mapProperties = this.data && this.data.properties;
                if (this.mapControl && mapProperties) {
                    var mapDiv = this.element.children(Map.MapContainer.selector), mapViewport = this.getMapViewPort();
                    if (mapDiv.height(mapViewport.height), mapDiv.width(mapViewport.width), this.rescaleMap && (mapDiv.css("transform", "scale(" + 1 / this.currentViewport.scale + ")"), 
                    mapDiv.css("transform-origin", "left top")), this.updateOffsets(dataChanged, redrawDataLabels), 
                    this.behavior && this.behavior.mapKeyboardAccessibility(this.host, this.data.properties.showZoomButtons), 
                    !this.behavior || !this.behavior.hasReceivedZoomOrPanEvent()) if (this.shouldSetSavedLocation && !1 === mapProperties.autoZoomEnabled && null != mapProperties.savedLatitude && null != mapProperties.savedLongitude && null != mapProperties.savedZoomLevel) this.updateMapView(new Microsoft.Maps.Location(mapProperties.savedLatitude, mapProperties.savedLongitude), mapProperties.savedZoomLevel), 
                    this.shouldSetSavedLocation = !1; else if (this.boundsHaveBeenUpdated && !0 === mapProperties.autoZoomEnabled) {
                        var center = (_a = this.getMapView(mapViewport.width, mapViewport.height)).center;
                        this.updateMapView(center, _a.levelOfDetail), this.shouldSetSavedLocation = !0;
                    }
                }
            }, Map.prototype.updateMapView = function(center, levelOfDetail) {
                this.mapControl && (levelOfDetail = Math.min(Math.max(levelOfDetail, this.minLevelOfDetail), this.maxLevelOfDetail), 
                this.mapControl.setView({
                    center,
                    zoom: levelOfDetail,
                    animate: !0,
                    labelOverlay: this.data.properties.showLabels ? Microsoft.Maps.LabelOverlay.visible : Microsoft.Maps.LabelOverlay.hidden
                }));
            }, Map.prototype.updateMapViewOnFocus = function() {
                var _a, mapViewport = this.getMapViewPort(), center = (_a = this.getMapView(mapViewport.width, mapViewport.height)).center;
                this.updateMapView(center, _a.levelOfDetail);
            }, Map.prototype.updateOffsets = function(dataChanged, redrawDataLabels) {
                var _this = this;
                if (!this.streetsideManager.InStreetsideMode) {
                    var data, dataView = this.dataView, viewport = this.getMapViewPort();
                    data = dataView ? this.dataPointRenderer.converter(viewport, this.data.dataLabelSettings, this.interactivityService, this.tooltipsEnabled, dataChanged) : {
                        bubbleData: [],
                        shapeData: [],
                        sliceData: []
                    };
                    var behaviorOptions = this.dataPointRenderer.updateInternal(data, viewport, dataChanged, this.interactivityService, redrawDataLabels, this.behavior);
                    if (this.plotLassoManager && (this.plotLassoManager.setUiScale(this.currentViewport.scale), 
                    this.syncLassoButton()), behaviorOptions && (behaviorOptions.focusCallback = function() {
                        _this.updateMapViewOnFocus();
                    }), (0, legend_util.xz)(d3.select(this.root[0]), this.legend), this.interactivityService && behaviorOptions) {
                        var navigationOptions = this.dataPointRenderer.getNavigationOptions();
                        this.interactivityService.bind(behaviorOptions.dataPoints, this.behavior, behaviorOptions, {
                            navigationOptions,
                            pointSourceKey: "map"
                        });
                    }
                }
            }, Map.prototype.onClearSelection = function() {
                this.interactivityService.clearSelection(), this.updateOffsets(!1, !1);
            }, Map.prototype.onRestoreSelection = function(options) {
                return !!this.interactivityService && this.interactivityService.restoreSelection(options.selection);
            }, Map.prototype.clearDataPoints = function() {
                this.dataPointRenderer.clearDataPoints(), this.legend.drawLegend({
                    data: (0, legend_converter.Fe)(this.style),
                    parentViewport: this.currentViewport
                });
            }, Map.prototype.updateZoomPanStateFromControl = function() {
                var mapProperties = this.data && this.data.properties;
                if (mapProperties) {
                    var center = this.mapControl.getCenter();
                    mapProperties.savedLatitude = center.latitude, mapProperties.savedLongitude = center.longitude, 
                    mapProperties.savedZoomLevel = this.mapControl.getZoom();
                }
            }, Map.prototype.persistZoomPanState = function(noUndo) {
                var mapProperties = this.data && this.data.properties, autoZoomEnabled = mapProperties && mapProperties.autoZoomEnabled, showZoomButtons = mapProperties && mapProperties.showZoomButtons, showLassoButton = mapProperties && mapProperties.showLassoButton;
                debug.fF.assert(function() {
                    return null != autoZoomEnabled;
                }, "autoZoom state should be resolved"), mapProperties && 0 !== this.viewMode && (autoZoomEnabled || debug.fF.assert(function() {
                    return _.isFinite(mapProperties.savedLatitude) && _.isFinite(mapProperties.savedLongitude) && _.isFinite(mapProperties.savedZoomLevel);
                }, "valid zoom/pan values"), this.host.persistProperties({
                    replace: [ {
                        objectName: "mapControls",
                        selector: null,
                        properties: autoZoomEnabled ? {
                            autoZoom: !0,
                            showZoomButtons,
                            showLassoButton
                        } : {
                            autoZoom: !1,
                            showZoomButtons,
                            centerLatitude: mapProperties.savedLatitude,
                            centerLongitude: mapProperties.savedLongitude,
                            zoomLevel: mapProperties.savedZoomLevel,
                            showLassoButton
                        }
                    } ]
                }, noUndo));
            }, Map.prototype.syncLassoButton = function() {
                var _this = this, navBarSelection = d3.select(this.root[0]).select(mapUtil.PN);
                if (!navBarSelection.empty()) {
                    var lassoButtonData = [];
                    this.lassoButtonShouldExist() && lassoButtonData.push(1);
                    var lassoButtonSelection = navBarSelection.selectAll(mapUtil.Kq).data(lassoButtonData), lassoButtonSelectionEnter = lassoButtonSelection.enter().append("a").classed(mapUtil.mS, !0).classed(mapUtil.Gs, !0).attr("id", mapUtil.eP).attr("title", this.host.getLocalizedString(mapUtil.TM)).attr("role", "button").attr("aria-label", this.host.getLocalizedString(mapUtil.TM)).on("click", function() {
                        _this.plotLassoManager.setForceLasso(!0), d3.event.stopPropagation();
                    });
                    lassoButtonSelectionEnter.append("div").classed(mapUtil.RR, !0).classed(mapUtil.tE, this.style.isHighContrast), 
                    lassoButtonSelectionEnter.merge(lassoButtonSelection).classed(mapUtil.tE, this.style.isHighContrast || this.data && (0, 
                    bingMapTheme1.VW)(this.data.properties.mapTheme)), lassoButtonSelection.exit().remove();
                }
            }, Map.prototype.lassoButtonShouldExist = function() {
                var _a, mapProperties = null === (_a = this.data) || void 0 === _a ? void 0 : _a.properties;
                return this.data && !mapProperties.showHeatMap && mapProperties.showLassoButton;
            }, Map.MapContainer = {
                cssClass: "mapControl",
                selector: ".mapControl"
            }, Map.innerGeometryAlpha = .6, Map.StrokeDarkenColorValue = 63.75, Map.ScheduleRedrawInterval = 3e3, 
            Map.MapControlDisposeDelay = 1e3, Map.MarkerRadiusMin = 2, Map.MarkerRadiusDefault = 6, 
            Map.MarkerRadiusMax = 20, Map;
        }();
        function areLatLongNumeric(latitude, longitude) {
            return null != latitude && _.isFinite(latitude) && null != longitude && _.isFinite(longitude);
        }
        var timeoutWrapped, mapsModule, wrappedSetTimeout, wrappedSetInterval, StreetsideModeManager = function() {
            function StreetsideModeManager(mapControl, changedMode) {
                this.mapControl = mapControl, this.changedMode = changedMode, this.InStreetsideMode = this.mapControl.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside;
            }
            return StreetsideModeManager.prototype.start = function() {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this.mapControl, "maptypechanged", function(args) {
                    return _this.mapTypeChanged(args);
                });
            }, StreetsideModeManager.prototype.mapTypeChanged = function(args) {
                if (args.newMapTypeId === Microsoft.Maps.MapTypeId.streetside) {
                    if (this.InStreetsideMode) return;
                    this.changeMode(!0);
                } else {
                    if (!this.InStreetsideMode) return;
                    this.startTransitionToRoadTimeout();
                }
            }, StreetsideModeManager.prototype.cancelTransitionToRoadTimeout = function() {
                this.transitionToRoadTimeout && (clearInterval(this.transitionToRoadTimeout), this.transitionToRoadTimeout = void 0);
            }, StreetsideModeManager.prototype.startTransitionToRoadTimeout = function() {
                var _this = this;
                this.transitionToRoadTimeout || (this.transitionToRoadTimeout = setInterval(function() {
                    _this.mapControl.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside ? null != _this.mapControl.tryLocationToPixel(new Microsoft.Maps.Location(0, 0)) && _this.changeMode(!1) : _this.cancelTransitionToRoadTimeout();
                }, mapUtil.h$));
            }, StreetsideModeManager.prototype.changeMode = function(streetside) {
                this.InStreetsideMode = streetside, this.cancelTransitionToRoadTimeout(), this.changedMode(streetside);
            }, StreetsideModeManager;
        }();
        function unwrap() {
            timeoutWrapped && (mapsModule.setTimeout = wrappedSetTimeout, mapsModule.setInterval = wrappedSetInterval, 
            mapsModule = void 0, timeoutWrapped = void 0);
        }
        function wrap() {
            if (void 0 === timeoutWrapped) {
                timeoutWrapped = !1, mapsModule = Microsoft.Maps;
                var setTimeoutIsFunction = _.isFunction(mapsModule && mapsModule.setTimeout), setIntervalIsFunction = _.isFunction(mapsModule && mapsModule.setInterval);
                if (mapsModule && setTimeoutIsFunction && setIntervalIsFunction) try {
                    wrappedSetTimeout = mapsModule.setTimeout, wrappedSetInterval = mapsModule.setInterval, 
                    mapsModule.setTimeout = function(code, delay) {
                        return wrappedSetTimeout.apply(this, [ function() {
                            return callSafely(code);
                        }, delay ]);
                    }, mapsModule.setInterval = function(code, delay) {
                        return wrappedSetInterval.apply(this, [ function() {
                            return callSafely(code);
                        }, delay ]);
                    }, timeoutWrapped = !0;
                } catch (err) {
                    mapsModule.setTimeout = wrappedSetTimeout, mapsModule.setInterval = wrappedSetInterval, 
                    trace.f.error("Unable to wrap Microsoft.Maps.setTimeout", !1, void 0, {
                        error: err && err.stack || JSON.stringify(err)
                    });
                } else trace.f.error("Unable to wrap Microsoft.Maps.setTimeout", !1, void 0, {
                    gotMapsModule: !!mapsModule,
                    setTimeoutIsFunction,
                    setIntervalIsFunction
                });
            }
        }
        function callSafely(code) {
            try {
                return code.apply(null);
            } catch (error) {
                trace.f.error("Exception in Microsoft.Maps timeout callback", !1, void 0, {
                    error: error && error.stack || JSON.stringify(error)
                });
            }
        }
    },
    58778: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            B: function() {
                return BubblingEventManager;
            }
        });
        var _debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62458), _Utility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38078), listenersKey = "BubblingEventListeners", managerKey = "BubblingEventManager", BubblingEventManager = function() {
            function BubblingEventManager(root) {
                this.root = root, this.registeredBubblingEvents = {}, this.registeredCapturedEvents = {}, 
                this.rootNode = root.node(), (0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(this.rootNode, managerKey, this);
            }
            return BubblingEventManager.prototype.ensureEventRegistered = function(eventType, capture) {
                var _this = this, registeredEvents = capture ? this.registeredCapturedEvents : this.registeredBubblingEvents;
                if (!registeredEvents[eventType]) {
                    registeredEvents[eventType] = !0;
                    var handler = capture ? handleCapturedEvent : handleBubblingEvent, eventName = "".concat(eventType, ".").concat(managerKey);
                    capture && (eventName += "Capture"), this.root.on(eventName, function() {
                        handler(_this.root);
                    }, capture);
                }
            }, BubblingEventManager.prototype.on = function(element, eventName, listener, capture) {
                var eventType = function(eventName) {
                    var dot = eventName.indexOf(".");
                    return -1 === dot ? eventName : eventName.substr(0, dot);
                }(eventName);
                this.ensureEventRegistered(eventType, !!capture);
                var listeners = getListeners(element, !0);
                if (listeners) {
                    var typeListeners = listeners[eventType];
                    typeListeners || (listeners[eventType] = typeListeners = {
                        bubbling: {},
                        captured: {}
                    }), (capture ? typeListeners.captured : typeListeners.bubbling)[eventName] = listener;
                }
            }, BubblingEventManager;
        }();
        function getListeners(element, create) {
            var listeners = (0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(element, listenersKey);
            if (!listeners) {
                if (!create) return;
                (0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(element, listenersKey, listeners = {});
            }
            return listeners;
        }
        function dispatch(eventListeners) {
            for (var eventName in eventListeners) {
                var eventListener = eventListeners[eventName];
                eventListener && eventListener();
            }
        }
        function visitListeners(root, visit) {
            for (var rootNode = root.node(), event = d3.event, target = event.target; target; ) {
                var listeners = getListeners(target, !1);
                if (listeners) {
                    var typeListeners = listeners[event.type];
                    typeListeners && visit(typeListeners);
                }
                if (target === rootNode) break;
                _debug__WEBPACK_IMPORTED_MODULE_1__.fF.assert(function() {
                    return !(0, _Utility__WEBPACK_IMPORTED_MODULE_0__.aT)(target, managerKey);
                }, "BubblingEventManagers cannot overlap"), target = target.parentElement;
            }
        }
        function handleCapturedEvent(root) {
            var captureListeners = [];
            visitListeners(root, function(listeners) {
                var captured = listeners.captured;
                captured && captureListeners.push(captured);
            });
            for (var i = captureListeners.length; i-- > 0; ) dispatch(captureListeners[i]);
        }
        function handleBubblingEvent(root) {
            visitListeners(root, function(listeners) {
                var bubbling = listeners.bubbling;
                bubbling && dispatch(bubbling);
            });
        }
    }
} ]);