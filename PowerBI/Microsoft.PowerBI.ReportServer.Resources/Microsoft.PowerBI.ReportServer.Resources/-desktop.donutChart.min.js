"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "donutChart" ], {
    2375: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            DonutChart: function() {
                return DonutChart;
            },
            DonutChartConverter: function() {
                return DonutChartConverter;
            },
            DonutChartWebBehavior: function() {
                return DonutChartWebBehavior;
            },
            WebDonutChartAnimator: function() {
                return WebDonutChartAnimator;
            },
            animationDurationMs: function() {
                return animationDurationMs;
            },
            donutChartProps: function() {
                return donutChartProps;
            },
            ease: function() {
                return ease;
            }
        });
        var tslib_es6 = __webpack_require__(81337), animatorCommon = __webpack_require__(94478), donutChart_capabilities = __webpack_require__(26314), renderUtil = __webpack_require__(60066), colorEnumerationHelper2 = __webpack_require__(32554), common_colorHelper = __webpack_require__(90120), converterHelper = __webpack_require__(54522), dataLabelRendererEnhanced = __webpack_require__(5381), dataLabelUtil = __webpack_require__(46769), dataLabelViewModel1 = __webpack_require__(21181), invalidDataValuesChecker = __webpack_require__(33777), navigationUtils = __webpack_require__(49203), onObjectUtil = __webpack_require__(80065), htmlSubSelectionHelper = __webpack_require__(52287), subSelectionOutlineRenderer = __webpack_require__(86900), tooltipUtils = __webpack_require__(38400), visualLocKeys = __webpack_require__(33024), dataViewCategoricalReader = __webpack_require__(51129), legend_formatting = __webpack_require__(86727), legend_converter = __webpack_require__(79811), legend_util = __webpack_require__(77686), legend = __webpack_require__(65741), services_interactivityService = __webpack_require__(72902), tooltipService = __webpack_require__(40739), tooltip = __webpack_require__(11305), donutLabelBackground = __webpack_require__(30431), donutLabelPosition = __webpack_require__(82030), labelStyle = __webpack_require__(6916), visualWarnings = __webpack_require__(45296), debug = __webpack_require__(62458), Double = __webpack_require__(41640), d3Helper = __webpack_require__(34644), Prototype = __webpack_require__(39681), browserUtils = __webpack_require__(59107), build_control_util = __webpack_require__(56578), StandaloneUtility3 = __webpack_require__(43286), svgUtil = __webpack_require__(10389), enums = __webpack_require__(46135), contracts_selector = __webpack_require__(32379), dataViewObject2 = __webpack_require__(82755), valueFormatter = __webpack_require__(72489), selectionId = __webpack_require__(26543), dataLabelViewModel1Consts = __webpack_require__(56707), dataLabelViewModel1Utils = __webpack_require__(70188), fontProperties = __webpack_require__(18664), labelLayout1 = __webpack_require__(63972), labelLayout3 = __webpack_require__(54086), textMeasurementService = __webpack_require__(32041), CssConstants = __webpack_require__(79154), DonutUtil = {
            ChartClass: (0, CssConstants.CH)("donutChart"),
            LegendClass: (0, CssConstants.CH)("donutLegend"),
            LegendArrowClass: (0, CssConstants.CH)("donutLegendArrow"),
            SliceClass: (0, CssConstants.CH)("slice"),
            SliceContainerClass: (0, CssConstants.CH)("slices"),
            SliceHighlightClass: (0, CssConstants.CH)("slice-highlight"),
            SubSelectionSlicesClassAndSelector: (0, CssConstants.CH)("sub-selection-slices"),
            SubSelectionSliceClassAndSelector: (0, CssConstants.CH)("sub-selection-slice"),
            DefaultStrokeColorName: "foregroundLight",
            isSingleColor: function(dataPoints) {
                if (dataPoints.length > 1) {
                    var lastPoint = dataPoints.length - 1;
                    dataPoints[lastPoint].data.isLastInDonut = dataPoints[lastPoint].data.color === dataPoints[0].data.color;
                }
            },
            UpdateCurrentArcElementFunc: function(d) {
                this._current = d;
            },
            ArcDescriptorKeyFunc: function(d) {
                return d.data.identity.getKey();
            }
        };
        function explodeXOffset(angle, donutChartProperties) {
            var offset = donutChartProperties.explode;
            return Math.sin(angle) * offset;
        }
        function explodeYOffset(angle, donutChartProperties) {
            var offset = donutChartProperties.explode;
            return -Math.cos(angle) * offset;
        }
        function getLabelLeaderLineForDonutChart(donutArcDescriptor, donutProperties, parentPoint, sliceArc, xOff, yOff, featureSwitches) {
            var textPoint, midPoint, chartPoint;
            if (void 0 === sliceArc && (sliceArc = 0), void 0 === xOff && (xOff = 0), void 0 === yOff && (yOff = 0), 
            sliceArc) {
                var arc = sliceArc, labelRadius = donutProperties.labelRadius;
                midPoint = [ Math.cos(arc) * labelRadius, Math.sin(arc) * labelRadius ], chartPoint = [ Math.cos(arc) * labelRadius, Math.sin(arc) * labelRadius ];
            } else midPoint = donutProperties.labelArc.centroid(donutArcDescriptor), chartPoint = donutProperties.labelArc.centroid(donutArcDescriptor);
            (null == featureSwitches ? void 0 : featureSwitches.pieChartMarginBetweenSlices) && (midPoint[0] = midPoint[0] - xOff, 
            midPoint[1] = midPoint[1] - yOff, chartPoint[0] = chartPoint[0] - xOff, chartPoint[1] = chartPoint[1] - yOff);
            var textPointX = parentPoint.x, lineMargin = dataLabelViewModel1Consts.wh / 2;
            return textPoint = [ textPointX += textPointX < 0 ? -lineMargin : lineMargin, parentPoint.y ], 
            chartPoint[0] *= .9111111111111111, chartPoint[1] *= .9111111111111111, [ chartPoint, midPoint, textPoint ];
        }
        function getLabelLeaderLinesSizeForDonutChart(leaderLinePoints) {
            return leaderLinePoints && leaderLinePoints.length > 2 ? [ {
                width: Math.abs(leaderLinePoints[1][0] - leaderLinePoints[0][0]),
                height: Math.abs(leaderLinePoints[1][1] - leaderLinePoints[0][1])
            }, {
                width: Math.abs(leaderLinePoints[2][0] - leaderLinePoints[1][0]),
                height: dataLabelViewModel1Consts.Pd
            } ] : null;
        }
        function getXPositionForDonutLabel(textPointX) {
            return textPointX + (textPointX < 0 ? -dataLabelViewModel1Consts.wh : dataLabelViewModel1Consts.wh);
        }
        function getSpaceAvailableForDonutLabels(labelXPos, viewport) {
            return viewport.width / 2 - Math.abs(labelXPos) - dataLabelViewModel1Consts.wh;
        }
        function canLabelFit(donutArcDescriptor, donutProperties, labelRect) {
            for (var left = labelRect.left, right = labelRect.left + labelRect.width, top = labelRect.top, bottom = labelRect.top + labelRect.height, _i = 0, fourPoints_1 = [ {
                x: left,
                y: top
            }, {
                x: left,
                y: bottom
            }, {
                x: right,
                y: top
            }, {
                x: right,
                y: bottom
            } ]; _i < fourPoints_1.length; _i++) if (!canPointFit(donutArcDescriptor, donutProperties, fourPoints_1[_i])) return !1;
            return !0;
        }
        function canPointFit(donutArcDescriptor, donutProperties, point) {
            var distanceToPoint = Math.sqrt(point.x * point.x + point.y * point.y);
            if (distanceToPoint < donutProperties.innerRadius) return !1;
            if (distanceToPoint > donutProperties.outerRadius) return !1;
            var angle = function(point) {
                if (debug.fF.assertValue(point, "DonutLabelUtils.getAngleFromPoint received a null point"), 
                point) {
                    var x = point.x, y = -point.y;
                    debug.fF.assertValue(x, "DonutLabelUtils.getAngleFromPoint received a point containing null"), 
                    debug.fF.assertValue(y, "DonutLabelUtils.getAngleFromPoint received a point containing null"), 
                    debug.fF.assert(function() {
                        return 0 !== x || 0 !== y;
                    }, "DonutLabelUtils.getAngleFromPoint received the point (0,0)");
                    var angleInDegrees = Math.atan2(x, y);
                    return angleInDegrees < 0 && (angleInDegrees += 2 * Math.PI), angleInDegrees;
                }
            }(point);
            return !(angle < donutArcDescriptor.startAngle || angle > donutArcDescriptor.endAngle);
        }
        var multiOptionsLabelStyle = [ labelStyle._q, labelStyle.f3, labelStyle.ev, labelStyle.qv ], radialPositionAdjustments = [ 0, 1, 2, 3, 4 ], DonutLabelLayout = function() {
            function DonutLabelLayout(donutChartProperties) {
                this.donutChartProperties = donutChartProperties, this.center = {
                    x: donutChartProperties.viewport.width / 2,
                    y: donutChartProperties.viewport.height / 2
                }, this.labelRadius = this.donutChartProperties.labelRadius;
                var textProperties = (0, fontProperties.qk)(donutChartProperties.dataLabelsSettings.fontProperties);
                this.additionalParenthesesWidth = textMeasurementService.b.measureSvgTextWidth(textProperties, "()"), 
                this.additionalSpaceWidth = textMeasurementService.b.measureSvgTextWidth(textProperties, " "), 
                this.ellipsisWidth = textMeasurementService.b.measureSvgTextWidth(textProperties, "\u2026");
            }
            return DonutLabelLayout.prototype.layout = function(labelDataPoints, labelSettings, featureSwitches) {
                for (var donutLabelDataPointsLayoutInfo = [], _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                    var donutLabel = labelDataPoints_1[_i];
                    donutLabelDataPointsLayoutInfo.push({
                        labelDataPoint: donutLabel,
                        hasBeenRendered: !1,
                        labelSize: donutLabel.textSize
                    });
                }
                for (var resultingLabels = [], preferredLabelsLayoutInfo = [], grid = new labelLayout1.qC([ {
                    labelDataPoints: donutLabelDataPointsLayoutInfo,
                    maxNumberOfLabels: labelDataPoints.length
                } ], this.donutChartProperties.viewport), i = donutLabelDataPointsLayoutInfo.length - 1; i >= 0; i--) donutLabelDataPointsLayoutInfo[i].labelDataPoint.isPreferred && (preferredLabelsLayoutInfo = donutLabelDataPointsLayoutInfo.splice(i, 1).concat(preferredLabelsLayoutInfo));
                if (preferredLabelsLayoutInfo.length > 0 && (resultingLabels = this.positionLabels(preferredLabelsLayoutInfo, grid, labelSettings, featureSwitches)), 
                labelDataPoints.length > 0) {
                    var labels = this.positionLabels(donutLabelDataPointsLayoutInfo, grid, labelSettings, featureSwitches);
                    resultingLabels = resultingLabels.concat(labels);
                }
                return _.filter(resultingLabels, function(d) {
                    return d.isVisible;
                });
            }, DonutLabelLayout.prototype.positionLabels = function(donutLabelDataPointsLayoutInfo, grid, labelSettings, featureSwitches) {
                var _this = this, resultingLabels = [], anyLabelOverflows = !1, positionLabels = function(positionFunction) {
                    for (var _i = 0, donutLabelDataPointsLayoutInfo_1 = donutLabelDataPointsLayoutInfo; _i < donutLabelDataPointsLayoutInfo_1.length; _i++) {
                        var donutLabelDataPointLayoutInfo = donutLabelDataPointsLayoutInfo_1[_i];
                        if (!donutLabelDataPointLayoutInfo.hasBeenRendered) {
                            var result = positionFunction(donutLabelDataPointLayoutInfo, grid);
                            if (result) {
                                var label = result.label;
                                label && (result.overflows && (anyLabelOverflows = !0), donutLabelDataPointLayoutInfo.hasBeenRendered = !0, 
                                resultingLabels.push(label));
                            }
                        }
                    }
                }, positionOutside = function() {
                    positionLabels(function(donutLabelDataPointLayoutInfo, grid) {
                        return {
                            label: _this.tryOutsidePositionForDonut(donutLabelDataPointLayoutInfo, grid, labelSettings, featureSwitches),
                            overflows: !0
                        };
                    });
                }, positionInside = function() {
                    positionLabels(function(donutLabelDataPointLayoutInfo, grid) {
                        if (_.includes(multiOptionsLabelStyle, _this.donutChartProperties.dataLabelsSettings.labelStyle)) {
                            var splitLabelDataPointLayoutInfo = _this.splitDonutDataPoint(donutLabelDataPointLayoutInfo, _this.donutChartProperties.dataLabelsSettings.labelStyle);
                            return _this.tryInsidePositionForDonut(splitLabelDataPointLayoutInfo, _this.donutChartProperties, grid, labelSettings);
                        }
                        return _this.tryInsidePositionForDonut(donutLabelDataPointLayoutInfo, _this.donutChartProperties, grid, labelSettings);
                    });
                };
                switch (labelSettings.position ?? donutLabelPosition.SX) {
                  case donutLabelPosition.SX:
                    positionOutside();
                    break;

                  case donutLabelPosition.Od:
                    positionInside();
                    break;

                  case donutLabelPosition.gC:
                    positionOutside(), positionInside();
                    break;

                  case donutLabelPosition.UX:
                    positionInside(), positionOutside();
                }
                if (anyLabelOverflows && labelSettings.enableBackgroundWithAuto === donutLabelBackground.d7) for (var _i = 0, resultingLabels_1 = resultingLabels; _i < resultingLabels_1.length; _i++) {
                    var label = resultingLabels_1[_i];
                    label.outside || (label.hasBackground = !0);
                }
                return resultingLabels;
            }, DonutLabelLayout.prototype.tryOutsidePositionForDonut = function(donutLabelDataPointLayoutInfo, grid, labelSettings, featureSwitches) {
                var parentShape = donutLabelDataPointLayoutInfo.labelDataPoint.parentShape;
                if (!_.isEmpty(parentShape.validPositions) && 0 !== parentShape.validPositions[0]) {
                    var defaultPosition = parentShape.validPositions[0], bestCandidate = this.tryAllOutsidePositions(donutLabelDataPointLayoutInfo, grid, defaultPosition, featureSwitches);
                    if (bestCandidate && 0 === bestCandidate.score) return this.buildLabel(bestCandidate, grid, !0, labelSettings);
                    if (_.includes(multiOptionsLabelStyle, this.donutChartProperties.dataLabelsSettings.labelStyle)) {
                        var splitLabelDataPointLayoutInfo = this.splitDonutDataPoint(donutLabelDataPointLayoutInfo, this.donutChartProperties.dataLabelsSettings.labelStyle), bestSplitCandidate = this.tryAllOutsidePositions(splitLabelDataPointLayoutInfo, grid, defaultPosition, featureSwitches);
                        if (bestSplitCandidate && (!bestCandidate || bestSplitCandidate.score < bestCandidate.score)) return this.buildLabel(bestSplitCandidate, grid, !0, labelSettings);
                    }
                    return bestCandidate ? this.buildLabel(bestCandidate, grid, !0, labelSettings) : void 0;
                }
            }, DonutLabelLayout.prototype.tryInsidePositionForDonut = function(donutLabelDataPointLayoutInfo, donutChartProperties, grid, labelSettings) {
                var bestCandidate = this.tryAllInsidePositions(donutLabelDataPointLayoutInfo, donutChartProperties, grid, labelSettings.overflow);
                if (bestCandidate) return {
                    label: this.buildLabel(bestCandidate, grid, !1, labelSettings),
                    overflows: bestCandidate.overflows
                };
            }, DonutLabelLayout.prototype.generateCandidate = function(donutLabelDataPointLayoutInfo, candidatePosition, grid, featureSwitches) {
                var labelDataPoint = donutLabelDataPointLayoutInfo.labelDataPoint, angle = DonutLabelLayout.generateCandidateAngleForPosition(labelDataPoint.donutArcDescriptor, candidatePosition), parentShape = this.getPointPositionForAngle(angle), parentPoint = parentShape.point, score = this.score(labelDataPoint, parentPoint), explodeAngle = (labelDataPoint.donutArcDescriptor.startAngle + labelDataPoint.donutArcDescriptor.endAngle) / 2, xOff = explodeXOffset(explodeAngle, this.donutChartProperties), yOff = explodeYOffset(explodeAngle, this.donutChartProperties), leaderLinePoints = getLabelLeaderLineForDonutChart(labelDataPoint.donutArcDescriptor, this.donutChartProperties, parentPoint, angle, xOff, yOff, featureSwitches), leaderLinesSize = getLabelLeaderLinesSizeForDonutChart(leaderLinePoints), newLabelDataPoint = _.clone(labelDataPoint);
                return newLabelDataPoint.parentShape = parentShape, newLabelDataPoint.leaderLinePoints = leaderLinePoints, 
                newLabelDataPoint.linesSize = leaderLinesSize, {
                    point: parentShape,
                    score,
                    labelRects: DonutLabelLayout.tryPositionPoint(grid, parentShape.validPositions[0], newLabelDataPoint, this.center, this.donutChartProperties.viewport, 0, featureSwitches),
                    donutLabelDataPointLayoutInfo: {
                        labelDataPoint: newLabelDataPoint,
                        hasBeenRendered: donutLabelDataPointLayoutInfo.hasBeenRendered,
                        labelSize: donutLabelDataPointLayoutInfo.labelSize
                    },
                    renderLeaderLines: !0,
                    overflows: !1
                };
            }, DonutLabelLayout.prototype.tryAllOutsidePositions = function(donutLabelDataPointLayoutInfo, grid, defaultPosition, featureSwitches) {
                var labelDataPoint = donutLabelDataPointLayoutInfo.labelDataPoint, boundingBoxes = DonutLabelLayout.tryPositionPoint(grid, defaultPosition, labelDataPoint, this.center, this.donutChartProperties.viewport, this.donutChartProperties.explode, featureSwitches), originalPoint = labelDataPoint.parentShape, originalCandidate = {
                    point: originalPoint,
                    score: this.score(labelDataPoint, originalPoint.point),
                    labelRects: boundingBoxes,
                    donutLabelDataPointLayoutInfo,
                    renderLeaderLines: !0,
                    overflows: !1
                };
                if (boundingBoxes && boundingBoxes.textRect && 0 === originalCandidate.score) return originalCandidate;
                var bestCandidate, positions = [];
                boundingBoxes && boundingBoxes.textRect ? (positions = DonutLabelLayout.getLabelPointPositions(labelDataPoint.parentShape, !0), 
                bestCandidate = originalCandidate) : positions = DonutLabelLayout.getLabelPointPositions(labelDataPoint.parentShape, !1);
                for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                    var candidate = this.generateCandidate(donutLabelDataPointLayoutInfo, positions_1[_i], grid, featureSwitches);
                    if (candidate.labelRects && candidate.labelRects.textRect && (null == bestCandidate || candidate.score < bestCandidate.score) && 0 === (bestCandidate = candidate).score) return bestCandidate;
                }
                return bestCandidate;
            }, DonutLabelLayout.prototype.tryAllInsidePositions = function(donutLabelDataPointLayoutInfo, donutChartProperties, grid, allowOverflow) {
                for (var bestParentPoint, bestOffsetRect, bestScore, bestOverflows, angle = donutLabelDataPointLayoutInfo.labelDataPoint.angle, midRadius = (donutChartProperties.innerRadius + donutChartProperties.outerRadius) / 2, xOff = explodeXOffset(angle, donutChartProperties), yOff = explodeYOffset(angle, donutChartProperties), _i = 0, radialPositionAdjustments_1 = radialPositionAdjustments; _i < radialPositionAdjustments_1.length; _i++) {
                    var offsetRect, position = this.getInsidePosition(donutLabelDataPointLayoutInfo, donutChartProperties, angle, midRadius, radialPositionAdjustments_1[_i]), score = this.score(donutLabelDataPointLayoutInfo.labelDataPoint, position), parentPoint = {
                        point: position,
                        radius: 0,
                        validPositions: [ 256 ]
                    }, labelRect = (0, labelLayout3.c)(donutLabelDataPointLayoutInfo.labelDataPoint.textSize, parentPoint, 256, 0);
                    offsetRect = 0 === donutChartProperties.explode ? {
                        left: labelRect.left + this.center.x,
                        top: labelRect.top + this.center.y,
                        width: labelRect.width,
                        height: labelRect.height
                    } : {
                        left: labelRect.left + this.center.x + xOff,
                        top: labelRect.top + this.center.y + yOff,
                        width: labelRect.width,
                        height: labelRect.height
                    };
                    var overflows = !canLabelFit(donutLabelDataPointLayoutInfo.labelDataPoint.donutArcDescriptor, donutChartProperties, labelRect);
                    !(null == bestScore || score > bestScore) || grid.hasConflict(offsetRect) || !allowOverflow && overflows || (bestParentPoint = parentPoint, 
                    bestOffsetRect = offsetRect, bestScore = score, bestOverflows = overflows);
                }
                if (bestParentPoint) return {
                    point: bestParentPoint,
                    score: 0,
                    labelRects: {
                        textRect: bestOffsetRect,
                        diagonalLineRect: null,
                        horizontalLineRect: null
                    },
                    donutLabelDataPointLayoutInfo,
                    renderLeaderLines: !1,
                    overflows: bestOverflows
                };
            }, DonutLabelLayout.prototype.getInsidePosition = function(donutLabelDataPointLayoutInfo, donutChartProperties, angle, midRadius, positionAdjustment) {
                var adjustedRadius = midRadius, adjustedAngle = angle;
                switch (positionAdjustment) {
                  case 0:
                    break;

                  case 1:
                    adjustedRadius = midRadius + .25 * (donutChartProperties.outerRadius - donutChartProperties.innerRadius);
                    break;

                  case 2:
                    adjustedRadius = midRadius - .25 * (donutChartProperties.outerRadius - donutChartProperties.innerRadius);
                    break;

                  case 3:
                    adjustedAngle = angle + .25 * (donutLabelDataPointLayoutInfo.labelDataPoint.donutArcDescriptor.endAngle - donutLabelDataPointLayoutInfo.labelDataPoint.donutArcDescriptor.startAngle);
                    break;

                  case 4:
                    adjustedAngle = angle - .25 * (donutLabelDataPointLayoutInfo.labelDataPoint.donutArcDescriptor.endAngle - donutLabelDataPointLayoutInfo.labelDataPoint.donutArcDescriptor.startAngle);
                    break;

                  default:
                    debug.fF.assertNever(positionAdjustment);
                }
                return function(angle, midRadius) {
                    var y;
                    return debug.fF.assert(function() {
                        return angle <= 2 * Math.PI && angle >= 0;
                    }, "DonutLabelUtils got an angle that was not betweeen 0 and 2 PI in radians (inclusive)"), 
                    y = midRadius * Math.sin(angle - Math.PI / 2), {
                        x: midRadius * Math.cos(angle - Math.PI / 2),
                        y
                    };
                }(adjustedAngle, adjustedRadius);
            }, DonutLabelLayout.prototype.buildLabel = function(labelLayout, grid, outside, labelSettings) {
                var isVisible, resultingBoundingBox = labelLayout.labelRects.textRect, horizontalLineRect = labelLayout.labelRects.horizontalLineRect, diagonalLineRect = labelLayout.labelRects.diagonalLineRect, labelPoint = labelLayout.donutLabelDataPointLayoutInfo.labelDataPoint;
                null == labelPoint.categoryLabel && null == labelPoint.dataLabel && null == labelPoint.percentLabel || (isVisible = !0), 
                grid.add(resultingBoundingBox), horizontalLineRect && grid.add(horizontalLineRect), 
                diagonalLineRect && grid.add(diagonalLineRect);
                var textAnchor, top = resultingBoundingBox.top - this.center.y, left = resultingBoundingBox.left - this.center.x;
                switch (outside && (left < 0 ? left += resultingBoundingBox.width / 2 : left -= resultingBoundingBox.width / 2), 
                labelLayout.point.validPositions[0]) {
                  case 8:
                    textAnchor = "start";
                    break;

                  case 4:
                    textAnchor = "end";
                    break;

                  case 256:
                    textAnchor = "middle";
                    break;

                  default:
                    debug.fF.assertFail("DonutLabelLayout.buildLabel received a shape with an unknown valid position");
                }
                var formattedDataLabel, formattedCategoryLabel, formattedPercentLabel, text, boundingBox = {
                    left,
                    top,
                    height: resultingBoundingBox.height,
                    width: resultingBoundingBox.width
                }, labelSettingsStyle = (0, dataLabelViewModel1Utils.RC)(this.donutChartProperties.dataLabelsSettings.labelStyle), spaceAvailableForCategoryLabels = getSpaceAvailableForDonutLabels(labelPoint.parentShape.point.x, this.donutChartProperties.viewport), spaceAvailableForDataLabels = spaceAvailableForCategoryLabels, getLabelTailoredText = dataLabelViewModel1.Gv;
                if (labelSettingsStyle === labelStyle.YK.categoryAndDataAndPercent ? null == labelPoint.secondRowText ? spaceAvailableForDataLabels = spaceAvailableForCategoryLabels /= 3 : spaceAvailableForDataLabels /= 2 : labelSettingsStyle === labelStyle.YK.categoryAndData ? null == labelPoint.secondRowText && (spaceAvailableForDataLabels = spaceAvailableForCategoryLabels /= 2) : labelSettingsStyle !== labelStyle.YK.categoryAndPercent && labelSettingsStyle !== labelStyle.YK.dataAndPercent || null == labelPoint.secondRowText && (spaceAvailableForDataLabels = spaceAvailableForCategoryLabels /= 2), 
                (0, StandaloneUtility3.yE)(labelSettingsStyle, labelStyle.nO)) {
                    var maxWidth = void 0;
                    (maxWidth = labelSettingsStyle !== labelStyle.YK.categoryAndDataAndPercent && labelSettingsStyle !== labelStyle.YK.categoryAndData || null != labelPoint.secondRowText ? spaceAvailableForDataLabels : spaceAvailableForDataLabels - this.additionalSpaceWidth) < this.ellipsisWidth && (isVisible = !1), 
                    formattedDataLabel = getLabelTailoredText({
                        label: labelPoint.dataLabel,
                        maxWidth,
                        fontProperties: labelPoint.fontProperties
                    });
                }
                if ((0, StandaloneUtility3.yE)(labelSettingsStyle, labelStyle.mA) && (spaceAvailableForCategoryLabels < this.ellipsisWidth && (isVisible = !1), 
                formattedCategoryLabel = getLabelTailoredText({
                    label: labelPoint.categoryLabel,
                    maxWidth: spaceAvailableForCategoryLabels,
                    fontProperties: labelPoint.fontProperties
                })), (0, StandaloneUtility3.yE)(labelSettingsStyle, labelStyle.tG)) {
                    switch (maxWidth = void 0, labelSettingsStyle) {
                      case labelStyle.YK.categoryAndDataAndPercent:
                        maxWidth = spaceAvailableForDataLabels - this.additionalParenthesesWidth - this.additionalSpaceWidth;
                        break;

                      case labelStyle.YK.dataAndPercent:
                        maxWidth = null == labelPoint.secondRowText ? spaceAvailableForDataLabels - this.additionalParenthesesWidth - this.additionalSpaceWidth : spaceAvailableForDataLabels - this.additionalParenthesesWidth;
                        break;

                      case labelStyle.YK.categoryAndPercent:
                        maxWidth = spaceAvailableForDataLabels - this.additionalSpaceWidth;
                        break;

                      case labelStyle.YK.percent:
                        maxWidth = spaceAvailableForDataLabels;
                        break;

                      default:
                        debug.fF.assertFail("Unexpected labelStyle: " + labelSettingsStyle), maxWidth = spaceAvailableForDataLabels;
                    }
                    maxWidth < this.ellipsisWidth && (isVisible = !1), formattedPercentLabel = getLabelTailoredText({
                        label: labelPoint.percentLabel,
                        maxWidth,
                        fontProperties: labelPoint.fontProperties
                    });
                }
                switch (formattedDataLabel && "\u2026" !== formattedDataLabel || formattedCategoryLabel && "\u2026" !== formattedCategoryLabel || formattedPercentLabel && "\u2026" !== formattedPercentLabel || (isVisible = !1), 
                labelSettingsStyle) {
                  case labelStyle.YK.categoryAndDataAndPercent:
                    formattedPercentLabel = formattedPercentLabel ? "(".concat(formattedPercentLabel, ")") : null, 
                    null == labelPoint.secondRowText ? text = (0, dataLabelViewModel1Utils.Ej)([ formattedCategoryLabel, formattedDataLabel, formattedPercentLabel ], " ") : (text = (0, 
                    dataLabelViewModel1Utils.Ej)([ formattedDataLabel, formattedPercentLabel ], " "), 
                    labelPoint.secondRowText = formattedCategoryLabel);
                    break;

                  case labelStyle.YK.categoryAndData:
                    null == labelPoint.secondRowText ? text = (0, dataLabelViewModel1Utils.Ej)([ formattedCategoryLabel, formattedDataLabel ], " ") : (text = formattedDataLabel, 
                    labelPoint.secondRowText = formattedCategoryLabel);
                    break;

                  case labelStyle.YK.categoryAndPercent:
                    null == labelPoint.secondRowText ? text = (0, dataLabelViewModel1Utils.Ej)([ formattedCategoryLabel, formattedPercentLabel ], " ") : (text = formattedPercentLabel, 
                    labelPoint.secondRowText = formattedCategoryLabel);
                    break;

                  case labelStyle.YK.dataAndPercent:
                    formattedPercentLabel = formattedPercentLabel ? "(".concat(formattedPercentLabel, ")") : null, 
                    null == labelPoint.secondRowText ? text = (0, dataLabelViewModel1Utils.Ej)([ formattedDataLabel, formattedPercentLabel ], " ") : (text = formattedPercentLabel, 
                    labelPoint.secondRowText = formattedDataLabel);
                    break;

                  case labelStyle.YK.data:
                    text = formattedDataLabel;
                    break;

                  case labelStyle.YK.percent:
                    text = formattedPercentLabel;
                    break;

                  case labelStyle.YK.category:
                    text = formattedCategoryLabel;
                    break;

                  default:
                    debug.fF.assertFail("Unexpected labelStyle: " + labelSettingsStyle), text = formattedCategoryLabel;
                }
                return labelPoint.textSize.width = Math.min(labelPoint.textSize.width, labelSettingsStyle === labelStyle.YK.categoryAndDataAndPercent && null == labelPoint.secondRowText ? spaceAvailableForCategoryLabels + spaceAvailableForDataLabels + spaceAvailableForDataLabels : labelSettingsStyle === labelStyle.YK.categoryAndData || labelSettingsStyle === labelStyle.YK.categoryAndPercent ? spaceAvailableForCategoryLabels + spaceAvailableForDataLabels : labelSettingsStyle === labelStyle.YK.dataAndPercent ? spaceAvailableForDataLabels + spaceAvailableForDataLabels : spaceAvailableForCategoryLabels), 
                {
                    boundingBox,
                    text,
                    tooltip: outside ? labelPoint.tooltip : null,
                    isVisible,
                    identity: labelPoint.identity,
                    fontProperties: (0, fontProperties.ED)(labelPoint.fontProperties, {
                        color: outside ? labelPoint.outsideFill : labelPoint.insideFill
                    }),
                    selected: !1,
                    textAnchor,
                    leaderLinePoints: labelLayout.renderLeaderLines ? labelPoint.leaderLinePoints : void 0,
                    hasBackground: !outside && labelSettings.enableBackgroundWithAuto === donutLabelBackground.on,
                    secondRowText: labelPoint.secondRowText,
                    backgroundColor: labelPoint.backgroundColor,
                    backgroundTransparency: labelPoint.backgroundTransparency,
                    outside
                };
            }, DonutLabelLayout.tryPositionPoint = function(grid, position, labelDataPoint, center, viewport, explodeOffset, featureSwitches) {
                void 0 === explodeOffset && (explodeOffset = 0);
                var offset, parentPoint = labelDataPoint.parentShape;
                offset = (null == featureSwitches ? void 0 : featureSwitches.pieChartMarginBetweenSlices) ? dataLabelViewModel1Consts.ki - explodeOffset < dataLabelViewModel1Consts.ki ? dataLabelViewModel1Consts.ki : dataLabelViewModel1Consts.ki - explodeOffset : dataLabelViewModel1Consts.ki;
                var textSize = _.clone(labelDataPoint.textSize);
                textSize.width = Math.min(textSize.width, getSpaceAvailableForDonutLabels(parentPoint.point.x, viewport));
                var labelRect = (0, labelLayout3.c)(textSize, parentPoint, position, offset), diagonalLineRect = (0, 
                labelLayout3.c)(labelDataPoint.linesSize[0], {
                    point: {
                        x: labelDataPoint.leaderLinePoints[0][0],
                        y: labelDataPoint.leaderLinePoints[0][1] < 0 ? labelDataPoint.leaderLinePoints[1][1] : labelDataPoint.leaderLinePoints[0][1]
                    },
                    radius: 0,
                    validPositions: null
                }, position, offset), horizontalLineRect = (0, labelLayout3.c)(labelDataPoint.linesSize[1], {
                    point: {
                        x: labelDataPoint.leaderLinePoints[1][0],
                        y: labelDataPoint.leaderLinePoints[1][1]
                    },
                    radius: 0,
                    validPositions: null
                }, position, offset);
                if (labelRect && diagonalLineRect && horizontalLineRect) {
                    labelRect.left += center.x, labelRect.top += center.y;
                    var centerForLinesWidth = center.x - labelRect.width / 2;
                    return diagonalLineRect.left += centerForLinesWidth, diagonalLineRect.top += center.y, 
                    horizontalLineRect.left += centerForLinesWidth, horizontalLineRect.top += center.y, 
                    grid.hasConflict(labelRect) || grid.hasConflict(diagonalLineRect) || grid.hasConflict(horizontalLineRect) ? void 0 : {
                        textRect: labelRect,
                        diagonalLineRect,
                        horizontalLineRect
                    };
                }
            }, DonutLabelLayout.getLabelPointPositions = function(parentShape, isTruncated) {
                var position = parentShape.validPositions[0];
                return isTruncated ? parentShape.point.y < 0 ? 8 === position ? [ 64 ] : [ 128 ] : 8 === position ? [ 16 ] : [ 32 ] : 4 === position ? [ 128, 32 ] : [ 16, 64 ];
            }, DonutLabelLayout.prototype.splitDonutDataPoint = function(donutLabelDataPointLayoutInfo, labelSettingStyle) {
                var percentLabelWidth, labelPoint = donutLabelDataPointLayoutInfo.labelDataPoint, categoryLabelWidth = labelPoint.categoryLabelSize ? labelPoint.categoryLabelSize.width : 0, dataLabelWidth = labelPoint.dataLabelSize ? labelPoint.dataLabelSize.width : 0;
                percentLabelWidth = labelPoint.percentLabelSize ? labelSettingStyle === labelStyle.qv ? labelPoint.percentLabelSize.width + this.additionalParenthesesWidth : labelSettingStyle === labelStyle._q ? labelPoint.percentLabelSize.width + this.additionalParenthesesWidth + this.additionalSpaceWidth : labelPoint.percentLabelSize.width : 0;
                var categoryLabelHeight = labelPoint.categoryLabelSize ? labelPoint.categoryLabelSize.height : 0, dataLabelHeight = labelPoint.dataLabelSize ? labelPoint.dataLabelSize.height : 0, percentLabelHeight = labelPoint.percentLabelSize ? labelPoint.percentLabelSize.height : 0, textSize = {
                    width: labelSettingStyle === labelStyle.qv ? Math.max(dataLabelWidth, percentLabelWidth) : Math.max(categoryLabelWidth, dataLabelWidth + percentLabelWidth),
                    height: 2 * Math.max(categoryLabelHeight, Math.max(dataLabelHeight, percentLabelHeight))
                }, newLabelDataPoint = _.clone(labelPoint);
                return newLabelDataPoint.textSize = textSize, newLabelDataPoint.secondRowText = labelSettingStyle === labelStyle.qv ? labelPoint.dataLabel : labelPoint.categoryLabel, 
                {
                    labelDataPoint: newLabelDataPoint,
                    hasBeenRendered: donutLabelDataPointLayoutInfo.hasBeenRendered,
                    labelSize: donutLabelDataPointLayoutInfo.labelSize
                };
            }, DonutLabelLayout.generateCandidateAngleForPosition = function(d, position) {
                var midAngle = d.startAngle + (d.endAngle - d.startAngle) / 2;
                switch (position) {
                  case 64:
                  case 32:
                    return (d.startAngle + midAngle - Math.PI) / 2;

                  case 128:
                  case 16:
                    return (midAngle + d.endAngle - Math.PI) / 2;

                  default:
                    debug.fF.assertFail("Unsupported label position");
                }
            }, DonutLabelLayout.prototype.getPointPositionForAngle = function(angle) {
                var labelX = getXPositionForDonutLabel(Math.cos(angle) * this.labelRadius);
                return {
                    point: {
                        x: labelX,
                        y: Math.sin(angle) * this.labelRadius
                    },
                    validPositions: [ labelX < 0 ? 4 : 8 ],
                    radius: 0
                };
            }, DonutLabelLayout.prototype.score = function(labelPoint, point) {
                var textWidth, spaceAvailableForLabels = getSpaceAvailableForDonutLabels(point.x, this.donutChartProperties.viewport), labelSettingsStyle = this.donutChartProperties.dataLabelsSettings.labelStyle, categoryLabelWidth = labelPoint.categoryLabelSize ? labelPoint.categoryLabelSize.width : 0, dataLabelWidth = labelPoint.dataLabelSize ? labelPoint.dataLabelSize.width : 0, percentLabelWidth = labelPoint.percentLabelSize ? labelPoint.percentLabelSize.width : 0;
                if (labelSettingsStyle === labelStyle._q) {
                    if (null != labelPoint.secondRowText) {
                        var firstLineScore = Math.max(categoryLabelWidth - spaceAvailableForLabels, 0), secondeLineScore = Math.max(Math.max(dataLabelWidth, percentLabelWidth + this.additionalParenthesesWidth + this.additionalSpaceWidth) - spaceAvailableForLabels / 2, 0);
                        return Math.max(firstLineScore, secondeLineScore);
                    }
                    textWidth = Math.max(categoryLabelWidth, dataLabelWidth + this.additionalSpaceWidth, percentLabelWidth + this.additionalParenthesesWidth + this.additionalSpaceWidth), 
                    spaceAvailableForLabels /= 3;
                } else labelSettingsStyle === labelStyle.f3 && null == labelPoint.secondRowText ? (textWidth = Math.max(categoryLabelWidth, dataLabelWidth + this.additionalSpaceWidth), 
                spaceAvailableForLabels /= 2) : labelSettingsStyle === labelStyle.ev && null == labelPoint.secondRowText ? (textWidth = Math.max(categoryLabelWidth, percentLabelWidth + this.additionalSpaceWidth), 
                spaceAvailableForLabels /= 2) : labelSettingsStyle === labelStyle.qv ? (textWidth = null == labelPoint.secondRowText ? Math.max(dataLabelWidth, percentLabelWidth + this.additionalParenthesesWidth + this.additionalSpaceWidth) : Math.max(dataLabelWidth, percentLabelWidth + this.additionalParenthesesWidth), 
                spaceAvailableForLabels /= 2) : textWidth = labelPoint.textSize.width;
                return Math.max(textWidth - spaceAvailableForLabels, 0);
            }, DonutLabelLayout;
        }(), WebDonutChartAnimator = function(_super) {
            function WebDonutChartAnimator(options) {
                return _super.call(this, options) || this;
            }
            return (0, tslib_es6.__extends)(WebDonutChartAnimator, _super), WebDonutChartAnimator.prototype.animate = function(options) {
                var _a, _b, _c, _d, _this = this;
                if (options.viewModel.highlightsOverflow || !this.previousViewModel || this.previousViewModel.highlightsOverflow) return this.previousViewModel = options.viewModel, 
                WebDonutChartAnimator.FailedResult;
                var previousHasHighlights = null === (_c = this.previousViewModel) || void 0 === _c ? void 0 : _c.hasHighlights, currentHasHighlights = options.viewModel.hasHighlights, transitionType = currentHasHighlights && !previousHasHighlights ? 0 : currentHasHighlights && previousHasHighlights ? 1 : !currentHasHighlights && previousHasHighlights ? 2 : void 0;
                if (null == transitionType) return this.previousViewModel = options.viewModel, WebDonutChartAnimator.FailedResult;
                var setCommonStyles = function(shapes) {
                    return shapes.style("fill", function(d) {
                        var _a;
                        return null !== (_a = d.data.color) && void 0 !== _a ? _a : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value;
                    }).style("stroke", common_colorHelper.v.getThemeColor(options.style, DonutUtil.DefaultStrokeColorName)).style("stroke-width", function(d) {
                        return d.data.strokeWidth;
                    });
                }, setOpacities = function(shapes, func) {
                    return shapes.style("fill-opacity", func).style("stroke-opacity", func);
                }, setAnimation = function(shapes) {
                    return shapes.transition().duration(_this.animationDuration);
                }, getShapeSelections = function(dataPoints, shapeClass) {
                    DonutUtil.isSingleColor(dataPoints);
                    var shapes = options.graphicsContext.select(DonutUtil.SliceContainerClass.selector).selectAll(shapeClass.selector).data(dataPoints, DonutUtil.ArcDescriptorKeyFunc);
                    return {
                        updated: shapes.enter().insert("path").classed(shapeClass.class, !0).each(DonutUtil.UpdateCurrentArcElementFunc).merge(shapes),
                        removed: shapes.exit()
                    };
                }, updated = (_a = getShapeSelections(options.viewModel.dataPoints, DonutUtil.SliceClass)).updated, removed = _a.removed;
                setCommonStyles(updated), setOpacities(updated, 2 === transitionType ? function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, d.data.selected, !d.data.selected);
                } : function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, !1, options.viewModel.hasHighlights);
                });
                var shapesUpdateWithTransition = setAnimation(updated).attrs(options.layout.shapeLayout.attrs).styles(options.layout.shapeLayout.styles);
                2 === transitionType && setOpacities(shapesUpdateWithTransition = shapesUpdateWithTransition.transition().duration(0), function(d) {
                    var _a;
                    return (0, renderUtil.eR)(d.data.selected, !1, null === (_a = options.interactivityService) || void 0 === _a ? void 0 : _a.hasSelection(), !1);
                }), removed.remove();
                var highlightsUpdated = (_b = getShapeSelections(options.viewModel.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                }), DonutUtil.SliceHighlightClass)).updated, highlightsRemoved = _b.removed;
                return 2 === transitionType ? (setCommonStyles(highlightsRemoved), setOpacities(highlightsRemoved, function() {
                    return (0, renderUtil.eR)(!1, !0, !1, !0);
                }), setAnimation(highlightsRemoved).attrTween("d", options.layout.highlightShapeTween(transitionType)).styles((null === (_d = options.interactivityService) || void 0 === _d ? void 0 : _d.hasSelection()) ? options.layout.zeroShapeLayout.styles : options.layout.shapeLayout.styles).remove()) : (setCommonStyles(highlightsUpdated), 
                setOpacities(highlightsUpdated, function(d) {
                    var _a;
                    return (0, renderUtil.eR)(d.data.selected, !0, null === (_a = options.interactivityService) || void 0 === _a ? void 0 : _a.hasSelection(), options.viewModel.hasHighlights);
                }), 0 === transitionType && highlightsUpdated.attrs(options.layout.shapeLayout.attrs).styles(options.layout.shapeLayout.styles), 
                setAnimation(highlightsUpdated).attrTween("d", options.layout.highlightShapeTween(transitionType)).styles(options.layout.highlightShapeLayout.styles), 
                highlightsRemoved.remove()), (0, dataLabelRendererEnhanced.gm)({
                    labelContext: options.labelGraphicsContext,
                    backgroundContext: options.labelBackgroundContext,
                    dataLabels: options.labels,
                    hasTooltip: !0,
                    numeric: !1,
                    twoRows: !0,
                    formatMode: options.formatMode,
                    onObject: options.onObject
                }), (0, dataLabelRendererEnhanced.z8)(options.labelGraphicsContext, options.labels), 
                this.previousViewModel = options.viewModel, {
                    failed: !1,
                    shapes: updated,
                    highlightShapes: highlightsUpdated
                };
            }, WebDonutChartAnimator.FailedResult = {
                failed: !0,
                shapes: null,
                highlightShapes: null
            }, WebDonutChartAnimator;
        }(animatorCommon.r5), interactivityUtils = __webpack_require__(30237), DonutChartWebBehavior = function() {
            function DonutChartWebBehavior() {}
            return DonutChartWebBehavior.prototype.bindEvents = function(options, selectionHandler, dataPointNavigationManagerWithKey, formatMode) {
                this.root = options.root, this.slices = options.slices, this.highlightSlices = options.highlightSlices, 
                this.hasHighlights = options.hasHighlights, this.visualInstanceId = options.visualInstanceId;
                var clearCatcher = options.clearCatcher;
                if (formatMode) (0, interactivityUtils.FO)(this.slices), this.highlightSlices && (0, 
                interactivityUtils.FO)(this.highlightSlices), (0, interactivityUtils.to)(this.root), 
                (0, interactivityUtils.Jv)(this.root), (0, interactivityUtils.BV)(this.root), (0, 
                interactivityUtils.wf)(this.slices), clearCatcher.on("click", null); else {
                    if ((0, interactivityUtils.a0)(this.slices, selectionHandler), this.highlightSlices && (0, 
                    interactivityUtils.a0)(this.highlightSlices, selectionHandler), dataPointNavigationManagerWithKey) {
                        var dataPointNavigationManager = dataPointNavigationManagerWithKey.dataPointNavigationManager, pointSourceKey = dataPointNavigationManagerWithKey.pointSourceKey;
                        dataPointNavigationManager.isEmpty(pointSourceKey) || ((0, interactivityUtils.lt)(this.root, selectionHandler), 
                        (0, interactivityUtils.zV)(this.root, this.visualInstanceId, pointSourceKey), (0, 
                        interactivityUtils.W3)(this.root, dataPointNavigationManager, pointSourceKey), (0, 
                        interactivityUtils.I8)(this.slices, dataPointNavigationManager, pointSourceKey));
                    }
                    clearCatcher.on("click", function() {
                        var d3Event = d3.event;
                        browserUtils.M.isCtrlOrMeta(d3Event) || selectionHandler.handleClearSelection();
                    });
                }
            }, DonutChartWebBehavior.prototype.renderFocus = function(element) {
                var focusElementId = "".concat(renderUtil.aY, "-").concat(this.visualInstanceId);
                this.root.select("#" + focusElementId).attr("id", null), element && (element.setAttribute("id", focusElementId), 
                browserUtils.M.focus(element));
            }, DonutChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.slices.style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, hasSelection, hasHighlights);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, hasSelection, hasHighlights);
                }).attr("aria-selected", function(d) {
                    return d.data.selected;
                }), this.highlightSlices && this.highlightSlices.style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !0, hasSelection, hasHighlights);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !0, hasSelection, hasHighlights);
                });
            }, DonutChartWebBehavior;
        }(), animationDurationMs = 500, ease = "cubic-in-out", donutChartProps = {
            general: {
                formatString: {
                    objectName: "general",
                    propertyName: "formatString"
                }
            },
            dataPoint: {
                defaultColor: {
                    objectName: "dataPoint",
                    propertyName: "defaultColor"
                },
                fill: {
                    objectName: "dataPoint",
                    propertyName: "fill"
                }
            },
            legend: {
                show: {
                    objectName: "legend",
                    propertyName: "show"
                },
                position: {
                    objectName: "legend",
                    propertyName: "position"
                },
                showTitle: {
                    objectName: "legend",
                    propertyName: "showTitle"
                },
                titleText: {
                    objectName: "legend",
                    propertyName: "titleText"
                },
                labelColor: {
                    objectName: "legend",
                    propertyName: "labelColor"
                }
            },
            slices: {
                innerRadiusRatio: {
                    objectName: "slices",
                    propertyName: "innerRadiusRatio"
                },
                startAngle: {
                    objectName: "slices",
                    propertyName: "startAngle"
                },
                borderWidth: {
                    objectName: "slices",
                    propertyName: "borderWidth"
                },
                borderColor: {
                    objectName: "slices",
                    propertyName: "borderColor"
                },
                explode: {
                    objectName: "slices",
                    propertyName: "explode"
                }
            },
            labels: {
                position: {
                    objectName: "labels",
                    propertyName: "position"
                },
                overflow: {
                    objectName: "labels",
                    propertyName: "overflow"
                },
                background: {
                    objectName: "labels",
                    propertyName: "background"
                }
            }
        }, DonutChart = function() {
            function DonutChart(options) {
                this.featureSwitches = {}, options && (this.isDonutChart = 0 !== options.sliceWidthRatio, 
                this.animator = options.animator, this.isScrollable = !!options.isScrollable && options.isScrollable, 
                this.disableGeometricCulling = !!options.disableGeometricCulling && options.disableGeometricCulling, 
                this.behavior = options.behavior, this.tooltipsEnabled = options.tooltipsEnabled, 
                options.smallViewPortProperties && (this.maxHeightToScaleDonutLegend = options.smallViewPortProperties.maxHeightToScaleDonutLegend));
            }
            return Object.defineProperty(DonutChart.prototype, "showPlaceholders", {
                get: function() {
                    var _a;
                    return (null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.onObject) && 1 === this.viewMode && this.isSelected;
                },
                enumerable: !1,
                configurable: !0
            }), DonutChart.getDefaultDonutLabelSettings = function(style) {
                return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, DonutChart.getDefaultLabelSettings(style)), {
                    labelStyle: labelStyle.W3,
                    percentagePrecision: dataLabelViewModel1Consts.Qc,
                    position: donutLabelPosition.SX,
                    overflow: !0,
                    enableBackgroundWithAuto: donutLabelBackground.d7,
                    bold: !1,
                    italic: !1,
                    underline: !1
                });
            }, DonutChart.converter = function(dataView, style, isDonutChart, formatMode, viewport, disableGeometricCulling, interactivityService, tooltipsEnabled, featureSwitches) {
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var converter = new DonutChartConverter(dataView, style, isDonutChart, tooltipsEnabled);
                converter.convert();
                var navigationStrategy, pieChartStartAngle = converter.startAngle * (Math.PI / DonutChart.OnePiRadianInDegree), pieChartEndAngle = pieChartStartAngle + 2 * Math.PI, d3PieLayout = d3.pie().startAngle(pieChartStartAngle).endAngle(pieChartEndAngle).sort(null).value(function(d) {
                    return d.percentage;
                });
                interactivityService && (navigationStrategy = !converter.hasCategoryData && converter.hasSeriesData ? services_interactivityService.jN.SeriesOnly : converter.hasCategoryData && converter.hasSeriesData ? services_interactivityService.jN.CategoryFirst : services_interactivityService.jN.CategoryOnly, 
                interactivityService.applySelectionStateToData(converter.dataPoints), interactivityService.applySelectionStateToData(converter.legendData.dataPoints));
                var subSelectionDataPoints, culledDataPoints = !disableGeometricCulling && viewport ? DonutChart.cullDataByViewport(converter.dataPoints, converter.maxValue, viewport, style.isHighContrast, converter.borderWidth, featureSwitches) : converter.dataPoints;
                return featureSwitches && featureSwitches.onObject && formatMode && (subSelectionDataPoints = this.getSubSelectionArcDescriptors({
                    dataView,
                    dataPoints: culledDataPoints,
                    hasCategoryData: converter.hasCategoryData,
                    hasDynamicSeries: converter.hasDynamicSeries,
                    startAngle: pieChartStartAngle,
                    endAngle: pieChartEndAngle
                })), {
                    dataPointsToDeprecate: culledDataPoints,
                    dataPoints: d3PieLayout(culledDataPoints),
                    unCulledDataPoints: converter.dataPoints,
                    dataPointsToEnumerate: converter.legendData.dataPoints,
                    legendData: converter.legendData,
                    hasHighlights: converter.hasHighlights,
                    highlightsOverflow: converter.highlightsOverflow,
                    dataLabelsSettings: converter.dataLabelsSettings,
                    legendObjectProperties: converter.legendObjectProperties,
                    maxValue: converter.maxValue,
                    visibleGeometryCulled: converter.dataPoints.length !== culledDataPoints.length,
                    hasNegativeValues: converter.hasNegativeValues,
                    allValuesAreNegative: converter.allValuesAreNegative,
                    donutInnerRadiusRatio: converter.donutInnerRadiusRatio,
                    startAngle: converter.startAngle,
                    navigationStrategy,
                    explode: converter.explode,
                    borderWidth: converter.borderWidth,
                    borderColor: converter.borderColor,
                    hasDynamicSeries: converter.hasDynamicSeries,
                    hasSeriesData: converter.hasSeriesData,
                    hasCategoryData: converter.hasCategoryData,
                    subSelectionDataPoints
                };
            }, DonutChart.getSubSelectionArcDescriptors = function(options) {
                for (var endAngle = options.endAngle, hasCategoryData = options.hasCategoryData, hasDynamicSeries = options.hasDynamicSeries, startAngle = options.startAngle, dataPointsBySlice = {}, _i = 0, dataPoints_1 = options.dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i], categoryIndex = dataPoint.categoryIndex, seriesIndex = dataPoint.seriesIndex, percentage = dataPoint.percentage, useCategoryIndex = hasCategoryData || !hasDynamicSeries, sliceIndex = useCategoryIndex ? categoryIndex : seriesIndex, sliceItem = dataPointsBySlice[sliceIndex];
                    sliceItem || (dataPointsBySlice[sliceIndex] = sliceItem = {
                        displayName: useCategoryIndex ? dataPoint.categoryLabel : dataPoint.label,
                        percentage: 0,
                        categoryIndex: useCategoryIndex ? categoryIndex : void 0,
                        seriesIndex: useCategoryIndex ? void 0 : seriesIndex
                    }), sliceItem.percentage += percentage;
                }
                var slices = _.values(dataPointsBySlice);
                return d3.pie().startAngle(startAngle).endAngle(endAngle).sort(null).value(function(d) {
                    return d.percentage;
                })(slices);
            }, DonutChart.prototype.getFirstElement = function() {
                var pointData = this.flattenViewModel();
                return _.isEmpty(pointData) ? {
                    element: null
                } : {
                    element: this.findHTMLElement(pointData[0].categoryIndex, pointData[0].seriesIndex)
                };
            }, DonutChart.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var pointData = this.flattenViewModel(), nextDataPoint = (0, navigationUtils.R)(pointData, categoryIndex, seriesIndex, this.data.navigationStrategy, direction);
                return {
                    element: this.findHTMLElement(nextDataPoint.categoryIndex, nextDataPoint.seriesIndex)
                };
            }, DonutChart.prototype.findHTMLElement = function(categoryIndex, seriesIndex) {
                return this.mainGraphicsContext.selectAll(DonutUtil.SliceClass.selector).filter(function(s) {
                    return s.data.categoryIndex === categoryIndex && s.data.seriesIndex === seriesIndex;
                }).node();
            }, DonutChart.prototype.flattenViewModel = function() {
                return this.data.dataPoints.map(function(d) {
                    return {
                        categoryIndex: d.data.categoryIndex,
                        seriesIndex: d.data.seriesIndex
                    };
                });
            }, DonutChart.prototype.getDefaultDonutData = function() {
                return {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: (0, legend_converter.Fe)(this.style),
                    hasHighlights: !1,
                    highlightsOverflow: !1,
                    dataLabelsSettings: DonutChart.getDefaultDonutLabelSettings(this.style),
                    hasDynamicSeries: !1,
                    hasNegativeValues: !1,
                    allValuesAreNegative: !1,
                    donutInnerRadiusRatio: this.isDonutChart ? DonutChart.DefaultDonutInnerRadiusRatio : 0,
                    startAngle: DonutChart.DefaultStartAngleDegrees,
                    navigationStrategy: null,
                    explode: DonutChart.DefaultExplode,
                    borderWidth: DonutChart.DefaultBorderWidth,
                    borderColor: DonutUtil.DefaultStrokeColorName,
                    hasCategoryData: !1,
                    hasSeriesData: !1
                };
            }, DonutChart.prototype.init = function(options) {
                var _a, _b, _this = this;
                this.options = options, this.featureSwitches = options.featureSwitches || {};
                var element = options.element;
                if (element.empty(), this.parentViewport = options.viewport, this.viewMode = options.host.getViewMode(), 
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                    scale: options.viewport.scale
                }, this.style = options.style, this.colors = this.style.colorPalette.dataColors, 
                this.data = this.getDefaultDonutData(), this.radius = 0, this.maxOffset = 0, this.mobileInteractiveLegend = !!(null === (_a = options.interactivity) || void 0 === _a ? void 0 : _a.mobileTileInteractive), 
                this.hostService = options.host, this.behavior && (this.interactivityService = (0, 
                services_interactivityService.ub)(this.hostService, this.featureSwitches)), this.legend = (0, 
                legend.OG)(element, this.mobileInteractiveLegend, this.interactivityService, this.isScrollable, void 0, this.style, this.hostService), 
                this.tooltipService = (0, tooltipService.r)(this.hostService), this.mobileInteractiveLegend && (this.legendContainer = d3.select(element.get(0)).append("div").classed(DonutUtil.LegendClass.class, !0), 
                this.interactivityState = {
                    interactiveLegend: new DonutChartInteractiveLegend(this, this.legendContainer, this.colors, options),
                    valueToAngleFactor: 0,
                    sliceAngles: [],
                    currentRotate: 0,
                    interactiveChosenSliceFinishedSetting: !1,
                    lastChosenInteractiveSliceIndex: 0,
                    totalDragAngleDifference: 0,
                    currentIndexDrag: 0,
                    previousIndexDrag: 0,
                    previousDragAngle: 0,
                    donutCenter: {
                        x: 0,
                        y: 0
                    }
                }), this.featureSwitches.onObject) {
                    var subSelectionHostService = null === (_b = this.hostService) || void 0 === _b ? void 0 : _b.getSubSelectionService(), renderer = null != subSelectionHostService ? subSelectionHostService : subSelectionOutlineRenderer.D.createWithDefaultHost();
                    this.subSelectionHelper = htmlSubSelectionHelper.O5.createHtmlSubselectionHelper({
                        selectorCallback: function(e) {
                            return _this.getSelectorsByColumnSubSelection(e);
                        },
                        customOutlineCallback: function(s) {
                            return _this.getCustomSubSelectionOutlines(s);
                        },
                        hostElement: element.get(0),
                        hostServices: this.hostService,
                        renderer,
                        targetSource: "format",
                        scale: function() {
                            return _this.currentViewport.scale;
                        }
                    });
                }
                if (this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(DonutUtil.ChartClass.class, !0), 
                this.behavior && (this.clearCatcher = (0, services_interactivityService.EX)(this.svg)), 
                this.mainGraphicsContext = this.svg.append("g"), this.mainGraphicsContext.append("g").classed(DonutUtil.SliceContainerClass.class, !0), 
                this.interactivityService) {
                    var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                    this.mainGraphicsContext.attr("tabindex", 0).attr("focusable", !0).attr("aria-label", this.hostService.getLocalizedString("Visual_Plot")).attr("aria-multiselectable", !0).attr("role", "listbox").classed(renderUtil.Pg, !isEdgeOrIE);
                }
                this.labelBackgroundGraphicsContext = this.svg.append("g").classed(dataLabelViewModel1Consts.u9.class, !0), 
                this.labelGraphicsContext = this.svg.append("g").classed(dataLabelViewModel1Consts.ZL.class, !0), 
                this.pie = d3.pie().sort(null).value(function(d) {
                    return d.percentage;
                });
            }, DonutChart.prototype.onViewModeChanged = function(viewMode) {
                this.ensurePlaceholders(viewMode, this.isSelected);
            }, DonutChart.prototype.onSelectionStateChanged = function(isSelected) {
                this.ensurePlaceholders(this.viewMode, isSelected);
            }, DonutChart.prototype.ensurePlaceholders = function(viewMode, isSelected) {
                var wasShowPlaceholders = this.showPlaceholders;
                this.isSelected = isSelected, this.viewMode = viewMode, wasShowPlaceholders !== this.showPlaceholders && !this.mobileInteractiveLegend && this.data && this.legend && this.renderLegend(this.formatMode);
            }, DonutChart.prototype.update = function(updateOptions) {
                var _a, _b;
                debug.fF.assertValue(updateOptions, "updateOptions");
                var updateDataViews = updateOptions.dataViews, formatMode = updateOptions.formatMode, subSelections = updateOptions.subSelections, suppressAnimations = updateOptions.suppressAnimations, type = updateOptions.type, viewport = updateOptions.viewport;
                if (this.formatMode = formatMode, this.parentViewport = viewport, this.featureSwitches.onObject && (this.subSelectionHelper.setFormatMode(formatMode), 
                null === (_a = this.interactivityService) || void 0 === _a || _a.setFormatMode(formatMode)), 
                type === enums.EP.Resize || type === enums.EP.ResizeEnd || (this.dataViews = updateDataViews, 
                this.data = (null === (_b = this.dataViews) || void 0 === _b ? void 0 : _b.length) > 0 && this.dataViews[0].categorical ? DonutChart.converter(this.dataViews[0], this.style, this.isDonutChart, formatMode, this.parentViewport, this.disableGeometricCulling, this.interactivityService, this.tooltipsEnabled, this.featureSwitches) : this.getDefaultDonutData()), 
                this.mobileInteractiveLegend || this.renderLegend(formatMode), this.initViewportDependantProperties(), 
                this.updateDonutProperties(), this.updateInternal(this.data, suppressAnimations, formatMode), 
                this.dataViews) {
                    var warnings = (0, invalidDataValuesChecker.b)(this.dataViews, !1, !1, !1, [ "Tooltips" ]);
                    this.data.allValuesAreNegative ? warnings.push(new visualWarnings.fi) : this.data.hasNegativeValues && warnings.push(new visualWarnings.v3), 
                    this.hostService.setWarnings(warnings);
                }
                if (this.subSelectionHelper && (type & enums.EP.Data || type & enums.EP.Resize || type & enums.EP.FormattingSubSelectionChange) && (this.subSelectionHelper.updateOutlinesFromSubSelections(subSelections, !0), 
                this.hostService.alertScreenReader && type & enums.EP.FormattingSubSelectionChange)) {
                    var labels = this.subSelectionHelper.getLabelsFromSubSelections(subSelections, [ "aria-label" ]), message = (null == labels ? void 0 : labels.length) && labels.join(" ");
                    message && this.hostService.alertScreenReader(message);
                }
            }, DonutChart.prototype.getLegendCard = function() {
                return (0, legend_formatting.ZF)({
                    legendData: this.data.legendData
                }, this.hostService, this.featureSwitches);
            }, DonutChart.prototype.getSlicesCard = function() {
                var _this = this;
                if (this.data) {
                    var slicesProps = donutChart_capabilities.V9.slices, localize = function(key) {
                        return _this.hostService.getLocalizedString(key);
                    }, slicesCardProps = [ donutChart_capabilities.V9.dataPoint.fill, slicesProps.innerRadiusRatio, slicesProps.borderColor, slicesProps.borderWidth, slicesProps.explode ], cardBuilder = new build_control_util.CQ(new build_control_util.lg("slices"), "Role_DisplayName_Slices", slicesCardProps, localize), dataPoints = (0, 
                    legend_formatting.l3)(this.data.legendData);
                    return dataPoints.length > 0 && cardBuilder.addGroup("colors", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Colors"), (0, colorEnumerationHelper2.y0)({
                            groupBuilder,
                            dataPoints,
                            seriesColorProps: donutChart_capabilities.V9.dataPoint,
                            localize,
                            featureSwitches: _this.featureSwitches
                        });
                    }), this.featureSwitches.pieChartMarginBetweenSlices ? (0 !== this.maxOffset && this.data.explode > this.maxOffset && (this.data.explode = this.maxOffset), 
                    cardBuilder.addGroup("border", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Border").addSimpleSlice("borderColor", new build_control_util.BT({
                            descriptor: slicesProps.borderColor,
                            value: {
                                value: _this.data.borderColor
                            }
                        }).build()).addSimpleSlice("borderWidth", new build_control_util.JN({
                            descriptor: donutChart_capabilities.V9.slices.borderWidth,
                            value: _this.data.borderWidth,
                            localize
                        }).build());
                    }), cardBuilder.addGroup("spacing", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Spacing").addSimpleSlice("innerRadius", new build_control_util.JN({
                            descriptor: slicesProps.innerRadiusRatio,
                            value: Math.round(100 * _this.data.donutInnerRadiusRatio / DonutChart.OuterRadiusRatio),
                            localize,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: 0
                                },
                                maxValue: {
                                    type: 1,
                                    value: 99
                                },
                                unitSymbol: visualLocKeys.t2
                            }
                        }).build()).addSimpleSlice("explode", new build_control_util.JN({
                            descriptor: slicesProps.explode,
                            value: _this.data.explode,
                            localize
                        }).build());
                    })) : this.isDonutChart && cardBuilder.addGroup("spacing", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Spacing").addSimpleSlice("innerRadius", new build_control_util.JN({
                            descriptor: slicesProps.innerRadiusRatio,
                            value: Math.round(100 * _this.data.donutInnerRadiusRatio / DonutChart.OuterRadiusRatio),
                            localize,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: 0
                                },
                                maxValue: {
                                    type: 1,
                                    value: 99
                                },
                                unitSymbol: visualLocKeys.t2
                            }
                        }).build());
                    }), cardBuilder.build();
                }
            }, DonutChart.prototype.getDetailLabelsCard = function() {
                var _a, _b, _this = this, detailLabelsProps = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, (0, 
                dataLabelViewModel1.kL)("labels")), {
                    position: donutChart_capabilities.V9.labels.position,
                    overflow: donutChart_capabilities.V9.labels.overflow,
                    background: donutChart_capabilities.V9.labels.background
                }), cardBuilder = new build_control_util.CQ(new build_control_util.lg("labels"), "Visual_DetailLabels", detailLabelsProps, function(key) {
                    return _this.hostService.getLocalizedString(key);
                });
                return (0, dataLabelViewModel1.XQ)({
                    cardBuilder,
                    dataLabelsProps: detailLabelsProps,
                    featureSwitches: this.featureSwitches,
                    hostServices: this.hostService,
                    options: {
                        dataLabelsSettings: null !== (_b = null === (_a = this.data) || void 0 === _a ? void 0 : _a.dataLabelsSettings) && void 0 !== _b ? _b : DonutChart.getDefaultDonutLabelSettings(this.style),
                        show: !0,
                        displayUnits: !0,
                        precision: !0,
                        percentagePrecision: !0,
                        fontSize: !0,
                        fontFamily: !0,
                        labelStyle: !0,
                        style: this.style,
                        bold: !0,
                        italic: !0,
                        underline: !0
                    },
                    omitDescription: !0,
                    individualSelector: this.getLabelIndividualSelector()
                });
            }, DonutChart.prototype.getRotationCard = function() {
                var _this = this;
                if (this.data) {
                    var localize = function(key) {
                        return _this.hostService.getLocalizedString(key);
                    };
                    return new build_control_util.CQ(new build_control_util.lg("rotation"), "Visual_BasicShape_Rotate", [ donutChart_capabilities.V9.slices.startAngle ], localize).addGroup("default", function(groupBuilder) {
                        return groupBuilder.addSimpleSlice("rotation", new build_control_util.JN({
                            descriptor: donutChart_capabilities.V9.slices.startAngle,
                            value: _this.data.startAngle,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: 0
                                },
                                maxValue: {
                                    type: 1,
                                    value: 360
                                },
                                unitSymbol: visualLocKeys.g
                            },
                            localize
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_BasicShape_Rotate");
                        });
                    }).build();
                }
            }, DonutChart.prototype.getFormattingModel = function() {
                var _this = this;
                if (this.data) return new build_control_util.Nq(function() {
                    return _this.getLegendCard();
                }, function() {
                    return _this.getSlicesCard();
                }, function() {
                    return _this.getDetailLabelsCard();
                }, function() {
                    return _this.getRotationCard();
                }).build();
            }, DonutChart.prototype.setInteractiveChosenSlice = function(sliceIndex, duration) {
                var _this = this;
                if (0 !== this.interactivityState.sliceAngles.length) {
                    this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex, this.interactivityState.interactiveChosenSliceFinishedSetting = !1;
                    var viewport = this.currentViewport, moduledIndex = sliceIndex % this.data.dataPoints.length, angle = this.interactivityState.sliceAngles[moduledIndex], rotateSelection = this.svg.select("g");
                    rotateSelection.transition().duration(null != duration ? duration : animationDurationMs).ease((0, 
                    d3Helper.Ad)(ease)).attr("transform", (0, svgUtil.I2)(viewport.width / 2, viewport.height / 2, 0, 0, angle)).on("end", function() {
                        _this.interactivityState.interactiveChosenSliceFinishedSetting = !0;
                    }), this.interactivityState.currentRotate = angle, this.interactivityState.interactiveLegend.updateLegend(moduledIndex), 
                    this.svg.selectAll(DonutUtil.SliceClass.selector).attr("opacity", function(_, index) {
                        return (0, renderUtil.eR)(index === moduledIndex, !1, !0, !1);
                    }), (0, svgUtil.bL)(this.options, rotateSelection);
                }
            }, DonutChart.prototype.calculateRadius = function() {
                var _a, viewport = this.currentViewport;
                if (!this.mobileInteractiveLegend && (null === (_a = this.data) || void 0 === _a ? void 0 : _a.dataLabelsSettings.show)) {
                    var denom = 2 + 1 / (1 + Math.exp(-5 * (viewport.height / viewport.width - 1)));
                    return Math.min(viewport.height, viewport.width) / denom;
                }
                return Math.min(viewport.height, viewport.width) / 2;
            }, DonutChart.prototype.getScaleForLegendArrow = function() {
                return this.maxHeightToScaleDonutLegend && this.currentViewport.height < this.maxHeightToScaleDonutLegend ? this.currentViewport.height / this.maxHeightToScaleDonutLegend : 1;
            }, DonutChart.prototype.initViewportDependantProperties = function(duration) {
                var _this = this;
                void 0 === duration && (duration = 0), this.currentViewport.height = this.parentViewport.height, 
                this.currentViewport.width = this.parentViewport.width, this.currentViewport.scale = this.parentViewport.scale;
                var viewport = this.currentViewport;
                if (this.mobileInteractiveLegend) viewport.height -= DonutChart.InteractiveLegendContainerHeight; else {
                    var legendMargins = this.legend.getMargins();
                    viewport.height -= legendMargins.height, viewport.width -= legendMargins.width;
                }
                this.svg.attr("width", viewport.width).attr("height", viewport.height), this.mobileInteractiveLegend ? (this.legendContainer.style("width", "100%").style("height", DonutChart.InteractiveLegendContainerHeight + "px").style("overflow", "hidden").style("top", 0), 
                this.svg.style("top", DonutChart.InteractiveLegendContainerHeight)) : (0, legend_util.xz)(this.svg, this.legend), 
                this.previousRadius = this.radius, this.radius = this.calculateRadius();
                var innerLabelRadius = this.radius * DonutChart.LabelRadiusRatio;
                this.outerArc = d3.arc(), this.labelArc = d3.arc().innerRadius(innerLabelRadius).outerRadius(innerLabelRadius - this.data.explode);
                var addTranslate = function(d3Selection) {
                    (_this.mobileInteractiveLegend ? d3Selection : d3Selection.transition().duration(duration)).attr("transform", (0, 
                    svgUtil.Iu)(viewport.width / 2, viewport.height / 2));
                };
                addTranslate(this.mainGraphicsContext), addTranslate(this.labelGraphicsContext), 
                addTranslate(this.labelBackgroundGraphicsContext), (0, svgUtil.bL)(this.options, this.mainGraphicsContext, this.labelGraphicsContext, this.labelBackgroundGraphicsContext);
            }, DonutChart.prototype.updateDonutProperties = function() {
                var maxOffset, labelRadius = this.radius * DonutChart.LabelRadiusRatio, outerRadius = this.radius * DonutChart.OuterRadiusRatio - this.data.explode, innerRadius = this.radius * this.data.donutInnerRadiusRatio;
                2 * outerRadius + 5 < Math.min(this.currentViewport.height, this.currentViewport.width) && (maxOffset = Math.round(this.radius * DonutChart.OuterRadiusRatio - (this.data.explode + 1)), 
                maxOffset = Math.min(50, Math.max(0, maxOffset))), (Math.round(outerRadius - innerRadius) < DonutChart.MinDonutThickness || this.radius * DonutChart.OuterRadiusRatio + this.data.explode > labelRadius) && (this.data.explode = 0), 
                this.donutProperties = {
                    viewport: this.currentViewport,
                    outerArc: this.outerArc.innerRadius(0).outerRadius(innerRadius),
                    labelArc: this.labelArc,
                    dataLabelsSettings: this.data.dataLabelsSettings,
                    innerRadius,
                    outerRadius,
                    labelRadius,
                    startAngle: this.data.startAngle,
                    explode: this.data.explode,
                    maxOffset
                };
            }, DonutChart.prototype.mergeDatasets = function(first, second) {
                for (var secondSet = {}, _i = 0, second_1 = second; _i < second_1.length; _i++) {
                    var dataPoint = second_1[_i], key = dataPoint.identity ? dataPoint.identity.getKey() : dataPoint.data.identity.getKey();
                    secondSet[key] = null;
                }
                var onlyFirst = _.filter(first, function(d) {
                    return !((d.identity ? d.identity.getKey() : d.data.identity.getKey()) in secondSet);
                }), firstPrototyped = _.map(onlyFirst, function(d) {
                    var derived = (0, Prototype.ED)(d);
                    return void 0 === derived.percentage ? derived.data.percentage = 0 : derived.percentage = 0, 
                    derived;
                });
                return (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], second, !0), firstPrototyped, !0);
            }, DonutChart.prototype.updateInternal = function(data, suppressAnimations, formatMode) {
                var _a;
                if (this.animator) {
                    var layout = this.getDonutLayout(data), dataLabels = (null === (_a = data.dataLabelsSettings) || void 0 === _a ? void 0 : _a.show) ? this.createLabels() : [], result = void 0, shapes = void 0, highlightShapes = void 0;
                    if (suppressAnimations || (shapes = (result = this.animator.animate({
                        viewModel: data,
                        colors: this.colors,
                        graphicsContext: this.mainGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        labelBackgroundContext: this.labelBackgroundGraphicsContext,
                        interactivityService: this.interactivityService,
                        layout,
                        radius: this.radius,
                        donutProperties: this.donutProperties,
                        viewport: this.currentViewport,
                        labels: dataLabels,
                        style: this.style,
                        formatMode,
                        onObject: this.featureSwitches.onObject
                    })).shapes, highlightShapes = result.highlightShapes), suppressAnimations || result.failed) {
                        shapes = this.drawDefaultShapes(data, layout, formatMode), highlightShapes = this.drawDefaultHighlightShapes(data, layout), 
                        (0, dataLabelRendererEnhanced.gm)({
                            labelContext: this.labelGraphicsContext,
                            dataLabels,
                            numeric: !1,
                            backgroundContext: this.labelBackgroundGraphicsContext,
                            twoRows: !0,
                            hasTooltip: !0,
                            formatMode,
                            onObject: this.featureSwitches.onObject
                        });
                        var defaultLeaderLineProps_1 = (0, dataLabelUtil.sW)(this.style);
                        dataLabels.map(function(labelDataPoint) {
                            labelDataPoint.leaderLine = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, defaultLeaderLineProps_1), {
                                strokeTransparency: 50,
                                strokeShow: !0
                            });
                        }), (0, dataLabelRendererEnhanced.z8)(this.labelGraphicsContext, dataLabels);
                    }
                    this.assignInteractions(shapes, highlightShapes, data, formatMode);
                } else {
                    var duration = (0, animatorCommon.Mb)(this.animator, suppressAnimations);
                    this.updateInternalToMove(data, duration, this.style, formatMode);
                }
                (0, svgUtil.bL)(this.options);
            }, DonutChart.prototype.createLabels = function() {
                return new DonutLabelLayout(this.donutProperties).layout(this.createLabelDataPoints(), this.data.dataLabelsSettings, this.featureSwitches);
            }, DonutChart.prototype.createLabelDataPoints = function() {
                var data = this.data, labelDataPoints = [], measureFormatterCache = (0, dataLabelViewModel1.fI)(), alternativeScale = null;
                0 === data.dataLabelsSettings.displayUnits && (alternativeScale = d3.max(data.dataPoints, function(d) {
                    return Math.abs(d.data.measure);
                }));
                for (var i = 0; i < this.data.dataPoints.length; i++) {
                    var label = this.createLabelDataPoint(data.dataPoints[i], alternativeScale, measureFormatterCache, this.featureSwitches);
                    labelDataPoints.push(label);
                }
                return labelDataPoints;
            }, DonutChart.prototype.createLabelDataPoint = function(d, alternativeScale, measureFormatterCache, featureSwitches) {
                var _a, _b, _c, _d, labelX, labelY, labelPoint = this.labelArc.centroid(d), angle = (d.startAngle + d.endAngle) / 2, xOff = explodeXOffset(angle, this.donutProperties), yOff = explodeYOffset(angle, this.donutProperties);
                (null == featureSwitches ? void 0 : featureSwitches.pieChartMarginBetweenSlices) ? (labelX = getXPositionForDonutLabel(labelPoint[0]) - xOff, 
                labelY = labelPoint[1] - yOff) : (labelX = getXPositionForDonutLabel(labelPoint[0]), 
                labelY = labelPoint[1]);
                var dataLabel, dataLabelSize, categoryLabel, categoryLabelSize, percentLabel, percentLabelSize, textSize, labelSettings = this.data.dataLabelsSettings, pointPosition = {
                    point: {
                        x: labelX,
                        y: labelY
                    },
                    validPositions: [ labelX < 0 ? 4 : 8 ],
                    radius: 0
                }, defaultLabelColor = common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.uQ), defaultInsideLabelColor = common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.pl), outsideFill = null !== (_b = null !== (_a = d.data.detailLabelFill) && void 0 !== _a ? _a : defaultLabelColor) && void 0 !== _b ? _b : labelSettings.fontProperties.color, insideFill = null !== (_d = null !== (_c = d.data.insideDetailLabelFill) && void 0 !== _c ? _c : defaultInsideLabelColor) && void 0 !== _d ? _d : labelSettings.fontProperties.color, labelSettingsStyle = (0, 
                dataLabelViewModel1Utils.RC)(labelSettings.labelStyle), fontProperties = labelSettings.fontProperties, tooltip = "", hasHighlights = this.data.hasHighlights, highlightsOverflow = this.data.highlightsOverflow;
                if ((0, StandaloneUtility3.yE)(labelSettingsStyle, labelStyle.nO)) {
                    var dataLabelValue = void 0, formatter = void 0;
                    hasHighlights && !highlightsOverflow ? (dataLabelValue = d.data.originalHighlightValue, 
                    formatter = measureFormatterCache.getOrCreate(d.data.highlightFormat, labelSettings, alternativeScale)) : (dataLabelValue = d.data.originalMeasure, 
                    formatter = measureFormatterCache.getOrCreate(d.data.measureFormat, labelSettings, alternativeScale)), 
                    dataLabel = null != dataLabelValue ? formatter.format(dataLabelValue) : null, dataLabelSize = (0, 
                    dataLabelViewModel1.y3)(dataLabel, fontProperties);
                }
                if ((0, StandaloneUtility3.yE)(labelSettingsStyle, labelStyle.mA) && (categoryLabelSize = (0, 
                dataLabelViewModel1.y3)(categoryLabel = d.data.label, fontProperties)), (0, StandaloneUtility3.yE)(labelSettingsStyle, labelStyle.tG)) {
                    var pctFormatString = (0, valueFormatter.Z)("Percentage"), percentageLabelValue = hasHighlights && !highlightsOverflow ? d.data.highlightPercentage : d.data.percentage, percentLabelSettings = _.clone(labelSettings), precision = percentLabelSettings.percentagePrecision;
                    if (percentLabelSettings.displayUnits = 0, _.isFinite(precision)) {
                        var measureFormatter = measureFormatterCache.getOrCreate(pctFormatString, percentLabelSettings, null, percentLabelSettings.percentagePrecision);
                        percentLabel = null != percentageLabelValue ? measureFormatter.format(percentageLabelValue) : null;
                    } else percentLabel = (0, valueFormatter.WU)(percentageLabelValue, pctFormatString);
                    percentLabelSize = (0, dataLabelViewModel1.y3)(percentLabel, fontProperties);
                }
                switch (labelSettingsStyle) {
                  case labelStyle.YK.categoryAndDataAndPercent:
                    tooltip = categoryLabel, dataLabel && (tooltip = (0, dataLabelViewModel1Utils.Ej)([ tooltip, dataLabel ], " ")), 
                    percentLabel && (tooltip = (0, dataLabelViewModel1Utils.Ej)([ tooltip, "(".concat(percentLabel, ")") ], " ")), 
                    textSize = (0, dataLabelViewModel1.y3)(tooltip, fontProperties);
                    break;

                  case labelStyle.YK.categoryAndData:
                    tooltip = categoryLabel, dataLabel && (tooltip = (0, dataLabelViewModel1Utils.Ej)([ tooltip, dataLabel ], " ")), 
                    textSize = (0, dataLabelViewModel1.y3)(tooltip, fontProperties);
                    break;

                  case labelStyle.YK.categoryAndPercent:
                    tooltip = categoryLabel, percentLabel && (tooltip = (0, dataLabelViewModel1Utils.Ej)([ tooltip, percentLabel ], " ")), 
                    textSize = (0, dataLabelViewModel1.y3)(tooltip, fontProperties);
                    break;

                  case labelStyle.YK.dataAndPercent:
                    tooltip = dataLabel, percentLabel && (tooltip = (0, dataLabelViewModel1Utils.Ej)([ tooltip, "(".concat(percentLabel, ")") ], " ")), 
                    textSize = (0, dataLabelViewModel1.y3)(tooltip, fontProperties);
                    break;

                  case labelStyle.YK.data:
                    textSize = _.clone(dataLabelSize), tooltip = dataLabel;
                    break;

                  case labelStyle.YK.percent:
                    textSize = _.clone(percentLabelSize), tooltip = percentLabel;
                    break;

                  case labelStyle.YK.category:
                    textSize = _.clone(categoryLabelSize), tooltip = categoryLabel;
                    break;

                  default:
                    debug.fF.assertFail("Unexpected labelStyle: " + labelSettingsStyle), textSize = _.clone(categoryLabelSize), 
                    tooltip = categoryLabel;
                }
                var leaderLinePoints = getLabelLeaderLineForDonutChart(d, this.donutProperties, pointPosition.point, 0, xOff, yOff, this.featureSwitches), leaderLinesSize = getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
                return {
                    isPreferred: !0,
                    text: "",
                    tooltip,
                    textSize,
                    outsideFill,
                    insideFill,
                    fontProperties,
                    identity: d.data.identity,
                    parentShape: pointPosition,
                    parentType: 0,
                    alternativeScale,
                    donutArcDescriptor: d,
                    angle: (d.endAngle + d.startAngle) / 2,
                    dataLabel,
                    dataLabelSize,
                    categoryLabel,
                    categoryLabelSize,
                    percentLabel,
                    percentLabelSize,
                    leaderLinePoints,
                    linesSize: leaderLinesSize,
                    backgroundColor: labelSettings.backgroundColor,
                    backgroundTransparency: labelSettings.backgroundTransparency
                };
            }, DonutChart.prototype.renderLegend = function(formatMode) {
                if (!this.mobileInteractiveLegend) {
                    var legendData = this.data.legendObjectProperties ? this.data.legendData : (0, legend_converter.Fe)(this.style);
                    null != legendData.position && this.legend.setPosition(legendData.position), this.legend.drawLegend({
                        data: legendData,
                        parentViewport: this.parentViewport,
                        formatMode,
                        onObject: this.featureSwitches.onObject,
                        showTitlePlaceholder: this.showPlaceholders,
                        titleSliceUid: "".concat("legend", "-").concat("title", "-titleText")
                    }), this.featureSwitches.onObject && this.subSelectionHelper.addDirectEditPlaceholderOutlines();
                }
            }, DonutChart.prototype.getSelectorsByColumnSubSelection = function(e) {
                if ("slices" === d3.select(e).attr(htmlSubSelectionHelper.Ez)) {
                    var datum = d3.select(e).datum();
                    return this.getSelectorFromArcDescriptor(datum);
                }
                return {};
            }, DonutChart.prototype.getSelectorFromArcDescriptor = function(arcDescriptor) {
                var _a, _b, categoryIndex = (_a = arcDescriptor.data).categoryIndex, legendData = (_b = this.data).legendData, legendIndex = _b.hasCategoryData || !_b.hasDynamicSeries ? categoryIndex : _a.seriesIndex, legendDataPoints = legendData.dataPoints;
                if (!_.isEmpty(legendDataPoints)) return legendDataPoints[legendIndex].identity.getSelectorsByColumn();
            }, DonutChart.prototype.getCustomSubSelectionOutlines = function(subSelection) {
                var _this = this, outlines = _.reduce(subSelection.visualObjects, function(existingOutlines, visualObject) {
                    var newOutlines;
                    return "slices" === visualObject.objectName && (newOutlines = _this.getSliceSubSelectionOutlines(visualObject)), 
                    _.isEmpty(newOutlines) || existingOutlines.push.apply(existingOutlines, newOutlines), 
                    existingOutlines;
                }, []);
                return _.isEmpty(outlines) ? void 0 : outlines;
            }, DonutChart.prototype.getSliceSubSelectionOutlines = function(visualObject) {
                var _a, _b, _c, _this = this, subSelectionSelectors = visualObject.selectorsByColumn, subSelectedDataPoint = this.data.subSelectionDataPoints.find(function(d) {
                    return (0, contracts_selector.Ic)(_this.getSelectorFromArcDescriptor(d), subSelectionSelectors);
                });
                if (subSelectedDataPoint) {
                    var unscaledInnerRadius = (_a = this.donutProperties).innerRadius, startAngle = subSelectedDataPoint.startAngle, endAngle = subSelectedDataPoint.endAngle, categoryIndex = (_b = subSelectedDataPoint.data).categoryIndex, seriesIndex = _b.seriesIndex, scaleFactor = this.parentViewport.scale, innerRadius = unscaledInnerRadius * scaleFactor, outerRadius = _a.outerRadius * scaleFactor, center = {
                        x: (_c = this.mainGraphicsContext.node().getBoundingClientRect()).left + _c.width / 2,
                        y: _c.top + _c.height / 2
                    };
                    return [ {
                        id: "category".concat(null != categoryIndex ? categoryIndex : -1, "-series").concat(null != seriesIndex ? seriesIndex : -1),
                        outline: {
                            type: 4,
                            center,
                            innerRadius,
                            outerRadius,
                            startAngle,
                            endAngle
                        }
                    } ];
                }
                debug.fF.assertFail("Unable to find data point for sub-selected slice");
            }, DonutChart.prototype.getSubSelectionStyles = function(subSelections) {
                if (this.featureSwitches.onObject) {
                    var subSelection = _.first(subSelections), visualObjects = subSelection.visualObjects;
                    debug.fF.assert(function() {
                        return 1 === visualObjects.length;
                    }, "Expected 1 visual");
                    var visualObject = visualObjects[0];
                    switch (debug.fF.assert(function() {
                        return 1 === subSelections.length || subSelections.every(function(newSubSelection) {
                            return _.isEqual(newSubSelection.visualObjects, [ visualObject ]);
                        }, "Expected 1 sub-selection or matching objects");
                    }), visualObject.objectName) {
                      case "legend-title":
                        return (0, legend_formatting.aJ)();

                      case "legend-items":
                        return (0, legend_formatting.Gh)(this.hostService);

                      case "data-labels":
                        return (0, onObjectUtil.Jf)({
                            hostServices: this.hostService,
                            omitSelectorForSingleSeries: !0,
                            individualSelector: this.getLabelIndividualSelector(),
                            selector: void 0,
                            repetitionSelector: void 0,
                            subSelectionStylesOptions: {
                                precision: {
                                    defaultPrecision: (0, valueFormatter.h1)(void 0, (0, valueFormatter.Z)("Percentage"))
                                }
                            }
                        }, {
                            fontFamilyReference: donutChart_capabilities.V9.labels.fontFamily,
                            fontSizeReference: donutChart_capabilities.V9.labels.fontSize,
                            boldReference: donutChart_capabilities.V9.labels.bold,
                            italicReference: donutChart_capabilities.V9.labels.italic,
                            underlineReference: donutChart_capabilities.V9.labels.underline,
                            fontColorReference: donutChart_capabilities.V9.labels.color,
                            displayUnitsReference: donutChart_capabilities.V9.labels.labelDisplayUnits,
                            precisionReference: donutChart_capabilities.V9.labels.labelPrecision
                        });

                      case "slices":
                        return this.getSliceSubSelectionStyles(subSelection);
                    }
                }
            }, DonutChart.prototype.getLabelIndividualSelector = function() {
                return (0, dataLabelViewModel1.WD)({
                    featureSwitches: this.featureSwitches,
                    hasCategories: this.data.hasCategoryData && null != _.first(this.data.legendData.dataPoints),
                    hasDynamicSeries: this.data.hasDynamicSeries,
                    hasSeriesSelector: !1
                });
            }, DonutChart.prototype.getSliceSubSelectionStyles = function(subSelection) {
                var visualObjects = subSelection.visualObjects;
                debug.fF.assert(function() {
                    return 1 === visualObjects.length;
                }, "Expected 1 visualObject");
                var selector = (0, contracts_selector.fd)((0, contracts_selector.tV)(visualObjects[0].selectorsByColumn));
                return {
                    type: 3,
                    fill: {
                        label: this.hostService.getLocalizedString("Visual_Fill"),
                        reference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, donutChart_capabilities.V9.dataPoint.fill), {
                            selector
                        })
                    }
                };
            }, DonutChart.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                if (this.featureSwitches.onObject && !filter) {
                    var visualObjects = _.first(subSelections).visualObjects;
                    debug.fF.assert(function() {
                        return 1 === visualObjects.length;
                    }, "Expected 1 visual");
                    var visualObject = visualObjects[0];
                    switch (debug.fF.assert(function() {
                        return 1 === subSelections.length || subSelections.every(function(newSubSelection) {
                            return _.isEqual(newSubSelection.visualObjects, [ visualObject ]);
                        }, "Expected 1 sub-selection or matching objects");
                    }), visualObject.objectName) {
                      case "legend-title":
                        return (0, legend_formatting.tV)(this.hostService);

                      case "legend-items":
                        return (0, legend_formatting.tY)({
                            hostServices: this.hostService,
                            showSort: !0
                        });

                      case "data-labels":
                        return this.getDetailLabelShortcuts();

                      case "slices":
                        return this.getSliceShortcuts(subSelections);
                    }
                }
            }, DonutChart.prototype.getSubSelectables = function(filter) {
                return this.subSelectionHelper.getAllSubSelectables(filter);
            }, DonutChart.prototype.getNextSubSelectable = function(currentSubSelectable, backwards) {
                return this.subSelectionHelper.getNextSubSelectable(currentSubSelectable, backwards);
            }, DonutChart.prototype.getDetailLabelShortcuts = function() {
                var _this = this, detailLabelsCardUid = "".concat("Visual", "-").concat("labels"), localize = function(value) {
                    return _this.hostService.getLocalizedString(value);
                };
                return [ {
                    type: 0
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 3
                }, donutChart_capabilities.V9.labels.labelStyle), {
                    label: localize("Visual_LabelContents")
                }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 3
                }, donutChart_capabilities.V9.labels.position), {
                    label: localize("Visual_Position")
                }), {
                    type: 1,
                    destinationInfo: {
                        cardUid: detailLabelsCardUid
                    },
                    label: localize("Format_Detail_Labels")
                } ];
            }, DonutChart.prototype.getSliceShortcuts = function(subSelections) {
                var _this = this, sliceCardUid = "".concat("Visual", "-").concat("slices"), localize = function(value) {
                    return _this.hostService.getLocalizedString(value);
                }, visualObjects = _.first(subSelections).visualObjects;
                debug.fF.assert(function() {
                    return 1 === visualObjects.length;
                }, "Expected 1 visualObject");
                var selector = (0, contracts_selector.fd)((0, contracts_selector.tV)(visualObjects[0].selectorsByColumn));
                return [ {
                    type: 0,
                    relatedResetFormattingIds: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, donutChart_capabilities.V9.dataPoint.fill), {
                        selector
                    }) ]
                }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                    type: 2
                }, donutChart_capabilities.V9.labels.show), {
                    enabledLabel: localize("Format_AddDetailLabels")
                }), {
                    type: 1,
                    destinationInfo: {
                        cardUid: sliceCardUid
                    },
                    label: localize("Format_Slices")
                } ];
            }, DonutChart.prototype.addInteractiveLegendArrow = function() {
                if (this.data && this.data.dataPoints && 0 !== this.data.dataPoints.length) {
                    if (!this.interactiveLegendArrow) {
                        var interactiveLegendArrow = this.svg.append("g");
                        interactiveLegendArrow.append("path").classed(DonutUtil.LegendArrowClass.class, !0).attr("d", "M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z"), 
                        this.interactiveLegendArrow = interactiveLegendArrow;
                    }
                    var scaleRatio = this.getScaleForLegendArrow();
                    this.interactiveLegendArrow.attr("transform", (0, svgUtil.aI)(this.currentViewport.width / 2 - 16.5 * scaleRatio, (this.currentViewport.height - 2 * this.radius) / 2 + 11 * scaleRatio, scaleRatio));
                }
            }, DonutChart.prototype.calculateSliceAngles = function() {
                var angles = [], data = this.data.dataPoints;
                if (0 === data.length) return this.interactivityState.valueToAngleFactor = 0, void (this.interactivityState.sliceAngles = []);
                for (var sum = 0, i = 0, ilen = data.length; i < ilen; i++) sum += data[i].data.percentage;
                debug.fF.assert(function() {
                    return 0 !== sum;
                }, "sum of slices values cannot be zero"), this.interactivityState.valueToAngleFactor = 360 / sum;
                var currentAngle = 0;
                for (i = 0, ilen = data.length; i < ilen; i++) {
                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                    angles.push(relativeAngle / 2 - (currentAngle += relativeAngle));
                }
                this.interactivityState.sliceAngles = angles;
            }, DonutChart.prototype.assignInteractions = function(slices, highlightSlices, data, formatMode) {
                if (this.mobileInteractiveLegend) this.assignInteractiveChartInteractions(slices); else if (this.interactivityService) {
                    var dataPoints = data.dataPoints.map(function(value) {
                        return value.data;
                    }), behaviorOptions = {
                        root: this.mainGraphicsContext,
                        clearCatcher: this.clearCatcher,
                        slices,
                        highlightSlices,
                        visual: this,
                        hasHighlights: data.hasHighlights,
                        visualInstanceId: this.hostService.instanceId
                    };
                    slices.attr("tabindex", 0).attr("focusable", !0), this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions, {
                        navigationOptions: {
                            navigationStrategy: this.data.navigationStrategy,
                            helper: this
                        },
                        pointSourceKey: "donut"
                    }), this.featureSwitches.onObject && this.interactivityService.setFormatMode(formatMode);
                }
                this.tooltipsEnabled && this.addTooltips(slices, highlightSlices);
            }, DonutChart.prototype.assignInteractiveChartInteractions = function(slice) {
                var _this = this, svgRect = this.svg.node().getBoundingClientRect();
                this.interactivityState.donutCenter = {
                    x: svgRect.left + svgRect.width / 2,
                    y: svgRect.top + svgRect.height / 2
                }, this.interactivityState.totalDragAngleDifference = 0, this.interactivityState.currentRotate = 0, 
                this.interactivityState.interactiveChosenSliceFinishedSetting = !0, this.calculateSliceAngles(), 
                slice.on("click", function(_, clickedIndex) {
                    d3.event.defaultPrevented || _this.setInteractiveChosenSlice(clickedIndex);
                });
                var drag = d3.drag().on("start", this.interactiveDragStart).on("drag", this.interactiveDragMove).on("end", this.interactiveDragEnd);
                this.svg.style("touch-action", "none").call(drag);
            }, DonutChart.prototype.getAngleFromDragEvent = function() {
                var pageX, pageY, interactivityState = this.interactivityState, sourceEvent = d3.event.sourceEvent;
                if (-1 !== sourceEvent.type.toLowerCase().indexOf("touch")) {
                    if (1 !== sourceEvent.touches.length) return null;
                    var touch = sourceEvent.touches[0];
                    pageX = touch.pageX, pageY = touch.pageY;
                } else pageX = sourceEvent.pageX, pageY = sourceEvent.pageY;
                var adjustedCoordinates = {
                    x: pageX - interactivityState.donutCenter.x,
                    y: -pageY + interactivityState.donutCenter.y
                };
                return 180 * Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) / Math.PI;
            }, DonutChart.prototype.interactiveDragStart = function() {
                this.interactivityState.totalDragAngleDifference = 0, this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
            }, DonutChart.prototype.interactiveDragMove = function() {
                var data = this.data.dataPoints, interactivityState = this.interactivityState;
                if (!0 === interactivityState.interactiveChosenSliceFinishedSetting) {
                    var currentDragAngle = this.getAngleFromDragEvent();
                    if (!currentDragAngle) return;
                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                    interactivityState.totalDragAngleDifference += angleDragDiff, interactivityState.previousDragAngle = currentDragAngle, 
                    interactivityState.currentRotate += angleDragDiff, this.svg.select("g").attr("transform", (0, 
                    svgUtil.I2)(this.currentViewport.width / 2, this.currentViewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor, currentAngle = interactivityState.currentRotate <= 0 ? -1 * interactivityState.currentRotate % 360 : 360 - interactivityState.currentRotate % 360;
                    interactivityState.currentIndexDrag = 0;
                    for (var dataLength = data.length; interactivityState.currentIndexDrag < dataLength && currentAngle > currentHigherLimit; ) interactivityState.currentIndexDrag < dataLength - 1 && (currentHigherLimit += data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor), 
                    interactivityState.currentIndexDrag++;
                    interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag && (interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag), 
                    this.svg.selectAll(DonutUtil.SliceClass.selector).attr("opacity", function(_, index) {
                        return (0, renderUtil.eR)(index === interactivityState.currentIndexDrag, !1, !0, !1);
                    }), interactivityState.previousIndexDrag = interactivityState.currentIndexDrag);
                }
            }, DonutChart.prototype.interactiveDragEnd = function() {
                0 !== this.interactivityState.totalDragAngleDifference && (this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag), 
                d3.event.sourceEvent.stopPropagation());
            }, DonutChart.prototype.updateInternalToMove = function(data, duration, style, formatMode) {
                var svg = this.svg, pie = this.pie, key = this.key, outerArc = this.outerArc, radius = this.radius, previousRadius = this.previousRadius, strokeColor = data.borderColor, donutProperties = this.donutProperties, existingData = this.svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceClass.selector).data().map(function(d) {
                    return d.data;
                });
                0 === existingData.length && (existingData = data.dataPointsToDeprecate);
                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate), slice = svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceClass.selector).data(pie(data.dataPointsToDeprecate), key);
                slice.enter().insert("path").classed(DonutUtil.SliceClass.class, !0).each(DonutUtil.UpdateCurrentArcElementFunc), 
                slice = svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceClass.selector).data(pie(is), key);
                var highlightUpdate, highlightExit, innerRadius = this.donutProperties.innerRadius;
                if (DonutUtil.isSingleColor(data.dataPoints), outerArc.innerRadius(innerRadius), 
                style.isHighContrast || slice.style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, !1, data.hasHighlights);
                }).style("stroke-dasharray", function(d) {
                    return DonutChart.drawStrokeForDonutChart(d, donutProperties);
                }), slice.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, !1, data.hasHighlights);
                }).style("stroke", strokeColor).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).transition().duration(duration).attrTween("d", function(d) {
                    var a = d3.interpolateObject(this._current, d), r = d3.interpolateNumber(previousRadius * DonutChart.OuterRadiusRatio, radius * DonutChart.OuterRadiusRatio);
                    return this._current = a(0), function(t) {
                        return outerArc.outerRadius(r(t))(a(t));
                    };
                }), (slice = svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceClass.selector).data(pie(data.dataPointsToDeprecate), key)).exit().transition().delay(duration).duration(0).remove(), 
                !this.mobileInteractiveLegend) {
                    var labelSettings = data.dataLabelsSettings, labels = [];
                    labelSettings && labelSettings.show && (labels = this.createLabels()), (0, dataLabelRendererEnhanced.gm)({
                        labelContext: this.labelGraphicsContext,
                        dataLabels: labels,
                        numeric: !1,
                        backgroundContext: this.labelBackgroundGraphicsContext,
                        formatMode,
                        onObject: this.featureSwitches.onObject
                    }), (0, dataLabelRendererEnhanced.z8)(this.labelGraphicsContext, labels);
                }
                if (data.hasHighlights) {
                    var highlightSlices = svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceHighlightClass.selector).data(pie(data.dataPointsToDeprecate), key);
                    highlightUpdate = highlightSlices.enter().insert("path").classed(DonutUtil.SliceHighlightClass.class, !0).each(DonutUtil.UpdateCurrentArcElementFunc).merge(highlightSlices), 
                    DonutUtil.isSingleColor(data.dataPoints), style.isHighContrast || highlightUpdate.style("stroke-opacity", 1).style("stroke-dasharray", function(d) {
                        return DonutChart.drawStrokeForDonutChart(d, donutProperties, d.data.highlightRatio);
                    });
                    var that_1 = this;
                    highlightUpdate.style("fill", function(d) {
                        return d.data.color;
                    }).style("fill-opacity", 1).style("stroke", strokeColor).style("stroke-width", function(d) {
                        return 0 === d.data.highlightRatio ? 0 : d.data.strokeWidth;
                    }).transition().duration(duration).attrTween("d", function(d) {
                        var a = d3.interpolateObject(this._current, d), r = d3.interpolateNumber(previousRadius * DonutChart.OuterRadiusRatio, that_1.getHighlightRadius(d));
                        return this._current = a(0), function(t) {
                            return outerArc.outerRadius(r(t))(a(t));
                        };
                    }), highlightExit = highlightSlices.exit().transition().delay(duration).duration(0).remove();
                } else svg.selectAll("path" + DonutUtil.SliceHighlightClass.selector).transition().delay(duration).duration(0).remove();
                this.assignInteractions(slice, highlightUpdate, data, formatMode), (0, svgUtil.bL)(this.options, slice, slice.exit(), highlightUpdate, highlightExit), 
                this.mobileInteractiveLegend && (this.addInteractiveLegendArrow(), this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate), 
                this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0, duration));
            }, DonutChart.prototype.addTooltips = function(shapes, highlightShapes) {
                this.tooltipService.addTooltip(shapes, function(args) {
                    var _a;
                    return null === (_a = args.data) || void 0 === _a ? void 0 : _a.data.tooltipInfo;
                }, function(args) {
                    var _a;
                    return (null === (_a = args.data) || void 0 === _a ? void 0 : _a.data.identity) && [ args.data.data.identity ];
                }), highlightShapes && this.tooltipService.addTooltip(highlightShapes, function(args) {
                    var _a;
                    return null === (_a = args.data) || void 0 === _a ? void 0 : _a.data.tooltipInfo;
                }, function(args) {
                    var _a;
                    return (null === (_a = args.data) || void 0 === _a ? void 0 : _a.data.identity) && [ args.data.data.identity ];
                });
            }, DonutChart.prototype.drawDefaultShapes = function(donutData, layout, formatMode) {
                var _a, shapes = this.svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceClass.selector).data(donutData.dataPoints, DonutUtil.ArcDescriptorKeyFunc), hasSelection = null === (_a = this.interactivityService) || void 0 === _a ? void 0 : _a.hasSelection(), shapesUpdate = shapes.enter().insert("path").attr("class", DonutUtil.SliceClass.class).merge(shapes);
                return DonutUtil.isSingleColor(donutData.dataPoints), this.interactivityService && shapesUpdate.attr("tabindex", function(d) {
                    return null != d.data.measure ? 0 : null;
                }).attr("focusable", function(d) {
                    return null != d.data.measure || null;
                }).attr("aria-label", function(d) {
                    return d.data.formattedTooltip;
                }).attr("role", "option").classed(renderUtil.Pg, !browserUtils.M.isInternetExplorerOrEdge()), 
                shapesUpdate.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, hasSelection, donutData.hasHighlights);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !1, hasSelection, donutData.hasHighlights);
                }).style("stroke", donutData.borderColor).style("stroke-width", function(d) {
                    return d.data.strokeWidth;
                }).attrs(layout.shapeLayout.attrs).styles(layout.shapeLayout.styles), shapes.exit().remove(), 
                this.featureSwitches.onObject && DonutChart.drawSubSelectionShapes(this.mainGraphicsContext, donutData, layout, this.hostService, formatMode), 
                shapesUpdate;
            }, DonutChart.drawSubSelectionShapes = function(graphicsContext, donutData, layout, hostServices, formatMode) {
                var _a, subSelectionSlicesContext = graphicsContext.selectAll(DonutUtil.SubSelectionSlicesClassAndSelector.selector).data(formatMode && donutData.subSelectionDataPoints ? [ {
                    subSelectionDataPoints: donutData.subSelectionDataPoints
                } ] : []), subSelectionSliceContextUpdate = subSelectionSlicesContext.enter().append("g").attr("class", DonutUtil.SubSelectionSlicesClassAndSelector.class).merge(subSelectionSlicesContext);
                subSelectionSlicesContext.exit().remove();
                var subSelectionSlices = subSelectionSliceContextUpdate.selectAll("path".concat(DonutUtil.SubSelectionSliceClassAndSelector.selector)).data(function(d) {
                    return d.subSelectionDataPoints;
                }), subSelectionSlicesUpdate = subSelectionSlices.enter().append("path").classed(DonutUtil.SubSelectionSliceClassAndSelector.class, !0).merge(subSelectionSlices);
                subSelectionSlicesUpdate.classed(htmlSubSelectionHelper.cy, formatMode).style("pointer-events", "all").style("fill-opacity", 0).attrs((_a = {}, 
                _a[htmlSubSelectionHelper.Ez] = "slices", _a[htmlSubSelectionHelper.QZ] = 3, _a)).attrs(layout.subSelectionShapeLayout.attrs), 
                subSelectionSlicesUpdate.each(function(d) {
                    htmlSubSelectionHelper.O5.setDataForElement(this, {
                        getDisplayName: function() {
                            return hostServices.getLocalizedString("MiniToolbar_Slice", d.data.displayName);
                        }
                    });
                }), subSelectionSlices.exit().remove();
            }, DonutChart.prototype.drawDefaultHighlightShapes = function(donutData, layout) {
                var shapes = this.svg.select(DonutUtil.SliceContainerClass.selector).selectAll("path" + DonutUtil.SliceHighlightClass.selector).data(donutData.dataPoints.filter(function(value) {
                    return null != value.data.highlightRatio;
                }), DonutUtil.ArcDescriptorKeyFunc), shapesUpdate = shapes.enter().insert("path").classed(DonutUtil.SliceHighlightClass.class, !0).each(DonutUtil.UpdateCurrentArcElementFunc).merge(shapes);
                return DonutUtil.isSingleColor(donutData.dataPoints), shapesUpdate.style("fill", function(d) {
                    return d.data.color;
                }).style("fill-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !0, !1, donutData.hasHighlights);
                }).style("stroke-opacity", function(d) {
                    return (0, renderUtil.eR)(d.data.selected, !0, !1, donutData.hasHighlights);
                }).style("stroke", common_colorHelper.v.getThemeColor(this.style, DonutUtil.DefaultStrokeColorName)).style("stroke-width", function(d) {
                    return 0 === d.data.highlightRatio ? 0 : d.data.strokeWidth;
                }).attrs(layout.highlightShapeLayout.attrs).styles(layout.highlightShapeLayout.styles), 
                shapes.exit().remove(), shapesUpdate;
            }, DonutChart.drawStrokeForDonutChart = function(d, donutChartProperties, highlightRatio) {
                void 0 === highlightRatio && (highlightRatio = 1);
                var sectionWithoutStroke, sectionWithStroke, highlightRadius = donutChartProperties.outerRadius * highlightRatio, innerRadius = donutChartProperties.innerRadius, sliceArc = (d.endAngle - d.startAngle) * highlightRadius;
                if (innerRadius > 0) {
                    var donutThickness = donutChartProperties.outerRadius - innerRadius, innerSliceArc = (d.endAngle - d.startAngle) * innerRadius;
                    if (d.data.highlightRatio && (sliceArc = (d.endAngle - d.startAngle) * (donutThickness + innerRadius)), 
                    d.data.isLastInDonut) return "0 " + sliceArc + " " + donutThickness + " " + innerSliceArc + " " + donutThickness;
                    sectionWithoutStroke = sliceArc + donutThickness + innerSliceArc, sectionWithStroke = donutThickness;
                } else d.data.isLastInDonut ? (sectionWithoutStroke = sliceArc, sectionWithStroke = 2 * highlightRadius) : (sectionWithoutStroke = sliceArc + highlightRadius, 
                sectionWithStroke = highlightRadius);
                return "0 " + sectionWithoutStroke + " " + sectionWithStroke;
            }, DonutChart.prototype.onClearSelection = function() {
                var _a;
                null === (_a = this.interactivityService) || void 0 === _a || _a.clearSelection();
            }, DonutChart.prototype.onRestoreSelection = function(options) {
                var _a, _b;
                return null !== (_b = null === (_a = this.interactivityService) || void 0 === _a ? void 0 : _a.restoreSelection(options.selection)) && void 0 !== _b && _b;
            }, DonutChart.prototype.getDonutLayout = function(donutData) {
                var _this = this, donutChartProperties = this.donutProperties, innerRadius = donutChartProperties.innerRadius, outerRadius = donutChartProperties.outerRadius, zeroRadius = innerRadius || DonutChart.EffectiveZeroValue, innerArc = d3.arc().innerRadius(innerRadius), shapeSlice = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius - donutData.explode), zeroSlice = d3.arc().innerRadius(innerRadius).outerRadius(zeroRadius), that = this;
                return {
                    shapeLayout: {
                        attrs: DonutChart.getStandardShapeLayoutAttrs(this.featureSwitches, shapeSlice, donutChartProperties),
                        styles: {
                            "stroke-dasharray": this.featureSwitches.pieChartMarginBetweenSlices || this.style.isHighContrast ? void 0 : function(d) {
                                return DonutChart.drawStrokeForDonutChart(d, donutChartProperties);
                            }
                        }
                    },
                    highlightShapeLayout: {
                        attrs: {
                            d: function(_d2) {
                                return innerArc.outerRadius(_this.getHighlightRadius(_d2))(_d2);
                            }
                        },
                        styles: {
                            "stroke-dasharray": this.style.isHighContrast ? void 0 : function(d) {
                                return DonutChart.drawStrokeForDonutChart(d, donutChartProperties, d.data.highlightRatio);
                            }
                        }
                    },
                    subSelectionShapeLayout: {
                        attrs: DonutChart.getStandardShapeLayoutAttrs(this.featureSwitches, shapeSlice, donutChartProperties)
                    },
                    highlightShapeTween: function(transitionType) {
                        return function(d) {
                            var highlightRadiusFrom = 0 === transitionType ? outerRadius : that.getHighlightRadius(this._current), highlightRadiusTo = 2 === transitionType ? outerRadius : that.getHighlightRadius(d), a = d3.interpolateObject(this._current, d), r = d3.interpolateNumber(highlightRadiusFrom, highlightRadiusTo);
                            return this._current = a(0), function(t) {
                                return innerArc.outerRadius(r(t))(a(t));
                            };
                        };
                    },
                    zeroShapeLayout: {
                        attrs: {
                            d: function(_d3) {
                                return zeroSlice(_d3);
                            }
                        },
                        styles: {
                            "stroke-dasharray": this.style.isHighContrast ? void 0 : function(d) {
                                return DonutChart.drawStrokeForDonutChart(d, donutChartProperties, zeroRadius);
                            }
                        }
                    }
                };
            }, DonutChart.getStandardShapeLayoutAttrs = function(featureSwitches, shapeSlice, donutChartProperties) {
                return {
                    d: function(_d4) {
                        return shapeSlice(_d4);
                    },
                    transform: featureSwitches.pieChartMarginBetweenSlices ? function(d) {
                        var angle = (d.startAngle + d.endAngle) / 2;
                        return "translate(" + explodeXOffset(angle, donutChartProperties) + ", " + explodeYOffset(angle, donutChartProperties) + ")";
                    } : function() {
                        return "translate(0, 0)";
                    }
                };
            }, DonutChart.prototype.getHighlightRadius = function(d) {
                var _a, _b, innerRadius = this.donutProperties.innerRadius, outerRadius = this.donutProperties.outerRadius, areaRatio = null !== (_b = null === (_a = d.data) || void 0 === _a ? void 0 : _a.highlightRatio) && void 0 !== _b ? _b : 1;
                return Math.sqrt(areaRatio * (outerRadius * outerRadius - innerRadius * innerRadius) + innerRadius * innerRadius);
            }, DonutChart.prototype.getArcArea = function(d, useHighlightedArea) {
                var innerRadius = this.donutProperties.innerRadius, outerRadius = useHighlightedArea ? this.getHighlightRadius(d) : this.donutProperties.outerRadius;
                return (d.endAngle - d.startAngle) * (outerRadius * outerRadius - innerRadius * innerRadius);
            }, DonutChart.cullDataByViewport = function(dataPoints, maxValue, viewport, isHighContrast, borderWidth, featureSwitches) {
                var twoPi = 2 * Math.PI, cullableValue = 0;
                if (dataPoints.length > 72) {
                    var estimatedRadius = Math.min(viewport.width, viewport.height) / 2;
                    cullableValue = DonutChart.InvisibleArcLengthInPixels / (estimatedRadius * twoPi) * maxValue;
                }
                for (var prevPointColor, culledDataPoints = [], _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var datapoint = dataPoints_2[_i];
                    datapoint.measure > cullableValue && (borderWidth = borderWidth === DonutChart.DefaultBorderWidth ? isHighContrast || prevPointColor === datapoint.color ? 1 : 0 : borderWidth, 
                    datapoint.strokeWidth = (null == featureSwitches ? void 0 : featureSwitches.pieChartMarginBetweenSlices) ? borderWidth : isHighContrast || prevPointColor === datapoint.color ? 1 : 0, 
                    prevPointColor = datapoint.color, culledDataPoints.push(datapoint));
                }
                return culledDataPoints;
            }, DonutChart.getDefaultLabelSettings = function(style) {
                return {
                    show: !0,
                    position: 0,
                    displayUnits: 0,
                    precision: dataLabelViewModel1Consts.NZ,
                    fontProperties: (0, dataLabelViewModel1.bT)({
                        style,
                        textClassName: "smallLightLabel",
                        noColor: !0
                    }).fontProperties,
                    enableBackground: !0,
                    backgroundColor: common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.lp),
                    backgroundTransparency: .5
                };
            }, DonutChart.OuterRadiusRatio = .8, DonutChart.LabelRadiusRatio = .9, DonutChart.DefaultDonutInnerRadiusRatio = .48, 
            DonutChart.DefaultStartAngleDegrees = 0, DonutChart.OnePiRadianInDegree = 180, DonutChart.DefaultExplode = 0, 
            DonutChart.DefaultBorderWidth = 0, DonutChart.MinDonutThickness = 5, DonutChart.InvisibleArcLengthInPixels = 1, 
            DonutChart.InteractiveLegendContainerHeight = 71, DonutChart.EffectiveZeroValue = 1e-9, 
            DonutChart;
        }(), DonutChartInteractiveLegend = function() {
            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions) {
                this.maxLegendItemWidth = 15, this.legendContainerParent = legendContainer, this.donutChart = donutChart, 
                this.visualInitOptions = visualInitOptions, this.legendItemsPositions = [];
            }
            return DonutChartInteractiveLegend.prototype.drawLegend = function(data) {
                var _this = this;
                this.data = data, this.currentNumberOfLegendItems = data.length, this.currentIndex = 0, 
                this.leftMostIndex = 0, this.rightMostIndex = data.length - 1, this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty() && (this.legendContainer = this.legendContainerParent.append("div").classed(DonutChartInteractiveLegend.LegendContainerClassName, !0));
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data), legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width, initialXOffset = legendContainerWidth / 2 - .4 * legendContainerWidth / 2 + DonutChartInteractiveLegend.ItemMargin, currX = initialXOffset;
                this.currentXOffset = initialXOffset, legendItems.enter().insert("div").classed(DonutChartInteractiveLegend.LegendItemClassName, !0).each(function(d) {
                    !function(itemDiv, datum) {
                        itemDiv.attr("data-legend-index", datum.index).css({
                            position: "absolute",
                            left: currX
                        });
                        var itemCategory = (0, valueFormatter.WU)(datum.label), itemValue = (0, valueFormatter.WU)(datum.originalMeasure, datum.measureFormat), itemPercentage = (0, 
                        valueFormatter.WU)(datum.percentage, "0.00 %;-0.00 %;0.00 %"), itemColor = datum.color, itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11), itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11), itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20), valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan), categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan), precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan), currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                        itemDiv.css("width", currentLegendBoxWidth), _this.maxLegendItemWidth = Math.max(_this.maxLegendItemWidth, currentLegendBoxWidth);
                        var getLeftValue = function(spanWidth) {
                            return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                        }, marginLeftValue = getLeftValue(valueSpanWidth), marginLeftCategory = getLeftValue(categorySpanWidth), marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                        DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory), 
                        DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue), 
                        DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css("color", itemColor), 
                        itemDiv.append(itemCategorySpan), itemDiv.append(itemPercentageSpan), itemDiv.append(itemValueSpan), 
                        _this.legendItemsPositions.push({
                            startX: currX,
                            boxWidth: currentLegendBoxWidth
                        }), currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                    }($(this), d);
                }), legendItems.exit().remove(), this.assignInteractions();
            }, DonutChartInteractiveLegend.prototype.updateLegend = function(sliceIndex) {
                var _a, _b, _this = this, legendContainerWidth = this.legendContainerWidth;
                this.currentIndex = sliceIndex, this.updateLabelBlocks(sliceIndex);
                var nextXOffset = -1 * (this.legendItemsPositions[sliceIndex].startX + this.legendItemsPositions[sliceIndex].boxWidth / 2 - legendContainerWidth / 2);
                this.legendContainer.transition().styleTween("-webkit-transform", function() {
                    return d3.interpolate((0, svgUtil.O7)(_this.currentXOffset, 0), (0, svgUtil.O7)(nextXOffset, 0));
                }).styleTween("transform", function() {
                    return d3.interpolate((0, svgUtil.O7)(_this.currentXOffset, 0), (0, svgUtil.O7)(nextXOffset, 0));
                }).duration(animationDurationMs).ease((0, d3Helper.Ad)(ease)).on("end", function() {
                    _this.currentXOffset = nextXOffset;
                });
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector), formattedLabel = legendItems.filter(function(i) {
                    return i.index === _this.currentIndex;
                }).data()[0].formattedTooltip;
                formattedLabel && (null === (_b = null === (_a = this.visualInitOptions) || void 0 === _a ? void 0 : _a.host) || void 0 === _b || _b.alertScreenReader(formattedLabel)), 
                legendItems.exit(), (0, svgUtil.bL)(this.visualInitOptions, this.legendContainer);
            }, DonutChartInteractiveLegend.prototype.assignInteractions = function() {
                var _this = this, currentDX = 0, drag = d3.drag().on("start", function() {
                    currentDX = 0;
                }).on("drag", function() {
                    currentDX += d3.event.dx, Math.abs(currentDX) < _this.maxLegendItemWidth || (_this.dragLegend(currentDX < 0), 
                    currentDX = 0);
                });
                this.legendContainer.style("touch-action", "none").style("cursor", "pointer").call(drag);
            }, DonutChartInteractiveLegend.prototype.dragLegend = function(dragDirectionLeft) {
                this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1 ? this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft) : this.shouldChangeIndexInNonCycling(dragDirectionLeft) && (dragDirectionLeft ? this.currentIndex++ : this.currentIndex--), 
                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
            }, DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function(dragDirectionLeft) {
                return !(0 === this.currentIndex && !dragDirectionLeft || this.currentIndex === this.currentNumberOfLegendItems - 1 && dragDirectionLeft);
            }, DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function(dragDirectionLeft) {
                var dataLen = this.data.length, newIndex = (this.currentIndex + (dragDirectionLeft ? 1 : -1)) % (dataLen || 1);
                return newIndex < 0 ? newIndex + dataLen : newIndex;
            }, DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function(rightSidedShift, numberOfLegendItemsBlocksToShift) {
                var legendContainer$ = $(this.legendContainer.node());
                if (rightSidedShift) {
                    var smallestItem = legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]");
                    smallestItem.remove().insertAfter(legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]")), 
                    this.legendItemsPositions[this.leftMostIndex].startX = newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin, 
                    smallestItem.css("left", newX), this.rightMostIndex = this.leftMostIndex, this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                } else {
                    var newX, highestItem = legendContainer$.find("[data-legend-index=" + this.rightMostIndex + "]");
                    highestItem.remove().insertBefore(legendContainer$.find("[data-legend-index=" + this.leftMostIndex + "]")), 
                    this.legendItemsPositions[this.rightMostIndex].startX = newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin, 
                    highestItem.css("left", newX), this.leftMostIndex = this.rightMostIndex, this.rightMostIndex = this.rightMostIndex - 1 == -1 ? this.legendItemsPositions.length - 1 : this.rightMostIndex - 1;
                }
                numberOfLegendItemsBlocksToShift - 1 != 0 && this.updateLegendItemsBlocks(rightSidedShift, numberOfLegendItemsBlocksToShift - 1);
            }, DonutChartInteractiveLegend.prototype.updateLabelBlocks = function(index) {
                this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled ? (this.rightMostIndex === index && this.updateLegendItemsBlocks(!0, 2), 
                this.leftMostIndex === index && this.updateLegendItemsBlocks(!1, 2), (this.rightMostIndex === index + 1 || 0 === this.rightMostIndex && index === this.currentNumberOfLegendItems - 1) && this.updateLegendItemsBlocks(!0, 1), 
                (this.leftMostIndex === index - 1 || this.leftMostIndex === this.currentNumberOfLegendItems - 1 && 0 === index) && this.updateLegendItemsBlocks(!1, 1)) : this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled && (this.rightMostIndex === index && this.updateLegendItemsBlocks(!0, 1), 
                this.leftMostIndex === index && this.updateLegendItemsBlocks(!1, 1));
            }, DonutChartInteractiveLegend.createBasicLegendItemSpan = function(spanClass, text, fontSize) {
                return $("<span></span>").addClass(spanClass).css({
                    "white-space": "nowrap",
                    "font-size": fontSize + "px"
                }).text(text);
            }, DonutChartInteractiveLegend.createLegendItemSpan = function(existingSpan, marginLeft) {
                return existingSpan.css({
                    overflow: "hidden",
                    "text-overflow": "ellipsis",
                    display: "inline-block",
                    width: "100%",
                    "margin-left": marginLeft
                }), existingSpan;
            }, DonutChartInteractiveLegend.legendBoxSize = function(valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                return (boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth) > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : boxSize + 2;
            }, DonutChartInteractiveLegend.spanWidth = function(span) {
                var _a;
                return null !== (_a = this.FakeElementSpan) && void 0 !== _a || (this.FakeElementSpan = $("<span>").hide().appendTo(document.body)), 
                this.FakeElementSpan.empty(), this.FakeElementSpan.append(span), this.FakeElementSpan.width();
            }, DonutChartInteractiveLegend.LegendContainerClassName = "legend-container", DonutChartInteractiveLegend.LegendContainerSelector = ".legend-container", 
            DonutChartInteractiveLegend.LegendItemClassName = "legend-item", DonutChartInteractiveLegend.LegendItemSelector = ".legend-item", 
            DonutChartInteractiveLegend.LegendItemCategoryClassName = "category", DonutChartInteractiveLegend.LegendItemPercentageClassName = "percentage", 
            DonutChartInteractiveLegend.LegendItemValueClassName = "value", DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160, 
            DonutChartInteractiveLegend.ItemMargin = 30, DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3, 
            DonutChartInteractiveLegend;
        }(), DonutChartConverter = function() {
            function DonutChartConverter(dataView, style, isDonutChart, tooltipsEnabled) {
                var _a;
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var reader = this.reader = (0, dataViewCategoricalReader.G)(dataView, {
                    staticSeriesRoleNames: [ "Y" ],
                    colorOptions: {
                        valueRole: "Y",
                        visualStyle: style
                    },
                    formatStringProp: donutChartProps.general.formatString
                }), dataReader = reader.data;
                this.dataView = dataView;
                var dataViewCategorical = dataView.categorical;
                if (this.dataViewMetadata = dataView.metadata, this.tooltipsEnabled = tooltipsEnabled, 
                this.maxValue = 0, this.hasNegativeValues = !1, this.allValuesAreNegative = !1, 
                this.style = style, (null === (_a = dataViewCategorical.categories) || void 0 === _a ? void 0 : _a.length) > 0) {
                    var category_1 = dataViewCategorical.categories[0];
                    this.categoryValues = category_1.values, this.categoryFormatString = (0, valueFormatter.EO)(category_1.source, donutChartProps.general.formatString);
                }
                this.hasDynamicSeries = reader.columns.hasDynamicSeries(), this.hasSeriesData = dataReader.hasSeries(), 
                this.hasCategoryData = dataReader.hasCategories(), this.highlightsOverflow = !1, 
                this.total = 0, this.highlightTotal = 0, this.dataPoints = [], this.dataLabelsSettings = null;
                var donutInnerRadiusRatio = 0, colorHelper = common_colorHelper.v.create(style);
                if (this.borderColor = colorHelper.getColorForProperty(reader.objects.getStaticObjects(), donutChartProps.slices.borderColor, DonutUtil.DefaultStrokeColorName), 
                this.explode = (0, dataViewObject2.NA)(reader.objects.getStaticObjects(), donutChartProps.slices.explode, DonutChart.DefaultExplode), 
                this.borderWidth = (0, dataViewObject2.NA)(reader.objects.getStaticObjects(), donutChartProps.slices.borderWidth, DonutChart.DefaultBorderWidth), 
                null == (donutInnerRadiusRatio = (0, dataViewObject2.NA)(reader.objects.getStaticObjects(), donutChartProps.slices.innerRadiusRatio)) ? donutInnerRadiusRatio = isDonutChart ? DonutChart.DefaultDonutInnerRadiusRatio : 0 : donutInnerRadiusRatio /= 100 / DonutChart.OuterRadiusRatio, 
                this.startAngle = (0, dataViewObject2.NA)(reader.objects.getStaticObjects(), donutChartProps.slices.startAngle, DonutChart.DefaultStartAngleDegrees), 
                this.donutInnerRadiusRatio = donutInnerRadiusRatio, dataReader.hasValues("Y")) {
                    var seriesCount = this.seriesCount = dataReader.getSeriesCount();
                    this.hasHighlights = dataReader.hasHighlights();
                    var categoryCount = dataReader.getCategoryCount() || 1;
                    this.allValuesAreNegative = void 0;
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                        var value = dataReader.getValue("Y", categoryIndex, seriesIndex), highlight = void 0;
                        this.hasHighlights && null == (highlight = dataReader.getHighlight("Y", categoryIndex, seriesIndex)) && (highlight = 0), 
                        this.allValuesAreNegative = void 0 === this.allValuesAreNegative ? (!this.hasHighlights || highlight <= 0) && value <= 0 : this.allValuesAreNegative && (!this.hasHighlights || highlight <= 0) && value <= 0, 
                        this.hasNegativeValues || (this.hasNegativeValues = value < 0 || !!this.hasHighlights && highlight < 0);
                    }
                    for (this.allValuesAreNegative = !!this.allValuesAreNegative, categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) value = dataReader.getValue("Y", categoryIndex, seriesIndex), 
                    value = DonutChartConverter.normalizedValue(value, this.allValuesAreNegative), this.total += value, 
                    this.hasHighlights && (highlight = dataReader.getHighlight("Y", categoryIndex, seriesIndex), 
                    highlight = DonutChartConverter.normalizedValue(highlight, this.allValuesAreNegative), 
                    this.highlightTotal += highlight, !this.highlightsOverflow && (0, Double.aP)(highlight, value, (0, 
                    Double.p8)(Math.min(highlight, value))) && (this.highlightsOverflow = !0));
                }
            }
            return DonutChartConverter.normalizedValue = function(value, allValuesAreNegative) {
                return null == value || isNaN(value) ? 0 : value === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : value === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : allValuesAreNegative ? Math.abs(value) : value < 0 ? 0 : value;
            }, DonutChartConverter.prototype.convert = function() {
                var _a, _b, _c, _d, _e, _f, reader = this.reader, dataReader = this.reader.data, convertedData = 0 === this.total ? [] : this.categoryValues ? this.convertCategoricalWithSlicing() : this.hasDynamicSeries ? this.convertSeries() : this.convertMeasures();
                this.dataLabelsSettings = this.convertDataLabelSettings(), (null === (_a = this.dataViewMetadata) || void 0 === _a ? void 0 : _a.objects) && (this.legendObjectProperties = null === (_b = this.dataViewMetadata) || void 0 === _b ? void 0 : _b.objects.legend);
                var category = _.isEmpty(this.dataView.categorical.categories) ? null : this.dataView.categorical.categories[0];
                this.dataPoints = [];
                for (var prevPointColor, formatStringProp = donutChartProps.general.formatString, pctFormatString = (0, 
                valueFormatter.Z)("Percentage"), defaultLabelColor = null !== (_c = this.dataLabelsSettings.fontProperties.color) && void 0 !== _c ? _c : common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.uQ), defaultInsideLabelColor = null !== (_d = this.dataLabelsSettings.fontProperties.color) && void 0 !== _d ? _d : common_colorHelper.v.getThemeColor(this.style, dataLabelViewModel1Consts.pl), i = 0, dataPointCount = convertedData.length; i < dataPointCount; i++) {
                    var point = convertedData[i], originalMeasure = point.measure, normalizedMeasure = DonutChartConverter.normalizedValue(point.measure, this.allValuesAreNegative), originalHighlight = point.highlightMeasure, normalizedHighlight = DonutChartConverter.normalizedValue(point.highlightMeasure, this.allValuesAreNegative), percentage = this.total > 0 ? normalizedMeasure / this.total : 0, highlightRatio = void 0, highlightPercentage = void 0;
                    normalizedMeasure > this.maxValue && (this.maxValue = normalizedMeasure), normalizedHighlight > this.maxValue && (this.maxValue = normalizedHighlight), 
                    this.hasHighlights && (this.highlightsOverflow ? (originalMeasure = originalHighlight, 
                    normalizedMeasure = normalizedHighlight, percentage = this.highlightTotal > 0 ? normalizedHighlight / this.highlightTotal : 0, 
                    highlightRatio = 1) : highlightRatio = 0 !== normalizedMeasure ? normalizedHighlight / normalizedMeasure : 0, 
                    highlightRatio || (highlightRatio = DonutChart.EffectiveZeroValue), highlightPercentage = percentage * highlightRatio);
                    var categoryValue = point.categoryLabel, categorical = this.dataView.categorical, valuesMetadata = reader.columns.getValueMetadataColumn("Y", null != point.seriesIndex ? point.seriesIndex : i), value = this.hasHighlights && this.highlightsOverflow ? originalHighlight : originalMeasure, formatString = point.measureFormat || (0, 
                    valueFormatter.EO)(valuesMetadata, formatStringProp), highlightValue = this.hasHighlights && !this.highlightsOverflow ? originalHighlight : void 0, highlightFormatString = point.highlightMeasureFormat || (0, 
                    valueFormatter.EO)(valuesMetadata, formatStringProp), pct = (0, valueFormatter.WU)(percentage, pctFormatString), valueAndPct = void 0;
                    null != value && null != pct && (valueAndPct = (0, valueFormatter.WU)(value, formatString) + " (" + pct + ")");
                    var highlightValueAndPct = void 0;
                    if (null != highlightValue && null != highlightPercentage) {
                        var highlightedPct = (0, valueFormatter.WU)(highlightPercentage, pctFormatString);
                        highlightValueAndPct = (0, valueFormatter.WU)(highlightValue, highlightFormatString) + " (" + highlightedPct + ")";
                    }
                    var tooltipInfo = void 0;
                    this.tooltipsEnabled && (tooltipInfo = [], category && tooltipInfo.push({
                        displayName: category.source.displayName,
                        value: categoryValue
                    }), this.hasDynamicSeries && (category && category.source === categorical.values.source || tooltipInfo.push({
                        displayName: categorical.values.source.displayName,
                        value: point.label
                    })), null != valueAndPct && tooltipInfo.push({
                        displayName: valuesMetadata.displayName,
                        value: valueAndPct
                    }), null != highlightValueAndPct && tooltipInfo.push({
                        displayName: tooltip.I6.localizationOptions.highlightedValueDisplayName,
                        value: highlightValueAndPct
                    }), (0, tooltip.VT)(reader, tooltipInfo, this.categoryValues ? point.categoryIndex : 0, this.hasDynamicSeries ? point.seriesIndex : void 0, formatStringProp));
                    var strokeWidth = this.style.isHighContrast || prevPointColor === point.color && percentage && percentage > 0 ? 1 : 0;
                    prevPointColor = percentage && percentage > 0 ? point.color : prevPointColor;
                    var labelFill = (0, dataLabelUtil.t$)({
                        defaultColor: defaultLabelColor,
                        categoricalDataReader: reader,
                        categoryIndex: point.categoryIndex,
                        seriesIndex: point.seriesIndex
                    }), insideLabelFill = (0, dataLabelUtil.t$)({
                        defaultColor: defaultInsideLabelColor,
                        categoricalDataReader: reader,
                        categoryIndex: point.categoryIndex,
                        seriesIndex: point.seriesIndex
                    }), fontPropColor = (0, dataLabelUtil.B8)(labelFill) ? labelFill.color : void 0;
                    fontPropColor && (this.dataLabelsSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropColor, this.dataLabelsSettings.fontProperties));
                    var withHighlights = this.hasHighlights && !this.highlightsOverflow;
                    this.dataPoints.push({
                        identity: point.identity,
                        measure: normalizedMeasure,
                        originalMeasure,
                        measureFormat: null !== (_e = point.measureFormat) && void 0 !== _e ? _e : valuesMetadata.format,
                        percentage,
                        index: point.index,
                        label: point.label,
                        highlightRatio,
                        highlightValue: withHighlights ? normalizedHighlight : void 0,
                        originalHighlightValue: withHighlights ? originalHighlight : void 0,
                        highlightFormat: withHighlights ? null !== (_f = point.highlightMeasureFormat) && void 0 !== _f ? _f : valuesMetadata.format : void 0,
                        highlightPercentage: withHighlights ? highlightPercentage : void 0,
                        selected: !1,
                        tooltipInfo,
                        formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                        color: point.color,
                        strokeWidth,
                        seriesIndex: point.seriesIndex ? point.seriesIndex : 0,
                        categoryIndex: point.categoryIndex ? point.categoryIndex : 0,
                        detailLabelFill: labelFill.color ? labelFill.color : void 0,
                        insideDetailLabelFill: insideLabelFill.color ? insideLabelFill.color : void 0,
                        categoryLabel: point.categoryLabel
                    });
                }
                this.legendData = dataReader.hasCategoryWithRole("Category") ? (0, legend_converter.xw)({
                    dataView: this.dataView,
                    categoryRole: "Category",
                    style: this.style,
                    valueRole: "Y",
                    showByDefault: !1
                }) : (0, legend_converter.pq)({
                    dataView: this.dataView,
                    staticSeriesRoleNames: [ "Y" ],
                    style: this.style,
                    showByDefault: !1
                });
            }, DonutChartConverter.prototype.convertCategoricalWithSlicing = function() {
                for (var _a, _b, reader = this.reader, dataReader = this.reader.data, dataViewCategorical = this.dataView.categorical, formatStringProp = donutChartProps.general.formatString, dataPoints = [], categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) for (var categoryValue = this.categoryValues[categoryIndex], color = reader.colors.createByCategory(categoryIndex), categoryLabel = (0, 
                valueFormatter.WU)(categoryValue, this.categoryFormatString), seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                    var value = dataReader.getValue("Y", categoryIndex, seriesIndex), formatString = dataReader.getFormatString("Y", categoryIndex, seriesIndex), highlightValue = this.hasHighlights ? dataReader.getHighlight("Y", categoryIndex, seriesIndex) : void 0, highlightFormatString = this.hasHighlights ? dataReader.getHighlightFormatString("Y", categoryIndex, seriesIndex) : void 0;
                    if (null != value || null != highlightValue) {
                        var valueColumn = reader.columns.getValueColumn("Y", seriesIndex), seriesValueColumn = dataViewCategorical.values.grouped()[seriesIndex], label = categoryLabel;
                        (this.hasDynamicSeries || dataReader.getSeriesCount() > 1) && (label = (0, converterHelper.TO)(valueColumn.source, dataViewCategorical.values, formatStringProp));
                        var measure = valueColumn.source.queryName, identity = selectionId.dw.builder().withCategory([ dataViewCategorical.categories[0] ], categoryIndex, null === (_b = null === (_a = dataViewCategorical.categories[0]) || void 0 === _a ? void 0 : _a.source) || void 0 === _b ? void 0 : _b.queryName, !0).withSeries(dataViewCategorical.values, this.hasDynamicSeries ? seriesValueColumn : void 0, !0).withMeasure(measure, valueColumn, categoryIndex).createSelectionId(), columnFormat = (0, 
                        valueFormatter.EO)(valueColumn.source, formatStringProp, !0);
                        dataPoints.push({
                            identity,
                            measureFormat: formatString || columnFormat,
                            measure: value,
                            highlightMeasureFormat: null != highlightFormatString ? highlightFormatString : columnFormat,
                            highlightMeasure: highlightValue,
                            index: dataPoints.length,
                            label,
                            categoryLabel,
                            color,
                            categoryIndex,
                            seriesIndex
                        });
                    }
                }
                return dataPoints;
            }, DonutChartConverter.prototype.convertMeasures = function() {
                for (var reader = this.reader, dataPoints = [], formatStringProp = donutChartProps.general.formatString, measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                    var value = reader.data.getValue("Y", 0, measureIndex), formatString = reader.data.getFormatString("Y", 0, measureIndex), highlightValue = this.hasHighlights ? reader.data.getHighlight("Y", 0, measureIndex) : void 0, highlightFormatValue = this.hasHighlights ? reader.data.getHighlightFormatString("Y", 0, measureIndex) : void 0, valueColumn = reader.columns.getValueColumn("Y", measureIndex), columnFormat = (0, 
                    valueFormatter.EO)(valueColumn.source, formatStringProp, !0), measureLabel = valueColumn.source.displayName, identity = selectionId.l0.createWithMeasure(valueColumn.source.queryName), color = reader.colors.createBySeries(measureIndex);
                    dataPoints.push({
                        identity,
                        measureFormat: formatString || columnFormat,
                        measure: value,
                        highlightMeasure: highlightValue,
                        highlightMeasureFormat: highlightFormatValue || columnFormat,
                        index: measureIndex,
                        label: measureLabel,
                        categoryLabel: measureLabel,
                        color,
                        categoryIndex: measureIndex,
                        seriesIndex: null
                    });
                }
                return dataPoints;
            }, DonutChartConverter.prototype.convertSeries = function() {
                for (var reader = this.reader, dataViewCategorical = this.dataView.categorical, dataPoints = [], formatStringProp = donutChartProps.general.formatString, seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                    var value = reader.data.getValue("Y", 0, seriesIndex), formatString = reader.data.getFormatString("Y", 0, seriesIndex), highlightValue = this.hasHighlights ? reader.data.getHighlight("Y", 0, seriesIndex) : void 0, highlightFormatString = this.hasHighlights ? reader.data.getHighlightFormatString("Y", 0, seriesIndex) : void 0, valueColumn = reader.columns.getValueColumn("Y", seriesIndex), seriesValueColumn = dataViewCategorical.values.grouped()[seriesIndex], seriesFormat = (0, 
                    valueFormatter.EO)(valueColumn.source, formatStringProp, !0), label = (0, converterHelper.TO)(valueColumn.source, dataViewCategorical.values, formatStringProp), identity = (new selectionId.dw).withSeries(dataViewCategorical.values, seriesValueColumn, !0).withMeasure(valueColumn.source.queryName, valueColumn, 0).createSelectionId(), color = reader.colors.createBySeries(seriesIndex);
                    dataPoints.push({
                        identity,
                        measureFormat: formatString || seriesFormat,
                        measure: value,
                        highlightMeasure: highlightValue,
                        highlightMeasureFormat: null != highlightFormatString ? highlightFormatString : seriesFormat,
                        index: seriesIndex,
                        label,
                        categoryLabel: label,
                        color,
                        categoryIndex: 0,
                        seriesIndex
                    });
                }
                return dataPoints;
            }, DonutChartConverter.prototype.convertDataLabelSettings = function() {
                var dataViewMetadata = this.dataViewMetadata, dataLabelsSettings = DonutChart.getDefaultDonutLabelSettings(this.style);
                if (dataViewMetadata) {
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var labelsObj = objects.labels;
                        labelsObj && (0, dataLabelViewModel1.ww)(labelsObj, dataLabelsSettings, void 0, this.style);
                    }
                    dataLabelsSettings.position = (0, dataViewObject2.NA)(objects, donutChartProps.labels.position, donutLabelPosition.SX), 
                    dataLabelsSettings.overflow = (0, dataViewObject2.NA)(objects, donutChartProps.labels.overflow, !0), 
                    dataLabelsSettings.enableBackgroundWithAuto = (0, dataViewObject2.NA)(objects, donutChartProps.labels.background, donutLabelBackground.d7);
                }
                return dataLabelsSettings;
            }, DonutChartConverter;
        }();
    },
    34644: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Ad: function() {
                return easeCompat;
            },
            LL: function() {
                return orderShapesByClass;
            },
            _9: function() {
                return isScaleBand;
            }
        });
        var _debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62458);
        function easeCompat(easeString) {
            switch (easeString) {
              case "linear":
                return d3.easeLinear;

              case "cubic-in-out":
                return d3.easeCubicInOut;

              case "cubic-out":
                return d3.easeCubicOut;

              case "back":
                return d3.easeBack;

              default:
                _debug__WEBPACK_IMPORTED_MODULE_0__.fF.assertNever(easeString);
            }
            return d3.easeCubicInOut;
        }
        function isScaleBand(scale) {
            return !!scale.bandwidth;
        }
        function orderShapesByClass(context, renderOrder) {
            var renderOrderableElements = context.selectAll(_.map(renderOrder, function(r) {
                return r.selector;
            }).join(", ")).nodes();
            renderOrderableElements.sort(function(a, b) {
                for (var result = 0, i = 0; i < renderOrder.length; i++) result += +d3.select(a).classed(renderOrder[i].class) * i, 
                result -= +d3.select(b).classed(renderOrder[i].class) * i;
                return result;
            }), d3.selectAll(renderOrderableElements).order();
        }
    }
} ]);