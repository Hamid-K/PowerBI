(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "shapeMap", "shapeMapBehaviors" ], {
    43174: function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        !function() {
            var topojson = {
                version: "1.6.19",
                mesh: function(topology) {
                    return object(topology, meshArcs.apply(this, arguments));
                },
                meshArcs,
                merge: function(topology) {
                    return object(topology, mergeArcs.apply(this, arguments));
                },
                mergeArcs,
                feature: function(topology, o) {
                    return "GeometryCollection" === o.type ? {
                        type: "FeatureCollection",
                        features: o.geometries.map(function(o) {
                            return feature(topology, o);
                        })
                    } : feature(topology, o);
                },
                neighbors: function(objects) {
                    var indexesByArc = {}, neighbors = objects.map(function() {
                        return [];
                    });
                    function line(arcs, i) {
                        arcs.forEach(function(a) {
                            a < 0 && (a = ~a);
                            var o = indexesByArc[a];
                            o ? o.push(i) : indexesByArc[a] = [ i ];
                        });
                    }
                    function polygon(arcs, i) {
                        arcs.forEach(function(arc) {
                            line(arc, i);
                        });
                    }
                    var geometryType = {
                        LineString: line,
                        MultiLineString: polygon,
                        Polygon: polygon,
                        MultiPolygon: function(arcs, i) {
                            arcs.forEach(function(arc) {
                                polygon(arc, i);
                            });
                        }
                    };
                    for (var i in objects.forEach(function geometry(o, i) {
                        "GeometryCollection" === o.type ? o.geometries.forEach(function(o) {
                            geometry(o, i);
                        }) : o.type in geometryType && geometryType[o.type](o.arcs, i);
                    }), indexesByArc) for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) for (var k = j + 1; k < m; ++k) {
                        var n, ij = indexes[j], ik = indexes[k];
                        (n = neighbors[ij])[i = bisect(n, ik)] !== ik && n.splice(i, 0, ik), (n = neighbors[ik])[i = bisect(n, ij)] !== ij && n.splice(i, 0, ij);
                    }
                    return neighbors;
                },
                presimplify: function(topology, triangleArea) {
                    var absolute = transformAbsolute(topology.transform), relative = function(transform) {
                        if (!transform) return noop;
                        var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
                        return function(point, i) {
                            i || (x0 = y0 = 0);
                            var x1 = (point[0] - dx) / kx | 0, y1 = (point[1] - dy) / ky | 0;
                            point[0] = x1 - x0, point[1] = y1 - y0, x0 = x1, y0 = y1;
                        };
                    }(topology.transform), heap = function() {
                        var heap = {}, array = [], size = 0;
                        function up(object, i) {
                            for (;i > 0; ) {
                                var j = (i + 1 >> 1) - 1, parent = array[j];
                                if (compareArea(object, parent) >= 0) break;
                                array[parent._ = i] = parent, array[object._ = i = j] = object;
                            }
                        }
                        function down(object, i) {
                            for (;;) {
                                var r = i + 1 << 1, l = r - 1, j = i, child = array[j];
                                if (l < size && compareArea(array[l], child) < 0 && (child = array[j = l]), r < size && compareArea(array[r], child) < 0 && (child = array[j = r]), 
                                j === i) break;
                                array[child._ = i] = child, array[object._ = i = j] = object;
                            }
                        }
                        return heap.push = function(object) {
                            return up(array[object._ = size] = object, size++), size;
                        }, heap.pop = function() {
                            if (!(size <= 0)) {
                                var object, removed = array[0];
                                return --size > 0 && down(array[(object = array[size])._ = 0] = object, 0), removed;
                            }
                        }, heap.remove = function(removed) {
                            var object, i = removed._;
                            if (array[i] === removed) return i !== --size && (compareArea(object = array[size], removed) < 0 ? up : down)(array[object._ = i] = object, i), 
                            i;
                        }, heap;
                    }();
                    function update(triangle) {
                        heap.remove(triangle), triangle[1][2] = triangleArea(triangle), heap.push(triangle);
                    }
                    return triangleArea || (triangleArea = cartesianTriangleArea), topology.arcs.forEach(function(arc) {
                        for (var triangle, p, triangles = [], maxArea = 0, i = 0, n = arc.length; i < n; ++i) absolute(arc[i] = [ (p = arc[i])[0], p[1], 1 / 0 ], i);
                        for (i = 1, n = arc.length - 1; i < n; ++i) (triangle = arc.slice(i - 1, i + 2))[1][2] = triangleArea(triangle), 
                        triangles.push(triangle), heap.push(triangle);
                        for (i = 0, n = triangles.length; i < n; ++i) (triangle = triangles[i]).previous = triangles[i - 1], 
                        triangle.next = triangles[i + 1];
                        for (;triangle = heap.pop(); ) {
                            var previous = triangle.previous, next = triangle.next;
                            triangle[1][2] < maxArea ? triangle[1][2] = maxArea : maxArea = triangle[1][2], 
                            previous && (previous.next = next, previous[2] = triangle[2], update(previous)), 
                            next && (next.previous = previous, next[0] = triangle[0], update(next));
                        }
                        arc.forEach(relative);
                    }), topology;
                }
            };
            function stitchArcs(topology, arcs) {
                var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
                function flush(fragmentByEnd, fragmentByStart) {
                    for (var k in fragmentByEnd) {
                        var f = fragmentByEnd[k];
                        delete fragmentByStart[f.start], delete f.start, delete f.end, f.forEach(function(i) {
                            stitchedArcs[i < 0 ? ~i : i] = 1;
                        }), fragments.push(f);
                    }
                }
                return arcs.forEach(function(i, j) {
                    var t, arc = topology.arcs[i < 0 ? ~i : i];
                    arc.length < 3 && !arc[1][0] && !arc[1][1] && (t = arcs[++emptyIndex], arcs[emptyIndex] = i, 
                    arcs[j] = t);
                }), arcs.forEach(function(i) {
                    var f, g, e = function(i) {
                        var p1, arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0];
                        return topology.transform ? (p1 = [ 0, 0 ], arc.forEach(function(dp) {
                            p1[0] += dp[0], p1[1] += dp[1];
                        })) : p1 = arc[arc.length - 1], i < 0 ? [ p1, p0 ] : [ p0, p1 ];
                    }(i), start = e[0], end = e[1];
                    if (f = fragmentByEnd[start]) if (delete fragmentByEnd[f.end], f.push(i), f.end = end, 
                    g = fragmentByStart[end]) {
                        delete fragmentByStart[g.start];
                        var fg = g === f ? f : f.concat(g);
                        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
                    } else fragmentByStart[f.start] = fragmentByEnd[f.end] = f; else if (f = fragmentByStart[end]) if (delete fragmentByStart[f.start], 
                    f.unshift(i), f.start = start, g = fragmentByEnd[start]) {
                        delete fragmentByEnd[g.end];
                        var gf = g === f ? f : g.concat(f);
                        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
                    } else fragmentByStart[f.start] = fragmentByEnd[f.end] = f; else fragmentByStart[(f = [ i ]).start = start] = fragmentByEnd[f.end = end] = f;
                }), flush(fragmentByEnd, fragmentByStart), flush(fragmentByStart, fragmentByEnd), 
                arcs.forEach(function(i) {
                    stitchedArcs[i < 0 ? ~i : i] || fragments.push([ i ]);
                }), fragments;
            }
            function meshArcs(topology, o, filter) {
                var arcs = [];
                if (arguments.length > 1) {
                    var geom, arc = function(i) {
                        var j = i < 0 ? ~i : i;
                        (geomsByArc[j] || (geomsByArc[j] = [])).push({
                            i,
                            g: geom
                        });
                    }, line = function(arcs) {
                        arcs.forEach(arc);
                    }, polygon = function(arcs) {
                        arcs.forEach(line);
                    }, geomsByArc = [], geometryType = {
                        LineString: line,
                        MultiLineString: polygon,
                        Polygon: polygon,
                        MultiPolygon: function(arcs) {
                            arcs.forEach(polygon);
                        }
                    };
                    !function geometry(o) {
                        "GeometryCollection" === o.type ? o.geometries.forEach(geometry) : o.type in geometryType && (geom = o, 
                        geometryType[o.type](o.arcs));
                    }(o), geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
                        arcs.push(geoms[0].i);
                    } : function(geoms) {
                        filter(geoms[0].g, geoms[geoms.length - 1].g) && arcs.push(geoms[0].i);
                    });
                } else for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
                return {
                    type: "MultiLineString",
                    arcs: stitchArcs(topology, arcs)
                };
            }
            function mergeArcs(topology, objects) {
                var polygonsByArc = {}, polygons = [], components = [];
                function register(polygon) {
                    polygon.forEach(function(ring) {
                        ring.forEach(function(arc) {
                            (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
                        });
                    }), polygons.push(polygon);
                }
                function exterior(ring) {
                    return function(ring) {
                        for (var a, i = -1, n = ring.length, b = ring[n - 1], area = 0; ++i < n; ) area += (a = b)[0] * (b = ring[i])[1] - a[1] * b[0];
                        return .5 * area;
                    }(object(topology, {
                        type: "Polygon",
                        arcs: [ ring ]
                    }).coordinates[0]) > 0;
                }
                return objects.forEach(function(o) {
                    "Polygon" === o.type ? register(o.arcs) : "MultiPolygon" === o.type && o.arcs.forEach(register);
                }), polygons.forEach(function(polygon) {
                    if (!polygon._) {
                        var component = [], neighbors = [ polygon ];
                        for (polygon._ = 1, components.push(component); polygon = neighbors.pop(); ) component.push(polygon), 
                        polygon.forEach(function(ring) {
                            ring.forEach(function(arc) {
                                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                                    polygon._ || (polygon._ = 1, neighbors.push(polygon));
                                });
                            });
                        });
                    }
                }), polygons.forEach(function(polygon) {
                    delete polygon._;
                }), {
                    type: "MultiPolygon",
                    arcs: components.map(function(polygons) {
                        var arcs = [];
                        if (polygons.forEach(function(polygon) {
                            polygon.forEach(function(ring) {
                                ring.forEach(function(arc) {
                                    polygonsByArc[arc < 0 ? ~arc : arc].length < 2 && arcs.push(arc);
                                });
                            });
                        }), arcs = stitchArcs(topology, arcs), (n = arcs.length) > 1) for (var t, sgn = exterior(polygons[0][0]), i = 0; i < n; ++i) if (sgn === exterior(arcs[i])) {
                            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
                            break;
                        }
                        return arcs;
                    })
                };
            }
            function feature(topology, o) {
                var f = {
                    type: "Feature",
                    id: o.id,
                    properties: o.properties || {},
                    geometry: object(topology, o)
                };
                return null == o.id && delete f.id, f;
            }
            function object(topology, o) {
                var absolute = transformAbsolute(topology.transform), arcs = topology.arcs;
                function arc(i, points) {
                    points.length && points.pop();
                    for (var p, a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) points.push(p = a[k].slice()), 
                    absolute(p, k);
                    i < 0 && function(array, n) {
                        for (var t, j = array.length, i = j - n; i < --j; ) t = array[i], array[i++] = array[j], 
                        array[j] = t;
                    }(points, n);
                }
                function point(p) {
                    return p = p.slice(), absolute(p, 0), p;
                }
                function line(arcs) {
                    for (var points = [], i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
                    return points.length < 2 && points.push(points[0].slice()), points;
                }
                function ring(arcs) {
                    for (var points = line(arcs); points.length < 4; ) points.push(points[0].slice());
                    return points;
                }
                function polygon(arcs) {
                    return arcs.map(ring);
                }
                var geometryType = {
                    Point: function(o) {
                        return point(o.coordinates);
                    },
                    MultiPoint: function(o) {
                        return o.coordinates.map(point);
                    },
                    LineString: function(o) {
                        return line(o.arcs);
                    },
                    MultiLineString: function(o) {
                        return o.arcs.map(line);
                    },
                    Polygon: function(o) {
                        return polygon(o.arcs);
                    },
                    MultiPolygon: function(o) {
                        return o.arcs.map(polygon);
                    }
                };
                return function geometry(o) {
                    var t = o.type;
                    return "GeometryCollection" === t ? {
                        type: t,
                        geometries: o.geometries.map(geometry)
                    } : t in geometryType ? {
                        type: t,
                        coordinates: geometryType[t](o)
                    } : null;
                }(o);
            }
            function bisect(a, x) {
                for (var lo = 0, hi = a.length; lo < hi; ) {
                    var mid = lo + hi >>> 1;
                    a[mid] < x ? lo = mid + 1 : hi = mid;
                }
                return lo;
            }
            function cartesianTriangleArea(triangle) {
                var a = triangle[0], b = triangle[1], c = triangle[2];
                return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
            }
            function compareArea(a, b) {
                return a[1][2] - b[1][2];
            }
            function transformAbsolute(transform) {
                if (!transform) return noop;
                var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
                return function(point, i) {
                    i || (x0 = y0 = 0), point[0] = (x0 += point[0]) * kx + dx, point[1] = (y0 += point[1]) * ky + dy;
                };
            }
            function noop() {}
            void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = topojson) ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        }();
    },
    78825: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            Matcher: function() {
                return Matcher;
            },
            ShapeMap: function() {
                return ShapeMap;
            },
            ShapeMapBehavior: function() {
                return ShapeMapBehavior;
            }
        });
        var shapeMap_capabilities = __webpack_require__(22921), colorEnumerationHelper2 = __webpack_require__(32554), common_colorHelper = __webpack_require__(90120), renderUtil = __webpack_require__(60066), converterHelper = __webpack_require__(54522), gradientUtils = __webpack_require__(52083), objectEnumerationBuilder = __webpack_require__(28579), dataViewCategoricalReader = __webpack_require__(51129), legend_converter = __webpack_require__(79811), legend = __webpack_require__(65741), legend_formatting = __webpack_require__(86727), legend_util = __webpack_require__(77686), interactivityService = __webpack_require__(72902), tooltipService = __webpack_require__(40739), tooltip = __webpack_require__(11305), shapeMapType = __webpack_require__(22091), standardGeoJson = __webpack_require__(20792), visualWarnings = __webpack_require__(45296), debug = __webpack_require__(62458), build_control_util = __webpack_require__(56578), dataRoleHelper = __webpack_require__(38958), dataViewObject2 = __webpack_require__(82755), selectionId = __webpack_require__(26543), geoJson = __webpack_require__(52967), shapeMapBehaviors = __webpack_require__(15841);
        function adder() {
            return new Adder;
        }
        function Adder() {
            this.reset();
        }
        Adder.prototype = {
            constructor: Adder,
            reset: function() {
                this.s = this.t = 0;
            },
            add: function(y) {
                _add(temp, y, this.t), _add(this, temp.s, this.s), this.s ? this.t += temp.t : this.s = temp.t;
            },
            valueOf: function() {
                return this.s;
            }
        };
        var temp = new Adder;
        function _add(adder, a, b) {
            var x = adder.s = a + b, bv = x - a;
            adder.t = a - (x - bv) + (b - bv);
        }
        var math_epsilon = 1e-6, pi = Math.PI, math_halfPi = pi / 2, quarterPi = pi / 4, tau = 2 * pi, math_degrees = 180 / pi, math_radians = pi / 180, math_abs = Math.abs, math_atan = Math.atan, math_atan2 = Math.atan2, math_cos = Math.cos, exp = (Math, 
        Math.exp), math_log = (Math, Math.log), math_sin = (Math, Math.sin), math_sign = Math.sign || function(x) {
            return x > 0 ? 1 : x < 0 ? -1 : 0;
        }, math_sqrt = Math.sqrt, math_tan = Math.tan;
        function acos(x) {
            return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
        }
        function math_asin(x) {
            return x > 1 ? math_halfPi : x < -1 ? -math_halfPi : Math.asin(x);
        }
        function noop() {}
        function streamGeometry(geometry, stream) {
            geometry && streamGeometryType.hasOwnProperty(geometry.type) && streamGeometryType[geometry.type](geometry, stream);
        }
        var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, centroid_lambda00, centroid_phi00, x0, y0, z0, streamObjectType = {
            Feature: function(object, stream) {
                streamGeometry(object.geometry, stream);
            },
            FeatureCollection: function(object, stream) {
                for (var features = object.features, i = -1, n = features.length; ++i < n; ) streamGeometry(features[i].geometry, stream);
            }
        }, streamGeometryType = {
            Sphere: function(object, stream) {
                stream.sphere();
            },
            Point: function(object, stream) {
                stream.point((object = object.coordinates)[0], object[1], object[2]);
            },
            MultiPoint: function(object, stream) {
                for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; ) stream.point((object = coordinates[i])[0], object[1], object[2]);
            },
            LineString: function(object, stream) {
                streamLine(object.coordinates, stream, 0);
            },
            MultiLineString: function(object, stream) {
                for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; ) streamLine(coordinates[i], stream, 0);
            },
            Polygon: function(object, stream) {
                streamPolygon(object.coordinates, stream);
            },
            MultiPolygon: function(object, stream) {
                for (var coordinates = object.coordinates, i = -1, n = coordinates.length; ++i < n; ) streamPolygon(coordinates[i], stream);
            },
            GeometryCollection: function(object, stream) {
                for (var geometries = object.geometries, i = -1, n = geometries.length; ++i < n; ) streamGeometry(geometries[i], stream);
            }
        };
        function streamLine(coordinates, stream, closed) {
            var coordinate, i = -1, n = coordinates.length - closed;
            for (stream.lineStart(); ++i < n; ) stream.point((coordinate = coordinates[i])[0], coordinate[1], coordinate[2]);
            stream.lineEnd();
        }
        function streamPolygon(coordinates, stream) {
            var i = -1, n = coordinates.length;
            for (stream.polygonStart(); ++i < n; ) streamLine(coordinates[i], stream, 1);
            stream.polygonEnd();
        }
        function src_stream(object, stream) {
            object && streamObjectType.hasOwnProperty(object.type) ? streamObjectType[object.type](object, stream) : streamGeometry(object, stream);
        }
        function spherical(cartesian) {
            return [ math_atan2(cartesian[1], cartesian[0]), math_asin(cartesian[2]) ];
        }
        function cartesian(spherical) {
            var lambda = spherical[0], phi = spherical[1], cosPhi = math_cos(phi);
            return [ cosPhi * math_cos(lambda), cosPhi * math_sin(lambda), math_sin(phi) ];
        }
        function cartesianDot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        function cartesianCross(a, b) {
            return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
        }
        function cartesianAddInPlace(a, b) {
            a[0] += b[0], a[1] += b[1], a[2] += b[2];
        }
        function cartesianScale(vector, k) {
            return [ vector[0] * k, vector[1] * k, vector[2] * k ];
        }
        function cartesianNormalizeInPlace(d) {
            var l = math_sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
            d[0] /= l, d[1] /= l, d[2] /= l;
        }
        adder(), adder(), adder();
        var centroidStream = {
            sphere: noop,
            point: centroidPoint,
            lineStart: centroidLineStart,
            lineEnd: centroidLineEnd,
            polygonStart: function() {
                centroidStream.lineStart = centroidRingStart, centroidStream.lineEnd = centroidRingEnd;
            },
            polygonEnd: function() {
                centroidStream.lineStart = centroidLineStart, centroidStream.lineEnd = centroidLineEnd;
            }
        };
        function centroidPoint(lambda, phi) {
            lambda *= math_radians;
            var cosPhi = math_cos(phi *= math_radians);
            centroidPointCartesian(cosPhi * math_cos(lambda), cosPhi * math_sin(lambda), math_sin(phi));
        }
        function centroidPointCartesian(x, y, z) {
            ++W0, X0 += (x - X0) / W0, Y0 += (y - Y0) / W0, Z0 += (z - Z0) / W0;
        }
        function centroidLineStart() {
            centroidStream.point = centroidLinePointFirst;
        }
        function centroidLinePointFirst(lambda, phi) {
            lambda *= math_radians;
            var cosPhi = math_cos(phi *= math_radians);
            x0 = cosPhi * math_cos(lambda), y0 = cosPhi * math_sin(lambda), z0 = math_sin(phi), 
            centroidStream.point = centroidLinePoint, centroidPointCartesian(x0, y0, z0);
        }
        function centroidLinePoint(lambda, phi) {
            lambda *= math_radians;
            var cosPhi = math_cos(phi *= math_radians), x = cosPhi * math_cos(lambda), y = cosPhi * math_sin(lambda), z = math_sin(phi), w = math_atan2(math_sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            W1 += w, X1 += w * (x0 + (x0 = x)), Y1 += w * (y0 + (y0 = y)), Z1 += w * (z0 + (z0 = z)), 
            centroidPointCartesian(x0, y0, z0);
        }
        function centroidLineEnd() {
            centroidStream.point = centroidPoint;
        }
        function centroidRingStart() {
            centroidStream.point = centroidRingPointFirst;
        }
        function centroidRingEnd() {
            centroidRingPoint(centroid_lambda00, centroid_phi00), centroidStream.point = centroidPoint;
        }
        function centroidRingPointFirst(lambda, phi) {
            centroid_lambda00 = lambda, centroid_phi00 = phi, lambda *= math_radians, phi *= math_radians, 
            centroidStream.point = centroidRingPoint;
            var cosPhi = math_cos(phi);
            x0 = cosPhi * math_cos(lambda), y0 = cosPhi * math_sin(lambda), z0 = math_sin(phi), 
            centroidPointCartesian(x0, y0, z0);
        }
        function centroidRingPoint(lambda, phi) {
            lambda *= math_radians;
            var cosPhi = math_cos(phi *= math_radians), x = cosPhi * math_cos(lambda), y = cosPhi * math_sin(lambda), z = math_sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = math_sqrt(cx * cx + cy * cy + cz * cz), w = math_asin(m), v = m && -w / m;
            X2 += v * cx, Y2 += v * cy, Z2 += v * cz, W1 += w, X1 += w * (x0 + (x0 = x)), Y1 += w * (y0 + (y0 = y)), 
            Z1 += w * (z0 + (z0 = z)), centroidPointCartesian(x0, y0, z0);
        }
        function compose(a, b) {
            function compose(x, y) {
                return x = a(x, y), b(x[0], x[1]);
            }
            return a.invert && b.invert && (compose.invert = function(x, y) {
                return (x = b.invert(x, y)) && a.invert(x[0], x[1]);
            }), compose;
        }
        function rotationIdentity(lambda, phi) {
            return [ lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi ];
        }
        function rotation_rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
            return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
        }
        function forwardRotationLambda(deltaLambda) {
            return function(lambda, phi) {
                return [ (lambda += deltaLambda) > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi ];
            };
        }
        function rotationLambda(deltaLambda) {
            var rotation = forwardRotationLambda(deltaLambda);
            return rotation.invert = forwardRotationLambda(-deltaLambda), rotation;
        }
        function rotationPhiGamma(deltaPhi, deltaGamma) {
            var cosDeltaPhi = math_cos(deltaPhi), sinDeltaPhi = math_sin(deltaPhi), cosDeltaGamma = math_cos(deltaGamma), sinDeltaGamma = math_sin(deltaGamma);
            function rotation(lambda, phi) {
                var cosPhi = math_cos(phi), x = math_cos(lambda) * cosPhi, y = math_sin(lambda) * cosPhi, z = math_sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
                return [ math_atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), math_asin(k * cosDeltaGamma + y * sinDeltaGamma) ];
            }
            return rotation.invert = function(lambda, phi) {
                var cosPhi = math_cos(phi), x = math_cos(lambda) * cosPhi, y = math_sin(lambda) * cosPhi, z = math_sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
                return [ math_atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), math_asin(k * cosDeltaPhi - x * sinDeltaPhi) ];
            }, rotation;
        }
        function circleRadius(cosRadius, point) {
            (point = cartesian(point))[0] -= cosRadius, cartesianNormalizeInPlace(point);
            var radius = acos(-point[1]);
            return ((-point[2] < 0 ? -radius : radius) + tau - math_epsilon) % tau;
        }
        function buffer() {
            var line, lines = [];
            return {
                point: function(x, y) {
                    line.push([ x, y ]);
                },
                lineStart: function() {
                    lines.push(line = []);
                },
                lineEnd: noop,
                rejoin: function() {
                    lines.length > 1 && lines.push(lines.pop().concat(lines.shift()));
                },
                result: function() {
                    var result = lines;
                    return lines = [], line = null, result;
                }
            };
        }
        function pointEqual(a, b) {
            return math_abs(a[0] - b[0]) < math_epsilon && math_abs(a[1] - b[1]) < math_epsilon;
        }
        function Intersection(point, points, other, entry) {
            this.x = point, this.z = points, this.o = other, this.e = entry, this.v = !1, this.n = this.p = null;
        }
        function rejoin(segments, compareIntersection, startInside, interpolate, stream) {
            var i, n, subject = [], clip = [];
            if (segments.forEach(function(segment) {
                if (!((n = segment.length - 1) <= 0)) {
                    var n, x, p0 = segment[0], p1 = segment[n];
                    if (pointEqual(p0, p1)) {
                        for (stream.lineStart(), i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
                        stream.lineEnd();
                    } else subject.push(x = new Intersection(p0, segment, null, !0)), clip.push(x.o = new Intersection(p0, null, x, !1)), 
                    subject.push(x = new Intersection(p1, segment, null, !1)), clip.push(x.o = new Intersection(p1, null, x, !0));
                }
            }), subject.length) {
                for (clip.sort(compareIntersection), rejoin_link(subject), rejoin_link(clip), i = 0, 
                n = clip.length; i < n; ++i) clip[i].e = startInside = !startInside;
                for (var points, point, start = subject[0]; ;) {
                    for (var current = start, isSubject = !0; current.v; ) if ((current = current.n) === start) return;
                    points = current.z, stream.lineStart();
                    do {
                        if (current.v = current.o.v = !0, current.e) {
                            if (isSubject) for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]); else interpolate(current.x, current.n.x, 1, stream);
                            current = current.n;
                        } else {
                            if (isSubject) for (i = (points = current.p.z).length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]); else interpolate(current.x, current.p.x, -1, stream);
                            current = current.p;
                        }
                        points = (current = current.o).z, isSubject = !isSubject;
                    } while (!current.v);
                    stream.lineEnd();
                }
            }
        }
        function rejoin_link(array) {
            if (n = array.length) {
                for (var n, b, i = 0, a = array[0]; ++i < n; ) a.n = b = array[i], b.p = a, a = b;
                a.n = b = array[0], b.p = a;
            }
        }
        rotationIdentity.invert = rotationIdentity;
        var compare, f, sum = adder();
        function src_ascending(a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        function merge(arrays) {
            for (var m, merged, array, n = arrays.length, i = -1, j = 0; ++i < n; ) j += arrays[i].length;
            for (merged = new Array(j); --n >= 0; ) for (m = (array = arrays[n]).length; --m >= 0; ) merged[--j] = array[m];
            return merged;
        }
        function clip(pointVisible, clipLine, interpolate, start) {
            return function(sink) {
                var polygon, segments, ring, line = clipLine(sink), ringBuffer = buffer(), ringSink = clipLine(ringBuffer), polygonStarted = !1, clip = {
                    point,
                    lineStart,
                    lineEnd,
                    polygonStart: function() {
                        clip.point = pointRing, clip.lineStart = ringStart, clip.lineEnd = ringEnd, segments = [], 
                        polygon = [];
                    },
                    polygonEnd: function() {
                        clip.point = point, clip.lineStart = lineStart, clip.lineEnd = lineEnd, segments = merge(segments);
                        var startInside = function(polygon, point) {
                            var lambda = point[0], phi = point[1], sinPhi = math_sin(phi), normal = [ math_sin(lambda), -math_cos(lambda), 0 ], angle = 0, winding = 0;
                            sum.reset(), 1 === sinPhi ? phi = math_halfPi + math_epsilon : -1 === sinPhi && (phi = -math_halfPi - math_epsilon);
                            for (var i = 0, n = polygon.length; i < n; ++i) if (m = (ring = polygon[i]).length) for (var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = math_sin(phi0), cosPhi0 = math_cos(phi0), j = 0; j < m; ++j, 
                            lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
                                var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = math_sin(phi1), cosPhi1 = math_cos(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
                                if (sum.add(math_atan2(k * sign * math_sin(absDelta), cosPhi0 * cosPhi1 + k * math_cos(absDelta))), 
                                angle += antimeridian ? delta + sign * tau : delta, antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
                                    var arc = cartesianCross(cartesian(point0), cartesian(point1));
                                    cartesianNormalizeInPlace(arc);
                                    var intersection = cartesianCross(normal, arc);
                                    cartesianNormalizeInPlace(intersection);
                                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * math_asin(intersection[2]);
                                    (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) && (winding += antimeridian ^ delta >= 0 ? 1 : -1);
                                }
                            }
                            return (angle < -math_epsilon || angle < math_epsilon && sum < -math_epsilon) ^ 1 & winding;
                        }(polygon, start);
                        segments.length ? (polygonStarted || (sink.polygonStart(), polygonStarted = !0), 
                        rejoin(segments, compareIntersection, startInside, interpolate, sink)) : startInside && (polygonStarted || (sink.polygonStart(), 
                        polygonStarted = !0), sink.lineStart(), interpolate(null, null, 1, sink), sink.lineEnd()), 
                        polygonStarted && (sink.polygonEnd(), polygonStarted = !1), segments = polygon = null;
                    },
                    sphere: function() {
                        sink.polygonStart(), sink.lineStart(), interpolate(null, null, 1, sink), sink.lineEnd(), 
                        sink.polygonEnd();
                    }
                };
                function point(lambda, phi) {
                    pointVisible(lambda, phi) && sink.point(lambda, phi);
                }
                function pointLine(lambda, phi) {
                    line.point(lambda, phi);
                }
                function lineStart() {
                    clip.point = pointLine, line.lineStart();
                }
                function lineEnd() {
                    clip.point = point, line.lineEnd();
                }
                function pointRing(lambda, phi) {
                    ring.push([ lambda, phi ]), ringSink.point(lambda, phi);
                }
                function ringStart() {
                    ringSink.lineStart(), ring = [];
                }
                function ringEnd() {
                    pointRing(ring[0][0], ring[0][1]), ringSink.lineEnd();
                    var i, m, segment, point, clean = ringSink.clean(), ringSegments = ringBuffer.result(), n = ringSegments.length;
                    if (ring.pop(), polygon.push(ring), ring = null, n) if (1 & clean) {
                        if ((m = (segment = ringSegments[0]).length - 1) > 0) {
                            for (polygonStarted || (sink.polygonStart(), polygonStarted = !0), sink.lineStart(), 
                            i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
                            sink.lineEnd();
                        }
                    } else n > 1 && 2 & clean && ringSegments.push(ringSegments.pop().concat(ringSegments.shift())), 
                    segments.push(ringSegments.filter(validSegment));
                }
                return clip;
            };
        }
        function validSegment(segment) {
            return segment.length > 1;
        }
        function compareIntersection(a, b) {
            return ((a = a.x)[0] < 0 ? a[1] - math_halfPi - math_epsilon : math_halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - math_halfPi - math_epsilon : math_halfPi - b[1]);
        }
        1 === (compare = src_ascending).length && (f = compare, compare = function(d, x) {
            return src_ascending(f(d), x);
        }), Math.sqrt(50), Math.sqrt(10), Math.sqrt(2);
        var antimeridian = clip(function() {
            return !0;
        }, function(stream) {
            var _clean, lambda0 = NaN, phi0 = NaN, sign0 = NaN;
            return {
                lineStart: function() {
                    stream.lineStart(), _clean = 1;
                },
                point: function(lambda1, phi1) {
                    var sign1 = lambda1 > 0 ? pi : -pi, delta = math_abs(lambda1 - lambda0);
                    math_abs(delta - pi) < math_epsilon ? (stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? math_halfPi : -math_halfPi), 
                    stream.point(sign0, phi0), stream.lineEnd(), stream.lineStart(), stream.point(sign1, phi0), 
                    stream.point(lambda1, phi0), _clean = 0) : sign0 !== sign1 && delta >= pi && (math_abs(lambda0 - sign0) < math_epsilon && (lambda0 -= sign0 * math_epsilon), 
                    math_abs(lambda1 - sign1) < math_epsilon && (lambda1 -= sign1 * math_epsilon), phi0 = function(lambda0, phi0, lambda1, phi1) {
                        var cosPhi0, cosPhi1, sinLambda0Lambda1 = math_sin(lambda0 - lambda1);
                        return math_abs(sinLambda0Lambda1) > math_epsilon ? math_atan((math_sin(phi0) * (cosPhi1 = math_cos(phi1)) * math_sin(lambda1) - math_sin(phi1) * (cosPhi0 = math_cos(phi0)) * math_sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
                    }(lambda0, phi0, lambda1, phi1), stream.point(sign0, phi0), stream.lineEnd(), stream.lineStart(), 
                    stream.point(sign1, phi0), _clean = 0), stream.point(lambda0 = lambda1, phi0 = phi1), 
                    sign0 = sign1;
                },
                lineEnd: function() {
                    stream.lineEnd(), lambda0 = phi0 = NaN;
                },
                clean: function() {
                    return 2 - _clean;
                }
            };
        }, function(from, to, direction, stream) {
            var phi;
            if (null == from) stream.point(-pi, phi = direction * math_halfPi), stream.point(0, phi), 
            stream.point(pi, phi), stream.point(pi, 0), stream.point(pi, -phi), stream.point(0, -phi), 
            stream.point(-pi, -phi), stream.point(-pi, 0), stream.point(-pi, phi); else if (math_abs(from[0] - to[0]) > math_epsilon) {
                var lambda = from[0] < to[0] ? pi : -pi;
                stream.point(-lambda, phi = direction * lambda / 2), stream.point(0, phi), stream.point(lambda, phi);
            } else stream.point(to[0], to[1]);
        }, [ -pi, -math_halfPi ]), clipMax = 1e9, clipMin = -clipMax;
        function src_identity(x) {
            return x;
        }
        adder();
        var x00, y00, area_x0, area_y0, area_areaSum = adder(), area_areaRingSum = adder(), area_areaStream = {
            point: noop,
            lineStart: noop,
            lineEnd: noop,
            polygonStart: function() {
                area_areaStream.lineStart = area_areaRingStart, area_areaStream.lineEnd = area_areaRingEnd;
            },
            polygonEnd: function() {
                area_areaStream.lineStart = area_areaStream.lineEnd = area_areaStream.point = noop, 
                area_areaSum.add(math_abs(area_areaRingSum)), area_areaRingSum.reset();
            },
            result: function() {
                var area = area_areaSum / 2;
                return area_areaSum.reset(), area;
            }
        };
        function area_areaRingStart() {
            area_areaStream.point = area_areaPointFirst;
        }
        function area_areaPointFirst(x, y) {
            area_areaStream.point = area_areaPoint, x00 = area_x0 = x, y00 = area_y0 = y;
        }
        function area_areaPoint(x, y) {
            area_areaRingSum.add(area_y0 * x - area_x0 * y), area_x0 = x, area_y0 = y;
        }
        function area_areaRingEnd() {
            area_areaPoint(x00, y00);
        }
        var centroid_x00, centroid_y00, centroid_x0, centroid_y0, path_area = area_areaStream, bounds_x0 = 1 / 0, bounds_y0 = bounds_x0, x1 = -bounds_x0, y1 = x1, path_bounds = {
            point: function(x, y) {
                x < bounds_x0 && (bounds_x0 = x), x > x1 && (x1 = x), y < bounds_y0 && (bounds_y0 = y), 
                y > y1 && (y1 = y);
            },
            lineStart: noop,
            lineEnd: noop,
            polygonStart: noop,
            polygonEnd: noop,
            result: function() {
                var bounds = [ [ bounds_x0, bounds_y0 ], [ x1, y1 ] ];
                return x1 = y1 = -(bounds_y0 = bounds_x0 = 1 / 0), bounds;
            }
        }, centroid_X0 = 0, centroid_Y0 = 0, centroid_Z0 = 0, centroid_X1 = 0, centroid_Y1 = 0, centroid_Z1 = 0, centroid_X2 = 0, centroid_Y2 = 0, centroid_Z2 = 0, centroid_centroidStream = {
            point: centroid_centroidPoint,
            lineStart: centroid_centroidLineStart,
            lineEnd: centroid_centroidLineEnd,
            polygonStart: function() {
                centroid_centroidStream.lineStart = centroid_centroidRingStart, centroid_centroidStream.lineEnd = centroid_centroidRingEnd;
            },
            polygonEnd: function() {
                centroid_centroidStream.point = centroid_centroidPoint, centroid_centroidStream.lineStart = centroid_centroidLineStart, 
                centroid_centroidStream.lineEnd = centroid_centroidLineEnd;
            },
            result: function() {
                var centroid = centroid_Z2 ? [ centroid_X2 / centroid_Z2, centroid_Y2 / centroid_Z2 ] : centroid_Z1 ? [ centroid_X1 / centroid_Z1, centroid_Y1 / centroid_Z1 ] : centroid_Z0 ? [ centroid_X0 / centroid_Z0, centroid_Y0 / centroid_Z0 ] : [ NaN, NaN ];
                return centroid_X0 = centroid_Y0 = centroid_Z0 = centroid_X1 = centroid_Y1 = centroid_Z1 = centroid_X2 = centroid_Y2 = centroid_Z2 = 0, 
                centroid;
            }
        };
        function centroid_centroidPoint(x, y) {
            centroid_X0 += x, centroid_Y0 += y, ++centroid_Z0;
        }
        function centroid_centroidLineStart() {
            centroid_centroidStream.point = centroidPointFirstLine;
        }
        function centroidPointFirstLine(x, y) {
            centroid_centroidStream.point = centroidPointLine, centroid_centroidPoint(centroid_x0 = x, centroid_y0 = y);
        }
        function centroidPointLine(x, y) {
            var dx = x - centroid_x0, dy = y - centroid_y0, z = math_sqrt(dx * dx + dy * dy);
            centroid_X1 += z * (centroid_x0 + x) / 2, centroid_Y1 += z * (centroid_y0 + y) / 2, 
            centroid_Z1 += z, centroid_centroidPoint(centroid_x0 = x, centroid_y0 = y);
        }
        function centroid_centroidLineEnd() {
            centroid_centroidStream.point = centroid_centroidPoint;
        }
        function centroid_centroidRingStart() {
            centroid_centroidStream.point = centroidPointFirstRing;
        }
        function centroid_centroidRingEnd() {
            centroidPointRing(centroid_x00, centroid_y00);
        }
        function centroidPointFirstRing(x, y) {
            centroid_centroidStream.point = centroidPointRing, centroid_centroidPoint(centroid_x00 = centroid_x0 = x, centroid_y00 = centroid_y0 = y);
        }
        function centroidPointRing(x, y) {
            var dx = x - centroid_x0, dy = y - centroid_y0, z = math_sqrt(dx * dx + dy * dy);
            centroid_X1 += z * (centroid_x0 + x) / 2, centroid_Y1 += z * (centroid_y0 + y) / 2, 
            centroid_Z1 += z, centroid_X2 += (z = centroid_y0 * x - centroid_x0 * y) * (centroid_x0 + x), 
            centroid_Y2 += z * (centroid_y0 + y), centroid_Z2 += 3 * z, centroid_centroidPoint(centroid_x0 = x, centroid_y0 = y);
        }
        var centroid = centroid_centroidStream;
        function PathContext(context) {
            this._context = context;
        }
        PathContext.prototype = {
            _radius: 4.5,
            pointRadius: function(_) {
                return this._radius = _, this;
            },
            polygonStart: function() {
                this._line = 0;
            },
            polygonEnd: function() {
                this._line = NaN;
            },
            lineStart: function() {
                this._point = 0;
            },
            lineEnd: function() {
                0 === this._line && this._context.closePath(), this._point = NaN;
            },
            point: function(x, y) {
                switch (this._point) {
                  case 0:
                    this._context.moveTo(x, y), this._point = 1;
                    break;

                  case 1:
                    this._context.lineTo(x, y);
                    break;

                  default:
                    this._context.moveTo(x + this._radius, y), this._context.arc(x, y, this._radius, 0, tau);
                }
            },
            result: noop
        };
        var lengthRing, measure_x00, measure_y00, measure_x0, measure_y0, measure_lengthSum = adder(), measure_lengthStream = {
            point: noop,
            lineStart: function() {
                measure_lengthStream.point = measure_lengthPointFirst;
            },
            lineEnd: function() {
                lengthRing && measure_lengthPoint(measure_x00, measure_y00), measure_lengthStream.point = noop;
            },
            polygonStart: function() {
                lengthRing = !0;
            },
            polygonEnd: function() {
                lengthRing = null;
            },
            result: function() {
                var length = +measure_lengthSum;
                return measure_lengthSum.reset(), length;
            }
        };
        function measure_lengthPointFirst(x, y) {
            measure_lengthStream.point = measure_lengthPoint, measure_x00 = measure_x0 = x, 
            measure_y00 = measure_y0 = y;
        }
        function measure_lengthPoint(x, y) {
            measure_lengthSum.add(math_sqrt((measure_x0 -= x) * measure_x0 + (measure_y0 -= y) * measure_y0)), 
            measure_x0 = x, measure_y0 = y;
        }
        var measure = measure_lengthStream;
        function PathString() {
            this._string = [];
        }
        function string_circle(radius) {
            return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
        }
        function path(projection, context) {
            var projectionStream, contextStream, pointRadius = 4.5;
            function path(object) {
                return object && ("function" == typeof pointRadius && contextStream.pointRadius(+pointRadius.apply(this, arguments)), 
                src_stream(object, projectionStream(contextStream))), contextStream.result();
            }
            return path.area = function(object) {
                return src_stream(object, projectionStream(path_area)), path_area.result();
            }, path.measure = function(object) {
                return src_stream(object, projectionStream(measure)), measure.result();
            }, path.bounds = function(object) {
                return src_stream(object, projectionStream(path_bounds)), path_bounds.result();
            }, path.centroid = function(object) {
                return src_stream(object, projectionStream(centroid)), centroid.result();
            }, path.projection = function(_) {
                return arguments.length ? (projectionStream = null == _ ? (projection = null, src_identity) : (projection = _).stream, 
                path) : projection;
            }, path.context = function(_) {
                return arguments.length ? (contextStream = null == _ ? (context = null, new PathString) : new PathContext(context = _), 
                "function" != typeof pointRadius && contextStream.pointRadius(pointRadius), path) : context;
            }, path.pointRadius = function(_) {
                return arguments.length ? (pointRadius = "function" == typeof _ ? _ : (contextStream.pointRadius(+_), 
                +_), path) : pointRadius;
            }, path.projection(projection).context(context);
        }
        function transform_transformer(methods) {
            return function(stream) {
                var s = new TransformStream;
                for (var key in methods) s[key] = methods[key];
                return s.stream = stream, s;
            };
        }
        function TransformStream() {}
        function fit(projection, fitBounds, object) {
            var clip = projection.clipExtent && projection.clipExtent();
            return projection.scale(150).translate([ 0, 0 ]), null != clip && projection.clipExtent(null), 
            src_stream(object, projection.stream(path_bounds)), fitBounds(path_bounds.result()), 
            null != clip && projection.clipExtent(clip), projection;
        }
        function fitExtent(projection, extent, object) {
            return fit(projection, function(b) {
                var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
                projection.scale(150 * k).translate([ x, y ]);
            }, object);
        }
        function fitSize(projection, size, object) {
            return fitExtent(projection, [ [ 0, 0 ], size ], object);
        }
        function fitWidth(projection, width, object) {
            return fit(projection, function(b) {
                var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
                projection.scale(150 * k).translate([ x, y ]);
            }, object);
        }
        function fitHeight(projection, height, object) {
            return fit(projection, function(b) {
                var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
                projection.scale(150 * k).translate([ x, y ]);
            }, object);
        }
        PathString.prototype = {
            _radius: 4.5,
            _circle: string_circle(4.5),
            pointRadius: function(_) {
                return (_ = +_) !== this._radius && (this._radius = _, this._circle = null), this;
            },
            polygonStart: function() {
                this._line = 0;
            },
            polygonEnd: function() {
                this._line = NaN;
            },
            lineStart: function() {
                this._point = 0;
            },
            lineEnd: function() {
                0 === this._line && this._string.push("Z"), this._point = NaN;
            },
            point: function(x, y) {
                switch (this._point) {
                  case 0:
                    this._string.push("M", x, ",", y), this._point = 1;
                    break;

                  case 1:
                    this._string.push("L", x, ",", y);
                    break;

                  default:
                    null == this._circle && (this._circle = string_circle(this._radius)), this._string.push("M", x, ",", y, this._circle);
                }
            },
            result: function() {
                if (this._string.length) {
                    var result = this._string.join("");
                    return this._string = [], result;
                }
                return null;
            }
        }, TransformStream.prototype = {
            constructor: TransformStream,
            point: function(x, y) {
                this.stream.point(x, y);
            },
            sphere: function() {
                this.stream.sphere();
            },
            lineStart: function() {
                this.stream.lineStart();
            },
            lineEnd: function() {
                this.stream.lineEnd();
            },
            polygonStart: function() {
                this.stream.polygonStart();
            },
            polygonEnd: function() {
                this.stream.polygonEnd();
            }
        };
        var maxDepth = 16, cosMinDistance = math_cos(30 * math_radians);
        function resample(project, delta2) {
            return +delta2 ? function(project, delta2) {
                function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
                    var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                    if (d2 > 4 * delta2 && depth--) {
                        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = math_sqrt(a * a + b * b + c * c), phi2 = math_asin(c /= m), lambda2 = math_abs(math_abs(c) - 1) < math_epsilon || math_abs(lambda0 - lambda1) < math_epsilon ? (lambda0 + lambda1) / 2 : math_atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                        (dz * dz / d2 > delta2 || math_abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) && (resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream), 
                        stream.point(x2, y2), resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream));
                    }
                }
                return function(stream) {
                    var lambda00, x00, y00, a00, b00, c00, lambda0, x0, y0, a0, b0, c0, resampleStream = {
                        point,
                        lineStart,
                        lineEnd,
                        polygonStart: function() {
                            stream.polygonStart(), resampleStream.lineStart = ringStart;
                        },
                        polygonEnd: function() {
                            stream.polygonEnd(), resampleStream.lineStart = lineStart;
                        }
                    };
                    function point(x, y) {
                        x = project(x, y), stream.point(x[0], x[1]);
                    }
                    function lineStart() {
                        x0 = NaN, resampleStream.point = linePoint, stream.lineStart();
                    }
                    function linePoint(lambda, phi) {
                        var c = cartesian([ lambda, phi ]), p = project(lambda, phi);
                        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream), 
                        stream.point(x0, y0);
                    }
                    function lineEnd() {
                        resampleStream.point = point, stream.lineEnd();
                    }
                    function ringStart() {
                        lineStart(), resampleStream.point = ringPoint, resampleStream.lineEnd = ringEnd;
                    }
                    function ringPoint(lambda, phi) {
                        linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0, 
                        resampleStream.point = linePoint;
                    }
                    function ringEnd() {
                        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream), 
                        resampleStream.lineEnd = lineEnd, lineEnd();
                    }
                    return resampleStream;
                };
            }(project, delta2) : function(project) {
                return transform_transformer({
                    point: function(x, y) {
                        x = project(x, y), this.stream.point(x[0], x[1]);
                    }
                });
            }(project);
        }
        var transformRadians = transform_transformer({
            point: function(x, y) {
                this.stream.point(x * math_radians, y * math_radians);
            }
        });
        function scaleTranslate(k, dx, dy) {
            function transform(x, y) {
                return [ dx + k * x, dy - k * y ];
            }
            return transform.invert = function(x, y) {
                return [ (x - dx) / k, (dy - y) / k ];
            }, transform;
        }
        function scaleTranslateRotate(k, dx, dy, alpha) {
            var cosAlpha = math_cos(alpha), sinAlpha = math_sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
            function transform(x, y) {
                return [ a * x - b * y + dx, dy - b * x - a * y ];
            }
            return transform.invert = function(x, y) {
                return [ ai * x - bi * y + ci, fi - bi * x - ai * y ];
            }, transform;
        }
        function projection_projection(project) {
            return projectionMutator(function() {
                return project;
            })();
        }
        function projectionMutator(projectAt) {
            var project, rotate, y0, x1, y1, projectResample, projectTransform, projectRotateTransform, cache, cacheStream, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, alpha = 0, theta = null, preclip = antimeridian, x0 = null, postclip = src_identity, delta2 = .5;
            function projection(point) {
                return projectRotateTransform(point[0] * math_radians, point[1] * math_radians);
            }
            function invert(point) {
                return (point = projectRotateTransform.invert(point[0], point[1])) && [ point[0] * math_degrees, point[1] * math_degrees ];
            }
            function recenter() {
                var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)), transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
                return rotate = rotation_rotateRadians(deltaLambda, deltaPhi, deltaGamma), projectTransform = compose(project, transform), 
                projectRotateTransform = compose(rotate, projectTransform), projectResample = resample(projectTransform, delta2), 
                reset();
            }
            function reset() {
                return cache = cacheStream = null, projection;
            }
            return projection.stream = function(stream) {
                return cache && cacheStream === stream ? cache : cache = transformRadians(function(rotate) {
                    return transform_transformer({
                        point: function(x, y) {
                            var r = rotate(x, y);
                            return this.stream.point(r[0], r[1]);
                        }
                    });
                }(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
            }, projection.preclip = function(_) {
                return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
            }, projection.postclip = function(_) {
                return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
            }, projection.clipAngle = function(_) {
                return arguments.length ? (preclip = +_ ? function(radius) {
                    var cr = math_cos(radius), delta = 6 * math_radians, smallRadius = cr > 0, notHemisphere = math_abs(cr) > math_epsilon;
                    function visible(lambda, phi) {
                        return math_cos(lambda) * math_cos(phi) > cr;
                    }
                    function intersect(a, b, two) {
                        var n1 = [ 1, 0, 0 ], n2 = cartesianCross(cartesian(a), cartesian(b)), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
                        if (!determinant) return !two && a;
                        var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1);
                        cartesianAddInPlace(A, cartesianScale(n2, c2));
                        var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
                        if (!(t2 < 0)) {
                            var t = math_sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
                            if (cartesianAddInPlace(q, A), q = spherical(q), !two) return q;
                            var z, lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1];
                            lambda1 < lambda0 && (z = lambda0, lambda0 = lambda1, lambda1 = z);
                            var delta = lambda1 - lambda0, polar = math_abs(delta - pi) < math_epsilon;
                            if (!polar && phi1 < phi0 && (z = phi0, phi0 = phi1, phi1 = z), polar || delta < math_epsilon ? polar ? phi0 + phi1 > 0 ^ q[1] < (math_abs(q[0] - lambda0) < math_epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
                                var q1 = cartesianScale(u, (-w + t) / uu);
                                return cartesianAddInPlace(q1, A), [ q, spherical(q1) ];
                            }
                        }
                    }
                    function code(lambda, phi) {
                        var r = smallRadius ? radius : pi - radius, code = 0;
                        return lambda < -r ? code |= 1 : lambda > r && (code |= 2), phi < -r ? code |= 4 : phi > r && (code |= 8), 
                        code;
                    }
                    return clip(visible, function(stream) {
                        var point0, c0, v0, v00, _clean;
                        return {
                            lineStart: function() {
                                v00 = v0 = !1, _clean = 1;
                            },
                            point: function(lambda, phi) {
                                var point2, point1 = [ lambda, phi ], v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                                if (!point0 && (v00 = v0 = v) && stream.lineStart(), v !== v0 && (!(point2 = intersect(point0, point1)) || pointEqual(point0, point2) || pointEqual(point1, point2)) && (point1[0] += math_epsilon, 
                                point1[1] += math_epsilon, v = visible(point1[0], point1[1])), v !== v0) _clean = 0, 
                                v ? (stream.lineStart(), point2 = intersect(point1, point0), stream.point(point2[0], point2[1])) : (point2 = intersect(point0, point1), 
                                stream.point(point2[0], point2[1]), stream.lineEnd()), point0 = point2; else if (notHemisphere && point0 && smallRadius ^ v) {
                                    var t;
                                    c & c0 || !(t = intersect(point1, point0, !0)) || (_clean = 0, smallRadius ? (stream.lineStart(), 
                                    stream.point(t[0][0], t[0][1]), stream.point(t[1][0], t[1][1]), stream.lineEnd()) : (stream.point(t[1][0], t[1][1]), 
                                    stream.lineEnd(), stream.lineStart(), stream.point(t[0][0], t[0][1])));
                                }
                                !v || point0 && pointEqual(point0, point1) || stream.point(point1[0], point1[1]), 
                                point0 = point1, v0 = v, c0 = c;
                            },
                            lineEnd: function() {
                                v0 && stream.lineEnd(), point0 = null;
                            },
                            clean: function() {
                                return _clean | (v00 && v0) << 1;
                            }
                        };
                    }, function(from, to, direction, stream) {
                        !function(stream, radius, delta, direction, t0, t1) {
                            if (delta) {
                                var cosRadius = math_cos(radius), sinRadius = math_sin(radius), step = direction * delta;
                                null == t0 ? (t0 = radius + direction * tau, t1 = radius - step / 2) : (t0 = circleRadius(cosRadius, t0), 
                                t1 = circleRadius(cosRadius, t1), (direction > 0 ? t0 < t1 : t0 > t1) && (t0 += direction * tau));
                                for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) point = spherical([ cosRadius, -sinRadius * math_cos(t), -sinRadius * math_sin(t) ]), 
                                stream.point(point[0], point[1]);
                            }
                        }(stream, radius, delta, direction, from, to);
                    }, smallRadius ? [ 0, -radius ] : [ -pi, radius - pi ]);
                }(theta = _ * math_radians) : (theta = null, antimeridian), reset()) : theta * math_degrees;
            }, projection.clipExtent = function(_) {
                return arguments.length ? (postclip = null == _ ? (x0 = y0 = x1 = y1 = null, src_identity) : function(x0, y0, x1, y1) {
                    function visible(x, y) {
                        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
                    }
                    function interpolate(from, to, direction, stream) {
                        var a = 0, a1 = 0;
                        if (null == from || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) do {
                            stream.point(0 === a || 3 === a ? x0 : x1, a > 1 ? y1 : y0);
                        } while ((a = (a + direction + 4) % 4) !== a1); else stream.point(to[0], to[1]);
                    }
                    function corner(p, direction) {
                        return math_abs(p[0] - x0) < math_epsilon ? direction > 0 ? 0 : 3 : math_abs(p[0] - x1) < math_epsilon ? direction > 0 ? 2 : 1 : math_abs(p[1] - y0) < math_epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
                    }
                    function compareIntersection(a, b) {
                        return comparePoint(a.x, b.x);
                    }
                    function comparePoint(a, b) {
                        var ca = corner(a, 1), cb = corner(b, 1);
                        return ca !== cb ? ca - cb : 0 === ca ? b[1] - a[1] : 1 === ca ? a[0] - b[0] : 2 === ca ? a[1] - b[1] : b[0] - a[0];
                    }
                    return function(stream) {
                        var segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean, activeStream = stream, bufferStream = buffer(), clipStream = {
                            point,
                            lineStart: function() {
                                clipStream.point = linePoint, polygon && polygon.push(ring = []), first = !0, v_ = !1, 
                                x_ = y_ = NaN;
                            },
                            lineEnd: function() {
                                segments && (linePoint(x__, y__), v__ && v_ && bufferStream.rejoin(), segments.push(bufferStream.result())), 
                                clipStream.point = point, v_ && activeStream.lineEnd();
                            },
                            polygonStart: function() {
                                activeStream = bufferStream, segments = [], polygon = [], clean = !0;
                            },
                            polygonEnd: function() {
                                var startInside = function() {
                                    for (var winding = 0, i = 0, n = polygon.length; i < n; ++i) for (var a0, a1, ring = polygon[i], j = 1, m = ring.length, point = ring[0], b0 = point[0], b1 = point[1]; j < m; ++j) a0 = b0, 
                                    a1 = b1, b0 = (point = ring[j])[0], b1 = point[1], a1 <= y1 ? b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0) && ++winding : b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0) && --winding;
                                    return winding;
                                }(), cleanInside = clean && startInside, visible = (segments = merge(segments)).length;
                                (cleanInside || visible) && (stream.polygonStart(), cleanInside && (stream.lineStart(), 
                                interpolate(null, null, 1, stream), stream.lineEnd()), visible && rejoin(segments, compareIntersection, startInside, interpolate, stream), 
                                stream.polygonEnd()), activeStream = stream, segments = polygon = ring = null;
                            }
                        };
                        function point(x, y) {
                            visible(x, y) && activeStream.point(x, y);
                        }
                        function linePoint(x, y) {
                            var v = visible(x, y);
                            if (polygon && ring.push([ x, y ]), first) x__ = x, y__ = y, v__ = v, first = !1, 
                            v && (activeStream.lineStart(), activeStream.point(x, y)); else if (v && v_) activeStream.point(x, y); else {
                                var a = [ x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_)) ], b = [ x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y)) ];
                                !function(a, b, x0, y0, x1, y1) {
                                    var r, ax = a[0], ay = a[1], t0 = 0, t1 = 1, dx = b[0] - ax, dy = b[1] - ay;
                                    if (r = x0 - ax, dx || !(r > 0)) {
                                        if (r /= dx, dx < 0) {
                                            if (r < t0) return;
                                            r < t1 && (t1 = r);
                                        } else if (dx > 0) {
                                            if (r > t1) return;
                                            r > t0 && (t0 = r);
                                        }
                                        if (r = x1 - ax, dx || !(r < 0)) {
                                            if (r /= dx, dx < 0) {
                                                if (r > t1) return;
                                                r > t0 && (t0 = r);
                                            } else if (dx > 0) {
                                                if (r < t0) return;
                                                r < t1 && (t1 = r);
                                            }
                                            if (r = y0 - ay, dy || !(r > 0)) {
                                                if (r /= dy, dy < 0) {
                                                    if (r < t0) return;
                                                    r < t1 && (t1 = r);
                                                } else if (dy > 0) {
                                                    if (r > t1) return;
                                                    r > t0 && (t0 = r);
                                                }
                                                if (r = y1 - ay, dy || !(r < 0)) {
                                                    if (r /= dy, dy < 0) {
                                                        if (r > t1) return;
                                                        r > t0 && (t0 = r);
                                                    } else if (dy > 0) {
                                                        if (r < t0) return;
                                                        r < t1 && (t1 = r);
                                                    }
                                                    return t0 > 0 && (a[0] = ax + t0 * dx, a[1] = ay + t0 * dy), t1 < 1 && (b[0] = ax + t1 * dx, 
                                                    b[1] = ay + t1 * dy), !0;
                                                }
                                            }
                                        }
                                    }
                                }(a, b, x0, y0, x1, y1) ? v && (activeStream.lineStart(), activeStream.point(x, y), 
                                clean = !1) : (v_ || (activeStream.lineStart(), activeStream.point(a[0], a[1])), 
                                activeStream.point(b[0], b[1]), v || activeStream.lineEnd(), clean = !1);
                            }
                            x_ = x, y_ = y, v_ = v;
                        }
                        return clipStream;
                    };
                }(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : null == x0 ? null : [ [ x0, y0 ], [ x1, y1 ] ];
            }, projection.scale = function(_) {
                return arguments.length ? (k = +_, recenter()) : k;
            }, projection.translate = function(_) {
                return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [ x, y ];
            }, projection.center = function(_) {
                return arguments.length ? (lambda = _[0] % 360 * math_radians, phi = _[1] % 360 * math_radians, 
                recenter()) : [ lambda * math_degrees, phi * math_degrees ];
            }, projection.rotate = function(_) {
                return arguments.length ? (deltaLambda = _[0] % 360 * math_radians, deltaPhi = _[1] % 360 * math_radians, 
                deltaGamma = _.length > 2 ? _[2] % 360 * math_radians : 0, recenter()) : [ deltaLambda * math_degrees, deltaPhi * math_degrees, deltaGamma * math_degrees ];
            }, projection.angle = function(_) {
                return arguments.length ? (alpha = _ % 360 * math_radians, recenter()) : alpha * math_degrees;
            }, projection.precision = function(_) {
                return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), 
                reset()) : math_sqrt(delta2);
            }, projection.fitExtent = function(extent, object) {
                return fitExtent(projection, extent, object);
            }, projection.fitSize = function(size, object) {
                return fitSize(projection, size, object);
            }, projection.fitWidth = function(width, object) {
                return fitWidth(projection, width, object);
            }, projection.fitHeight = function(height, object) {
                return fitHeight(projection, height, object);
            }, function() {
                return project = projectAt.apply(this, arguments), projection.invert = project.invert && invert, 
                recenter();
            };
        }
        function conicEqualAreaRaw(y0, y1) {
            var sy0 = math_sin(y0), n = (sy0 + math_sin(y1)) / 2;
            if (math_abs(n) < math_epsilon) return function(phi0) {
                var cosPhi0 = math_cos(phi0);
                function forward(lambda, phi) {
                    return [ lambda * cosPhi0, math_sin(phi) / cosPhi0 ];
                }
                return forward.invert = function(x, y) {
                    return [ x / cosPhi0, math_asin(y * cosPhi0) ];
                }, forward;
            }(y0);
            var c = 1 + sy0 * (2 * n - sy0), r0 = math_sqrt(c) / n;
            function project(x, y) {
                var r = math_sqrt(c - 2 * n * math_sin(y)) / n;
                return [ r * math_sin(x *= n), r0 - r * math_cos(x) ];
            }
            return project.invert = function(x, y) {
                var r0y = r0 - y;
                return [ math_atan2(x, math_abs(r0y)) / n * math_sign(r0y), math_asin((c - (x * x + r0y * r0y) * n * n) / (2 * n)) ];
            }, project;
        }
        function conicEqualArea() {
            return (projectAt = conicEqualAreaRaw, phi0 = 0, phi1 = pi / 3, m = projectionMutator(projectAt), 
            p = m(phi0, phi1), p.parallels = function(_) {
                return arguments.length ? m(phi0 = _[0] * math_radians, phi1 = _[1] * math_radians) : [ phi0 * math_degrees, phi1 * math_degrees ];
            }, p).scale(155.424).center([ 0, 33.6442 ]);
            var projectAt, phi0, phi1, m, p;
        }
        function azimuthalRaw(scale) {
            return function(x, y) {
                var cx = math_cos(x), cy = math_cos(y), k = scale(cx * cy);
                return [ k * cy * math_sin(x), k * math_sin(y) ];
            };
        }
        function azimuthalInvert(angle) {
            return function(x, y) {
                var z = math_sqrt(x * x + y * y), c = angle(z), sc = math_sin(c), cc = math_cos(c);
                return [ math_atan2(x * sc, z * cc), math_asin(z && y * sc / z) ];
            };
        }
        function mercator_mercatorRaw(lambda, phi) {
            return [ lambda, math_log(math_tan((math_halfPi + phi) / 2)) ];
        }
        function equirectangular_equirectangularRaw(lambda, phi) {
            return [ lambda, phi ];
        }
        function orthographicRaw(x, y) {
            return [ math_cos(y) * math_sin(x), math_sin(y) ];
        }
        function orthographic() {
            return projection_projection(orthographicRaw).scale(249.5).clipAngle(90 + math_epsilon);
        }
        azimuthalRaw(function(cxcy) {
            return math_sqrt(2 / (1 + cxcy));
        }).invert = azimuthalInvert(function(z) {
            return 2 * math_asin(z / 2);
        }), azimuthalRaw(function(c) {
            return (c = acos(c)) && c / math_sin(c);
        }).invert = azimuthalInvert(function(z) {
            return z;
        }), mercator_mercatorRaw.invert = function(x, y) {
            return [ x, 2 * math_atan(exp(y)) - math_halfPi ];
        }, equirectangular_equirectangularRaw.invert = equirectangular_equirectangularRaw, 
        math_sqrt(3), azimuthalInvert(math_atan), orthographicRaw.invert = azimuthalInvert(math_asin), 
        azimuthalInvert(function(z) {
            return 2 * math_atan(z);
        });
        var _a, topojson = __webpack_require__(43174), ShapeMapBehavior = shapeMapBehaviors.ShapeMapBehavior, standardGeoJsonFile = ((_a = {})[standardGeoJson.fC] = {
            projections: [ shapeMapType.Lu, shapeMapType.hD, shapeMapType.s6 ]
        }, _a[standardGeoJson.M4] = {
            projections: [ shapeMapType.Lu, shapeMapType.hD, shapeMapType.s6 ]
        }, _a[standardGeoJson.p8] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.S9] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.G] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.r5] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.Bo] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.S$] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.sp] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.Ss] = {
            projections: [ shapeMapType.Lu, shapeMapType.hD, shapeMapType.s6 ]
        }, _a[standardGeoJson.Xl] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.ei] = {
            projections: [ shapeMapType.Lu, shapeMapType.hD, shapeMapType.s6 ]
        }, _a[standardGeoJson.Wl] = {
            projections: [ shapeMapType.s6, shapeMapType.hD, shapeMapType.Lu ]
        }, _a[standardGeoJson.X9] = {
            projections: [ shapeMapType.rU, shapeMapType.hD, shapeMapType.Lu, shapeMapType.s6 ]
        }, _a), defaultProjections = [ shapeMapType.Lu, shapeMapType.hD, shapeMapType.s6 ], ShapeMap = function() {
            function ShapeMap(options) {
                this.resetToDefault = !1, options && (this.behavior = options.behavior, this.behavior && (this.behavior.shapeMap = this), 
                this.tooltipsEnabled = options.tooltipsEnabled);
            }
            return ShapeMap.prototype.init = function(options) {
                this.root = options.element, this.hostServices = options.host, this.tooltipService = (0, 
                tooltipService.r)(options.host), this.viewport = options.viewport, this.featureSwitches = options.featureSwitches, 
                this.svg = d3.select(this.root.get(0)).append("svg").attr("focus-nav-mode", "Hierarchy").attr("tabindex", "0").attr("aria-label", this.hostServices.getLocalizedString("Visual_Plot")).attr("class", "shapeMap").attr("width", this.viewport.width).attr("height", this.viewport.height).attr("drag-resize-disabled", "true").style("position", "absolute"), 
                this.behavior && (this.clearCatcher = (0, interactivityService.EX)(this.svg), this.interactivityService = (0, 
                interactivityService.ub)(this.hostServices, this.featureSwitches)), this.mapG = this.svg.append("g"), 
                this.style = options.style, this.legend = (0, legend.OG)(this.root, options.interactivity && options.interactivity.mobileTileInteractive, this.interactivityService, !0, void 0, this.style, this.hostServices);
            }, ShapeMap.prototype.update = function(options) {
                if (this.viewport = options.viewport, !_.isEmpty(options.dataViews) && options.dataViews[0]) {
                    var dataView = this.dataView = options.dataViews[0];
                    this.viewModel = ShapeMap.converter(dataView, this.style, this.interactivityService, this.tooltipsEnabled), 
                    this.render(options.suppressAnimations);
                }
            }, ShapeMap.prototype.enumerateObjectInstances = function(options) {
                if (this.viewModel) {
                    var enumeration = new objectEnumerationBuilder.G;
                    switch (options.objectName) {
                      case "shape":
                        enumeration.pushInstance(this.viewModel.shapeMap ? {
                            objectName: "shape",
                            selector: null,
                            properties: {
                                map: _.clone(this.viewModel.shapeMap),
                                projectionEnum: this.viewModel.projectionEnum
                            },
                            validValues: {
                                projectionEnum: ShapeMap.validProjectionsForShapeMap(this.viewModel.shapeMap)
                            }
                        } : {
                            objectName: "shape",
                            selector: null,
                            properties: {
                                map: {}
                            },
                            validValues: {
                                projectionEnum: defaultProjections
                            }
                        });
                        break;

                      case "defaultColors":
                        enumeration.pushInstance({
                            objectName: "defaultColors",
                            selector: null,
                            properties: {
                                defaultShow: this.viewModel.defaultShow,
                                defaultColor: this.viewModel.defaultShow ? this.viewModel.defaultColor : null,
                                borderColor: this.viewModel.borderColor,
                                borderThickness: this.viewModel.borderThickness
                            }
                        });
                    }
                    return enumeration.complete();
                }
            }, ShapeMap.prototype.getFormattingModel = function() {
                return new build_control_util.Nq(this.getMapSettingsCard(), this.getLegendCard(), this.getFillColorsCard()).build();
            }, ShapeMap.prototype.getMapSettingsCard = function() {
                var _this = this, shapeProps = shapeMap_capabilities.L.shape, zoomProps = shapeMap_capabilities.L.zoom, cardBuilder = new build_control_util.CQ(new build_control_util.lg("mapSettings"), "Visual_AzureMapsMapSettings", [ shapeProps.map, shapeProps.projectionEnum, zoomProps.autoZoom, zoomProps.selectionZoom, zoomProps.manualZoom ], function(key) {
                    return _this.hostServices.getLocalizedString(key);
                }), viewModel = this.viewModel, shapeMap = viewModel.shapeMap;
                return cardBuilder.addGroup("options", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_AzureMapsMapSettings").addSimpleSlice("shapeMapSelector", new build_control_util.vX({
                        descriptor: shapeProps.map,
                        value: shapeMap ? _.clone(shapeMap) : void 0
                    }).build()).addSimpleSlice("projection", new build_control_util.uY({
                        descriptor: shapeProps.projectionEnum,
                        value: shapeMap && viewModel.projectionEnum,
                        filterValues: shapeMap ? ShapeMap.validProjectionsForShapeMap(shapeMap) : defaultProjections
                    }).build());
                }).addGroup("zoom", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_ShapeMap_Zoom").addSimpleSlice("autoZoom", new build_control_util.bd({
                        descriptor: zoomProps.autoZoom,
                        value: viewModel.autoZoom
                    }).build()).addSimpleSlice("selectionZoom", new build_control_util.bd({
                        descriptor: zoomProps.selectionZoom,
                        value: viewModel.selectionZoom
                    }).build()).addSimpleSlice("manualZoom", new build_control_util.bd({
                        descriptor: zoomProps.manualZoom,
                        value: viewModel.manualZoom
                    }).build());
                }), cardBuilder.build();
            }, ShapeMap.prototype.getLegendCard = function() {
                var viewModel = this.viewModel;
                return (0, legend_formatting.ZF)({
                    legendData: viewModel.legendData
                }, this.hostServices, this.featureSwitches, !viewModel.hasDynamicSeries);
            }, ShapeMap.prototype.getFillColorsCard = function() {
                var _this = this, viewModel = this.viewModel, dataView = this.dataView, dataPointProps = shapeMap_capabilities.L.dataPoint, defaultColorProps = shapeMap_capabilities.L.defaultColors, localize = function(key) {
                    return _this.hostServices.getLocalizedString(key);
                }, gradientDiverging = {
                    objectName: "gradient",
                    propertyName: "diverging"
                }, gradientBar = {
                    objectName: "gradient",
                    propertyName: "gradientBar"
                }, gradientMinColor = {
                    objectName: "gradient",
                    propertyName: "minColor"
                }, gradientMidColor = {
                    objectName: "gradient",
                    propertyName: "midColor"
                }, gradientMaxColor = {
                    objectName: "gradient",
                    propertyName: "maxColor"
                }, gradientMinValue = {
                    objectName: "gradient",
                    propertyName: "minValue"
                }, gradientMidValue = {
                    objectName: "gradient",
                    propertyName: "midValue"
                }, gradientMaxValue = {
                    objectName: "gradient",
                    propertyName: "maxValue"
                }, cardBuilder = new build_control_util.CQ(new build_control_util.lg("fillColors"), "Visual_FillColors", [ dataPointProps.fill, dataPointProps.fillRule, dataPointProps.showAllDataPoints, defaultColorProps.defaultShow, defaultColorProps.defaultColor, defaultColorProps.borderColor, defaultColorProps.borderThickness, gradientDiverging, gradientBar, gradientMinColor, gradientMidColor, gradientMaxColor, gradientMinValue, gradientMidValue, gradientMaxValue ], function(key) {
                    return _this.hostServices.getLocalizedString(key);
                });
                if (ShapeMap.shouldEnumerateDataPoints(dataView)) cardBuilder.addGroup("colors", function(groupBuilder) {
                    if (groupBuilder.withDisplayName("Visual_Colors"), viewModel.hasDynamicSeries) {
                        var formatOptions = {
                            groupBuilder,
                            dataPoints: (0, legend_formatting.l3)(viewModel.legendData),
                            seriesColorProps: dataPointProps,
                            localize,
                            featureSwitches: _this.featureSwitches
                        };
                        (0, colorEnumerationHelper2.y0)(formatOptions);
                    } else {
                        var options = {
                            groupBuilder,
                            colorProps: dataPointProps,
                            featureSwitches: _this.featureSwitches,
                            hostService: _this.hostServices,
                            options: {
                                dataView,
                                style: _this.style,
                                categories: _.map(viewModel.dataPoints, function(category) {
                                    return {
                                        displayName: category.location,
                                        color: category.color,
                                        identity: category.identity
                                    };
                                }),
                                fillInstanceKind: 3
                            }
                        };
                        (0, colorEnumerationHelper2.jN)(options);
                    }
                }); else {
                    var fillRule = (0, dataViewObject2.NA)(this.dataView && this.dataView.metadata && this.dataView.metadata.objects, {
                        objectName: "dataPoint",
                        propertyName: "fillRule"
                    }, null), gradientSettings_1 = (0, gradientUtils.Wt)(fillRule), defaultGradientColors_1 = this.style.colorPalette.dataColors.getGradientColors();
                    cardBuilder.addGroup("colors", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Colors").addSimpleSlice("diverging", new build_control_util.bd({
                            descriptor: gradientDiverging,
                            value: gradientSettings_1.diverging
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("ConditionalFormattingDialogModern_Mode_ColorScale").withCustomDescription("Visual_Gradient_DivergingDescription");
                        }).addSimpleSlice("gradientBar", new build_control_util._m({
                            descriptor: gradientBar,
                            value: (0, gradientUtils.Kj)(gradientSettings_1, defaultGradientColors_1)
                        }).build()).addSimpleSlice("minColor", new build_control_util.BT({
                            descriptor: gradientMinColor,
                            value: {
                                value: gradientSettings_1.minColor || defaultGradientColors_1.minColor.value
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Aggregate_Min").withCustomDescription("Visual_Gradient_MinColorDescription");
                        }), gradientSettings_1.diverging && groupBuilder.addSimpleSlice("midColor", new build_control_util.BT({
                            descriptor: gradientMidColor,
                            value: {
                                value: gradientSettings_1.midColor || defaultGradientColors_1.midColor.value
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("ConditionalFormattingDialog_CenterHeader").withCustomDescription("Visual_Gradient_MidColorDescription");
                        }), groupBuilder.addSimpleSlice("maxColor", new build_control_util.BT({
                            descriptor: gradientMaxColor,
                            value: {
                                value: gradientSettings_1.maxColor || defaultGradientColors_1.maxColor.value
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Aggregate_Max").withCustomDescription("Visual_Gradient_MaxColorDescription");
                        }).addSimpleSlice("minValue", new build_control_util.mu({
                            descriptor: gradientMinValue,
                            value: gradientSettings_1.minValue
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Aggregate_Min").withCustomDescription("Visual_Gradient_MinValueDescription");
                        }), gradientSettings_1.diverging && groupBuilder.addSimpleSlice("midValue", new build_control_util.mu({
                            descriptor: gradientMidValue,
                            value: gradientSettings_1.midValue
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("ConditionalFormattingDialog_CenterHeader").withCustomDescription("Visual_Gradient_MidValueDescription");
                        }), groupBuilder.addSimpleSlice("maxValue", new build_control_util.mu({
                            descriptor: gradientMaxValue,
                            value: gradientSettings_1.maxValue
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Aggregate_Max").withCustomDescription("Visual_Gradient_MaxValueDescription");
                        });
                    });
                }
                return cardBuilder.addGroup("blankAreas", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_ShapeMap_BlankAreas").addSimpleSlice("showBlankAreas", new build_control_util.bd({
                        descriptor: defaultColorProps.defaultShow,
                        value: viewModel.defaultShow
                    }).build(), function(builder) {
                        return builder.withCustomDisplayName("Visual_ShapeMap_BlankAreasShow");
                    }).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: defaultColorProps.defaultColor,
                        value: {
                            value: viewModel.defaultColor
                        }
                    }).build(), function(slice) {
                        return slice.withDisabled(!viewModel.defaultShow);
                    });
                }).addGroup("border", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_Border").addSimpleSlice("color", new build_control_util.BT({
                        descriptor: defaultColorProps.borderColor,
                        value: {
                            value: viewModel.borderColor
                        }
                    }).build(), function(builder) {
                        return builder.withCustomDisplayName("Generic_Color");
                    }).addSimpleSlice("thickness", new build_control_util.mu({
                        descriptor: defaultColorProps.borderThickness,
                        value: viewModel.borderThickness,
                        options: {
                            minValue: {
                                type: 0,
                                value: 0
                            },
                            maxValue: {
                                type: 1,
                                value: 10
                            }
                        }
                    }).build(), function(builder) {
                        return builder.withCustomDisplayName("Visual_General_Properties_Width");
                    });
                }), cardBuilder.build();
            }, ShapeMap.getStandardGeoJsonFiles = function() {
                return _.clone(standardGeoJsonFile);
            }, ShapeMap.validProjectionsForShapeMap = function(shapeMap) {
                if (!shapeMap || !shapeMap.name) return defaultProjections;
                var standardFile = standardGeoJsonFile[shapeMap.name];
                return !standardFile || _.isEmpty(standardFile.projections) ? defaultProjections : standardFile.projections;
            }, ShapeMap.shouldEnumerateDataPoints = function(dataView) {
                return !!(0, dataRoleHelper.c5)(dataView, shapeMapType.ac) || !(0, dataRoleHelper.c5)(dataView, shapeMapType.S3);
            }, ShapeMap.prototype.getDataPointFromShape = function(shape) {
                return this.matcher.getDataPointFromShape(shape);
            }, ShapeMap.getObjectProperties = function(dataView, style) {
                var objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : {}, shapeMapProps = shapeMap_capabilities.L, map = (0, 
                dataViewObject2.NA)(objects, shapeMapProps.shape.map, null), validProjections = ShapeMap.validProjectionsForShapeMap(map), projectionEnumDefault = validProjections[0], projectionEnum = (0, 
                dataViewObject2.NA)(objects, shapeMapProps.shape.projectionEnum, projectionEnumDefault);
                _.includes(validProjections, projectionEnum) || (projectionEnum = projectionEnumDefault);
                var colorHelper = common_colorHelper.v.create(style);
                return {
                    map,
                    projectionEnum,
                    autoZoom: (0, dataViewObject2.NA)(objects, shapeMapProps.zoom.autoZoom, !1),
                    selectionZoom: (0, dataViewObject2.NA)(objects, shapeMapProps.zoom.selectionZoom, !1),
                    manualZoom: (0, dataViewObject2.NA)(objects, shapeMapProps.zoom.manualZoom, !1),
                    defaultShow: (0, dataViewObject2.NA)(objects, shapeMapProps.defaultColors.defaultShow, !0),
                    defaultColor: colorHelper.getColorForProperty(objects, shapeMapProps.defaultColors.defaultColor, "backgroundNeutral"),
                    borderColor: colorHelper.getColorForProperty(objects, shapeMapProps.defaultColors.borderColor, "foregroundNeutralSecondaryAlt2"),
                    borderThickness: (0, dataViewObject2.NA)(objects, shapeMapProps.defaultColors.borderThickness, 1)
                };
            }, ShapeMap.converter = function(dataView, style, interactivityService, tooltipsEnabled) {
                var _a, _b, _c;
                void 0 === tooltipsEnabled && (tooltipsEnabled = !0);
                var reader, dataReader, columnReader, categoryDisplayName, dataPoints = [], seriesCount = 0, formatStringProp = shapeMap_capabilities.L.general.formatString;
                dataView && (columnReader = (reader = (0, dataViewCategoricalReader.G)(dataView, {
                    colorOptions: {
                        valueRole: shapeMapType.S3,
                        visualStyle: style
                    },
                    formatStringProp
                })).columns, categoryDisplayName = (dataReader = reader.data).getCategoryDisplayName(shapeMapType.W3));
                var hasDynamicSeries = !1, hasValues = !1, hasCategoryGroup = !1;
                reader && (hasDynamicSeries = columnReader.hasDynamicSeries(), hasValues = dataReader.hasValues(shapeMapType.S3), 
                hasCategoryGroup = dataReader.hasCategoryWithRole(shapeMapType.W3), dataReader.getValueQueryName(shapeMapType.S3));
                var dataAvailable = dataView && reader && dataReader.hasCategories();
                if (dataAvailable) {
                    seriesCount = dataReader.getSeriesCount();
                    for (var categoryIndex = 0; categoryIndex < dataReader.getCategoryCount(); categoryIndex++) {
                        var value = dataReader.getValue(shapeMapType.S3, categoryIndex), formatString = dataReader.getFormatString(shapeMapType.S3, categoryIndex), categoryValue = void 0, categoryTooltipItem = void 0, seriesTooltipItem = void 0, valueTooltipItem = void 0;
                        hasCategoryGroup && (categoryValue = dataReader.getCategoryValue(shapeMapType.W3, categoryIndex), 
                        categoryTooltipItem = {
                            displayName: dataReader.getCategoryDisplayName(shapeMapType.W3),
                            value: (0, converterHelper.xq)(categoryValue, columnReader.getCategoryMetadataColumn(shapeMapType.W3), formatStringProp)
                        }), seriesCount = dataReader.getSeriesCount(), dataReader.hasValues(shapeMapType.S3) || (seriesCount = 1);
                        for (var category = columnReader.getCategoryColumn(shapeMapType.W3), categoryIdentity = (new selectionId.dw).withCategory([ category ], categoryIndex, null === (_a = null == category ? void 0 : category.source) || void 0 === _a ? void 0 : _a.queryName, !0).withMeasure(dataReader.getValueQueryName(shapeMapType.S3)).createSelectionId(), seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                            var color, grouped = null === (_b = dataView.categorical.values) || void 0 === _b ? void 0 : _b.grouped(), valueColumn = grouped && grouped[seriesIndex];
                            color = reader.colors.createBySeries(seriesIndex, categoryIndex);
                            var categoryGroup = columnReader.getCategoryColumn(hasCategoryGroup ? shapeMapType.W3 : shapeMapType.S3), identityBuilder = (new selectionId.dw).withCategory([ categoryGroup ], categoryIndex, null === (_c = null == categoryGroup ? void 0 : categoryGroup.source) || void 0 === _c ? void 0 : _c.queryName, !0).withMeasure(dataReader.getValueQueryName(shapeMapType.S3), columnReader.getValueColumn(shapeMapType.S3, seriesIndex), categoryIndex);
                            hasDynamicSeries && (identityBuilder = identityBuilder.withSeries(columnReader.getSeriesValueColumns(), valueColumn, !0), 
                            seriesTooltipItem = {
                                displayName: dataReader.getSeriesDisplayName(),
                                value: (0, converterHelper.xq)(dataReader.getSeriesName(seriesIndex), columnReader.getSeriesMetadataColumn(), formatStringProp)
                            }), hasValues && (value = dataReader.getValue(shapeMapType.S3, categoryIndex, seriesIndex), 
                            formatString = dataReader.getFormatString(shapeMapType.S3, categoryIndex, seriesIndex), 
                            valueTooltipItem = {
                                displayName: dataReader.getValueDisplayName(shapeMapType.S3),
                                value: (0, converterHelper.xq)(value, columnReader.getValueMetadataColumn(shapeMapType.S3, seriesIndex), formatStringProp, !1, formatString)
                            });
                            var tooltipInfo = [];
                            tooltipsEnabled && (categoryTooltipItem && tooltipInfo.push(categoryTooltipItem), 
                            seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), valueTooltipItem && tooltipInfo.push(valueTooltipItem), 
                            (0, tooltip.VT)(reader, tooltipInfo, categoryIndex, seriesIndex, formatStringProp)), 
                            null == value && hasValues || dataPoints.push({
                                location: categoryValue,
                                identity: identityBuilder.createSelectionId(),
                                value,
                                selected: !1,
                                tooltipInfo,
                                color,
                                categoryIdentity
                            });
                        }
                    }
                }
                interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                var objectProperties = ShapeMap.getObjectProperties(dataView, style);
                return {
                    shapeMap: objectProperties.map,
                    projectionEnum: objectProperties.projectionEnum,
                    autoZoom: objectProperties.autoZoom,
                    selectionZoom: objectProperties.selectionZoom,
                    manualZoom: objectProperties.manualZoom,
                    defaultShow: objectProperties.defaultShow,
                    defaultColor: objectProperties.defaultColor,
                    borderColor: objectProperties.borderColor,
                    borderThickness: objectProperties.borderThickness,
                    dataPoints,
                    categoryName: categoryDisplayName,
                    dataAvailable,
                    hasDynamicSeries,
                    seriesCount,
                    legendData: (0, legend_converter.pq)({
                        dataView,
                        showByDefault: !0,
                        style
                    })
                };
            }, ShapeMap.createProjection = function(projectionEnum) {
                var projection;
                switch (projectionEnum) {
                  case shapeMapType.rU:
                    projection = function() {
                        var cache, cacheStream, lower48Point, alaskaPoint, hawaiiPoint, _point, lower48 = conicEqualArea().parallels([ 29.5, 45.5 ]).scale(1070).translate([ 480, 250 ]).rotate([ 96, 0 ]).center([ -.6, 38.7 ]), alaska = conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]), hawaii = conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]), pointStream = {
                            point: function(x, y) {
                                _point = [ x, y ];
                            }
                        };
                        function albersUsa(coordinates) {
                            var x = coordinates[0], y = coordinates[1];
                            return _point = null, lower48Point.point(x, y), _point || (alaskaPoint.point(x, y), 
                            _point) || (hawaiiPoint.point(x, y), _point);
                        }
                        function reset() {
                            return cache = cacheStream = null, albersUsa;
                        }
                        return albersUsa.invert = function(coordinates) {
                            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
                        }, albersUsa.stream = function(stream) {
                            return cache && cacheStream === stream ? cache : cache = function(streams) {
                                var n = streams.length;
                                return {
                                    point: function(x, y) {
                                        for (var i = -1; ++i < n; ) streams[i].point(x, y);
                                    },
                                    sphere: function() {
                                        for (var i = -1; ++i < n; ) streams[i].sphere();
                                    },
                                    lineStart: function() {
                                        for (var i = -1; ++i < n; ) streams[i].lineStart();
                                    },
                                    lineEnd: function() {
                                        for (var i = -1; ++i < n; ) streams[i].lineEnd();
                                    },
                                    polygonStart: function() {
                                        for (var i = -1; ++i < n; ) streams[i].polygonStart();
                                    },
                                    polygonEnd: function() {
                                        for (var i = -1; ++i < n; ) streams[i].polygonEnd();
                                    }
                                };
                            }([ lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream) ]);
                        }, albersUsa.precision = function(_) {
                            return arguments.length ? (lower48.precision(_), alaska.precision(_), hawaii.precision(_), 
                            reset()) : lower48.precision();
                        }, albersUsa.scale = function(_) {
                            return arguments.length ? (lower48.scale(_), alaska.scale(.35 * _), hawaii.scale(_), 
                            albersUsa.translate(lower48.translate())) : lower48.scale();
                        }, albersUsa.translate = function(_) {
                            if (!arguments.length) return lower48.translate();
                            var k = lower48.scale(), x = +_[0], y = +_[1];
                            return lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream), 
                            alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + math_epsilon, y + .12 * k + math_epsilon ], [ x - .214 * k - math_epsilon, y + .234 * k - math_epsilon ] ]).stream(pointStream), 
                            hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + math_epsilon, y + .166 * k + math_epsilon ], [ x - .115 * k - math_epsilon, y + .234 * k - math_epsilon ] ]).stream(pointStream), 
                            reset();
                        }, albersUsa.fitExtent = function(extent, object) {
                            return fitExtent(albersUsa, extent, object);
                        }, albersUsa.fitSize = function(size, object) {
                            return fitSize(albersUsa, size, object);
                        }, albersUsa.fitWidth = function(width, object) {
                            return fitWidth(albersUsa, width, object);
                        }, albersUsa.fitHeight = function(height, object) {
                            return fitHeight(albersUsa, height, object);
                        }, albersUsa.scale(1070);
                    }();
                    break;

                  case shapeMapType.hD:
                    projection = projection_projection(equirectangular_equirectangularRaw).scale(152.63);
                    break;

                  case shapeMapType.Lu:
                    projection = function(project) {
                        var y0, x1, y1, m = projection_projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null;
                        function reclip() {
                            var k = pi * scale(), t = m(function(rotate) {
                                function forward(coordinates) {
                                    return (coordinates = rotate(coordinates[0] * math_radians, coordinates[1] * math_radians))[0] *= math_degrees, 
                                    coordinates[1] *= math_degrees, coordinates;
                                }
                                return rotate = rotation_rotateRadians(rotate[0] * math_radians, rotate[1] * math_radians, rotate.length > 2 ? rotate[2] * math_radians : 0), 
                                forward.invert = function(coordinates) {
                                    return (coordinates = rotate.invert(coordinates[0] * math_radians, coordinates[1] * math_radians))[0] *= math_degrees, 
                                    coordinates[1] *= math_degrees, coordinates;
                                }, forward;
                            }(m.rotate()).invert([ 0, 0 ]));
                            return clipExtent(null == x0 ? [ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ] : project === mercator_mercatorRaw ? [ [ Math.max(t[0] - k, x0), y0 ], [ Math.min(t[0] + k, x1), y1 ] ] : [ [ x0, Math.max(t[1] - k, y0) ], [ x1, Math.min(t[1] + k, y1) ] ]);
                        }
                        return m.scale = function(_) {
                            return arguments.length ? (scale(_), reclip()) : scale();
                        }, m.translate = function(_) {
                            return arguments.length ? (translate(_), reclip()) : translate();
                        }, m.center = function(_) {
                            return arguments.length ? (center(_), reclip()) : center();
                        }, m.clipExtent = function(_) {
                            return arguments.length ? (null == _ ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], 
                            y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : null == x0 ? null : [ [ x0, y0 ], [ x1, y1 ] ];
                        }, reclip();
                    }(mercator_mercatorRaw).scale(961 / tau);
                    break;

                  case shapeMapType.s6:
                    projection = orthographic();
                    break;

                  default:
                    debug.fF.assertFail("undefined projection"), projection = orthographic();
                }
                return projectionEnum === shapeMapType.s6 && projection.clipAngle(90), projection;
            }, ShapeMap.adjustProjection = function(projection, rotationAxes, width, height, zoomFeatureCollection, hostServices, marginScale) {
                if (void 0 === marginScale && (marginScale = 1), projection.scale(1), projection.translate([ 0, 0 ]), 
                rotationAxes > 0) {
                    var centroid = function(object) {
                        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0, src_stream(object, centroidStream);
                        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
                        return m < 1e-12 && (x = X1, y = Y1, z = Z1, W1 < math_epsilon && (x = X0, y = Y0, 
                        z = Z0), (m = x * x + y * y + z * z) < 1e-12) ? [ NaN, NaN ] : [ math_atan2(y, x) * math_degrees, math_asin(z / math_sqrt(m)) * math_degrees ];
                    }(zoomFeatureCollection);
                    projection.rotate(centroid.map(function(el, index) {
                        return index < rotationAxes ? -el : 0;
                    }));
                }
                var mapBounds;
                try {
                    mapBounds = path().projection(projection).bounds(zoomFeatureCollection);
                } catch (e) {
                    if (e instanceof TypeError) return void hostServices.setWarnings([ new visualWarnings.pi ]);
                    throw e;
                }
                var rawLeft = mapBounds[0][0], rawRight = mapBounds[1][0], rawTop = mapBounds[0][1], rawBottom = mapBounds[1][1], rawWidth = Math.abs(rawRight - rawLeft), rawHeight = Math.abs(rawBottom - rawTop), scale = Math.min(width / rawWidth, height / rawHeight);
                projection.scale(scale *= marginScale), projection.translate([ (width - scale * (rawRight + rawLeft)) / 2, (height - scale * (rawBottom + rawTop)) / 2 ]);
            }, ShapeMap.prototype.createGetColorFunction = function() {
                var _this = this;
                return function(shape) {
                    var dataPoint = _this.matcher.getDataPointFromShape(shape);
                    return dataPoint && null != dataPoint.color ? dataPoint.color : _this.viewModel.defaultColor;
                };
            }, ShapeMap.rotationAxes = function(projectionEnum) {
                switch (projectionEnum) {
                  case shapeMapType.rU:
                    return 0;

                  case shapeMapType.Lu:
                  case shapeMapType.hD:
                    return 1;

                  case shapeMapType.s6:
                    return 2;

                  default:
                    return 0;
                }
            }, ShapeMap.prototype.zoomOnClick = function(shape) {
                this.viewModel && this.viewModel.selectionZoom && (this.selectionZoomShape = !shape && this.selectionZoomShape || shape && shape.id && this.selectionZoomShape && this.selectionZoomShape.id && this.selectionZoomShape.id === shape.id ? null : shape, 
                this.render(!1, !0));
            }, ShapeMap.prototype.resetToDefaultMap = function() {
                var shapeMap = {
                    type: geoJson.c1,
                    name: standardGeoJson.X9,
                    content: void 0
                };
                this.hostServices.persistProperties([ {
                    objectName: "shape",
                    selector: null,
                    properties: {
                        map: shapeMap,
                        projectionEnum: shapeMapType.rU
                    },
                    validValues: {
                        projectionEnum: ShapeMap.validProjectionsForShapeMap(shapeMap)
                    }
                } ]);
            }, ShapeMap.loadFeatureCollection = function(topology) {
                if (_.isEmpty(topology.objects)) return {
                    features: [],
                    type: "FeatureCollection"
                };
                for (var propertyName in topology.objects) return topojson.feature(topology, topology.objects[propertyName]);
            }, ShapeMap.prototype.featuresToZoomTo = function(allFeatures, zoomingToSelection) {
                var _this = this;
                if (zoomingToSelection && this.selectionZoomShape) return {
                    type: "FeatureCollection",
                    features: [ this.selectionZoomShape ]
                };
                if (this.viewModel.autoZoom) {
                    var featuresWithData = {
                        type: "FeatureCollection",
                        features: allFeatures.features.filter(function(d) {
                            return !!_this.getDataPointFromShape(d);
                        })
                    };
                    if (featuresWithData.features.length > 0) return featuresWithData;
                }
                return allFeatures;
            }, ShapeMap.prototype.render = function(suppressAnimations, zoomingToSelection) {
                var _this = this;
                if (this.viewModel.shapeMap && this.viewModel.shapeMap.content) {
                    this.resetToDefault = !1, this.mapG.interrupt(), this.shapes && this.shapes.interrupt(), 
                    this.shapesExit && this.shapesExit.interrupt(), this.manualZoomDisconnect(), this.viewModel.projectionEnum !== this.projectionEnum && (this.projection = null), 
                    this.projectionEnum = this.viewModel.projectionEnum, this.renderLegend(), (0, legend_util.xz)(this.svg, this.legend);
                    var mapViewport = this.getMapViewport();
                    this.svg.attr("width", mapViewport.width).attr("height", mapViewport.height);
                    var geojson = JSON.parse(this.viewModel.shapeMap.content), featureCollection = ShapeMap.loadFeatureCollection(geojson);
                    this.matcher = new Matcher(featureCollection.features, this.viewModel.dataPoints, this.viewModel.categoryName);
                    var projection, zoomToFeatureCollection = this.featuresToZoomTo(featureCollection, zoomingToSelection), keepTheOldProjection = this.projection && !this.viewModel.autoZoom && !this.viewModel.selectionZoom && this.prevAutoZoom === this.viewModel.autoZoom && this.prevManualZoom === this.viewModel.manualZoom && this.prevSelectionZoom === this.viewModel.selectionZoom && this.prevShapeMapName === this.viewModel.shapeMap.name && this.prevMapViewportWidth === mapViewport.width && this.prevMapViewportHeight === mapViewport.height;
                    if (this.prevAutoZoom = this.viewModel.autoZoom, this.prevManualZoom = this.viewModel.manualZoom, 
                    this.prevSelectionZoom = this.viewModel.selectionZoom, this.prevShapeMapName = this.viewModel.shapeMap.name, 
                    this.prevMapViewportWidth = mapViewport.width, this.prevMapViewportHeight = mapViewport.height, 
                    keepTheOldProjection) projection = this.projection; else {
                        projection = ShapeMap.createProjection(this.viewModel.projectionEnum);
                        var rotationAxes = ShapeMap.rotationAxes(this.viewModel.projectionEnum);
                        ShapeMap.adjustProjection(projection, rotationAxes, mapViewport.width, mapViewport.height, zoomToFeatureCollection, this.hostServices, .9);
                    }
                    var calculateFillColor = this.createGetColorFunction();
                    this.mapG.style("stroke-width", this.viewModel.borderThickness / 2).style("stroke", this.viewModel.borderColor).style("fill", this.viewModel.defaultColor);
                    var shapes = this.mapG.selectAll("path").data(this.visibleFeatures(featureCollection), this.shapeKeyFunction(featureCollection));
                    this.shapesExit = void 0;
                    var hasSelection = !1;
                    if (this.interactivityService && (hasSelection = this.interactivityService.hasSelection()), 
                    !this.projection || suppressAnimations) this.projection = projection, this.path = path().projection(this.projection), 
                    this.shapes = shapes.enter().append("path").merge(shapes), this.shapes.attr("d", this.path).style("fill", calculateFillColor).style("opacity", function(d) {
                        var datapoint = _this.getDataPointFromShape(d);
                        return (0, renderUtil.eR)(datapoint && datapoint.selected, !1, hasSelection, !1);
                    }), this.setAccessibilityAttributes(this.shapes, hasSelection), shapes.exit().remove(), 
                    this.manualZoomConnect(); else if (this.path = path().projection(this.projection), 
                    this.shapes = shapes.enter().append("path").style("fill", calculateFillColor).style("opacity", 0).attr("d", this.path).merge(shapes), 
                    this.setAccessibilityAttributes(this.shapes, hasSelection), this.shapes.transition().duration(600).style("fill", calculateFillColor).style("opacity", function(d) {
                        var datapoint = _this.getDataPointFromShape(d);
                        return (0, renderUtil.eR)(datapoint && datapoint.selected, !1, hasSelection, !1);
                    }), this.shapesExit = shapes.exit(), this.shapesExit.transition().duration(600).style("fill", calculateFillColor).style("opacity", 0).remove(), 
                    ShapeMap.projectionsEqual(this.projection, projection)) this.projection = projection, 
                    this.shapes.attr("d", this.path), this.shapesExit.attr("d", this.path), this.manualZoomConnect(); else {
                        var p0_1 = this.projection, p1_1 = projection;
                        this.mapG.transition().duration(600).tween("projection transition", function() {
                            var s = p0_1.scale && d3.interpolate(p0_1.scale(), p1_1.scale()), t = p0_1.translate && d3.interpolate(p0_1.translate(), p1_1.translate()), r = p0_1.rotate && d3.interpolate(p0_1.rotate(), p1_1.rotate());
                            return p0_1 = null, p1_1 = null, function(pct) {
                                s && _this.projection.scale(s(pct)), t && _this.projection.translate(t(pct)), r && _this.projection.rotate(r(pct)), 
                                _this.shapes.attr("d", _this.path), _this.shapesExit.attr("d", _this.path);
                            };
                        }).on("end", function() {
                            return _this.manualZoomConnect();
                        });
                    }
                    if (this.tooltipsEnabled) {
                        var shapePropNames_1 = [];
                        this.viewModel.dataAvailable || (shapePropNames_1 = this.matcher.shapeProps.map(function(d) {
                            return d.propName;
                        }).sort()), this.tooltipService.addTooltip(this.shapes, function(args) {
                            if (_this.viewModel.dataAvailable) {
                                if (!args.data) return;
                                var dataPoint = _this.matcher.getDataPointFromShape(args.data);
                                return dataPoint ? dataPoint.tooltipInfo : [ {
                                    displayName: _this.viewModel.categoryName,
                                    value: "" + _this.matcher.getShapeProp(args.data, _this.matcher.shapePropName) || ""
                                } ];
                            }
                            return shapePropNames_1.map(function(propName) {
                                return {
                                    displayName: propName || "ID",
                                    value: "" + _this.matcher.getShapeProp(args.data, propName)
                                };
                            });
                        }, function(args) {
                            var dataPoint = args.data && _this.matcher.getDataPointFromShape(args.data);
                            if (dataPoint) return dataPoint.identity && [ dataPoint.identity ];
                        });
                    }
                    this.behavior && this.interactivityService && this.interactivityService.bind(this.viewModel.dataPoints, this.behavior, {
                        shapes: this.shapes,
                        clearCatcher: this.clearCatcher
                    }, {
                        pointSourceKey: "shape-map"
                    });
                } else this.resetToDefault || (this.resetToDefault = !0, this.resetToDefaultMap());
            }, ShapeMap.prototype.setAccessibilityAttributes = function(shapes, hasSelection) {
                var _this = this;
                shapes.attr("tabindex", function(d) {
                    return _this.getDataPointFromShape(d) ? "0" : void 0;
                }).attr("aria-selected", function(d) {
                    var datapoint = _this.getDataPointFromShape(d);
                    if (datapoint) return hasSelection && datapoint.selected;
                });
            }, ShapeMap.prototype.visibleFeatures = function(allFeatureCollection) {
                var _this = this;
                return this.viewModel.defaultShow ? allFeatureCollection.features : allFeatureCollection.features.filter(function(d) {
                    return !!_this.getDataPointFromShape(d);
                });
            }, ShapeMap.prototype.shapeKeyFunction = function(allFeatureCollection) {
                return allFeatureCollection.features[0] && null != allFeatureCollection.features[0].id ? function(data) {
                    return data.id;
                } : null;
            }, ShapeMap.projectionsEqual = function(p0, p1) {
                return !(p0.scale && !_.isEqual(p0.scale(), p1.scale()) || p0.rotate && !_.isEqual(p0.rotate(), p1.rotate()) || p0.translate && !_.isEqual(p0.translate(), p1.translate()));
            }, ShapeMap.prototype.manualZoomConnect = function() {
                var _a, _this = this;
                if (!this.zoom && this.viewModel.manualZoom) {
                    var scale = this.projection.scale(), scaleExtent = [ scale / 4, 16 * scale ];
                    this.zoom = d3.zoom().scaleExtent(scaleExtent).on("zoom", function() {
                        var transform = d3.event.transform;
                        _this.projection.translate([ transform.x, transform.y ]).scale(transform.k), _this.shapes.attr("d", _this.path);
                    }), this.svg.call(this.zoom).call(this.zoom.transform, (_a = d3.zoomIdentity).translate.apply(_a, this.projection.translate()).scale(scale));
                }
            }, ShapeMap.prototype.manualZoomDisconnect = function() {
                this.zoom && this.zoom.on("zoom", null), this.zoom = null;
            }, ShapeMap.prototype.getMapViewport = function() {
                var currentViewport = this.viewport, legendMargins = this.legend.getMargins();
                return {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height
                };
            }, ShapeMap.prototype.renderLegend = function() {
                var legendData = this.viewModel.legendData;
                null != legendData.position && this.legend.setPosition(legendData.position), 1 === legendData.dataPoints.length && !legendData.grouped && !this.viewModel.hasDynamicSeries && (legendData.dataPoints = []), 
                this.legend.drawLegend({
                    data: legendData,
                    parentViewport: this.viewport
                });
            }, ShapeMap.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, ShapeMap.prototype.onRestoreSelection = function(options) {
                return !!this.interactivityService && this.interactivityService.restoreSelection(options.selection);
            }, ShapeMap;
        }(), Matcher = function() {
            function Matcher(shapes, dataPoints, categoryName) {
                this.shapes = shapes, this.dataPoints = dataPoints, this.categoryName = categoryName, 
                this.shapeProps = this.countShapeProps(this.shapes), this.shapeProps = this.shapeProps.sort(this.getShapePropCompareFunction(this.categoryName)), 
                this.buildMappings();
            }
            return Matcher.prototype.getDataPointFromShape = function(shape) {
                var shapePropValue = this.getShapeProp(shape, this.shapePropName);
                return shapePropValue || 0 === shapePropValue ? this.shapeToData[shapePropValue] : null;
            }, Matcher.prototype.getShapeFromDataPoint = function(dataPoint) {
                return this.dataToShape[dataPoint.location];
            }, Matcher.prototype.countShapeProps = function(shapes) {
                for (var propCount = {}, idPropCount = 0, shapeCount = shapes.length, i = 0; i < shapeCount; i++) {
                    var shape = shapes[i];
                    for (var propName in shape.hasOwnProperty("id") && idPropCount++, shape.properties) propCount.hasOwnProperty(propName) ? propCount[propName]++ : propCount[propName] = 1;
                }
                var result = [];
                for (var propName in propCount) propCount.hasOwnProperty(propName) && result.push({
                    propName,
                    count: propCount[propName]
                });
                return idPropCount > 0 && result.push({
                    propName: "",
                    count: idPropCount
                }), result;
            }, Matcher.prototype.getShapePropCompareFunction = function(preferredCategoryName) {
                return function(a, b) {
                    if (a.count !== b.count) return b.count - a.count;
                    if (preferredCategoryName) {
                        if (a.propName === preferredCategoryName) return -1;
                        if (b.propName === preferredCategoryName) return 1;
                        if (preferredCategoryName = preferredCategoryName.toLowerCase().trim(), a.propName.toLowerCase().trim() === preferredCategoryName) return -1;
                        if (b.propName.toLowerCase().trim() === preferredCategoryName) return 1;
                    }
                    return 0;
                };
            }, Matcher.prototype.getShapeProp = function(shape, propName) {
                return "" === propName ? shape.id : shape.properties[propName];
            }, Matcher.prototype.removeAtIndex = function(arr, index) {
                return arr.slice(0, index).concat(arr.slice(index + 1));
            }, Matcher.prototype.buildMappings = function() {
                var maxMatchCount = 0;
                shapePropLoop: for (var _i = 0, _a = this.shapeProps; _i < _a.length; _i++) {
                    var shapeProp = _a[_i];
                    if (maxMatchCount > shapeProp.count) break shapePropLoop;
                    for (var matchCount = 0, dataToShape = {}, shapeToData = {}, unmatchedShapes = this.shapes, unmatchedData = this.dataPoints, shapeIndex = unmatchedShapes.length - 1; shapeIndex >= 0; shapeIndex--) {
                        var unmatchedShape = unmatchedShapes[shapeIndex], unmatchedShapeValue = this.getShapeProp(unmatchedShape, shapeProp.propName);
                        if (unmatchedShapeValue || 0 === unmatchedShapeValue) {
                            unmatchedDataLoop: for (var dataIndex = 0; dataIndex < unmatchedData.length; dataIndex++) {
                                var unmatchedDataPoint = unmatchedData[dataIndex], unmatchedDataValue = unmatchedDataPoint.location;
                                if (null != unmatchedDataValue && (unmatchedDataValue === unmatchedShapeValue || unmatchedDataValue.toLowerCase && unmatchedShapeValue.toLowerCase && unmatchedDataValue.toLowerCase() === unmatchedShapeValue.toLowerCase())) {
                                    dataToShape[unmatchedDataValue] = unmatchedShape, shapeToData[unmatchedShapeValue] = unmatchedDataPoint, 
                                    unmatchedShapes = this.removeAtIndex(unmatchedShapes, shapeIndex), unmatchedData = this.removeAtIndex(unmatchedData, dataIndex), 
                                    matchCount++;
                                    break unmatchedDataLoop;
                                }
                            }
                            if (0 === unmatchedShapes.length || 0 === unmatchedData.length) {
                                maxMatchCount = matchCount, this.shapePropName = shapeProp.propName, this.shapeToData = shapeToData, 
                                this.dataToShape = dataToShape;
                                break shapePropLoop;
                            }
                        }
                    }
                    matchCount > maxMatchCount && (maxMatchCount = matchCount, this.shapePropName = shapeProp.propName, 
                    this.shapeToData = shapeToData, this.dataToShape = dataToShape);
                }
            }, Matcher;
        }();
    },
    15841: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            ShapeMapBehavior: function() {
                return ShapeMapBehavior;
            }
        });
        var _Visuals_common_renderUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60066), _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66232), _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30237), _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38400), _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59107), ShapeMapBehavior = function() {
            function ShapeMapBehavior() {}
            return ShapeMapBehavior.prototype.onClick = function(d, selectionHandler) {
                var datapoint = this.shapeMap.getDataPointFromShape(d);
                datapoint ? (0, _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_0__.c8)({
                    identity: datapoint.categoryIdentity,
                    selected: datapoint.selected
                }, selectionHandler) : selectionHandler.handleClearSelection();
            }, ShapeMapBehavior.prototype.bindEvents = function(options, selectionHandler, dataPointNavigationManagerWithKey) {
                var _this = this;
                options.clearCatcher.on("click", function() {
                    var d3Event = d3.event;
                    _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(d3Event) || selectionHandler.handleClearSelection(), 
                    _this.shapeMap.zoomOnClick();
                }), this.shapes = options.shapes, this.shapes.on("click", function(d, i) {
                    _this.onClick(d, selectionHandler), _this.shapeMap.zoomOnClick(d);
                }), this.shapes.on("focus", function() {
                    var d3Event = d3.event, selectedTarget = d3.select(d3Event.target), d = selectedTarget.datum();
                    if (d) {
                        var datapoint = _this.shapeMap.getDataPointFromShape(d);
                        datapoint && selectedTarget.attr("aria-label", (0, _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_2__.X)(datapoint.tooltipInfo));
                    }
                }), this.shapes.on("contextmenu", function() {
                    var d3Event = d3.event;
                    if (!_VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(d3Event)) {
                        d3Event.preventDefault(), (0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_3__.n)(d3Event);
                        var d = d3.select(d3Event.target).datum();
                        if (d) {
                            var datapoint = _this.shapeMap.getDataPointFromShape(d);
                            if (datapoint) {
                                var position = (0, _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_0__.bt)();
                                selectionHandler.handleContextMenu(datapoint, position);
                            }
                        }
                    }
                }), this.shapes.on("keydown.select", function(d) {
                    var keyCode = d3.event.keyCode;
                    32 !== keyCode && 13 !== keyCode || _this.onClick(d, selectionHandler);
                });
            }, ShapeMapBehavior.prototype.renderSelection = function(hasSelection) {
                var _this = this;
                this.shapes.attr("aria-selected", function(d) {
                    var datapoint = _this.shapeMap.getDataPointFromShape(d);
                    return hasSelection && datapoint && datapoint.selected;
                }).transition().duration(600).style("opacity", function(d) {
                    var datapoint = _this.shapeMap.getDataPointFromShape(d);
                    return (0, _Visuals_common_renderUtil__WEBPACK_IMPORTED_MODULE_4__.eR)(datapoint && datapoint.selected, !1, hasSelection, !1);
                });
            }, ShapeMapBehavior;
        }();
    }
} ]);