"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "azureMap", "azureMapBehaviors" ], {
    2379: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            b: function() {
                return MapMath;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _VisualsCommon_geometry_shapes7__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92379), MapMath = function() {
            function MapMath() {}
            return MapMath.createMultiPolygonCoordinatesFromPaths = function(paths, coordinates) {
                var allPolygons = [];
                if (paths.filter(function(path) {
                    return path.geographic;
                }).forEach(function(path) {
                    var latitude, polygonPoints = [];
                    path.geographic.forEach(function(val, i) {
                        i % 2 == 0 ? latitude = val : polygonPoints.push([ val, latitude ]);
                    }), allPolygons.push(polygonPoints);
                }), 0 === allPolygons.length) return [];
                for (var multiPolygons = [ [ allPolygons[0] ] ], i = 1; i < allPolygons.length; i++) {
                    var currentPolygonSeries = multiPolygons[multiPolygons.length - 1], polygon = allPolygons[i];
                    this.isPointInsidePolygon(polygon[0], currentPolygonSeries[0]) ? currentPolygonSeries.push(polygon) : multiPolygons.push([ polygon ]);
                }
                return this.combineMultiPolygonCoordinatesAtAntimeridian(coordinates, multiPolygons);
            }, MapMath.combineMultiPolygonCoordinatesAtAntimeridian = function(coordinates, multiPolygons) {
                return this.shouldCheckAntimeridianCrossing(coordinates) ? this.checkAndMergePolygonsAtAntimeridian(multiPolygons) : multiPolygons;
            }, MapMath.shouldCheckAntimeridianCrossing = function(coordinates) {
                var boundingBoxOfRussia = new atlas.data.BoundingBox([ 19.8, 41.2, -169.6, 81.45 ]);
                return coordinates.longitude > 175 || coordinates.longitude < -175 || !!atlas.data.BoundingBox.containsPosition(boundingBoxOfRussia, [ coordinates.longitude, coordinates.latitude ]);
            }, MapMath.checkAndMergePolygonsAtAntimeridian = function(multiPolygons) {
                for (var boundingBoxes = multiPolygons.map(function(p) {
                    return atlas.data.BoundingBox.fromPositions(p[0]);
                }), resultPolygons = [], remainingRightPolygons = [], leftIndices = [], i = 0; i < boundingBoxes.length; i++) {
                    var east = atlas.data.BoundingBox.getEast(boundingBoxes[i]), west = atlas.data.BoundingBox.getWest(boundingBoxes[i]), polygon = _.cloneDeep(multiPolygons[i]), boundingBox = boundingBoxes[i];
                    180 === east || -180 === east ? (resultPolygons.push({
                        polygon,
                        boundingBox
                    }), leftIndices.push(resultPolygons.length - 1)) : 180 === west || -180 === west ? remainingRightPolygons.push({
                        polygon,
                        boundingBox
                    }) : resultPolygons.push({
                        polygon,
                        boundingBox
                    });
                }
                for (var _i = 0, leftIndices_1 = leftIndices; _i < leftIndices_1.length; _i++) for (var leftPolygon = resultPolygons[leftIndices_1[_i]], rightIndex = 0; rightIndex < remainingRightPolygons.length; rightIndex++) if (this.matchAndMerge(leftPolygon.polygon, remainingRightPolygons[rightIndex].polygon)) {
                    remainingRightPolygons.splice(rightIndex, 1);
                    break;
                }
                return resultPolygons.map(function(polyInfo) {
                    return polyInfo.polygon;
                });
            }, MapMath.matchAndMerge = function(leftPolygon, rightPolygon) {
                for (var _this = this, left = (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], leftPolygon[0], !0), right = (0, 
                tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], rightPolygon[0], !0), rotatedCount = 0; Math.abs(left[0][0] - 180) < this.floatPrecision && rotatedCount < 3; ) left.push(left.shift()), 
                rotatedCount += 1;
                for (rotatedCount = 0; Math.abs(right[0][0] + 180) < this.floatPrecision && rotatedCount < 3; ) right.push(right.shift()), 
                rotatedCount += 1;
                var leftSouthSplitIndex = _.findIndex(left, function(p) {
                    return Math.abs(p[0] - 180) < _this.floatPrecision;
                }), leftNorthSplitIndex = _.findLastIndex(left, function(p) {
                    return Math.abs(p[0] - 180) < _this.floatPrecision;
                }), rightNorthSplitIndex = _.findIndex(right, function(p) {
                    return Math.abs(p[0] + 180) < _this.floatPrecision;
                }), rightSouthSplitIndex = _.findLastIndex(right, function(p) {
                    return Math.abs(p[0] + 180) < _this.floatPrecision;
                });
                if (-1 === leftSouthSplitIndex || leftNorthSplitIndex === leftSouthSplitIndex || -1 === rightNorthSplitIndex || rightSouthSplitIndex === rightNorthSplitIndex) return !1;
                var leftSouth = left[leftSouthSplitIndex][1], leftNorth = left[leftNorthSplitIndex][1], rightNorth = right[rightNorthSplitIndex][1], rightSouth = right[rightSouthSplitIndex][1], totalRange = Math.max(leftNorth, rightNorth) - Math.min(leftSouth, rightSouth), overlapRange = Math.min(leftNorth, rightNorth) - Math.max(leftSouth, rightSouth);
                if (totalRange > 0 && overlapRange / totalRange > .9) {
                    var leftLowerRing = left.slice(0, leftSouthSplitIndex + 1), leftUpperRing = left.slice(leftNorthSplitIndex);
                    right.forEach(function(p) {
                        return p[0] += 360;
                    });
                    var rightUpperRing = right.slice(0, rightNorthSplitIndex + 1), rightLowerRing = right.slice(rightSouthSplitIndex);
                    return leftPolygon[0] = leftLowerRing.concat(rightLowerRing, rightUpperRing, leftUpperRing), 
                    leftPolygon.push.apply(leftPolygon, rightPolygon.slice(1)), !0;
                }
                return !1;
            }, MapMath.isPointInsidePolygon = function(point, polygonPoints) {
                for (var crossingCount = 0, i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) this.isRayCrossEdgeUpward(point, polygonPoints[i], polygonPoints[j]) && crossingCount++;
                return crossingCount % 2 == 1;
            }, MapMath.isRayCrossEdgeUpward = function(point, edgePoint1, edgePoint2) {
                var x = point[0], y = point[1], x1 = edgePoint1[0], y1 = edgePoint1[1], x2 = edgePoint2[0], y2 = edgePoint2[1];
                return Math.abs(x2 - x1) > 180 && (x > 0 ? (x1 < 0 && (x1 += 360), x2 < 0 && (x2 += 360)) : (x1 > 0 && (x1 -= 360), 
                x2 > 0 && (x2 -= 360))), x1 > x != x2 > x && y < (y2 - y1) * (x - x1) / (x2 - x1) + y1;
            }, MapMath.shapesWithinPolygon = function(shapes, searchArea) {
                var results = [];
                if (shapes && searchArea) {
                    var id_1, idLookupTable_1 = {}, points_1 = [], sourceShapes = shapes instanceof atlas.source.DataSource ? shapes.getShapes() : shapes;
                    _.forEach(sourceShapes, function(s) {
                        id_1 = s.getId(), idLookupTable_1[id_1] = s, points_1.push({
                            id: id_1,
                            coordinates: s.getProperties().coordinates
                        });
                    }), results = MapMath.pointsWithinPolygon(points_1, searchArea).map(function(f) {
                        return idLookupTable_1[f.id];
                    });
                }
                return results;
            }, MapMath.pointsWithinPolygon = function(points, searchArea) {
                if (points && searchArea) {
                    var poly = MapMath.getPolygon(searchArea), polygonHelper_1 = MapMath.getPowerBIShapePolygon(poly);
                    return points.filter(function(p) {
                        return polygonHelper_1.inside(MapMath.getPowerBIShapePoint(p.coordinates));
                    });
                }
                return [];
            }, MapMath.getPowerBIShapePoint = function(coordinates) {
                return {
                    x: coordinates[0],
                    y: coordinates[1]
                };
            }, MapMath.getPowerBIShapePolygon = function(polygon) {
                var allShapePoints = [].concat.apply([], polygon.coordinates).map(function(p) {
                    return {
                        x: atlas.math.normalizeLongitude(p[0]),
                        y: atlas.math.normalizeLatitude(p[1])
                    };
                });
                return _VisualsCommon_geometry_shapes7__WEBPACK_IMPORTED_MODULE_1__.m.fromPolygonPoints(allShapePoints);
            }, MapMath.getPolygon = function(shape) {
                var poly;
                if (shape instanceof atlas.Shape) shape.isCircle() ? poly = new atlas.data.Polygon([ shape.getCircleCoordinates() ]) : shape.getType().indexOf("Polygon") > -1 && (poly = shape.toJson().geometry); else {
                    var f = shape;
                    "Feature" === f.type && ("Point" === f.geometry.type && "Circle" === f.properties.subType && "number" == typeof f.properties.radius ? poly = new atlas.data.Polygon(atlas.math.getRegularPolygonPath(f.geometry.coordinates, f.properties.radius, 72, "meters")) : f.geometry.type.indexOf("Polygon") > -1 && (poly = f.geometry)), 
                    -1 !== f.type.indexOf("Polygon") && (poly = shape);
                }
                return poly;
            }, MapMath.floatPrecision = 1e-4, MapMath;
        }();
    },
    49988: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            t: function() {
                return PieChartFactory;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _VisualsCommon_Utility_pbiDeferred__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65363), createPieSlice = function(options, cx, cy, r, startAngle, angle, fillColor, maskId, sliceIdx) {
            var opt = options, pi = Math.PI, mask = "";
            maskId && (mask = ' mask="url(#'.concat(maskId, '"'));
            var pieOpacity = void 0 !== options.selectionPieIndexes && void 0 === options.selectionPieIndexes.filter(function(idx) {
                return idx === sliceIdx;
            })[0] ? options.deselectedPieOpacity : 1, filterExpression = options.gaussianBlurStandardDeviation ? 'filter="url(#f1)"' : "";
            if (angle > 2 * pi * .99) return '<circle r="'.concat(r, '" cx="').concat(cx, '" cy="').concat(cy, '" ').concat(filterExpression, ' style="opacity:').concat(pieOpacity, ";stroke-opacity:").concat(opt.strokeOpacity, ";fill:").concat(fillColor, ";stroke:").concat(opt.strokeColor, ";stroke-width:").concat(opt.strokeWidth, 'px;"').concat(mask, "></circle>");
            var sin = Math.sin, cos = Math.cos, x1 = cx + r * sin(startAngle), y1 = cy - r * cos(startAngle), x2 = cx + r * sin(startAngle + angle), y2 = cy - r * cos(startAngle + angle), big = 0;
            return angle > pi && (big = 1), '<path d="M'.concat(cx, " ").concat(cy, " L ").concat(x1, " ").concat(y1, " A ").concat(r, ",").concat(r, " 0 ").concat(big, " 1 ").concat(x2, " ").concat(y2, 'z" ').concat(filterExpression, ' style="opacity:').concat(pieOpacity, ";stroke-opacity:").concat(opt.strokeOpacity, ";fill:").concat(fillColor, ";stroke:").concat(opt.strokeColor, ";stroke-width:").concat(opt.strokeWidth, 'px;"').concat(mask, "></path>");
        }, generatePieChartSVG = function(point, options, selectedIndexes) {
            return function(options) {
                var maskId, data = options.values, radius = options.radius, startAngle = 0, angle = 0, o = radius + options.strokeWidth, svg = [ '<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(2 * o, 'px" height="').concat(2 * o, 'px" opacity="').concat(void 0 !== options.opacity || null !== options.opacity ? options.opacity : 1, '">') ], filterExpression = '<filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="'.concat(options.gaussianBlurStandardDeviation, '" /></filter>');
                svg.push("\n        <defs>".concat(options.gaussianBlurStandardDeviation ? filterExpression : "", "</defs>\n    ")), 
                options.innerRadius > 0 && options.innerRadius <= options.radius && (maskId = "piechart-innercircle-" + Math.round(1e7 * Math.random()), 
                svg.push('<defs><mask id="'.concat(maskId, '"><rect width="100%" height="100%" fill="white"/><circle r="').concat(options.innerRadius, '" cx="').concat(o, '" cy="').concat(o, '" fill="black"/></mask></defs>\n            <circle r="').concat(options.innerRadius, '" cx="').concat(o, '" cy="').concat(o, '" style="fill:').concat(options.fillColor, ";stroke:").concat(options.strokeColor, ";stroke-width:").concat(2 * options.strokeWidth, 'px;"/>')));
                var _total = data.reduce(function(a, b) {
                    return a + b.count;
                }, 0);
                if (_total > 0) for (var ratio = 2 * Math.PI / _total, i = 0; i < data.length; i++) svg.push(createPieSlice(options, o, o, radius, startAngle, angle = ratio * data[i].count, data[i].fill, maskId, i)), 
                startAngle += angle;
                var text = options.text;
                return text && svg.push('<text x="'.concat(o, '" y="').concat(o + 7, '" style="font-size:').concat(16, 'px;font-family:arial;fill:#000;font-weight:bold;" class="').concat(options.textClassName || "", '" text-anchor="middle">').concat(text, "</text>")), 
                svg.push("</svg>"), svg.join("");
            }(makeOptions(point, options, selectedIndexes));
        }, makeOptions = function(point, options, selectedIndexes) {
            return {
                values: point.subDataPoints.map(function(sp) {
                    return {
                        count: Math.max(sp.size, 0),
                        fill: sp.color
                    };
                }),
                radius: point.bubbleRadius,
                pixelOffset: [ 0, 0 ],
                innerRadius: 0,
                colors: [],
                fillColor: "transparent",
                gaussianBlurStandardDeviation: options.blur,
                strokeWidth: options.strokeWidth,
                strokeColor: options.strokeColor,
                strokeOpacity: 1 - options.strokeTransparency / 100,
                textClassName: void 0,
                opacity: 1 - options.transparency / 100,
                selectionPieIndexes: selectedIndexes || point.subDataPoints.map(function(_, i) {
                    return i;
                }),
                deselectedPieOpacity: .1
            };
        }, gcd = function gcd(a, b) {
            return b ? gcd(b, a % b) : a;
        }, gcdOf = function(numbers, length) {
            for (var res = numbers[0], i = 1; i < length; i++) if (1 === (res = gcd(numbers[i], res))) return 1;
            return res;
        }, PieChartFactory = function() {
            function PieChartFactory(imageSprite) {
                this.cache = {}, this.imageSprite = imageSprite;
            }
            return PieChartFactory.prototype.clearAll = function() {
                this.imageSprite.clear(), this.cache = {};
            }, PieChartFactory.hash = function(point, options, selectedIndexes) {
                return function(options) {
                    var counts = options.values.map(function(v) {
                        return v.count;
                    }), gcd = gcdOf(counts, counts.length);
                    return function(inputStr) {
                        var i, len, hash = 0;
                        if (0 === inputStr.length) return hash;
                        var lowerInputString = inputStr.toLowerCase();
                        for (i = 0, len = lowerInputString.length; i < len; i++) hash = (hash << 5) - hash + lowerInputString.charCodeAt(i), 
                        hash |= 0;
                        return hash;
                    }(Object.keys(options).filter(function(key) {
                        return "values" !== key && (void 0 !== options[key] || null !== options[key]);
                    }).map(function(key) {
                        return {
                            key,
                            value: options[key]
                        };
                    }).concat([ {
                        key: "values",
                        value: options.values.map(function(value) {
                            return [ "fill=".concat(value.fill), "count=".concat(value.count / gcd) ].join(",");
                        }).join(";")
                    } ]).map(function(_a) {
                        var key = _a.key, value = _a.value, serializedValue = value instanceof Array ? value.join(",") : "".concat(value);
                        return "".concat(key, "=").concat(serializedValue);
                    }).join(";"));
                }(makeOptions(point, options, selectedIndexes));
            }, PieChartFactory.prototype.svgContent = function(point, options, hidden, selectedIndexes) {
                void 0 === hidden && (hidden = !1);
                var svgOptions = hidden ? (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, options), {
                    transparency: 100
                }) : options, pieHash = PieChartFactory.hash(point, svgOptions, selectedIndexes), cached = this.cache[pieHash];
                if (void 0 !== cached) return cached.svgContent;
                var svgContent = generatePieChartSVG(point, svgOptions, selectedIndexes);
                return this.cache[pieHash] = {
                    svgContent
                }, svgContent;
            }, PieChartFactory.prototype.objectUrl = function(point, options, selectedIndexes) {
                var pieHash = PieChartFactory.hash(point, options, selectedIndexes), cached = this.cache[pieHash];
                if (void 0 !== cached && cached.objectUrl) return cached.objectUrl;
                if (void 0 !== cached) {
                    var svgBlob = new Blob([ cached.svgContent ], {
                        type: "image/svg+xml;charset=utf-8"
                    }), url = URL.createObjectURL(svgBlob);
                    return cached.objectUrl = url, this.cache[pieHash].objectUrl = url, url;
                }
                var svgContent = generatePieChartSVG(point, options, selectedIndexes), objectUrl = (svgBlob = new Blob([ svgContent ], {
                    type: "image/svg+xml;charset=utf-8"
                }), URL.createObjectURL(svgBlob));
                return this.cache[pieHash] = {
                    objectUrl,
                    svgContent
                }, objectUrl;
            }, PieChartFactory.prototype.loadIcon = function(point, options, selectedIndexes, hash) {
                var pieHash = null != hash ? hash : PieChartFactory.hash(point, options, selectedIndexes);
                if (this.cache[pieHash] && this.cache[pieHash].objectUrl || this.imageSprite.hasImage(pieHash.toString())) return (0, 
                _VisualsCommon_Utility_pbiDeferred__WEBPACK_IMPORTED_MODULE_1__.DR)(void 0);
                var objectUrl = this.objectUrl(point, options, selectedIndexes);
                return this.imageSprite.add(pieHash.toString(), objectUrl);
            }, PieChartFactory;
        }();
    },
    93816: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            AzureMap: function() {
                return AzureMap;
            },
            createAzureMap: function() {
                return createAzureMap;
            },
            createAzureMapBehavior: function() {
                return createAzureMapBehavior;
            }
        });
        var tslib_es6 = __webpack_require__(81337), azureMap_capabilities = __webpack_require__(60637), mapUtil = __webpack_require__(5962), objectEnumerationBuilder = __webpack_require__(28579), htmlSubSelectionHelper = __webpack_require__(52287), subSelectionOutlineRenderer = __webpack_require__(86900), legend = __webpack_require__(65741), legend_formatting = __webpack_require__(86727), legend_util = __webpack_require__(77686), interactivityService = __webpack_require__(72902), visualWarnings = __webpack_require__(45296), color = __webpack_require__(64067), DomFactory = __webpack_require__(38308), CssConstants = __webpack_require__(79154), debug = __webpack_require__(62458), geoTaggingAnalyzerService = __webpack_require__(15621), trace = __webpack_require__(12913), build_control_util = __webpack_require__(56578), enums = __webpack_require__(46135), azureMapBehaviors = __webpack_require__(35824), common_colorHelper = __webpack_require__(90120), converterHelper = __webpack_require__(54522), dataLabelViewModel1 = __webpack_require__(21181), common_fontProperties = __webpack_require__(18664), legend_converter = __webpack_require__(79811), geocodingCulture = __webpack_require__(56919), VisualsCommon_colorHelper = __webpack_require__(44783), Utility = __webpack_require__(38078), markerRangeType = __webpack_require__(90700), dataRoleHelper = __webpack_require__(38958), dataViewObject2 = __webpack_require__(82755), selectionId = __webpack_require__(26543), AzureMapBubbleHelper = function() {
            function AzureMapBubbleHelper() {}
            return AzureMapBubbleHelper.getRadius = function(value, azureMapData) {
                var minDataValue = azureMapData.minDataValue, maxDataValue = azureMapData.maxDataValue;
                if (!azureMapData.hasSize || minDataValue === maxDataValue) return azureMapData.properties.bubble.radius;
                var bubbleLayerProps = azureMapData.properties.bubble, rangeType = bubbleLayerProps.markerRangeType;
                rangeType === markerRangeType.Dl.auto && (rangeType = minDataValue >= 0 || maxDataValue <= 0 ? markerRangeType.Dl.magnitude : markerRangeType.Dl.dataRange), 
                rangeType === markerRangeType.Dl.magnitude && (value = Math.abs(value), maxDataValue = Math.max(Math.abs(minDataValue), Math.abs(maxDataValue)), 
                minDataValue = 0);
                var minRadius = bubbleLayerProps.minRadius, maxRadius = bubbleLayerProps.maxRadius, clampedInput = _.clamp(value, minDataValue, maxDataValue);
                return Math.sqrt((clampedInput - minDataValue) / (maxDataValue - minDataValue)) * (maxRadius - minRadius) + minRadius;
            }, AzureMapBubbleHelper.updateRadiusForDataPoints = function(azureMapData) {
                azureMapData.dataPoints.forEach(function(dataPoint) {
                    var totalSize = dataPoint.subDataPoints.reduce(function(total, subDataPoint) {
                        return total + subDataPoint.size;
                    }, 0), radiusInPixel = AzureMapBubbleHelper.getRadius(totalSize, azureMapData);
                    dataPoint.bubbleRadius = radiusInPixel;
                });
            }, AzureMapBubbleHelper;
        }(), azureMapConstant = __webpack_require__(70508), dataLabelViewModel1Consts = __webpack_require__(56707), strokeStyle = __webpack_require__(2241), strokeLineJoin = __webpack_require__(41234), strokePattern = __webpack_require__(47316), ReferenceDataLayerOptions = function() {
            return function() {
                this.allowExtrusions = !0, this.visible = !0, this.bubble = {
                    strokeShow: !0,
                    strokePattern: strokePattern.Dv.solid,
                    strokeColor: "white",
                    strokeWidth: 2,
                    strokeTransparency: 0,
                    fillColor: "#1A73AA",
                    fillOpacity: 1
                }, this.line = {
                    strokeShow: !0,
                    strokePattern: strokePattern.Dv.solid,
                    strokeColor: "#1e90ff",
                    strokeWidth: 3,
                    strokeTransparency: 0,
                    strokeDashCap: strokePattern.qH.round,
                    strokeLineJoin: strokeLineJoin.t.round
                }, this.polygon = {
                    strokeShow: !0,
                    strokePattern: strokePattern.Dv.solid,
                    strokeColor: "#1e90ff",
                    strokeWidth: 3,
                    strokeTransparency: 0,
                    fillColor: "#1e90ff",
                    fillOpacity: .5,
                    strokeDashCap: strokePattern.qH.round,
                    strokeLineJoin: strokeLineJoin.t.round
                }, this.unselectedTransparency = 80;
            };
        }(), parseNumber = Utility.b$.parseNumber, AzureMapConverter = function() {
            function AzureMapConverter() {}
            return AzureMapConverter.getHeatMapGradientColorScale = function(style) {
                var baseColor = common_colorHelper.v.getDataColorByIndex(style, 0);
                return (0, color.X6)(baseColor);
            }, AzureMapConverter.converter = function(options) {
                var dataView = options.dataView, geoTaggingAnalyzerService = options.geoTaggingAnalyzerService, interactivityService = options.interactivityService, style = options.style, featureSwitches = options.featureSwitches, matrix = dataView.matrix, staticObjects = dataView.metadata.objects, colorHelper = common_colorHelper.v.create(style, azureMap_capabilities.MC.dataPoint.fill, (0, 
                dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.dataPoint.defaultColor), (0, 
                dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.dataPoint.fill));
                if (!matrix || !matrix.rows || !matrix.rows.levels || 0 === matrix.rows.levels.length) return AzureMapConverter.getDefaultMapData(style, featureSwitches);
                var rowSources = [].concat.apply([], matrix.rows.levels.map(function(l) {
                    return l.sources && l.sources.map(function(s) {
                        return s;
                    });
                }) || []), columnSources = [].concat.apply([], matrix.columns.levels.map(function(l) {
                    return l.sources && l.sources.map(function(s) {
                        return s;
                    });
                }) || []), dataFlags = AzureMapConverter.determineDataFlags(rowSources, columnSources, matrix.valueSources), mapControlsProps = AzureMapConverter.getMapControlProperties(staticObjects);
                mapControlsProps.geocodingCulture && !(0, geocodingCulture._h)(mapControlsProps.geocodingCulture) && (mapControlsProps.geocodingCulture = void 0, 
                dataFlags.hasInvalidGeocodingCulture = !0);
                var dataPoints, paths, geocodingCategory = null, series = [];
                if (dataFlags.hasCategory) {
                    var categorySources = !_.isEmpty(matrix.rows.levels) && _.last(matrix.rows.levels).sources;
                    if (!dataFlags.hasSeries || dataFlags.hasSize || dataFlags.hasX || dataFlags.hasY || dataFlags.hasTooltip || dataFlags.hasPointOrder) {
                        var result = AzureMapConverter.convertMatrixWithCategory(dataFlags, matrix, series, colorHelper, geoTaggingAnalyzerService, interactivityService, featureSwitches, mapControlsProps.geocodingCulture);
                        dataPoints = result.dataPoints, paths = result.paths;
                    } else dataPoints = (results = AzureMapConverter.convertMatrixWithOnlyCategoryAndSeries(dataFlags, matrix, series, colorHelper, geoTaggingAnalyzerService, featureSwitches, mapControlsProps.geocodingCulture)).dataPoints, 
                    paths = results.paths;
                    geocodingCategory = AzureMapConverter.getGeocodingCategory(_.last(categorySources), geoTaggingAnalyzerService);
                } else {
                    var results;
                    dataPoints = (results = AzureMapConverter.convertMatrixWithoutCategory(dataFlags, matrix, series, colorHelper, interactivityService, featureSwitches)).dataPoints, 
                    paths = results.paths;
                }
                var commonDataOptions = AzureMapConverter.getCommonDataLayerProperties(staticObjects, dataFlags.hasSize, dataPoints, featureSwitches), properties = {
                    mapControls: mapControlsProps,
                    traffic: AzureMapConverter.getTrafficProperties(staticObjects),
                    tile: AzureMapConverter.getTileLayerProperties(staticObjects),
                    filledMap: AzureMapConverter.getFilledMapProperties(staticObjects, style),
                    bubble: AzureMapConverter.getBubbleLayerProperties(staticObjects, style),
                    heatMap: AzureMapConverter.getHeatMapLayerProperties(staticObjects, style),
                    barChart: AzureMapConverter.getBarChartProperties(staticObjects, style),
                    commonDataOptions,
                    referenceLayer: AzureMapConverter.getReferenceLayerProperties(staticObjects)
                };
                dataFlags.hasDuplicatedLatLong && (properties.bubble.autoStrokeColor = !1, properties.bubble.blur = 0, 
                properties.bubble.zoomScaleFactor = 1, properties.bubble.pitchAlignment = "viewport"), 
                properties.heatMap.heatMapRadius = "meters" === properties.heatMap.heatMapRadiusUnit ? Math.min(properties.heatMap.heatMapRadius, azureMapConstant.NI) : Math.min(properties.heatMap.heatMapRadius, azureMapConstant.OH);
                var legendData = this.composeLegendData(dataFlags, options, colorHelper, style, featureSwitches), mapData = {
                    dataPoints,
                    properties,
                    shouldRenderFilledMap: properties.filledMap.showFilledMap && !dataFlags.hasSize,
                    geocodingCategory,
                    hasCategory: dataFlags.hasCategory,
                    hasSeries: dataFlags.hasSeries,
                    hasXY: dataFlags.hasXY,
                    hasSize: dataFlags.hasSize,
                    hasInvalidLatLong: dataFlags.hasInvalidLatLong,
                    hasInvalidGeocodingCulture: dataFlags.hasInvalidGeocodingCulture,
                    hasDuplicatedLatLong: dataFlags.hasDuplicatedLatLong,
                    hasPathID: dataFlags.hasPathID,
                    colorHelper,
                    minDataValue: dataFlags.hasSize ? commonDataOptions.minDataValue : void 0,
                    maxDataValue: dataFlags.hasSize ? commonDataOptions.maxDataValue : void 0,
                    legendData,
                    dataLabelSettings: this.calculateDataLabelSettings(dataView, style),
                    series,
                    paths
                };
                return !(properties.bubble.markerRangeType === markerRangeType.Dl.deprecated) && properties.bubble.showBubbleLayer && AzureMapBubbleHelper.updateRadiusForDataPoints(mapData), 
                mapData;
            }, AzureMapConverter.composeLegendData = function(dataFlags, options, colorHelper, style, featureSwitches) {
                var legendConverterOptions = {
                    dataView: options.dataView,
                    colorHelper,
                    style,
                    formatStringProp: azureMap_capabilities.MC.general.formatString,
                    showByDefault: !0
                };
                return dataFlags.hasSeries && dataFlags.hasCategory && (dataFlags.hasSize || dataFlags.hasXY || dataFlags.hasTooltip) ? (0, 
                legend_converter.Lk)(legendConverterOptions) : dataFlags.hasSeries && featureSwitches.azureMapsPathLayer && dataFlags.hasPathID ? (0, 
                legend_converter.z9)(legendConverterOptions) : dataFlags.hasSeries ? (0, legend_converter.PP)(legendConverterOptions) : (0, 
                legend_converter.Fe)(style);
            }, AzureMapConverter.determineDataFlags = function(rowSources, columnSources, valueSources) {
                var hasCategory = AzureMapConverter.HaveRole(rowSources, azureMap_capabilities.Wx.category), hasSeries = AzureMapConverter.HaveRole(columnSources, azureMap_capabilities.Wx.series) || AzureMapConverter.HaveRole(rowSources, azureMap_capabilities.Wx.series), hasX = AzureMapConverter.HaveRole(valueSources, azureMap_capabilities.Wx.x) || AzureMapConverter.HaveRole(rowSources, azureMap_capabilities.Wx.x), hasY = AzureMapConverter.HaveRole(valueSources, azureMap_capabilities.Wx.y) || AzureMapConverter.HaveRole(rowSources, azureMap_capabilities.Wx.y);
                return {
                    hasCategory,
                    hasSeries,
                    hasX,
                    hasY,
                    hasXY: hasX && hasY,
                    hasSize: AzureMapConverter.HaveRole(valueSources, azureMap_capabilities.Wx.size),
                    hasTooltip: AzureMapConverter.HaveRole(valueSources, azureMap_capabilities.Wx.tooltips),
                    hasInvalidLatLong: !1,
                    hasInvalidGeocodingCulture: !1,
                    hasDuplicatedLatLong: !1,
                    hasPathID: AzureMapConverter.HaveRole(rowSources, azureMap_capabilities.Wx.pathID),
                    hasPointOrder: AzureMapConverter.HaveRole(valueSources, azureMap_capabilities.Wx.pointOrder)
                };
            }, AzureMapConverter.convertMatrixWithOnlyCategoryAndSeries = function(dataFlags, matrix, series, colorHelper, geoTaggingAnalyzerService, featureSwitches, geocodingCulture) {
                debug.fF.assertNonEmpty(matrix.rows.levels, "Matrix should have rows");
                var shouldDrawPaths = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID, rows = shouldDrawPaths ? matrix.rows.root.children || [] : [ {
                    children: matrix.rows.root.children || []
                } ], seriesLevelIndex = shouldDrawPaths ? 1 : 0, seriesSource = !_.isEmpty(matrix.rows.levels) && matrix.rows.levels[seriesLevelIndex].sources[0], nextCategoryIndex = 0, categoryIndexMap = {}, dataPoints = [], paths = new Map, seriesIdentityFields = this.getRowBasedSeriesIdentityFields(matrix, dataFlags, featureSwitches), seriesIndex = 0;
                return rows.forEach(function(pathNode) {
                    var children = pathNode.children, pathID = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID && String(pathNode.levelValues[0].value) || "";
                    children.forEach(function(seriesNode) {
                        var _a, seriesColor = colorHelper.getColorForSeriesValue(seriesNode.objects, seriesIdentityFields, seriesNode.value, VisualsCommon_colorHelper.fA), seriesValue = (0, 
                        converterHelper.xq)(seriesNode.value, seriesSource, azureMap_capabilities.MC.general.formatString), seriesTooltipItem = {
                            displayName: seriesSource.displayName,
                            value: seriesValue
                        }, seriesValueDetails = AzureMapConverter.getSeriesValueDetails(featureSwitches, seriesNode, seriesSource), seriesIdBuilder = (new selectionId.dw).withColumnIdentity(seriesNode.identity, seriesSource.queryName, seriesValueDetails);
                        if (series.push({
                            value: seriesValue,
                            color: seriesColor,
                            identity: seriesIdBuilder.createSelectionId(),
                            selected: !1
                        }), seriesNode.children) {
                            var categorySources_1 = null === (_a = matrix.rows.levels) || void 0 === _a ? void 0 : _a[seriesLevelIndex + 1].sources, lastCategorySource_1 = _.last(categorySources_1);
                            seriesNode.children.forEach(function(categoryNode) {
                                var categoryValueDetails = AzureMapConverter.getCategoryValueDetails(featureSwitches, categoryNode, categorySources_1), identityBuilder = (new selectionId.dw).withColumnIdentity(categoryNode.identity, lastCategorySource_1.queryName, categoryValueDetails);
                                if (pathID.length > 0) {
                                    var pathIDSource = matrix.rows.levels[0].sources[0], pathIDValueDetails = AzureMapConverter.getPathIDValueDetails(featureSwitches, pathNode, pathIDSource);
                                    identityBuilder.withColumnIdentity(pathNode.identity, pathIDSource.queryName, pathIDValueDetails);
                                }
                                var categoryIdentityKey = identityBuilder.createSelectionId().getKey();
                                identityBuilder.withColumnIdentity(seriesNode.identity, seriesSource.queryName, seriesValueDetails);
                                var categoryIndex = categoryIndexMap[categoryIdentityKey];
                                null == categoryIndex && (categoryIndex = nextCategoryIndex++, categoryIndexMap[categoryIdentityKey] = categoryIndex);
                                for (var queryLocation = {
                                    components: [],
                                    culture: geocodingCulture
                                }, categoryTooltipItems = [], formattedCategoryValues = [], unformattedCategoryValues = categoryNode.levelValues.map(function(lv) {
                                    return lv.value;
                                }), i = 0; i < unformattedCategoryValues.length; ++i) {
                                    var catSource = categorySources_1[i], unformattedCategoryValue = unformattedCategoryValues[i], geocodingCategory = AzureMapConverter.getGeocodingCategory(catSource, geoTaggingAnalyzerService), formattedCategoryValue = (0, 
                                    converterHelper.xq)(unformattedCategoryValue, catSource, azureMap_capabilities.MC.general.formatString);
                                    formattedCategoryValues.unshift(formattedCategoryValue), queryLocation.components.push({
                                        query: formattedCategoryValue,
                                        category: geocodingCategory
                                    }), categoryTooltipItems.push({
                                        displayName: catSource.displayName,
                                        value: formattedCategoryValue
                                    });
                                }
                                var categoryValue = formattedCategoryValues.join(", "), dataPoint = dataPoints[categoryIndex];
                                dataPoint || (dataPoint = {
                                    categoryValue,
                                    queryLocation,
                                    subDataPoints: []
                                }, pathID.length > 0 && (dataPoint.pathID = pathID), dataPoints[categoryIndex] = dataPoint, 
                                pathID.length > 0 && (paths.has(pathID) ? paths.get(pathID).push(categoryIndex) : paths.set(pathID, [ categoryIndex ])));
                                var tooltipInfo = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], categoryTooltipItems, !0), [ seriesTooltipItem ], !1);
                                dataPoint.subDataPoints.push({
                                    size: 1,
                                    color: seriesColor,
                                    identity: identityBuilder.createSelectionId(),
                                    selected: !1,
                                    tooltipInfo,
                                    seriesIndex
                                });
                            });
                        } else {
                            var categoryNode = seriesNode, categorySource = seriesSource, formattedCategoryValue = (0, 
                            converterHelper.xq)(categoryNode.levelValues[0].value, categorySource, azureMap_capabilities.MC.general.formatString), queryLocation = {
                                components: [ {
                                    query: formattedCategoryValue,
                                    category: AzureMapConverter.getGeocodingCategory(categorySource, geoTaggingAnalyzerService)
                                } ],
                                culture: geocodingCulture
                            }, categoryValueDetails = AzureMapConverter.getCategoryValueDetails(featureSwitches, categoryNode, [ categorySource ], !0), identityBuilder = (new selectionId.dw).withColumnIdentity(categoryNode.identity, categorySource.queryName, categoryValueDetails);
                            dataPoints.push({
                                categoryValue: formattedCategoryValue,
                                queryLocation,
                                subDataPoints: [ {
                                    size: 1,
                                    color: seriesColor,
                                    identity: identityBuilder.createSelectionId(),
                                    selected: !1,
                                    tooltipInfo: [ seriesTooltipItem ],
                                    seriesIndex
                                } ]
                            }), pathID.length > 0 && (dataPoints[dataPoints.length - 1].pathID = pathID, paths.has(pathID) ? paths.get(pathID).push(dataPoints.length - 1) : paths.set(pathID, [ dataPoints.length - 1 ]));
                        }
                        seriesIndex++;
                    });
                }), {
                    dataPoints,
                    paths
                };
            }, AzureMapConverter.convertMatrixWithCategory = function(dataFlags, matrix, series, colorHelper, geoTaggingAnalyzerService, interactivityService, featureSwitches, geocodingCulture) {
                var shouldDrawPaths = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID, rows = shouldDrawPaths ? matrix.rows.root.children || [] : [ {
                    children: matrix.rows.root.children || []
                } ], columns = matrix.columns.root.children || [], categoryLevelsIndex = shouldDrawPaths ? 1 : 0, categorySources = !_.isEmpty(matrix.rows.levels) && matrix.rows.levels[categoryLevelsIndex].sources, lastCategorySource = categorySources ? categorySources[categorySources.length - 1] : void 0, seriesSource = !_.isEmpty(matrix.columns.levels) && matrix.columns.levels[0].sources[0], valueSources = matrix.valueSources, sizeIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.size), pointOrderIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.pointOrder), dataPoints = [], selectablePoints = [], paths = new Map;
                if (dataFlags.hasSeries) for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var seriesNode = columns_1[_i], seriesColor = colorHelper.getColorForSeriesValue(seriesNode.objects, matrix.columns.root.childIdentityFields, seriesNode.value, VisualsCommon_colorHelper.fA), seriesValue = (0, 
                    converterHelper.xq)(seriesNode.value, seriesSource, azureMap_capabilities.MC.general.formatString), seriesValueDetails = AzureMapConverter.getSeriesValueDetails(featureSwitches, seriesNode, seriesSource), seriesIdBuilder = (new selectionId.dw).withColumnIdentity(seriesNode.identity, seriesSource.queryName, seriesValueDetails);
                    series.push({
                        value: seriesValue,
                        color: seriesColor,
                        identity: seriesIdBuilder.createSelectionId(),
                        selected: !1,
                        valueDetails: seriesValueDetails
                    });
                }
                return rows.forEach(function(pathNode) {
                    var children = pathNode.children, pathID = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID && String(pathNode.levelValues[0].value) || "";
                    children.forEach(function(categoryNode) {
                        for (var location, pointOrder, formattedCategoryValues = [], queryLocation = {
                            components: [],
                            culture: geocodingCulture
                        }, categoryTooltipItems = [], unformattedCategoryValues = categoryNode.levelValues.map(function(lv) {
                            return lv.value;
                        }), i = 0; i < unformattedCategoryValues.length; ++i) {
                            var catSource = categorySources[i], unformattedCategoryValue = unformattedCategoryValues[i], geocodingCategory = AzureMapConverter.getGeocodingCategory(catSource, geoTaggingAnalyzerService), formattedCategoryValue = (0, 
                            converterHelper.xq)(unformattedCategoryValue, catSource, azureMap_capabilities.MC.general.formatString);
                            formattedCategoryValues.unshift(formattedCategoryValue), queryLocation.components.push({
                                query: formattedCategoryValue,
                                category: geocodingCategory
                            }), categoryTooltipItems.push({
                                displayName: catSource.displayName,
                                value: formattedCategoryValue
                            });
                        }
                        var categoryValue = formattedCategoryValues.join(", "), categoryValueDetails = AzureMapConverter.getCategoryValueDetails(featureSwitches, categoryNode, categorySources), subDataPoints = [];
                        if (dataFlags.hasSeries) for (var _loop_1 = function(col) {
                            var valueLength = valueSources.length, sizeValue = -1 !== sizeIndex ? parseNumber(categoryNode.values[col * valueLength + sizeIndex].value) : 0;
                            if (dataFlags.hasPointOrder && (pointOrder = AzureMapConverter.getPointOrderValueFromNode(categoryNode.values[col * valueLength + pointOrderIndex], pointOrder)), 
                            dataFlags.hasSize && null == sizeValue) return "continue";
                            var columnValues = valueSources.map(function(vs, i) {
                                return categoryNode.values[col * valueLength + i].value;
                            });
                            if (columnValues.every(function(v) {
                                return null == v;
                            })) return "continue";
                            if (dataFlags.hasXY && !location) {
                                var xValueIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.x), yValueIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.y), xValue = parseNumber(columnValues[xValueIndex]), yValue = parseNumber(columnValues[yValueIndex]);
                                null != xValue && null != yValue && (location = {
                                    longitude: parseNumber(xValue),
                                    latitude: parseNumber(yValue)
                                });
                            }
                            var seriesNode = columns[col], identityBuilder = (new selectionId.dw).withColumnIdentity(seriesNode.identity, seriesSource.queryName, series[col].valueDetails).withColumnIdentity(categoryNode.identity, lastCategorySource.queryName, categoryValueDetails), tooltipInfo = (0, 
                            tslib_es6.__spreadArray)([], categoryTooltipItems, !0);
                            tooltipInfo.push({
                                displayName: seriesSource.displayName,
                                value: series[col].value
                            });
                            for (var i = 0; i < valueLength; i++) {
                                var tooltipValue = columnValues[i];
                                null !== tooltipValue && tooltipInfo.push({
                                    displayName: valueSources[i].displayName,
                                    value: (0, converterHelper.xq)(tooltipValue, valueSources[i], azureMap_capabilities.MC.general.formatString)
                                });
                            }
                            subDataPoints.push({
                                size: dataFlags.hasSize ? Math.min(sizeValue, azureMapConstant.Y4) : 1,
                                color: series[col].color,
                                identity: identityBuilder.createSelectionId(),
                                selected: !1,
                                tooltipInfo,
                                seriesIndex: col
                            });
                        }, col = 0; col < columns.length; col++) _loop_1(col); else {
                            if (dataFlags.hasXY) {
                                var xValueIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.x), yValueIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.y);
                                location = {
                                    longitude: parseNumber(categoryNode.values[xValueIndex].value),
                                    latitude: parseNumber(categoryNode.values[yValueIndex].value)
                                };
                            }
                            var color = colorHelper.getColorForMeasure(categoryNode.objects, -1 !== sizeIndex && valueSources[sizeIndex].queryName, VisualsCommon_colorHelper.fA), identityBuilder = (new selectionId.dw).withColumnIdentity(categoryNode.identity, lastCategorySource.queryName, categoryValueDetails), sizeValue = -1 !== sizeIndex ? parseNumber(categoryNode.values[sizeIndex].value) : 0, tooltipInfo = (0, 
                            tslib_es6.__spreadArray)([], categoryTooltipItems, !0);
                            if (dataFlags.hasPointOrder && (pointOrder = AzureMapConverter.getPointOrderValueFromNode(categoryNode.values[pointOrderIndex], pointOrder)), 
                            !_.isEmpty(columns)) for (col = 0; col < columns.length; col++) {
                                var tooltipValue = categoryNode.values[col].value;
                                null !== tooltipValue && tooltipInfo.push({
                                    displayName: valueSources[col].displayName,
                                    value: (0, converterHelper.xq)(tooltipValue, valueSources[col], azureMap_capabilities.MC.general.formatString)
                                });
                            }
                            subDataPoints.push({
                                size: Math.min(sizeValue, azureMapConstant.Y4),
                                color,
                                identity: identityBuilder.createSelectionId(),
                                selected: !1,
                                tooltipInfo
                            });
                        }
                        if (location && AzureMapConverter.AreLatLongInvalid(location)) dataFlags.hasInvalidLatLong = !0; else if (subDataPoints.length > 0) {
                            var dataPoint = {
                                queryLocation,
                                location,
                                subDataPoints,
                                categoryValue,
                                pointOrder
                            };
                            pathID.length > 0 && (dataPoint.pathID = pathID), debug.fF.assertNonEmpty(dataPoint.subDataPoints, "subDataPoints should be defined and its length > 0"), 
                            dataPoints.push(dataPoint), pathID.length > 0 && (paths.has(pathID) ? paths.get(pathID).push(dataPoints.length - 1) : paths.set(pathID, [ dataPoints.length - 1 ])), 
                            interactivityService && selectablePoints.push.apply(selectablePoints, dataPoint.subDataPoints);
                        }
                    });
                }), interactivityService && selectablePoints.length > 0 && interactivityService.applySelectionStateToData(selectablePoints), 
                {
                    dataPoints,
                    paths
                };
            }, AzureMapConverter.convertMatrixWithoutCategory = function(dataFlags, matrix, series, colorHelper, interactivityService, featureSwitches) {
                if (!dataFlags.hasXY) return {
                    dataPoints: []
                };
                var shouldDrawPaths = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID, rows = shouldDrawPaths ? matrix.rows.root.children || [] : [ {
                    children: matrix.rows.root.children || []
                } ], valueSources = matrix.valueSources, sizeIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.size), dataPoints = [], selectablePoints = [], pathIDSource = AzureMapConverter.GetSource(matrix.rows.levels[0].sources, azureMap_capabilities.Wx.pathID), paths = new Map, pointOrderIndex = AzureMapConverter.GetValueIndexForRole(valueSources, azureMap_capabilities.Wx.pointOrder);
                if (dataFlags.hasSeries) {
                    var seriesLevelIndex = shouldDrawPaths ? 1 : 0, xyLevel = matrix.rows.levels[seriesLevelIndex + 1], seriesSource_1 = AzureMapConverter.GetSource(matrix.rows.levels[seriesLevelIndex].sources, azureMap_capabilities.Wx.series), xSource_1 = AzureMapConverter.GetSource(xyLevel.sources, azureMap_capabilities.Wx.x), ySource_1 = AzureMapConverter.GetSource(xyLevel.sources, azureMap_capabilities.Wx.y), seriesIdentityFields_1 = AzureMapConverter.getRowBasedSeriesIdentityFields(matrix, dataFlags, featureSwitches), seriesIndex_1 = 0;
                    rows.forEach(function(pathIDNode) {
                        var latLongMap = {}, children = pathIDNode.children, pathID = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID && String(pathIDNode.levelValues[0].value) || "";
                        children.forEach(function(seriesNode) {
                            var pointOrder, seriesValue = (0, converterHelper.xq)(seriesNode.levelValues[0].value, seriesSource_1, azureMap_capabilities.MC.general.formatString), seriesColor = colorHelper.getColorForSeriesValue(seriesNode.objects, seriesIdentityFields_1, seriesValue, VisualsCommon_colorHelper.fA), seriesValueDetails = AzureMapConverter.getSeriesValueDetails(featureSwitches, seriesNode, seriesSource_1), seriesIdBuilder = (new selectionId.dw).withColumnIdentity(seriesNode.identity, seriesSource_1.queryName, seriesValueDetails);
                            series.push({
                                value: seriesValue,
                                color: seriesColor,
                                identity: seriesIdBuilder.createSelectionId(),
                                selected: !1
                            }), seriesNode.children.forEach(function(xyNode) {
                                var dataPointValue = AzureMapConverter.getDataPointValueFromXyNode(xyNode, sizeIndex, xSource_1, ySource_1, valueSources, {
                                    displayName: seriesSource_1.displayName,
                                    value: seriesValue
                                });
                                if (dataFlags.hasPointOrder && (pointOrder = AzureMapConverter.getPointOrderValueFromNode(xyNode.values[pointOrderIndex], pointOrder)), 
                                AzureMapConverter.AreLatLongInvalid(dataPointValue.location)) dataFlags.hasInvalidLatLong = !0; else {
                                    var xValueDetails = AzureMapConverter.getXYValueDetails(featureSwitches, xyNode, xSource_1, dataPointValue), yValueDetails = AzureMapConverter.getXYValueDetails(featureSwitches, xyNode, ySource_1, dataPointValue), identityBuilder = (new selectionId.dw).withColumnIdentity(seriesNode.identity, seriesSource_1.queryName, seriesValueDetails).withColumnIdentity(xyNode.identity, xSource_1.queryName, xValueDetails).withColumnIdentity(xyNode.identity, ySource_1.queryName, yValueDetails);
                                    if (pathID.length > 0) {
                                        var pathIDValueDetails = AzureMapConverter.getPathIDValueDetails(featureSwitches, pathIDNode, pathIDSource);
                                        identityBuilder.withColumnIdentity(pathIDNode.identity, pathIDSource.queryName, pathIDValueDetails);
                                    }
                                    var subDataPoint = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataPointValue.subDataPoint), {
                                        size: Math.min(dataPointValue.subDataPoint.size, azureMapConstant.Y4),
                                        color: seriesColor,
                                        identity: identityBuilder.createSelectionId(),
                                        selected: !1,
                                        seriesIndex: seriesIndex_1
                                    }), latLongKey = "".concat(dataPointValue.location.latitude, ",").concat(dataPointValue.location.longitude), aggregateDuplicatedPoints = featureSwitches.azureMapsLatLongPieCharts;
                                    if (aggregateDuplicatedPoints && latLongKey in latLongMap) latLongMap[latLongKey].subDataPoints.push(subDataPoint), 
                                    dataFlags.hasDuplicatedLatLong = !0; else {
                                        var dataPoint = {
                                            location: dataPointValue.location,
                                            categoryValue: dataPointValue.categoryValue,
                                            subDataPoints: [ subDataPoint ],
                                            pointOrder
                                        };
                                        debug.fF.assertNonEmpty(dataPoint.subDataPoints, "subDataPoints should be defined and its length > 0"), 
                                        pathID.length > 0 && (dataPoint.pathID = pathID), dataPoints.push(dataPoint), pathID.length > 0 && (paths.has(pathID) ? paths.get(pathID).push(dataPoints.length - 1) : paths.set(pathID, [ dataPoints.length - 1 ])), 
                                        aggregateDuplicatedPoints && (latLongMap[latLongKey] = dataPoint);
                                    }
                                    interactivityService && selectablePoints.push(subDataPoint);
                                }
                            }), seriesIndex_1++;
                        });
                    });
                } else {
                    var sizeSource_1 = -1 !== sizeIndex && valueSources[sizeIndex].queryName, xSource_2 = AzureMapConverter.GetSource((xyLevel = matrix.rows.levels[shouldDrawPaths ? 1 : 0]).sources, azureMap_capabilities.Wx.x), ySource_2 = AzureMapConverter.GetSource(xyLevel.sources, azureMap_capabilities.Wx.y);
                    rows.forEach(function(pathIDNode) {
                        var children = pathIDNode.children, pathID = featureSwitches.azureMapsPathLayer && dataFlags.hasPathID && String(pathIDNode.levelValues[0].value) || "";
                        children.forEach(function(node) {
                            var dataPointValue = AzureMapConverter.getDataPointValueFromXyNode(node, sizeIndex, xSource_2, ySource_2, valueSources), pointOrder = dataFlags.hasPointOrder ? AzureMapConverter.getPointOrderValueFromNode(node.values[pointOrderIndex]) : null;
                            if (AzureMapConverter.AreLatLongInvalid(dataPointValue.location)) dataFlags.hasInvalidLatLong = !0; else {
                                var color = colorHelper.getColorForMeasure(node.objects, sizeSource_1, VisualsCommon_colorHelper.fA), xValueDetails = AzureMapConverter.getXYValueDetails(featureSwitches, node, xSource_2, dataPointValue), yValueDetails = AzureMapConverter.getXYValueDetails(featureSwitches, node, ySource_2, dataPointValue), identityBuilder = (new selectionId.dw).withColumnIdentity(node.identity, xSource_2.queryName, xValueDetails).withColumnIdentity(node.identity, ySource_2.queryName, yValueDetails);
                                pathID.length > 0 && identityBuilder.withColumnIdentity(pathIDNode.identity, pathIDSource.queryName, AzureMapConverter.getPathIDValueDetails(featureSwitches, pathIDNode, pathIDSource));
                                var dataPoint = {
                                    location: dataPointValue.location,
                                    categoryValue: dataPointValue.categoryValue,
                                    subDataPoints: [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, dataPointValue.subDataPoint), {
                                        size: Math.min(dataPointValue.subDataPoint.size, azureMapConstant.Y4),
                                        color,
                                        identity: identityBuilder.createSelectionId(),
                                        selected: !1
                                    }) ],
                                    pointOrder
                                };
                                debug.fF.assertNonEmpty(dataPoint.subDataPoints, "subDataPoints should be defined and its length > 0"), 
                                pathID.length > 0 && (dataPoint.pathID = pathID), dataPoints.push(dataPoint), pathID.length > 0 && (paths.has(pathID) ? paths.get(pathID).push(dataPoints.length - 1) : paths.set(pathID, [ dataPoints.length - 1 ])), 
                                interactivityService && selectablePoints.push.apply(selectablePoints, dataPoint.subDataPoints);
                            }
                        });
                    });
                }
                return interactivityService && selectablePoints.length > 0 && interactivityService.applySelectionStateToData(selectablePoints), 
                {
                    dataPoints,
                    paths
                };
            }, AzureMapConverter.getRowBasedSeriesIdentityFields = function(matrix, dataFlags, featureSwitches) {
                if (!featureSwitches.azureMapsPathLayer || !dataFlags.hasPathID) return matrix.rows.root.childIdentityFields;
                var seriesColumnIdentifiersMap = new Map;
                return matrix.rows.root.children.flatMap(function(node) {
                    return node.childIdentityFields;
                }).forEach(function(identifier) {
                    var stringifyIdentifier = JSON.stringify(identifier);
                    seriesColumnIdentifiersMap.has(stringifyIdentifier) || seriesColumnIdentifiersMap.set(stringifyIdentifier, identifier);
                }), Array.from(seriesColumnIdentifiersMap.values());
            }, AzureMapConverter.getDataPointValueFromXyNode = function(xyNode, sizeIndex, xSource, ySource, tooltipValueSources, seriesTooltipItem) {
                var longitude = parseNumber(xyNode.levelValues[0].value), formattedLongitude = (0, 
                converterHelper.xq)(longitude, xSource, azureMap_capabilities.MC.general.formatString), latitude = parseNumber(xyNode.levelValues[1].value), formattedLatitude = (0, 
                converterHelper.xq)(latitude, ySource, azureMap_capabilities.MC.general.formatString), sizeValue = -1 !== sizeIndex ? parseNumber(xyNode.values[sizeIndex].value) : 1, tooltipInfo = [];
                void 0 !== seriesTooltipItem && tooltipInfo.push(seriesTooltipItem), tooltipInfo.push({
                    displayName: ySource.displayName,
                    value: formattedLatitude
                }), tooltipInfo.push({
                    displayName: xSource.displayName,
                    value: formattedLongitude
                });
                for (var i = 0; i < tooltipValueSources.length; i++) {
                    var tooltipValue = xyNode.values[i].value;
                    null !== tooltipValue && tooltipInfo.push({
                        displayName: tooltipValueSources[i].displayName,
                        value: (0, converterHelper.xq)(tooltipValue, tooltipValueSources[i], azureMap_capabilities.MC.general.formatString)
                    });
                }
                return {
                    location: {
                        latitude,
                        longitude
                    },
                    subDataPoint: {
                        tooltipInfo,
                        size: sizeValue
                    },
                    categoryValue: formattedLatitude + ", " + formattedLongitude,
                    formattedLatitude,
                    formattedLongitude
                };
            }, AzureMapConverter.getSeriesValueDetails = function(featureSwitches, seriesNode, seriesSource) {
                var seriesValueDetails;
                if (featureSwitches.interactivityServiceCaching) {
                    seriesValueDetails = [];
                    for (var _i = 0, _a = seriesNode.levelValues; _i < _a.length; _i++) {
                        var levelValue = _a[_i];
                        seriesValueDetails.push({
                            expr: seriesSource.expr,
                            formattedValue: (0, converterHelper.xq)(levelValue.value, seriesSource, azureMap_capabilities.MC.general.formatString),
                            value: levelValue.value,
                            identity: seriesNode.identity
                        });
                    }
                }
                return seriesValueDetails;
            }, AzureMapConverter.getCategoryValueDetails = function(featureSwitches, categoryNode, categorySources, repeatCategorySource) {
                var categoryValueDetails;
                if (featureSwitches.interactivityServiceCaching) {
                    categoryValueDetails = [];
                    for (var categoryLevelValues = categoryNode.levelValues, index = 0; index < categoryLevelValues.length; index++) {
                        var categorySource = repeatCategorySource ? categorySources[0] : categorySources[index];
                        categoryValueDetails.push({
                            expr: categorySource.expr,
                            formattedValue: (0, converterHelper.xq)(categoryLevelValues[index].value, categorySource, azureMap_capabilities.MC.general.formatString),
                            value: categoryLevelValues[index].value,
                            identity: categoryNode.identity
                        });
                    }
                }
                return categoryValueDetails;
            }, AzureMapConverter.getXYValueDetails = function(featureSwitches, node, xySource, dataPointValue) {
                var xyValueDetails;
                return featureSwitches.interactivityServiceCaching && (xyValueDetails = [ {
                    expr: xySource.expr,
                    formattedValue: dataPointValue.formattedLongitude,
                    value: dataPointValue.location.longitude,
                    identity: node.identity
                } ]), xyValueDetails;
            }, AzureMapConverter.getPathIDValueDetails = function(featureSwitches, pathIDNode, pathIDSource) {
                if (featureSwitches.interactivityServiceCaching) for (var _i = 0, _a = pathIDNode.levelValues; _i < _a.length; _i++) {
                    var levelValue = _a[_i];
                    (void 0).push({
                        expr: pathIDSource.expr,
                        formattedValue: (0, converterHelper.xq)(levelValue.value, pathIDSource, azureMap_capabilities.MC.general.formatString),
                        value: levelValue.value,
                        identity: pathIDNode.identity
                    });
                }
            }, AzureMapConverter.getGeocodingCategory = function(column, geoTaggingAnalyzerService) {
                var geotaggedResult;
                if (geotaggedResult = geoTaggingAnalyzerService.getFieldTypeFromDescriptor(column.type)) return geotaggedResult;
                if (geotaggedResult = geoTaggingAnalyzerService.getFieldType(column.displayName)) return geotaggedResult;
                var roles = column.roles;
                if (roles) for (var roleNames = Object.keys(roles), i = 0, len = roleNames.length; i < len; ++i) {
                    var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                    if (typeFromRoleName) return typeFromRoleName;
                }
            }, AzureMapConverter.calculateDataLabelSettings = function(dataView, style) {
                var dataLabelSettings = this.getDefaultMapLabelSettings(style), staticObjects = dataView.metadata.objects;
                if (staticObjects) {
                    dataLabelSettings.showCategory = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.categoryLabels.show, dataLabelSettings.showCategory);
                    var categoryLabelsObj = staticObjects.categoryLabels;
                    categoryLabelsObj && (0, dataLabelViewModel1.ww)(categoryLabelsObj, dataLabelSettings, void 0, style);
                    var colorHelper = common_colorHelper.v.create(style);
                    dataLabelSettings.enableBackground = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.categoryLabels.enableBackground, !0), 
                    dataLabelSettings.backgroundColor = colorHelper.getColorForProperty(staticObjects, azureMap_capabilities.MC.categoryLabels.backgroundColor, azureMapConstant.Dy), 
                    dataLabelSettings.backgroundTransparency = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.categoryLabels.backgroundTransparency, 100 * azureMapConstant._O) / 100;
                }
                return dataLabelSettings;
            }, AzureMapConverter.getDefaultMapLabelSettings = function(style) {
                var defaultColor = common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl), defaultFontProperties = (0, 
                dataLabelViewModel1.bT)({
                    style,
                    labelColor: defaultColor,
                    textClassName: "smallLightLabel"
                }).fontProperties;
                return {
                    show: !1,
                    showCategory: !1,
                    position: 0,
                    fontProperties: defaultFontProperties = (0, common_fontProperties.ED)(defaultFontProperties, {
                        color: defaultColor
                    }),
                    enableBackground: !0,
                    backgroundColor: common_colorHelper.v.getThemeColor(style, azureMapConstant.Dy),
                    backgroundTransparency: azureMapConstant._O,
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, AzureMapConverter.getDefaultMapData = function(style, featureSwitches) {
                return {
                    dataPoints: [],
                    dataLabelSettings: this.getDefaultMapLabelSettings(style),
                    properties: {
                        mapControls: AzureMapConverter.getMapControlProperties(null),
                        traffic: AzureMapConverter.getTrafficProperties(null),
                        tile: AzureMapConverter.getTileLayerProperties(null),
                        filledMap: AzureMapConverter.getFilledMapProperties(null, style),
                        bubble: AzureMapConverter.getBubbleLayerProperties(null, style),
                        heatMap: AzureMapConverter.getHeatMapLayerProperties(null, style),
                        barChart: AzureMapConverter.getBarChartProperties(null, style),
                        commonDataOptions: AzureMapConverter.getCommonDataLayerProperties(null, !1, [], featureSwitches),
                        referenceLayer: AzureMapConverter.getReferenceLayerProperties(null)
                    },
                    shouldRenderFilledMap: !1,
                    geocodingCategory: "",
                    hasCategory: !1,
                    hasSeries: !1,
                    hasXY: !1,
                    hasSize: !1,
                    hasInvalidLatLong: !1,
                    hasInvalidGeocodingCulture: !1,
                    hasDuplicatedLatLong: !1,
                    hasPathID: !1,
                    colorHelper: common_colorHelper.v.create(style, azureMap_capabilities.MC.dataPoint.fill),
                    series: [],
                    paths: null
                };
            }, AzureMapConverter.getMapControlProperties = function(staticObjects) {
                return {
                    styleProperties: {
                        defaultStyle: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.defaultStyle, azureMap_capabilities.a.grayscaleLight),
                        showLabels: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.showLabels, !0),
                        worldWrap: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.worldWrap, !0)
                    },
                    controlToggles: {
                        showStylePicker: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.showStylePicker, !0),
                        showNavigationControls: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.showNavigationControls, !0),
                        showSelectionControl: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.showSelectionControl, !1)
                    },
                    cameraProperties: {
                        zoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.zoom, 0),
                        centerLatitude: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.centerLatitude, 0),
                        centerLongitude: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.centerLongitude, 0),
                        heading: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.heading, 0),
                        pitch: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.pitch, 0),
                        autoZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.autoZoom, !0)
                    },
                    geocodingCulture: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.mapControls.geocodingCulture, geocodingCulture.gA)
                };
            }, AzureMapConverter.getTrafficProperties = function(staticObjects) {
                return {
                    showTraffic: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.traffic.showTraffic, !1),
                    showIncidents: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.traffic.showIncidents, !0),
                    showTrafficControl: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.traffic.showTrafficControl, !1)
                };
            }, AzureMapConverter.getTileLayerProperties = function(staticObjects) {
                return {
                    tileLayerUrl: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.tileLayerUrl, ""),
                    tileSize: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.tileSize, 512),
                    northBounds: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.northBounds, 85.0511),
                    southBounds: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.southBounds, -85.0511),
                    eastBounds: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.eastBounds, 180),
                    westBounds: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.westBounds, -180),
                    transparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.transparency, 0),
                    isTMS: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.isTMS, !1),
                    minZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.minZoom, azureMapConstant.JX),
                    maxZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.maxZoom, azureMapConstant.Yd),
                    layerPosition: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.tileLayer.layerPosition, "labels")
                };
            }, AzureMapConverter.getFilledMapProperties = function(staticObjects, style) {
                return {
                    showFilledMap: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.show, !1),
                    defaultColor: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.filledMap.defaultColor, style.colorPalette.dataColors.getColorByIndex(0).value),
                    transparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.transparency, 0),
                    strokeColor: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.filledMap.strokeColor, style.colorPalette.backgroundDark.value),
                    strokeTransparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.strokeTransparency, 0),
                    strokeWidth: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.strokeWidth, 1),
                    minZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.minZoom, azureMapConstant.JX),
                    maxZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.maxZoom, azureMapConstant.Yd),
                    layerPosition: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.filledMap.layerPosition, "labels")
                };
            }, AzureMapConverter.getBubbleLayerProperties = function(staticObjects, style) {
                var radius = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.radius, 5), singleBubbleFilledColor = (0, 
                dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.dataPoint.fill, common_colorHelper.v.getDataColorByIndex(style, 0)), singleBubbleStrokeColor = (0, 
                dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.bubbleLayer.strokeColor, style.colorPalette.background.value), singleBubbleStrokeWidth = (0, 
                dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.strokeWidth, 2);
                return {
                    showBubbleLayer: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.show, !0),
                    transparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.transparency, 0),
                    radius,
                    minRadius: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.minRadius, 5),
                    markerRangeType: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.markerRangeType, markerRangeType.Dl.dataRange),
                    radiusScalingMethod: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.radiusScalingMethod, 0),
                    maxRadius: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.maxRadius, 30),
                    autoStrokeColor: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.autoStrokeColor, !1),
                    strokeColor: singleBubbleStrokeColor,
                    strokeTransparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.strokeTransparency, 0),
                    strokeWidth: singleBubbleStrokeWidth,
                    blur: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.blur, 0),
                    pitchAlignment: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.pitchAlignment, "viewport"),
                    zoomScaleFactor: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.zoomScaleFactor, 1),
                    logScale: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.logScale, 2),
                    x1: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.x1, .15),
                    x2: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.x2, .85),
                    y1: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.y1, .7),
                    y2: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.y2, .3),
                    minZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.minZoom, azureMapConstant.JX),
                    maxZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.maxZoom, azureMapConstant.Yd),
                    layerPosition: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.layerPosition, "labels"),
                    clusteringEnabled: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteringEnabled, !1),
                    clusteredBubbleRadius: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteredBubbleRadius, Math.max(radius, 12)),
                    clusteredBubbleFillColor: style.isHighContrast ? common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.fA) : (0, 
                    dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFillColor, singleBubbleFilledColor),
                    clusteredBubbleFontColor: style.isHighContrast ? common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.U) : (0, 
                    dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFontColor, common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.U)),
                    clusteredBubbleFontSize: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFontSize, 18),
                    clusteredBubbleStrokeColor: style.isHighContrast ? common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.U) : (0, 
                    dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteredBubbleStrokeColor, singleBubbleStrokeColor),
                    clusteredBubbleStrokeWidth: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.clusteredBubbleStrokeWidth, singleBubbleStrokeWidth)
                };
            }, AzureMapConverter.getHeatMapLayerProperties = function(staticObjects, style) {
                var heatMapGradientScale = this.getHeatMapGradientColorScale(style);
                return {
                    showHeatMapLayer: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.show, !1),
                    heatMapRadius: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapRadius, 20),
                    heatMapRadiusUnit: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapRadiusUnit, azureMapConstant.c8),
                    heatMapTransparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapTransparency, 0),
                    heatMapIntensity: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapIntensity, 1),
                    heatMapColorLow: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapColorLow, heatMapGradientScale(0)),
                    heatMapColorCenter: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapColorCenter, heatMapGradientScale(.5)),
                    heatMapColorHigh: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapColorHigh, heatMapGradientScale(1)),
                    heatMapUseSize: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.heatMapUseSize, !1),
                    minZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.minZoom, azureMapConstant.JX),
                    maxZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.maxZoom, azureMapConstant.Yd),
                    layerPosition: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.heatMapLayer.layerPosition, "labels")
                };
            }, AzureMapConverter.getBarChartProperties = function(staticObjects, style) {
                return {
                    dataProperties: {
                        showBarChart: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.show, !1),
                        barShape: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.barShape, 0),
                        thickness: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.thickness, 1),
                        scaleThicknessOnZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.scaleThicknessOnZoom, !0)
                    },
                    paintProperties: {
                        height: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.height, 1),
                        scaleHeightOnZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.scaleHeightOnZoom, !0),
                        defaultColor: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.barChart.defaultColor, style.colorPalette.dataColors.getColorByIndex(0).value),
                        transparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.transparency, 0),
                        minZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.minZoom, azureMapConstant.JX),
                        maxZoom: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.maxZoom, azureMapConstant.Yd),
                        layerPosition: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.barChart.layerPosition, "labels")
                    }
                };
            }, AzureMapConverter.getCommonDataLayerProperties = function(staticObjects, hasSize, dataPoints, featureSwitches) {
                for (var commonProperties = {
                    unselectedTransparency: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.commonDataOptions.unselectedTransparency, 80)
                }, dataPointValues = [], _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var sumOfSubDataPoints = _.sum(dataPoints_1[_i].subDataPoints.map(function(p) {
                        return p.size;
                    }));
                    dataPointValues.push(sumOfSubDataPoints);
                }
                if (hasSize) {
                    var showZeros = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.commonDataOptions.showZeros, !0), showNegatives = (0, 
                    dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.commonDataOptions.showNegatives, !0), rangeType = (0, 
                    dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.bubbleLayer.markerRangeType, void 0), sizeValues = (0, 
                    tslib_es6.__spreadArray)([], dataPointValues, !0);
                    (!rangeType || rangeType === markerRangeType.Dl.deprecated) && (showNegatives && !showZeros ? sizeValues = dataPointValues.map(function(d) {
                        return Math.abs(d);
                    }).filter(function(s) {
                        return s > 0;
                    }) : showNegatives ? sizeValues = dataPointValues.map(function(d) {
                        return Math.abs(d);
                    }) : showZeros || (sizeValues = dataPointValues.filter(function(s) {
                        return s > 0;
                    })));
                    var minValueFromData = Math.min.apply(Math, sizeValues), maxValueFromData = Math.max.apply(Math, sizeValues);
                    commonProperties.showZeros = showZeros, commonProperties.showNegatives = showNegatives, 
                    commonProperties.minDataValue = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.commonDataOptions.minDataValue, minValueFromData), 
                    commonProperties.maxDataValue = (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.commonDataOptions.maxDataValue, maxValueFromData);
                }
                return commonProperties;
            }, AzureMapConverter.getReferenceLayerProperties = function(staticObjects) {
                var defaults = new ReferenceDataLayerOptions;
                return {
                    additionalDatasource: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.referenceLayer.additionalDatasource, void 0),
                    referenceLayerUrl: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.referenceLayer.referenceLayerUrl, ""),
                    datasourceType: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.referenceLayer.datasourceType, "file_upload"),
                    bubble: (0, tslib_es6.__assign)({
                        fillColor: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.referenceLayerBubble.fillColor, defaults.bubble.fillColor),
                        fillOpacity: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.referenceLayerBubble.fillOpacity, defaults.bubble.fillOpacity)
                    }, (0, strokeStyle.QI)(staticObjects, azureMap_capabilities.MC.referenceLayerBubble, defaults.bubble)),
                    line: (0, strokeStyle.QI)(staticObjects, azureMap_capabilities.MC.referenceLayerLine, defaults.line),
                    polygon: (0, tslib_es6.__assign)({
                        fillColor: (0, dataViewObject2.W7)(staticObjects, azureMap_capabilities.MC.referenceLayerPolygon.fillColor, defaults.polygon.fillColor),
                        fillOpacity: (0, dataViewObject2.NA)(staticObjects, azureMap_capabilities.MC.referenceLayerPolygon.fillOpacity, defaults.polygon.fillOpacity)
                    }, (0, strokeStyle.QI)(staticObjects, azureMap_capabilities.MC.referenceLayerPolygon, defaults.polygon))
                };
            }, AzureMapConverter.GetSource = function(sources, roleName) {
                return sources.find(function(source) {
                    return (0, dataRoleHelper.nu)(source, roleName);
                });
            }, AzureMapConverter.HaveRole = function(sources, roleName) {
                return -1 !== sources.findIndex(function(source) {
                    return (0, dataRoleHelper.nu)(source, roleName);
                });
            }, AzureMapConverter.GetValueIndexForRole = function(valueSources, roleName) {
                return valueSources.findIndex(function(valueSource) {
                    return (0, dataRoleHelper.nu)(valueSource, roleName);
                });
            }, AzureMapConverter.AreLatLongInvalid = function(location) {
                return !location || (0, mapUtil.IU)(location.latitude, location.longitude);
            }, AzureMapConverter.getPointOrderValueFromNode = function(nodeValue, curPointOrder) {
                var _a;
                return null != curPointOrder ? curPointOrder : null !== (_a = parseNumber(nodeValue.value)) && void 0 !== _a ? _a : AzureMapConverter.parseDate(nodeValue.value);
            }, AzureMapConverter.parseDate = function(value) {
                return value instanceof Date ? value : "string" == typeof value ? isNaN(Date.parse(value)) ? null : new Date(value) : "number" == typeof value ? new Date(value) : null;
            }, AzureMapConverter;
        }(), colorEnumerationHelper2 = __webpack_require__(32554), visualLocKeys = __webpack_require__(33024), formatUtil = __webpack_require__(59694), AzureMapFormatModelHelper = function() {
            function AzureMapFormatModelHelper() {}
            return AzureMapFormatModelHelper.getMapSettingsCard = function(props, featureSwitches, localize) {
                var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.mapControls), "Visual_AzureMapsMapSettings", azureMap_capabilities.MC.mapControls, localize).withDescription("Visual_MapControlsDescription");
                return cardBuilder.addGroup("style", function(groupBuilder) {
                    groupBuilder.withDisplayName("Style").addSimpleSlice(azureMap_capabilities.MC.mapControls.defaultStyle, new build_control_util.uY({
                        descriptor: azureMap_capabilities.MC.mapControls.defaultStyle,
                        value: props.mapControls.styleProperties.defaultStyle
                    }).build()), featureSwitches.azureMapsShowLabels && groupBuilder.addSimpleSlice(azureMap_capabilities.MC.mapControls.showLabels, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.mapControls.showLabels,
                        value: props.mapControls.styleProperties.showLabels
                    }).build());
                }).addGroup("view", function(groupBuilder) {
                    groupBuilder.withDisplayName("View").addSimpleSlice(azureMap_capabilities.MC.mapControls.autoZoom, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.mapControls.autoZoom,
                        value: props.mapControls.cameraProperties.autoZoom
                    }).build()).addSimpleSlice(azureMap_capabilities.MC.mapControls.zoom, new build_control_util.JN({
                        descriptor: azureMap_capabilities.MC.mapControls.zoom,
                        value: props.mapControls.cameraProperties.zoom,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.JX
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Yd
                            }
                        },
                        localize
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(props.mapControls.cameraProperties.autoZoom);
                    }).addSimpleSlice(azureMap_capabilities.MC.mapControls.centerLatitude, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.mapControls.centerLatitude,
                        value: props.mapControls.cameraProperties.centerLatitude,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.U1
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.hW
                            },
                            unitSymbol: visualLocKeys.g
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(props.mapControls.cameraProperties.autoZoom);
                    }).addSimpleSlice(azureMap_capabilities.MC.mapControls.centerLongitude, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.mapControls.centerLongitude,
                        value: props.mapControls.cameraProperties.centerLongitude,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.Nq
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Yi
                            },
                            unitSymbol: visualLocKeys.g
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(props.mapControls.cameraProperties.autoZoom);
                    }).addSimpleSlice(azureMap_capabilities.MC.mapControls.heading, new build_control_util.JN({
                        descriptor: azureMap_capabilities.MC.mapControls.heading,
                        value: props.mapControls.cameraProperties.heading,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.Yl
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Ix
                            },
                            unitSymbol: visualLocKeys.g
                        },
                        localize
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(props.mapControls.cameraProperties.autoZoom);
                    }).addSimpleSlice(azureMap_capabilities.MC.mapControls.pitch, new build_control_util.JN({
                        descriptor: azureMap_capabilities.MC.mapControls.pitch,
                        value: props.mapControls.cameraProperties.pitch,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.WL
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.a_
                            },
                            unitSymbol: visualLocKeys.g
                        },
                        localize
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled(props.mapControls.cameraProperties.autoZoom);
                    });
                }).addGroup("controls", function(groupBuilder) {
                    groupBuilder.withDisplayName("Controls").addSimpleSlice(azureMap_capabilities.MC.mapControls.worldWrap, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.mapControls.worldWrap,
                        value: props.mapControls.styleProperties.worldWrap
                    }).build()).addSimpleSlice(azureMap_capabilities.MC.mapControls.showStylePicker, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.mapControls.showStylePicker,
                        value: props.mapControls.controlToggles.showStylePicker
                    }).build()).addSimpleSlice(azureMap_capabilities.MC.mapControls.showNavigationControls, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.mapControls.showNavigationControls,
                        value: props.mapControls.controlToggles.showNavigationControls
                    }).build(), function(slicerBuilder) {
                        return slicerBuilder.withCustomDisplayName("Navigation");
                    }).addSimpleSlice(azureMap_capabilities.MC.mapControls.showSelectionControl, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.mapControls.showSelectionControl,
                        value: props.mapControls.controlToggles.showSelectionControl
                    }).build(), function(slicerBuilder) {
                        return slicerBuilder.withCustomDisplayName("ExplorationCanvasItemsPane_Title");
                    }), featureSwitches.azureMapsGeocoding && groupBuilder.addSimpleSlice(azureMap_capabilities.MC.mapControls.geocodingCulture, new build_control_util.uY({
                        descriptor: azureMap_capabilities.MC.mapControls.geocodingCulture,
                        value: props.mapControls.geocodingCulture || geocodingCulture.gA
                    }).build());
                }), cardBuilder.build();
            }, AzureMapFormatModelHelper.getLayerSettingsCard = function(data, props, featureSwitches, localize) {
                var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.commonDataOptions), "Visual_AzureMapsCommonDataLayer", azureMap_capabilities.MC.commonDataOptions, localize).withDescription("Visual_AzureMapsCommonDataLayerDescription");
                return data.hasSize && cardBuilder.addGroup("values", function(groupBuilder) {
                    groupBuilder.withDisplayName("Role_DisplayName_Values").addSimpleSlice(azureMap_capabilities.MC.commonDataOptions.minDataValue, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.commonDataOptions.minDataValue,
                        value: props.commonDataOptions.minDataValue,
                        options: {
                            maxValue: {
                                type: 1,
                                value: props.commonDataOptions.maxDataValue
                            }
                        }
                    }).build(), function(slicerBuilder) {
                        return slicerBuilder.withCustomDisplayName("Aggregate_Min");
                    }).addSimpleSlice(azureMap_capabilities.MC.commonDataOptions.maxDataValue, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.commonDataOptions.maxDataValue,
                        value: props.commonDataOptions.maxDataValue,
                        options: {
                            minValue: {
                                type: 0,
                                value: props.commonDataOptions.minDataValue
                            }
                        }
                    }).build(), function(slicerBuilder) {
                        return slicerBuilder.withCustomDisplayName("Aggregate_Max");
                    });
                }), cardBuilder.addGroup("options", function(groupBuilder) {
                    groupBuilder.withDisplayName("Desktop_FileMenu_Options").addSimpleSlice(azureMap_capabilities.MC.commonDataOptions.unselectedTransparency, build_control_util.JN.getTransparencySliderBuilder({
                        descriptor: azureMap_capabilities.MC.commonDataOptions.unselectedTransparency,
                        value: props.commonDataOptions.unselectedTransparency,
                        localize
                    }).build());
                }), cardBuilder.build();
            }, AzureMapFormatModelHelper.getLegendCard = function(hostService, legendData, featureSwitches, data) {
                return (0, legend_formatting.ZF)({
                    legendData
                }, hostService, featureSwitches, !data.hasSeries);
            }, AzureMapFormatModelHelper.getBubbleCard = function(data, dataView, props, seriesOptionsBuilder, categoryOptionsBuilder, featureSwitches, localize) {
                if (data && data.dataPoints && 0 !== data.dataPoints.length && dataView) {
                    var exclusivelyRenderPieChart = data.hasCategory && data.hasSeries, detectedDuplicatedLatLong = featureSwitches.azureMapsLatLongPieCharts && data.hasDuplicatedLatLong, bubbleLayerPropsExcludeCluster = _.omit(azureMap_capabilities.MC.bubbleLayer, [ "clusteringEnabled", "clusteredBubbleFillColor", "clusteredBubbleFontColor", "clusteredBubbleFontSize", "clusteredBubbleRadius", "clusteredBubbleStrokeColor", "clusteredBubbleStrokeWidth" ]), cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.bubbleLayer), "Visual_AzureMapsBubbleLayer", (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, bubbleLayerPropsExcludeCluster), azureMap_capabilities.MC.dataPoint), localize).withDescription("Visual_BubblesDescription");
                    return cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.show,
                            value: props.bubble.showBubbleLayer
                        }).build();
                    }), cardBuilder.addGroup("size", function(groupBuilder) {
                        var _a;
                        if (groupBuilder.withDisplayName("Visual_BubbleSize"), data.hasSize) {
                            groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.minRadius, new build_control_util.JN({
                                descriptor: azureMap_capabilities.MC.bubbleLayer.minRadius,
                                value: props.bubble.minRadius,
                                options: {
                                    minValue: {
                                        type: 0,
                                        value: azureMapConstant.Fw
                                    },
                                    maxValue: {
                                        type: 1,
                                        value: Math.min(azureMapConstant.rn, props.bubble.maxRadius)
                                    },
                                    unitSymbol: visualLocKeys.e_
                                },
                                localize
                            }).build(), function(slicerBuilder) {
                                return slicerBuilder.withCustomDisplayName("Aggregate_Min");
                            }).addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.maxRadius, new build_control_util.JN({
                                descriptor: azureMap_capabilities.MC.bubbleLayer.maxRadius,
                                value: props.bubble.maxRadius,
                                options: {
                                    minValue: {
                                        type: 0,
                                        value: Math.max(azureMapConstant.Fw, props.bubble.minRadius)
                                    },
                                    maxValue: {
                                        type: 1,
                                        value: azureMapConstant.rn
                                    },
                                    unitSymbol: visualLocKeys.e_
                                },
                                localize
                            }).build(), function(slicerBuilder) {
                                return slicerBuilder.withCustomDisplayName("Aggregate_Max");
                            });
                            var getLocalizedString_1 = {
                                get: function(key) {
                                    return localize(key);
                                },
                                getOptional: function(key) {
                                    return localize(key);
                                },
                                format: function(key) {
                                    return localize(key);
                                }
                            }, items = _.map(markerRangeType.Yu, function(enumValue) {
                                return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, enumValue), {
                                    displayName: enumValue.displayName(getLocalizedString_1)
                                });
                            }), value = null !== (_a = items.find(function(item) {
                                return item.value === props.bubble.markerRangeType;
                            })) && void 0 !== _a ? _a : {
                                value: markerRangeType.Dl.deprecated,
                                displayName: localize("Visual_MarkerRangeType_Deprecated")
                            };
                            groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.markerRangeType, new build_control_util.uY({
                                descriptor: azureMap_capabilities.MC.bubbleLayer.markerRangeType,
                                items,
                                value
                            }).build(), function(slicerBuilder) {
                                return slicerBuilder.withCustomDisplayName("Visual_MarkerRangeType");
                            });
                        } else groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.radius, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.radius,
                            value: props.bubble.radius,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.Fw
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.rn
                                },
                                unitSymbol: visualLocKeys.e_
                            },
                            localize
                        }).build());
                    }).addGroup("shape", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Shape").addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.transparency, build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.transparency,
                            value: props.bubble.transparency,
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Transparency");
                        });
                    }).addGroup("colors", function(groupBuilder) {
                        if (groupBuilder.withDisplayName("Visual_Colors"), data.hasSeries) {
                            var groupSeriesColorsOptions = seriesOptionsBuilder(groupBuilder);
                            (0, colorEnumerationHelper2.y0)(groupSeriesColorsOptions);
                        } else {
                            var groupCategoryColorsOptions = categoryOptionsBuilder(groupBuilder);
                            (0, colorEnumerationHelper2.jN)(groupCategoryColorsOptions);
                        }
                    }).addGroup("border", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Border"), exclusivelyRenderPieChart || groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.autoStrokeColor, new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.autoStrokeColor,
                            value: props.bubble.autoStrokeColor
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("BuiltInReportThemeHighContrast").withDisabled(detectedDuplicatedLatLong).withCustomDescriptionIf(function() {
                                return detectedDuplicatedLatLong;
                            }, "Visual_AzureMapsDisabledOptionForPieChartDescription");
                        }), props.bubble.autoStrokeColor && !exclusivelyRenderPieChart || groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.strokeColor, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.strokeColor,
                            value: {
                                value: props.bubble.strokeColor
                            }
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Generic_Color");
                        }), groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.strokeTransparency, build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.strokeTransparency,
                            value: props.bubble.strokeTransparency,
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Transparency");
                        }).addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.strokeWidth, new build_control_util.mu({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.strokeWidth,
                            value: props.bubble.strokeWidth,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.Bc
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Qv
                                },
                                unitSymbol: visualLocKeys.e_
                            }
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Visual_General_Properties_Width");
                        }), exclusivelyRenderPieChart || groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.blur, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.blur,
                            value: props.bubble.blur,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.fN
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.fQ
                                },
                                unitSymbol: visualLocKeys.e_
                            },
                            localize
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withDisabled(detectedDuplicatedLatLong).withCustomDescriptionIf(function() {
                                return detectedDuplicatedLatLong;
                            }, "Visual_AzureMapsDisabledOptionForPieChartDescription");
                        });
                    }).addGroup("zoom", function(groupBuilder) {
                        return groupBuilder.withDisplayName("Visual_ShapeMap_Zoom").addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.maxZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.maxZoom,
                            value: props.bubble.maxZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Max");
                        }).addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.minZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.minZoom,
                            value: props.bubble.minZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Min");
                        });
                    }).addGroup("options", function(groupBuilder) {
                        groupBuilder.withDisplayName("Desktop_FileMenu_Options"), exclusivelyRenderPieChart || groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.pitchAlignment, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.pitchAlignment,
                            value: props.bubble.pitchAlignment
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withDisabled(detectedDuplicatedLatLong).withCustomDescriptionIf(function() {
                                return detectedDuplicatedLatLong;
                            }, "Visual_AzureMapsDisabledOptionForPieChartDescription");
                        }), groupBuilder.addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.layerPosition, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.layerPosition,
                            value: props.bubble.layerPosition
                        }).build());
                    }), cardBuilder.build();
                }
            }, AzureMapFormatModelHelper.getBubbleClusteringCard = function(data, dataView, props, featureSwitches, localize) {
                if (featureSwitches.azureMapsBubbleCluster && data && data.dataPoints && 0 !== data.dataPoints.length && dataView) {
                    var clusteredBubbleProps = _.pick(azureMap_capabilities.MC.bubbleLayer, [ "clusteringEnabled", "clusteredBubbleFillColor", "clusteredBubbleFontColor", "clusteredBubbleFontSize", "clusteredBubbleRadius", "clusteredBubbleStrokeColor", "clusteredBubbleStrokeWidth" ]), cardBuilder = new build_control_util.CQ(new build_control_util.lg("bubbleClustering"), "Visual_AzureMapsClusterBubbles", clusteredBubbleProps, localize).withDescription("Visual_AzureMapsClusterBubbles_Description");
                    return cardBuilder.addTopLevelToggle("clusteringEnabled", function() {
                        return new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteringEnabled,
                            value: props.bubble.clusteringEnabled
                        }).build();
                    }).addGroup("size", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_BubbleSize").addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.clusteredBubbleRadius, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteredBubbleRadius,
                            value: props.bubble.clusteredBubbleRadius,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.Fw
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.rn
                                },
                                unitSymbol: visualLocKeys.e_
                            },
                            localize
                        }).build());
                    }).addGroup("colors", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Colors").addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFillColor, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFillColor,
                            value: {
                                value: props.bubble.clusteredBubbleFillColor
                            }
                        }).build());
                    }).addGroup("value", function(groupBuilder) {
                        groupBuilder.withDisplayName("Role_DisplayName_Values").addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFontSize, new build_control_util.mu({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFontSize,
                            value: props.bubble.clusteredBubbleFontSize,
                            options: build_control_util.JJ
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFontColor, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteredBubbleFontColor,
                            value: {
                                value: props.bubble.clusteredBubbleFontColor
                            }
                        }).build());
                    }).addGroup("border", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Border").addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.clusteredBubbleStrokeColor, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteredBubbleStrokeColor,
                            value: {
                                value: props.bubble.clusteredBubbleStrokeColor
                            }
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.bubbleLayer.clusteredBubbleStrokeWidth, new build_control_util.mu({
                            descriptor: azureMap_capabilities.MC.bubbleLayer.clusteredBubbleStrokeWidth,
                            value: props.bubble.clusteredBubbleStrokeWidth,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.Bc
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Qv
                                },
                                unitSymbol: visualLocKeys.e_
                            }
                        }).build());
                    }), data.properties.bubble.showBubbleLayer || cardBuilder.withDisabled(!0, "Visual_AzureMaps_FormatOption_DisabledReason_ClusterBubble"), 
                    cardBuilder.build();
                }
            }, AzureMapFormatModelHelper.getCategoryLabelCard = function(data, props, dataLabelsSettings, style, featureSwitches, localize) {
                if (featureSwitches.azureMapsCategoryLabels && data && data.dataPoints && 0 !== data.dataPoints.length) {
                    var categoryLabelsProps = azureMap_capabilities.MC.categoryLabels;
                    return (0, dataLabelViewModel1.Zu)({
                        cardName: "Visual_CategoryLabels",
                        dataLabelSettings: dataLabelsSettings,
                        isShowCategory: !1,
                        localize,
                        props: categoryLabelsProps,
                        revertToDefaultProps: categoryLabelsProps,
                        showBackground: !0,
                        showValueColor: !0,
                        style,
                        disabled: !props.bubble.showBubbleLayer,
                        disabledReason: "Visual_AzureMapsCategoryLabelsDisabledReason_BubbleLayerOff"
                    });
                }
            }, AzureMapFormatModelHelper.getHeatMapCard = function(data, props, localize) {
                if (data && data.dataPoints && 0 !== data.dataPoints.length) {
                    var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.heatMapLayer), "Visual_HeatMap", azureMap_capabilities.MC.heatMapLayer, localize).withDescription("Visual_HeatMapDescription");
                    return cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.show,
                            value: props.heatMap.showHeatMapLayer
                        }).build();
                    }).addGroup("size", function(groupBuilder) {
                        var maxHeatMapRadius = azureMapConstant.OH;
                        "meters" === props.heatMap.heatMapRadiusUnit && (maxHeatMapRadius = azureMapConstant.NI), 
                        groupBuilder.withDisplayName("Visual_BubbleSize").addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapRadius, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapRadius,
                            value: props.heatMap.heatMapRadius,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant._0
                                },
                                maxValue: {
                                    type: 1,
                                    value: maxHeatMapRadius
                                },
                                unitSymbol: visualLocKeys.e_
                            },
                            localize
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapRadiusUnit, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapRadiusUnit,
                            value: props.heatMap.heatMapRadiusUnit
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_DisplayUnits");
                        }).addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapIntensity, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapIntensity,
                            value: props.heatMap.heatMapIntensity,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.x6
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Dz
                                }
                            },
                            localize
                        }).build()), data.hasSize && groupBuilder.addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapUseSize, new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapUseSize,
                            value: props.heatMap.heatMapUseSize
                        }).build());
                    }).addGroup("colors", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Colors").addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapColorLow, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapColorLow,
                            value: {
                                value: props.heatMap.heatMapColorLow
                            }
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapColorCenter, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapColorCenter,
                            value: {
                                value: props.heatMap.heatMapColorCenter
                            }
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapColorHigh, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapColorHigh,
                            value: {
                                value: props.heatMap.heatMapColorHigh
                            }
                        }).build());
                    }).addGroup("zoom", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_ShapeMap_Zoom").addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.maxZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.maxZoom,
                            value: props.heatMap.maxZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Max");
                        }).addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.minZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.minZoom,
                            value: props.heatMap.minZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Min");
                        });
                    }).addGroup("options", function(groupBuilder) {
                        groupBuilder.withDisplayName("Desktop_FileMenu_Options").addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.heatMapTransparency, build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.heatMapTransparency,
                            value: props.heatMap.heatMapTransparency,
                            localize
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.heatMapLayer.layerPosition, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.heatMapLayer.layerPosition,
                            value: props.heatMap.layerPosition
                        }).build());
                    }), data.hasSeries && cardBuilder.withDisabled(!0, "Visual_AzureMapsHeatMapFormatOptionDisabledReason"), 
                    cardBuilder.build();
                }
            }, AzureMapFormatModelHelper.getFilledMapCard = function(data, dataView, props, filledMapSwitch, seriesOptionsBuilder, categoryOptionsBuilder, localize) {
                if (filledMapSwitch && data && data.dataPoints && 0 !== data.dataPoints.length && dataView) {
                    var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.filledMap), "FilledMap_ToolTip", (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, azureMap_capabilities.MC.filledMap), azureMap_capabilities.MC.dataPoint), localize).withDescription("Visual_AzureMapsFilledMapDescription");
                    return cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.filledMap.show,
                            value: props.filledMap.showFilledMap
                        }).build();
                    }).addGroup("shape", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Shape").addSimpleSlice(azureMap_capabilities.MC.filledMap.transparency, build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: azureMap_capabilities.MC.filledMap.transparency,
                            value: props.filledMap.transparency,
                            localize
                        }).build());
                    }).addGroup("colors", function(groupBuilder) {
                        if (groupBuilder.withDisplayName("Visual_Colors"), data.hasSeries) {
                            var groupSeriesColorsOptions = seriesOptionsBuilder(groupBuilder);
                            (0, colorEnumerationHelper2.y0)(groupSeriesColorsOptions);
                        } else {
                            var groupCategoryColorsOptions = categoryOptionsBuilder(groupBuilder);
                            (0, colorEnumerationHelper2.jN)(groupCategoryColorsOptions);
                        }
                    }).addGroup("border", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Border").addSimpleSlice(azureMap_capabilities.MC.filledMap.strokeColor, new build_control_util.BT({
                            descriptor: azureMap_capabilities.MC.filledMap.strokeColor,
                            value: {
                                value: props.filledMap.strokeColor
                            }
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Generic_Color");
                        }).addSimpleSlice(azureMap_capabilities.MC.filledMap.strokeTransparency, build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: azureMap_capabilities.MC.filledMap.strokeTransparency,
                            value: props.filledMap.strokeTransparency,
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Transparency");
                        }).addSimpleSlice(azureMap_capabilities.MC.filledMap.strokeWidth, new build_control_util.mu({
                            descriptor: azureMap_capabilities.MC.filledMap.strokeWidth,
                            value: props.filledMap.strokeWidth,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.Bc
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Qv
                                },
                                unitSymbol: visualLocKeys.e_
                            }
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Visual_General_Properties_Width");
                        });
                    }).addGroup("zoom", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_ShapeMap_Zoom").addSimpleSlice(azureMap_capabilities.MC.filledMap.maxZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.filledMap.maxZoom,
                            value: props.filledMap.maxZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Max");
                        }).addSimpleSlice(azureMap_capabilities.MC.filledMap.minZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.filledMap.minZoom,
                            value: props.filledMap.minZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Min");
                        });
                    }).addGroup("options", function(groupBuilder) {
                        groupBuilder.withDisplayName("Desktop_FileMenu_Options").addSimpleSlice(azureMap_capabilities.MC.filledMap.layerPosition, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.filledMap.layerPosition,
                            value: props.filledMap.layerPosition
                        }).build());
                    }), data.hasSize && cardBuilder.withDisabled(!0, "Visual_AzureMaps_FormatOption_DisabledReason_FilledMap"), 
                    cardBuilder.build();
                }
            }, AzureMapFormatModelHelper.getBarChartCard = function(data, dataView, props, seriesOptionsBuilder, categoryOptionsBuilder, localize) {
                if (data && data.dataPoints && 0 !== data.dataPoints.length && dataView) {
                    var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.barChart), "Visual_AzureMapsBarChartLayer", (0, 
                    tslib_es6.__assign)((0, tslib_es6.__assign)({}, azureMap_capabilities.MC.barChart), azureMap_capabilities.MC.dataPoint), localize).withDescription("Visual_AzureMapsBarChartDescription");
                    return cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.barChart.show,
                            value: props.barChart.dataProperties.showBarChart
                        }).build();
                    }).addGroup("size", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_BubbleSize").addSimpleSlice(azureMap_capabilities.MC.barChart.height, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.barChart.height,
                            value: props.barChart.paintProperties.height,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.Z3
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.t
                                },
                                unitSymbol: visualLocKeys.e_
                            },
                            localize
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.barChart.thickness, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.barChart.thickness,
                            value: props.barChart.dataProperties.thickness,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.z$
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.W5
                                },
                                unitSymbol: visualLocKeys.e_
                            },
                            localize
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.barChart.scaleHeightOnZoom, new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.barChart.scaleHeightOnZoom,
                            value: props.barChart.paintProperties.scaleHeightOnZoom
                        }).build()).addSimpleSlice(azureMap_capabilities.MC.barChart.scaleThicknessOnZoom, new build_control_util.bd({
                            descriptor: azureMap_capabilities.MC.barChart.scaleThicknessOnZoom,
                            value: props.barChart.dataProperties.scaleThicknessOnZoom
                        }).build());
                    }).addGroup("shape", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Shape").addSimpleSlice(azureMap_capabilities.MC.barChart.barShape, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.barChart.barShape,
                            value: props.barChart.dataProperties.barShape
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Style");
                        }).addSimpleSlice(azureMap_capabilities.MC.barChart.transparency, build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: azureMap_capabilities.MC.barChart.transparency,
                            value: props.barChart.paintProperties.transparency,
                            localize
                        }).build());
                    }).addGroup("colors", function(groupBuilder) {
                        if (groupBuilder.withDisplayName("Visual_Colors"), data.hasSeries) {
                            var groupSeriesColorsOptions = seriesOptionsBuilder(groupBuilder);
                            (0, colorEnumerationHelper2.y0)(groupSeriesColorsOptions);
                        } else {
                            var groupCategoryColorsOptions = categoryOptionsBuilder(groupBuilder);
                            (0, colorEnumerationHelper2.jN)(groupCategoryColorsOptions);
                        }
                    }).addGroup("zoom", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_ShapeMap_Zoom").addSimpleSlice(azureMap_capabilities.MC.barChart.maxZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.barChart.maxZoom,
                            value: props.barChart.paintProperties.maxZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Max");
                        }).addSimpleSlice(azureMap_capabilities.MC.barChart.minZoom, new build_control_util.JN({
                            descriptor: azureMap_capabilities.MC.barChart.minZoom,
                            value: props.barChart.paintProperties.minZoom,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: azureMapConstant.JX
                                },
                                maxValue: {
                                    type: 1,
                                    value: azureMapConstant.Yd
                                }
                            },
                            localize
                        }).build(), function(slicerBuilder) {
                            return slicerBuilder.withCustomDisplayName("Aggregate_Min");
                        });
                    }).addGroup("options", function(groupBuilder) {
                        groupBuilder.withDisplayName("Desktop_FileMenu_Options").addSimpleSlice(azureMap_capabilities.MC.barChart.layerPosition, new build_control_util.uY({
                            descriptor: azureMap_capabilities.MC.barChart.layerPosition,
                            value: props.barChart.paintProperties.layerPosition
                        }).build());
                    }), cardBuilder.build();
                }
            }, AzureMapFormatModelHelper.getReferenceLayerCard = function(props, featureSwitches, localize) {
                var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.referenceLayer), "Visual_AzureMapsReferenceLayer", (0, 
                tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)((0, 
                tslib_es6.__spreadArray)([], Object.values(azureMap_capabilities.MC.referenceLayer), !0), Object.values(azureMap_capabilities.MC.referenceLayerLine), !0), Object.values(azureMap_capabilities.MC.referenceLayerPolygon), !0), Object.values(azureMap_capabilities.MC.referenceLayerBubble), !0), localize);
                return cardBuilder.withDescription(featureSwitches.azureMapsMultiDataFormats ? "Visual_AzureMapsReferenceLayerDescriptionMultiDataFormats" : "Visual_AzureMapsReferenceLayerDescription"), 
                cardBuilder.addGroup(featureSwitches.azureMapsCustomFormattingReferenceLayer ? azureMap_capabilities.DQ.dataSource : azureMap_capabilities.Do.referenceLayer, function(groupBuilder) {
                    if (featureSwitches.azureMapsCustomFormattingReferenceLayer && groupBuilder.withDisplayName("Data_Source"), 
                    featureSwitches.azureMapsMultiDataFormats) if (groupBuilder.addSimpleSlice(azureMap_capabilities.MC.referenceLayer.datasourceType, new build_control_util.uY({
                        descriptor: azureMap_capabilities.MC.referenceLayer.datasourceType,
                        value: props.referenceLayer.datasourceType
                    }).build()), "url" === props.referenceLayer.datasourceType) {
                        var referenceUrlDescriptor = featureSwitches.azureMapsDynamicReferenceLayer ? (0, 
                        tslib_es6.__assign)((0, tslib_es6.__assign)({}, azureMap_capabilities.MC.referenceLayer.referenceLayerUrl), {
                            instanceKind: 3
                        }) : azureMap_capabilities.MC.referenceLayer.referenceLayerUrl;
                        groupBuilder.addSimpleSlice(azureMap_capabilities.MC.referenceLayer.referenceLayerUrl, new build_control_util.fq({
                            descriptor: referenceUrlDescriptor,
                            value: props.referenceLayer.referenceLayerUrl,
                            placeholder: ""
                        }).build());
                    } else "file_upload" === props.referenceLayer.datasourceType && groupBuilder.addSimpleSlice(azureMap_capabilities.MC.referenceLayer.additionalDatasource, new build_control_util.vX({
                        descriptor: azureMap_capabilities.MC.referenceLayer.additionalDatasource,
                        value: props.referenceLayer.additionalDatasource,
                        isAzMapReferenceSelector: !0,
                        enableMultipleDataFormats: featureSwitches.azureMapsMultiDataFormats,
                        keepIconURLs: featureSwitches.azureMapsMultiDataFormatsKeepIconURLs
                    }).build()); else groupBuilder.addSimpleSlice(azureMap_capabilities.MC.referenceLayer.additionalDatasource, new build_control_util.vX({
                        descriptor: azureMap_capabilities.MC.referenceLayer.additionalDatasource,
                        value: props.referenceLayer.additionalDatasource,
                        isAzMapReferenceSelector: !0
                    }).build());
                }), featureSwitches.azureMapsCustomFormattingReferenceLayer && cardBuilder.addGroup(azureMap_capabilities.DQ.point, function(groupBuilder) {
                    return groupBuilder.withDisplayName("Visual_Forecast_Units_Point").withDescription("AzureMapVisual_ReferenceLayer_Style_Message").addSimpleSlice(azureMap_capabilities.MC.referenceLayerBubble.fillColor, new build_control_util.BT({
                        descriptor: azureMap_capabilities.MC.referenceLayerBubble.fillColor,
                        value: {
                            value: props.referenceLayer.bubble.fillColor
                        }
                    }).build()).addSlices((0, strokeStyle.Iq)({
                        containerItemBuilder: groupBuilder,
                        descriptors: azureMap_capabilities.MC.referenceLayerBubble,
                        strokeData: props.referenceLayer.bubble,
                        selector: null,
                        maxWidth: azureMapConstant.Qv,
                        localize
                    }).map(function(slice) {
                        return slice.build();
                    }));
                }).addGroup(azureMap_capabilities.DQ.line, function(groupBuilder) {
                    return groupBuilder.withDisplayName("Visual_Lines").withDescription("AzureMapVisual_ReferenceLayer_Style_Message").addSlices((0, 
                    strokeStyle.Iq)({
                        containerItemBuilder: groupBuilder,
                        descriptors: azureMap_capabilities.MC.referenceLayerLine,
                        strokeData: props.referenceLayer.line,
                        selector: null,
                        maxWidth: azureMapConstant.Qv,
                        localize
                    }).map(function(slice) {
                        return slice.build();
                    }));
                }).addGroup(azureMap_capabilities.DQ.polygon, function(groupBuilder) {
                    return groupBuilder.withDisplayName("AzureMapVisual_Polygons").withDescription("AzureMapVisual_ReferenceLayer_Style_Message").addSimpleSlice(azureMap_capabilities.MC.referenceLayerPolygon.fillColor, new build_control_util.BT({
                        descriptor: azureMap_capabilities.MC.referenceLayerPolygon.fillColor,
                        value: {
                            value: props.referenceLayer.polygon.fillColor
                        }
                    }).build()).addSlices((0, strokeStyle.Iq)({
                        containerItemBuilder: groupBuilder,
                        descriptors: azureMap_capabilities.MC.referenceLayerPolygon,
                        strokeData: props.referenceLayer.polygon,
                        selector: null,
                        maxWidth: azureMapConstant.Qv,
                        localize
                    }).map(function(slice) {
                        return slice.build();
                    }));
                }), cardBuilder.build();
            }, AzureMapFormatModelHelper.getTrafficCard = function(props, localize) {
                var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.traffic), "Visual_AzureMapsTrafficLayer", azureMap_capabilities.MC.traffic, localize).withDescription("Visual_AzureMapsTrafficLayerDescription");
                return cardBuilder.addTopLevelToggle("show", function() {
                    return new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.traffic.showTraffic,
                        value: props.traffic.showTraffic
                    }).build();
                }).addGroup(azureMap_capabilities.Do.traffic, function(groupBuilder) {
                    groupBuilder.addSimpleSlice(azureMap_capabilities.MC.traffic.showIncidents, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.traffic.showIncidents,
                        value: props.traffic.showIncidents
                    }).build()), groupBuilder.addSimpleSlice(azureMap_capabilities.MC.traffic.showTrafficControl, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.traffic.showTrafficControl,
                        value: props.traffic.showTrafficControl
                    }).build());
                }), cardBuilder.build();
            }, AzureMapFormatModelHelper.getTileLayerCard = function(props, localize) {
                var cardBuilder = new build_control_util.CQ(new build_control_util.lg(azureMap_capabilities.Do.tileLayer), "Visual_AzureMapsTileLayer", azureMap_capabilities.MC.tileLayer, localize).withDescription("Visual_AzureMapsTileLayerDescription");
                return cardBuilder.addGroup("tile", function(groupBuilder) {
                    groupBuilder.withDisplayName("Tile_Generic").addSimpleSlice(azureMap_capabilities.MC.tileLayer.tileLayerUrl, new build_control_util.fq({
                        descriptor: azureMap_capabilities.MC.tileLayer.tileLayerUrl,
                        value: props.tile.tileLayerUrl,
                        placeholder: ""
                    }).build()).addSimpleSlice(azureMap_capabilities.MC.tileLayer.tileSize, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.tileLayer.tileSize,
                        value: props.tile.tileSize,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.nv
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Co
                            },
                            unitSymbol: visualLocKeys.e_
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    });
                }).addGroup("view", function(groupBuilder) {
                    groupBuilder.withDisplayName("View").addSimpleSlice(azureMap_capabilities.MC.tileLayer.northBounds, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.tileLayer.northBounds,
                        value: props.tile.northBounds,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.U1
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.hW
                            },
                            unitSymbol: visualLocKeys.g
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    }).addSimpleSlice(azureMap_capabilities.MC.tileLayer.southBounds, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.tileLayer.southBounds,
                        value: props.tile.southBounds,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.U1
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.hW
                            },
                            unitSymbol: visualLocKeys.g
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    }).addSimpleSlice(azureMap_capabilities.MC.tileLayer.eastBounds, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.tileLayer.eastBounds,
                        value: props.tile.eastBounds,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.Nq
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Yi
                            },
                            unitSymbol: visualLocKeys.g
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    }).addSimpleSlice(azureMap_capabilities.MC.tileLayer.westBounds, new build_control_util.mu({
                        descriptor: azureMap_capabilities.MC.tileLayer.westBounds,
                        value: props.tile.westBounds,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.Nq
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Yi
                            },
                            unitSymbol: visualLocKeys.g
                        }
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    });
                }).addGroup("zoom", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_ShapeMap_Zoom").addSimpleSlice(azureMap_capabilities.MC.tileLayer.maxZoom, new build_control_util.JN({
                        descriptor: azureMap_capabilities.MC.tileLayer.maxZoom,
                        value: props.tile.maxZoom,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.JX
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Yd
                            }
                        },
                        localize
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl)).withCustomDisplayName("Aggregate_Max");
                    }).addSimpleSlice(azureMap_capabilities.MC.tileLayer.minZoom, new build_control_util.JN({
                        descriptor: azureMap_capabilities.MC.tileLayer.minZoom,
                        value: props.tile.minZoom,
                        options: {
                            minValue: {
                                type: 0,
                                value: azureMapConstant.JX
                            },
                            maxValue: {
                                type: 1,
                                value: azureMapConstant.Yd
                            }
                        },
                        localize
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl)).withCustomDisplayName("Aggregate_Min");
                    });
                }).addGroup("operations", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_AzureMapsOperations").addSimpleSlice(azureMap_capabilities.MC.tileLayer.transparency, build_control_util.JN.getTransparencySliderBuilder({
                        descriptor: azureMap_capabilities.MC.tileLayer.transparency,
                        value: props.tile.transparency,
                        localize
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    }).addSimpleSlice(azureMap_capabilities.MC.tileLayer.isTMS, new build_control_util.bd({
                        descriptor: azureMap_capabilities.MC.tileLayer.isTMS,
                        value: props.tile.isTMS
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    }).addSimpleSlice(azureMap_capabilities.MC.tileLayer.layerPosition, new build_control_util.uY({
                        descriptor: azureMap_capabilities.MC.tileLayer.layerPosition,
                        value: props.tile.layerPosition
                    }).build(), function(sliceBuilder) {
                        return sliceBuilder.withDisabled((0, formatUtil.g)(props.tile.tileLayerUrl));
                    });
                }), cardBuilder.build();
            }, AzureMapFormatModelHelper;
        }(), AzureMapLandingPage = function() {
            function AzureMapLandingPage(rootElement) {
                this.rootElement = rootElement;
            }
            return AzureMapLandingPage.prototype.display = function() {
                null == this.container && (this.container = jQuery('<div class="azureMapSplashDiv"><div class="azureMapsSplash" aria-live="polite"><div class="azureMapsSplashLogo"></div></div></div>'), 
                this.rootElement.prepend(this.container));
            }, AzureMapLandingPage.prototype.remove = function() {
                this.container && (this.container.remove(), this.container = null);
            }, AzureMapLandingPage;
        }(), dataLabelRendererEnhanced = __webpack_require__(5381), labelLayout1 = __webpack_require__(63972), textMeasurementService = __webpack_require__(32041), browserUtils = __webpack_require__(59107), keyUtils = __webpack_require__(9795), selector = __webpack_require__(32379), geoJson = __webpack_require__(52967), azureMapExpressionHelper = __webpack_require__(72118), azureMapFeatureHelper = __webpack_require__(81293), pieChartFactory = __webpack_require__(49988), ReferenceDataLayer = function() {
            function ReferenceDataLayer(datasource, options) {
                this._options = new ReferenceDataLayerOptions, this._datasource = datasource;
                var customizedOptions = _.merge(_.cloneDeep(this._options), _.cloneDeep(options));
                this.setLayers(customizedOptions), this.setOptions(customizedOptions);
            }
            return ReferenceDataLayer.prototype.setLayers = function(options) {
                var style = options.style, unselectedTransparency = options.unselectedTransparency;
                this._layers = {
                    bubbleLayer: new atlas.layer.BubbleLayer(this._datasource, null, (0, tslib_es6.__assign)({
                        filter: [ "all", [ "!", [ "has", "image" ] ], [ "any", [ "==", [ "geometry-type" ], "Point" ], [ "==", [ "geometry-type" ], "MultiPoint" ] ] ],
                        radius: [ "case", [ "has", "size" ], [ "*", [ "get", "size" ], 4 ], [ "has", "marker-size" ], [ "match", [ "get", "marker-size" ], "small", 6, "medium", 8, "large", 12, 1 ], [ "has", "scale" ], [ "*", [ "get", "scale" ], 4 ], 4 ],
                        color: ReferenceDataLayer.bubbleFillColorExp(options.bubble.fillColor, style),
                        opacity: ReferenceDataLayer.getFillOpacityExp(options.bubble.fillOpacity, unselectedTransparency)
                    }, ReferenceDataLayer.getStrokeExpression(options.bubble, unselectedTransparency, style, !0))),
                    extrudedPolygonLayer: new atlas.layer.PolygonExtrusionLayer(this._datasource, null, {
                        base: [ "case", [ "has", "base" ], [ "get", "base" ], 0 ],
                        fillColor: [ "case", [ "has", "fillColor" ], [ "get", "fillColor" ], [ "has", "fill" ], [ "get", "fill" ], "#1e90ff" ],
                        filter: [ "all", [ "any", [ "==", [ "geometry-type" ], "Polygon" ], [ "==", [ "geometry-type" ], "MultiPolygon" ] ], [ "all", [ "has", "height" ], [ "!=", [ "get", "height" ], 0 ] ] ],
                        height: [ "get", "height" ]
                    }),
                    polygonBorderLayer: new atlas.layer.LineLayer(this._datasource, null, (0, tslib_es6.__assign)({
                        filter: [ "any", [ "==", [ "geometry-type" ], "Polygon" ], [ "==", [ "geometry-type" ], "MultiPolygon" ] ]
                    }, ReferenceDataLayer.getStrokeExpression(options.polygon, unselectedTransparency, style))),
                    lineLayer: new atlas.layer.LineLayer(this._datasource, null, (0, tslib_es6.__assign)({
                        filter: [ "any", [ "==", [ "geometry-type" ], "LineString" ], [ "==", [ "geometry-type" ], "MultiLineString" ] ]
                    }, ReferenceDataLayer.getStrokeExpression(options.line, unselectedTransparency, style))),
                    polygonLayer: new atlas.layer.PolygonLayer(this._datasource, null, {
                        fillColor: ReferenceDataLayer.polygonFillColorExp(options.polygon.fillColor, style),
                        fillOpacity: ReferenceDataLayer.getFillOpacityExp(options.polygon.fillOpacity, unselectedTransparency),
                        filter: [ "all", [ "any", [ "==", [ "geometry-type" ], "Polygon" ], [ "==", [ "geometry-type" ], "MultiPolygon" ] ], [ "any", [ "!", [ "has", "height" ] ], [ "==", [ "get", "height" ], 0 ] ] ]
                    }),
                    symbolLayer: new atlas.layer.SymbolLayer(this._datasource, null, {
                        filter: [ "all", [ "any", [ "==", [ "geometry-type" ], "Point" ], [ "==", [ "geometry-type" ], "MultiPoint" ] ] ],
                        iconOptions: {
                            allowOverlap: !0,
                            anchor: [ "case", [ "has", "anchor" ], [ "match", [ "get", "anchor" ], [ "center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right" ], [ "get", "anchor" ], "bottom" ], "bottom" ],
                            ignorePlacement: !0,
                            image: [ "case", [ "has", "image" ], [ "get", "image" ], "none" ],
                            offset: [ "case", [ "has", "offset" ], [ "get", "offset" ], [ "literal", [ 0, 0 ] ] ],
                            rotation: [ "case", [ "has", "rotation" ], [ "get", "rotation" ], 0 ],
                            size: [ "case", [ "has", "size" ], [ "get", "size" ], [ "has", "marker-size" ], [ "match", [ "get", "marker-size" ], "small", .5, "medium", 1, "large", 2, 1 ], 1 ]
                        },
                        textOptions: {
                            offset: [ "case", [ "has", "image" ], [ "literal", [ 0, 1.2 ] ], [ "literal", [ 0, 2 ] ] ]
                        }
                    })
                };
            }, ReferenceDataLayer.prototype.getLayers = function() {
                var _this = this, extractedLayers = [];
                return Object.keys(this._layers).forEach(function(key) {
                    extractedLayers.push(_this._layers[key]);
                }), extractedLayers;
            }, ReferenceDataLayer.prototype.setOptions = function(newOptions) {
                var _this = this, style = newOptions.style, unselectedTransparency = newOptions.unselectedTransparency;
                this._options.allowExtrusions !== newOptions.allowExtrusions && (newOptions.allowExtrusions ? (this._layers.extrudedPolygonLayer.setOptions({
                    filter: [ "all", [ "any", [ "==", [ "geometry-type" ], "Polygon" ], [ "==", [ "geometry-type" ], "MultiPolygon" ] ], [ "all", [ "has", "height" ], [ "!=", [ "get", "height" ], 0 ] ] ],
                    visible: this._options.visible
                }), this._layers.polygonLayer.setOptions({
                    filter: [ "all", [ "any", [ "==", [ "geometry-type" ], "Polygon" ], [ "==", [ "geometry-type" ], "MultiPolygon" ] ], [ "any", [ "!", [ "has", "height" ] ], [ "==", [ "get", "height" ], 0 ] ] ]
                })) : (this._layers.extrudedPolygonLayer.setOptions({
                    visible: !1
                }), this._layers.polygonLayer.setOptions({
                    filter: [ "all", [ "any", [ "==", [ "geometry-type" ], "Polygon" ], [ "==", [ "geometry-type" ], "MultiPolygon" ] ] ]
                })));
                var updateStrokeOptions = function(current, newStyle, targetLayer, isBubble) {
                    var newExprs = ReferenceDataLayer.getStrokeExpression(newStyle, unselectedTransparency, style, isBubble);
                    current.strokeColor !== newStyle.strokeColor && targetLayer.setOptions({
                        strokeColor: newExprs.strokeColor
                    }), current.strokeWidth !== newStyle.strokeWidth && targetLayer.setOptions({
                        strokeWidth: newExprs.strokeWidth
                    }), current.strokeTransparency === newStyle.strokeTransparency && _this._options.unselectedTransparency === unselectedTransparency || targetLayer.setOptions({
                        strokeOpacity: newExprs.strokeOpacity
                    });
                };
                updateStrokeOptions(this._options.bubble, newOptions.bubble, this._layers.bubbleLayer, !0), 
                updateStrokeOptions(this._options.line, newOptions.line, this._layers.lineLayer), 
                updateStrokeOptions(this._options.polygon, newOptions.polygon, this._layers.polygonBorderLayer), 
                this._options.bubble.fillColor !== newOptions.bubble.fillColor && this._layers.bubbleLayer.setOptions({
                    color: ReferenceDataLayer.bubbleFillColorExp(newOptions.bubble.fillColor, style)
                }), this._options.polygon.fillColor !== newOptions.polygon.fillColor && this._layers.polygonLayer.setOptions({
                    fillColor: ReferenceDataLayer.polygonFillColorExp(newOptions.polygon.fillColor, style)
                }), this._options.unselectedTransparency !== unselectedTransparency && (this._layers.bubbleLayer.setOptions({
                    opacity: ReferenceDataLayer.getFillOpacityExp(newOptions.bubble.fillOpacity, unselectedTransparency)
                }), this._layers.polygonLayer.setOptions({
                    fillOpacity: ReferenceDataLayer.getFillOpacityExp(newOptions.polygon.fillOpacity, unselectedTransparency)
                })), this._options.visible !== newOptions.visible && (this._layers.polygonBorderLayer.setOptions({
                    visible: newOptions.visible
                }), this._layers.polygonLayer.setOptions({
                    visible: newOptions.visible
                }), this._layers.lineLayer.setOptions({
                    visible: newOptions.visible
                }), this._layers.extrudedPolygonLayer.setOptions({
                    visible: newOptions.visible && newOptions.allowExtrusions
                }), this._layers.bubbleLayer.setOptions({
                    visible: newOptions.visible
                }), this._layers.symbolLayer.setOptions({
                    visible: newOptions.visible
                })), this._options = newOptions;
            }, ReferenceDataLayer.prototype.onAdd = function(map) {
                map.layers.add([ this._layers.polygonLayer, this._layers.polygonBorderLayer, this._layers.lineLayer, this._layers.extrudedPolygonLayer ], "labels"), 
                map.layers.add([ this._layers.bubbleLayer, this._layers.symbolLayer ]);
            }, ReferenceDataLayer.getStrokeExpression = function(stroke, unselectedTransparency, style, isBubble) {
                var strokeColor = (null == style ? void 0 : style.isHighContrast) ? common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.U) : stroke.strokeColor;
                return {
                    strokeColor: isBubble ? strokeColor : [ "case", [ "has", "strokeColor" ], [ "get", "strokeColor" ], [ "has", "stroke" ], [ "get", "stroke" ], strokeColor ],
                    strokeOpacity: [ "case", azureMapExpressionHelper.J.getSelectionFilter(!0), (0, 
                    color.TD)(stroke.strokeTransparency), azureMapExpressionHelper.J.getSelectionFilter(!1), (0, 
                    color.TD)(unselectedTransparency), [ "has", "strokeOpacity" ], [ "get", "strokeOpacity" ], [ "has", "stroke-opacity" ], [ "get", "stroke-opacity" ], (0, 
                    color.TD)(stroke.strokeTransparency) ],
                    strokeWidth: [ "case", [ "has", "strokeWidth" ], [ "get", "strokeWidth" ], [ "has", "stroke-width" ], [ "get", "stroke-width" ], [ "has", "stroke-thickness" ], [ "get", "stroke-thickness" ], stroke.strokeWidth ],
                    lineCap: "none" === stroke.strokeDashCap ? "butt" : stroke.strokeDashCap,
                    lineJoin: stroke.strokeLineJoin
                };
            }, ReferenceDataLayer.getFillOpacityExp = function(fillOpacity, unselectedTransparency) {
                return [ "case", azureMapExpressionHelper.J.getSelectionFilter(!0), fillOpacity, azureMapExpressionHelper.J.getSelectionFilter(!1), (0, 
                color.TD)(unselectedTransparency), [ "has", "fillOpacity" ], [ "get", "fillOpacity" ], [ "has", "fill-opacity" ], [ "get", "fill-opacity" ], fillOpacity ];
            }, ReferenceDataLayer.bubbleFillColorExp = function(bubbleFillColor, style) {
                return [ "case", [ "has", "color" ], [ "get", "color" ], [ "has", "marker-color" ], [ "get", "marker-color" ], bubbleFillColor = (null == style ? void 0 : style.isHighContrast) ? common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.fA) : bubbleFillColor ];
            }, ReferenceDataLayer.polygonFillColorExp = function(polygonFillColor, style) {
                return [ "case", [ "has", "fillColor" ], [ "get", "fillColor" ], [ "has", "fill" ], [ "get", "fill" ], polygonFillColor = (null == style ? void 0 : style.isHighContrast) ? common_colorHelper.v.getThemeColor(style, VisualsCommon_colorHelper.fA) : polygonFillColor ];
            }, ReferenceDataLayer;
        }(), ReferenceDataShapeMatcher = function() {
            function ReferenceDataShapeMatcher(shapes, dataPoints) {
                this.setShapes(shapes), this.setDataPoints(dataPoints), this.createShapeDataMappings();
            }
            return ReferenceDataShapeMatcher.prototype.getDataPointFromShape = function(shape) {
                var shapePropValue = this.getShapePropValue(shape, this.shapePropName);
                if (shapePropValue) return this.shapeToData[shapePropValue];
            }, ReferenceDataShapeMatcher.prototype.getShapesFromDataPoint = function(dataPoint) {
                var dataPropValue = dataPoint.categoryValue;
                if (dataPropValue) return this.categoryToShapes[dataPropValue];
            }, ReferenceDataShapeMatcher.prototype.countShapeProps = function(shapes) {
                var propCount = {};
                return shapes.forEach(function(shape) {
                    for (var propName in shape.properties) propCount.hasOwnProperty(propName) ? propCount[propName]++ : propCount[propName] = 1;
                }), Object.entries(propCount).map(function(_a) {
                    return {
                        propName: _a[0],
                        count: _a[1]
                    };
                });
            }, ReferenceDataShapeMatcher.prototype.getShapePropValue = function(shape, propName) {
                var _a, shapePropValue = null === (_a = null == shape ? void 0 : shape.properties) || void 0 === _a ? void 0 : _a[propName];
                if ("string" == typeof shapePropValue) return shapePropValue;
            }, ReferenceDataShapeMatcher.prototype.getShapes = function() {
                return this.shapes;
            }, ReferenceDataShapeMatcher.prototype.setShapes = function(shapes) {
                this.shapes = shapes;
            }, ReferenceDataShapeMatcher.prototype.setDataPoints = function(dataPoints) {
                this.dataPoints = dataPoints;
            }, ReferenceDataShapeMatcher.prototype.clearMappings = function() {
                this.shapes = [], this.dataPoints = [], this.shapeToData = {}, this.categoryToShapes = {};
            }, ReferenceDataShapeMatcher.prototype.matchShapesToDataPoints = function(dataPointMap) {
                var maxMatchCount = 0;
                shapePropLoop: for (var _i = 0, _a = this.shapeProps; _i < _a.length; _i++) {
                    var shapeProp = _a[_i];
                    if (maxMatchCount > shapeProp.count) break shapePropLoop;
                    for (var matchCount = 0, categoryToShapes = new Map, shapeToData = new Map, unmatchedShapes = (0, 
                    tslib_es6.__spreadArray)([], this.shapes, !0), shapeIndex = unmatchedShapes.length - 1; shapeIndex >= 0; shapeIndex--) {
                        var unmatchedShape = unmatchedShapes[shapeIndex], unmatchedShapeValue = this.getShapePropValue(unmatchedShape, shapeProp.propName);
                        if (unmatchedShapeValue || 0 === unmatchedShapeValue) {
                            var unmatchedShapeValueLower = unmatchedShapeValue.toString().toLowerCase(), matchedDataPoint = dataPointMap.get(unmatchedShapeValueLower);
                            if (matchedDataPoint && (categoryToShapes.has(matchedDataPoint.categoryValue) || categoryToShapes.set(matchedDataPoint.categoryValue, []), 
                            categoryToShapes.get(matchedDataPoint.categoryValue).push(unmatchedShape), shapeToData.set(unmatchedShapeValue, matchedDataPoint), 
                            unmatchedShapes.splice(shapeIndex, 1), matchCount++), 0 === unmatchedShapes.length || 0 === dataPointMap.size) {
                                maxMatchCount = matchCount, this.shapePropName = shapeProp.propName, this.shapeToData = Object.fromEntries(shapeToData), 
                                this.categoryToShapes = Object.fromEntries(categoryToShapes);
                                break shapePropLoop;
                            }
                        }
                    }
                    matchCount > maxMatchCount && (maxMatchCount = matchCount, this.shapePropName = shapeProp.propName, 
                    this.shapeToData = Object.fromEntries(shapeToData), this.categoryToShapes = Object.fromEntries(categoryToShapes));
                }
            }, ReferenceDataShapeMatcher.prototype.createShapeDataMappings = function() {
                this.shapeProps = this.countShapeProps(this.shapes), this.shapeProps = this.shapeProps.sort(function(a, b) {
                    return b.count - a.count;
                });
                var dataPointMap = this.dataPoints.reduce(function(map, dataPoint) {
                    return dataPoint.categoryValue && map.set(dataPoint.categoryValue.toLowerCase(), dataPoint), 
                    map;
                }, new Map);
                this.matchShapesToDataPoints(dataPointMap);
            }, ReferenceDataShapeMatcher;
        }(), mapMath = __webpack_require__(2379), ControlStyler = function() {
            function ControlStyler(container, map, style) {
                var _this = this;
                this.mapStyleChanged = function() {
                    if (_.startsWith(_this.map.getStyle().style.toLowerCase(), "blank")) _this.observer || (_this.onBackgroundChange(), 
                    _this.observer = new MutationObserver(_this.onBackgroundChange), _this.observer.observe(_this.map.getMapContainer(), {
                        attributes: !0,
                        attributeFilter: [ "style" ]
                    })); else {
                        _this.observer && (_this.observer.disconnect(), delete _this.observer);
                        var theme = "light";
                        [ "satellite", "satellite_road_labels", "grayscale_dark", "night" ].indexOf(_this.map.getStyle().style) > -1 && (theme = "dark"), 
                        _this.setTheme(theme);
                    }
                }, this.onBackgroundChange = function() {
                    var theme = "light";
                    switch (_this.map.getStyle().style) {
                      case "satellite":
                      case "satellite_road_labels":
                      case "grayscale_dark":
                      case "night":
                        theme = "dark";
                    }
                    _this.setTheme(theme);
                }, this.container = container, this.map = map, this.style = style, "auto" === style ? (this.mapStyleChanged(), 
                this.map.events.add("styledata", this.mapStyleChanged)) : container.classList.add(style);
            }
            return ControlStyler.prototype.dispose = function() {
                var _this = this;
                this.container && (this.container = null), this.updateMap(null), Object.keys(this).forEach(function(k) {
                    _this[k] = null;
                });
            }, ControlStyler.prototype.updateMap = function(map) {
                this.map && "auto" === this.style && this.map.events.remove("styledata", this.mapStyleChanged), 
                this.map = map, map && "auto" === this.style && map.events.add("styledata", this.mapStyleChanged);
            }, ControlStyler.prototype.setTheme = function(theme) {
                this.theme !== theme && (this.container.classList.remove(this.theme), this.container.classList.add(theme), 
                this.theme = theme);
            }, ControlStyler;
        }(), focusManager = __webpack_require__(65302);
        function isSourceLayer(layer) {
            return "getSource" in layer;
        }
        var AzureMapMapControlHelper = function() {
            function AzureMapMapControlHelper(mapControl, host, featureSwitches, behavior, style, isTouchEvent) {
                var _this = this;
                this.mapControl = mapControl, this.host = host, this.featureSwitches = featureSwitches, 
                this.behavior = behavior, this.style = style, this.isTouchEvent = isTouchEvent, 
                this.svgMarkers = {}, this.markerIdentityKeyLastHovered = null, this.viewportSize = {
                    width: 0,
                    height: 0
                }, this.clickPieState = null, this.mapControlMoved = function() {
                    _this.drawDataLabels();
                }, this.shouldUseLegacyFormat = function() {
                    return _this.data.properties.bubble.markerRangeType === markerRangeType.Dl.deprecated;
                }, this.showTooltip = function(coordinates, identifiableDataPoint) {
                    _this.tooltipService && _this.tooltipService.show({
                        coordinates,
                        isTouchEvent: _this.isTouchEvent,
                        dataItems: identifiableDataPoint.tooltipInfo,
                        identities: identifiableDataPoint.identity ? [ identifiableDataPoint.identity.getSelectorsByColumn() ] : []
                    });
                }, this.hideTooltip = function() {
                    _this.tooltipService && _this.tooltipService.hide({
                        isTouchEvent: _this.isTouchEvent,
                        immediately: !1
                    });
                }, this.zoomChanged = function() {
                    _this.mapControl && _this.lastDataZoom !== Math.round(_this.mapControl.getCamera().zoom) && (_this.lastDataZoom = Math.round(_this.mapControl.getCamera().zoom), 
                    _this.data.properties.barChart.dataProperties.showBarChart && _this.updateFeatures());
                }, this.updateFeatures = function() {
                    var _a, _b, _c, _d, _f, _g, _h;
                    _this.featureSwitches.azureMapsDataBoundReferenceLayer && _this.referenceDataMatcher && (_this.referenceDataMatcher.setDataPoints(_this.data.dataPoints), 
                    _this.referenceDataMatcher.createShapeDataMappings());
                    var featureMapping = _this.getFeatureMapping();
                    _this.updateFeatureDataSource(_this.bubbleDataSource, featureMapping.bubble), _this.updateFeatureDataSource(_this.barChart3DDataSource, featureMapping.barChart3D), 
                    _this.updateFeatureDataSource(_this.filledMapDataSource, featureMapping.filledMap), 
                    _this.updateFeatureDataSource(_this.heatMapDataSource, featureMapping.heatMap), 
                    _this.featureSwitches.azureMapsDataBoundReferenceLayer && _this.updateFeatureDataSource(_this.referenceDataSource, featureMapping.reference), 
                    _this.features = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)((0, 
                    tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], null !== (_a = featureMapping.bubble) && void 0 !== _a ? _a : [], !0), null !== (_b = featureMapping.barChart3D) && void 0 !== _b ? _b : [], !0), null !== (_c = featureMapping.filledMap) && void 0 !== _c ? _c : [], !0), null !== (_d = featureMapping.heatMap) && void 0 !== _d ? _d : [], !0), null !== (_f = featureMapping.reference) && void 0 !== _f ? _f : [], !0), 
                    null === (_h = null === (_g = _this.behavior) || void 0 === _g ? void 0 : _g.renderSelection) || void 0 === _h || _h.call(_g, _this.behavior.visualHasSelection());
                }, this.disableControlsDefaultEvent = function(e) {
                    e.stopPropagation();
                }, this.updateOutlinesFromSubSelections = function(subSelection) {
                    var objectName = subSelection.visualObjects[0].objectName, selectorsByColumn = subSelection.visualObjects[0].selectorsByColumn, seriesIndex = _this.data.series.findIndex(function(s) {
                        return (0, selector.Ic)(s.identity.getSelectorsByColumn(), selectorsByColumn);
                    });
                    if ("bubbles" !== objectName.split("-")[0]) return [];
                    var pointsToRenderOutlines = -1 !== seriesIndex ? _this.data.dataPoints.filter(function(d) {
                        return d.subDataPoints[0].seriesIndex === seriesIndex;
                    }) : _this.data.dataPoints, radiusExp_1 = _this.bubbleLayer.getOptions().radius, camera_1 = _this.mapControl.getCamera(), shouldUseLegacyFormat_1 = _this.shouldUseLegacyFormat(), strokeWidth_1 = _this.data.properties.bubble.strokeWidth;
                    return _this.subSelectionRegionOutlineFragment = {
                        id: objectName,
                        outline: {
                            type: 0,
                            outlines: pointsToRenderOutlines.filter(function(dataPoint) {
                                return dataPoint.location;
                            }).map(function(dataPoint) {
                                var mapContainerRect = _this.mapControl.getMapContainer().getBoundingClientRect(), currentScale = mapContainerRect.width / _this.viewportSize.width, radiusXY = (shouldUseLegacyFormat_1 ? azureMapExpressionHelper.J.LEGACY_evaluateRadiusExpression(radiusExp_1, camera_1.zoom, dataPoint.subDataPoints[0].size) + strokeWidth_1 : (dataPoint.bubbleRadius || 0) + strokeWidth_1) * currentScale, centerPositions = _this.mapControl.positionsToPixels([ [ dataPoint.location.longitude, dataPoint.location.latitude ] ])[0].map(function(p) {
                                    return p * currentScale;
                                });
                                return {
                                    type: 1,
                                    x: mapContainerRect.x + centerPositions[0] - radiusXY,
                                    y: mapContainerRect.y + centerPositions[1] - radiusXY,
                                    width: 2 * radiusXY,
                                    height: 2 * radiusXY
                                };
                            })
                        }
                    }, [ _this.subSelectionRegionOutlineFragment ];
                }, this.clearLastHoverMarker = function() {
                    _this.markerIdentityKeyLastHovered && _this.svgMarkers[_this.markerIdentityKeyLastHovered] && _this.mapControl.markers.remove(_this.svgMarkers[_this.markerIdentityKeyLastHovered]);
                }, this.handleMousemoveOnPie = function(mouseEvent) {
                    if (_this.formatMode) return _this.clearLastHoverMarker(), void (_this.markerIdentityKeyLastHovered = null);
                    _this.mapControl.getCanvasContainer().style.cursor = "pointer";
                    var shape = mouseEvent && _.find(mouseEvent.shapes, function(s) {
                        return s && s.getProperties;
                    }), markerIdentityKey = shape && AzureMapMapControlHelper.getFirstIdentityKey(shape);
                    if (void 0 !== markerIdentityKey && _this.markerIdentityKeyLastHovered !== markerIdentityKey) {
                        _this.clearLastHoverMarker(), _this.markerIdentityKeyLastHovered = markerIdentityKey;
                        var dataPointHovered_1 = _this.data.dataPoints.filter(function(d) {
                            return d.subDataPoints[0].identity.getKey() === markerIdentityKey;
                        })[0], marker = _this.svgMarkers[markerIdentityKey];
                        _this.mapControl.markers.add(marker), marker.getElement().querySelectorAll("circle, path").forEach(function(elem, idx) {
                            _this.tooltipService && (elem.onmouseover = function(e) {
                                _this.tooltipService.show({
                                    coordinates: [ e.x, e.y ],
                                    isTouchEvent: _this.isTouchEvent,
                                    dataItems: dataPointHovered_1.subDataPoints[idx].tooltipInfo,
                                    identities: dataPointHovered_1.subDataPoints[idx].identity ? [ dataPointHovered_1.subDataPoints[idx].identity.getSelectorsByColumn() ] : []
                                });
                            }), elem.onclick = elem.oncontextmenu = function(event) {
                                _this.clickPieState = {
                                    idx,
                                    dataPointHovered: dataPointHovered_1,
                                    event
                                };
                            };
                        });
                    }
                }, this.tooltipService = host.tooltips(), this.pieFactory = new pieChartFactory.t(mapControl.imageSprite);
            }
            return Object.defineProperty(AzureMapMapControlHelper.prototype, "bubbleDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(azureMapConstant.oy);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapMapControlHelper.prototype, "heatMapDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(azureMapConstant.Ol);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapMapControlHelper.prototype, "filledMapDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(azureMapConstant.HC);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapMapControlHelper.prototype, "barChart3DDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(azureMapConstant.zD);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapMapControlHelper.prototype, "referenceDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(azureMapConstant.uL);
                },
                enumerable: !1,
                configurable: !0
            }), AzureMapMapControlHelper.prototype.setupMap = function(_element, selectionControl) {
                var _this = this;
                this.createDataSource(azureMapConstant.oy, {
                    promoteId: "_azureMapsShapeId",
                    clusterProperties: {
                        _azureMapsShapeId: [ [ "slice", [ "concat", [ "accumulated" ], [ "get", "_azureMapsShapeId" ] ], 0, 72 ], [ "get", "_azureMapsShapeId" ] ],
                        selected: [ "any", [ "get", "selected" ] ]
                    }
                }), this.createDataSource(azureMapConstant.Ol), this.createDataSource(azureMapConstant.HC, {
                    tolerance: 1
                }), this.createDataSource(azureMapConstant.zD, {
                    tolerance: 1
                }), this.createDataSource(azureMapConstant.uL, {
                    tolerance: 1
                }), this.trafficControl = this.createTrafficControl(), this.styleControl = new atlas.control.StyleControl({
                    mapStyles: "all",
                    layout: "list"
                }), this.pitchControl = new atlas.control.PitchControl, this.compassControl = new atlas.control.CompassControl, 
                this.zoomControl = new atlas.control.ZoomControl, this.selectionControl = selectionControl || function(host, options) {
                    var modesEnum;
                    !function(modesEnum) {
                        modesEnum.circle = "circle", modesEnum.rectangle = "rectangle", modesEnum.polygon = "polygon", 
                        modesEnum.routeRange = "routeRange";
                    }(modesEnum || (modesEnum = {}));
                    var SelectionControl = function(_super) {
                        function SelectionControl(host, options) {
                            var _this = _super.call(this) || this;
                            return _this.options = {
                                style: "light",
                                selectionModes: "all",
                                fillColor: "#F2C811",
                                fillOpacity: .5,
                                strokeColor: "#F2C811",
                                strokeWidth: 1,
                                persistSearchArea: !1,
                                routeRangeMinMapSize: [ 325, 200 ],
                                routeRangeOptions: {}
                            }, _this.hasMouse = !1, _this.hasFocus = !1, _this.copyDrawnShape = function(shape) {
                                _this.rangeDataSource.setShapes([ new atlas.Shape(new atlas.data.Polygon(shape.getCoordinates())) ]);
                            }, _this.displayRangePolygon = function(searchArea) {
                                _this.rangeDataSource.setShapes([ searchArea ]);
                            }, _this.searchArea = function(searchArea) {
                                _this.clear();
                                var sourceIds = _this.options.sourceIds;
                                if (sourceIds && searchArea) {
                                    var shapes = sourceIds.reduce(function(acc, cur) {
                                        return (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], acc, !0), _this.map.sources.getById(cur).getShapes(), !0);
                                    }, []), shapesInArea = mapMath.b.shapesWithinPolygon(shapes, searchArea);
                                    _this._invokeEvent("dataSelected", shapesInArea);
                                }
                                _this.drawingManager.setOptions({
                                    mode: atlas.drawing.DrawingMode.idle
                                });
                            }, _this.mapResized = function() {
                                var minSize = _this.options.routeRangeMinMapSize, mapSize = _this.map.getMapContainer().getBoundingClientRect();
                                _this.routeRangeBtn.css("display", mapSize.width >= minSize[0] && mapSize.height >= minSize[1] ? "" : "none");
                            }, _this.host = host, _this.options = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, _this.options), options || {}), 
                            _this;
                        }
                        return (0, tslib_es6.__extends)(SelectionControl, _super), Object.defineProperty(SelectionControl.prototype, "rangeDataSource", {
                            get: function() {
                                var _a;
                                return null === (_a = this.map) || void 0 === _a ? void 0 : _a.sources.getById("routeRangeDataSource");
                            },
                            enumerable: !1,
                            configurable: !0
                        }), SelectionControl.prototype.getContainer = function() {
                            return this.container.get(0);
                        }, SelectionControl.prototype.clear = function() {
                            this.drawingManager && this.drawingManager.getSource().clear(), this.rangeDataSource && this.rangeDataSource.clear();
                        }, SelectionControl.prototype.dispose = function() {
                            var _this = this;
                            this.map && this.map.controls.remove(this), this.styler && this.styler.dispose(), 
                            Object.keys(this).forEach(function(k) {
                                _this[k] = null;
                            });
                        }, SelectionControl.prototype.getDrawingManager = function() {
                            return this.drawingManager;
                        }, SelectionControl.prototype.getOptions = function() {
                            return (0, tslib_es6.__assign)({}, this.options);
                        }, SelectionControl.prototype.onAdd = function(map, options) {
                            this.position = options && options.position ? options.position : "non-fixed", this.map = map;
                            var opts = this.options, dm = new atlas.drawing.DrawingManager(map);
                            this.drawingManager = dm, map.events.add("drawingcomplete", dm, this.searchArea), 
                            map.events.add("drawingchanged", dm, this.copyDrawnShape);
                            var l = dm.getLayers();
                            l.polygonLayer.setOptions({
                                fillColor: opts.fillColor,
                                fillOpacity: opts.fillOpacity
                            });
                            var lineOptions = {
                                strokeColor: opts.strokeColor,
                                strokeWidth: opts.strokeWidth
                            };
                            return l.polygonOutlineLayer.setOptions(lineOptions), l.lineLayer.setOptions(lineOptions), 
                            map.sources.add(new atlas.source.DataSource("routeRangeDataSource", {
                                buffer: 512
                            })), this.rangeLayers = [ new atlas.layer.PolygonLayer(this.rangeDataSource, "polygonRangeLayer", l.polygonLayer.getOptions()), new atlas.layer.LineLayer(this.rangeDataSource, "lineRangeLayer", l.lineLayer.getOptions()) ], 
                            this.map.layers.add(this.rangeLayers, "transit"), this.createContainer(), this.styler && this.styler.dispose(), 
                            this.styler = new ControlStyler(this.container.get(0), map, opts.style || "light"), 
                            this.container.get(0);
                        }, SelectionControl.prototype.onRemove = function() {
                            this.clear(), this.container && (this.container.remove(), this.container = null), 
                            this.map && (this.rangeControl && (this.map.events.remove("showRange", this.rangeControl, this.displayRangePolygon), 
                            this.map.events.remove("rangeCalculated", this.rangeControl, this.searchArea), this.map.controls.remove(this.rangeControl), 
                            this.rangeControl = null), this.map.events.remove("resize", this.mapResized), this.drawingManager && this.map.events.remove("drawingchanged", this.drawingManager, this.copyDrawnShape), 
                            this.rangeLayers && (this.map.layers.remove(this.rangeLayers), this.rangeLayers = null), 
                            this.map.sources.remove(this.rangeDataSource)), this.styler.updateMap(null), this.drawingManager && (this.drawingManager.dispose(), 
                            this.drawingManager = null), this.map = null;
                        }, SelectionControl.prototype.createContainer = function() {
                            var _this = this, opts = this.options, css = SelectionControl.css;
                            this.container = jQuery('<div class="azure-maps-control-container" alt="'.concat("selectionControl", '" title="').concat("selectionControl", '"></div>'));
                            var selectionGrid = jQuery('<div class="sub-container '.concat(css.hidden, '" alt="selectionModes" title="selectionModes"></div>')), modes = Object.keys(modesEnum);
                            Array.isArray(opts.selectionModes) && (modes = opts.selectionModes), modes.forEach(function(key) {
                                var selectionBtn = _this.buildSelectModeBtn(key);
                                selectionGrid.append(selectionBtn), "routeRange" === key && (_this.routeRangeBtn = selectionBtn);
                            }), this.container.on("mouseover", function() {
                                _this.hasMouse = !0, _this.container.addClass(css.inUse), selectionGrid.removeClass(css.hidden);
                            }), this.container.on("focusin", function() {
                                _this.hasFocus = !0, _this.container.addClass(css.inUse), selectionGrid.removeClass(css.hidden);
                            }), this.container.on("mouseleave", function() {
                                _this.hasMouse = !1, _this.hasFocus || (_this.container.removeClass(css.inUse), 
                                selectionGrid.addClass(css.hidden));
                            }), this.container.on("focusout", function(event) {
                                event.relatedTarget instanceof Node && _this.container.get(0).contains(event.relatedTarget) || (_this.hasFocus = !1, 
                                _this.hasMouse || (_this.container.removeClass(css.inUse), selectionGrid.addClass(css.hidden)));
                            });
                            var flyoutTitle = this.host.getLocalizedString("Visual_AzureMapsSelectionControlMode"), flyoutButton = jQuery('<button type="button" class="'.concat(css.button, ' pointer-selection" alt="').concat(flyoutTitle, '" title="').concat(flyoutTitle, '"></button>'));
                            flyoutButton.on("click", function() {
                                _this.clear();
                            }), !opts || "top-right" !== this.position && "bottom-right" !== this.position ? (this.container.append(flyoutButton), 
                            this.container.append(selectionGrid)) : (this.container.append(selectionGrid), this.container.append(flyoutButton));
                            var rangeOptions = {
                                isVisible: !1,
                                markerOptions: {
                                    color: this.options.fillColor
                                },
                                style: opts.style || "light",
                                collapsible: !0,
                                calculateOnMarkerMove: !1
                            };
                            opts.routeRangeOptions && (opts.routeRangeOptions.markerOptions && (opts.routeRangeOptions.markerOptions = (0, 
                            tslib_es6.__assign)((0, tslib_es6.__assign)({}, rangeOptions.markerOptions), opts.routeRangeOptions.markerOptions)), 
                            rangeOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, rangeOptions), opts.routeRangeOptions));
                            var routeRangeControl = function(host, rangeOptions) {
                                var RouteRangeControl = function(_super) {
                                    function RouteRangeControl(host, options) {
                                        var _this = _super.call(this) || this;
                                        return _this.options = {
                                            markerOptions: {
                                                color: "#F2C811",
                                                secondaryColor: "#011C2C",
                                                htmlContent: '<svg xmlns="http://www.w3.org/2000/svg" style="cursor:move" width="28px" height="39px" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><g style="transform:scale(0.2);transform-origin: 13% 10%;"><path d="m50 38h-4v14c0 0 0 1 0 1l9 9 2-2-9-9v-13z" fill="{secondaryColor}" stroke="{secondaryColor}" stroke-width="2px"/><path d="m48 81c-15 0-28-12-28-28s12-28 28-28 28 12 28 28-12 28-28 28zm23-52 3-3c1-1 1-3-0-4-1-1-3-1-4-0l-3 3c-4-3-10-5-16-5v-4h9v-6h-24v6h9v4c-15 1-28 13-30 29s7 31 22 36 31-0 40-14 6-31-5-42z" fill="{secondaryColor}" stroke="{secondaryColor}" stroke-width="2px"/></g></svg>'
                                            },
                                            style: "light",
                                            isVisible: !0,
                                            position: "right",
                                            collapsible: !1,
                                            calculateOnMarkerMove: !0
                                        }, _this.markerMoveSearchDelay = 600, _this.arrowKeyOffset = 5, _this.showOptionsDelay = 0, 
                                        _this.settings = {}, _this.displayPropertyName = "display", _this.createContainer = function() {
                                            _this.container = jQuery('<div aria-label="'.concat(_this.resource.routeRangeDescription, '" tabindex="-1" class="azure-maps-control-container atlas-route-range-container light ').concat(_this.options.position, '">')), 
                                            _this.container.css(_this.displayPropertyName, _this.options.isVisible ? "" : "none"), 
                                            _this.container.addClass("themeableElement"), _this.container.on("keydown", _this.onContainerKeyDown);
                                            var header = jQuery('<div class="atlas-route-range-header"/>'), title = jQuery('<div class="atlas-route-range-title">'.concat(_this.resource.title, "</div>")), closeButton = jQuery('<button aria-label="'.concat(_this.resource.close, '"  class="closeIcon glyphicon pbi-glyph-close glyph-mini atlas-route-range-close-icon" alt="').concat(_this.resource.closeDialog, '" title="').concat(_this.resource.closeDialog, '"></button>'));
                                            closeButton.on("click", _this.onCancel), header.append(title), header.append(closeButton), 
                                            _this.container.append(header);
                                            var instructions = jQuery('<div class="atlas-route-range-instructions">'.concat(_this.resource.selectOrigin, "</div>"));
                                            _this.container.append(instructions), _this.optionSection = _this.getControlOptions(), 
                                            _this.container.append(_this.optionSection);
                                            var buttonRow = jQuery('<div class="atlas-route-range-buttons" style="display: block;"></div>'), actionRow = jQuery("<div/>");
                                            _this.container.append(buttonRow), buttonRow.append(actionRow);
                                            var showAreaLabel = jQuery('<label class="atlas-route-range-outline-area"></label>'), showAreaJQuery = jQuery('<input type="checkbox" checked="checked" alt="'.concat(_this.resource.showArea, '" title="').concat(_this.resource.showArea, '">'));
                                            showAreaJQuery.on("change", function() {
                                                _this.settings.showArea = showAreaJQuery.is(":checked");
                                            }), showAreaLabel.append(showAreaJQuery), showAreaLabel.append(_this.resource.showArea), 
                                            _this.showArea = showAreaLabel;
                                            var searchButton = _this.getControlButton(_this.resource.search, "pbi-fluent-button pbi-modern-button primaryBtn save atlas-route-range-searchButton");
                                            searchButton.on("click", _this.onSearch), _this.searchButton = searchButton;
                                            var cancelButton = _this.getControlButton(_this.resource.cancel, "pbi-fluent-button pbi-modern-button secondaryBtn cancel atlas-route-range-cancelButton");
                                            _this.cancelButton = cancelButton, cancelButton.on("click", _this.onCancel), _this.options.collapsible || cancelButton.css(_this.displayPropertyName, "none");
                                            var buttonContainer = jQuery('<div style="text-align: right;"></div>');
                                            buttonContainer.append(searchButton), buttonContainer.append(cancelButton), actionRow.append([ showAreaLabel, buttonContainer ]), 
                                            _this.map.events.add("resize", _this.mapResized), _this.mapResized(), _this.options.isVisible && _this.setVisible(_this.options.isVisible);
                                        }, _this.onSearch = function() {
                                            var convertDistance = atlas.math.convertDistance, round = Math.round, request = _this.settings, numberFormatter = new Intl.NumberFormat("en-US", {
                                                useGrouping: !1
                                            }).format, queryString = [];
                                            queryString.push("query=".concat(numberFormatter(request.origin[1]), ",").concat(numberFormatter(request.origin[0]))), 
                                            queryString.push("travelMode=car"), queryString.push("time" === request.selectionArea ? "timeBudgetInSec=".concat(numberFormatter(round(60 * request.travelTime))) : "distanceBudgetInMeters=".concat(numberFormatter(round(convertDistance(request.distance, request.distanceUnits, "meters")))));
                                            var url = "https://".concat(_this.map.getServiceOptions().domain, "/route/range/json?api-version=1.0&").concat(queryString.join("&")), requestParams = _this.map.authentication.signRequest({
                                                url
                                            });
                                            fetch(requestParams.url, {
                                                method: "GET",
                                                mode: "cors",
                                                headers: new Headers(requestParams.headers)
                                            }).then(function(r) {
                                                return r.json();
                                            }, function(e) {
                                                return _this._invokeEvent("error", _this.resource.error);
                                            }).then(function(response) {
                                                if (response.reachableRange) {
                                                    var positions = response.reachableRange.boundary.map(function(latLng) {
                                                        return [ latLng.longitude, latLng.latitude ];
                                                    }), isochrone = new atlas.data.Polygon([ positions ]);
                                                    _this._invokeEvent("rangeCalculated", isochrone), _this.settings.showArea && _this._invokeEvent("showRange", isochrone);
                                                } else _this._invokeEvent("error", _this.resource.error);
                                            }, function(error) {
                                                return _this._invokeEvent("error", _this.resource.error);
                                            }), _this.options.collapsible && _this.setVisible(!1);
                                        }, _this.onCancel = function() {
                                            _this.setVisible(!1);
                                            var elementToFocus = _this.map.getMapContainer().querySelector(".routeRange-selection");
                                            focusManager.IK.focus(elementToFocus);
                                        }, _this.onMarkerDragged = function() {
                                            _this.settings.origin = _this.marker.getOptions().position, [ _this.optionSection, _this.searchButton, _this.cancelButton, _this.showArea ].forEach(function(x) {
                                                return x.css(_this.displayPropertyName, "");
                                            }), _this.hideOptionsTimeout = null, _this.options.calculateOnMarkerMove && _this.onSearch();
                                        }, _this.onMarkerDargStart = function() {
                                            _this.hideOptionsTimeout && (clearTimeout(_this.hideOptionsTimeout), _this.hideOptionsTimeout = null);
                                        }, _this.onContainerKeyDown = function(e) {
                                            if (e.keyCode > 36 && e.keyCode <= 40 && e.target.classList.contains("azure-maps-control-container")) {
                                                var zoom = _this.map.getCamera().zoom, pixel = atlas.math.mercatorPositionsToPixels([ _this.marker.getOptions().position ], zoom)[0], offset = _this.arrowKeyOffset;
                                                37 === e.keyCode ? pixel[0] -= offset : 38 === e.keyCode ? pixel[1] -= offset : 39 === e.keyCode ? pixel[0] += offset : 40 === e.keyCode && (pixel[1] += offset);
                                                var pos = atlas.math.mercatorPixelsToPositions([ pixel ], zoom)[0];
                                                _this.marker.setOptions({
                                                    position: pos
                                                }), _this.settings.origin = pos, _this.options.calculateOnMarkerMove && (_this.markerKeyMoveTimeout && clearTimeout(_this.markerKeyMoveTimeout), 
                                                _this.markerKeyMoveTimeout = setTimeout(function() {
                                                    _this.onSearch();
                                                }, _this.markerMoveSearchDelay)), e.preventDefault(), e.stopPropagation();
                                            }
                                        }, _this.mapResized = function() {
                                            var mapSize = _this.map.getMapContainer().getBoundingClientRect(), delay = 0, position = _this.options.position;
                                            (mapSize.width < 750 || "center" === position && mapSize.height < 600) && (delay = 5e3), 
                                            _this.container.removeClass([ "left", "right", "center", "left-min", "right-min", "center-min" ]), 
                                            _this.container.addClass(position), _this.showOptionsDelay = delay;
                                        }, _this.host = host, options.markerOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, options.markerOptions), _this.options.markerOptions), 
                                        _this.options = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, _this.options), options), 
                                        _this.marker = new atlas.HtmlMarker((0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, _this.options.markerOptions), {
                                            draggable: !0
                                        })), _this;
                                    }
                                    return (0, tslib_es6.__extends)(RouteRangeControl, _super), RouteRangeControl.prototype.dispose = function() {
                                        var _this = this;
                                        this.map && this.map.controls.remove(this), this.styler && this.styler.dispose(), 
                                        Object.keys(this).forEach(function(k) {
                                            _this[k] = null;
                                        });
                                    }, RouteRangeControl.prototype.setMarkerOptions = function(options) {
                                        this.options.markerOptions = (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, this.options.markerOptions), options), 
                                        this.marker.setOptions(options);
                                    }, RouteRangeControl.prototype.setVisible = function(isVisible) {
                                        var _this = this;
                                        if (this.marker && this.map) {
                                            var cam = this.map.getCamera(), pos = cam.center;
                                            this.settings.origin && atlas.data.BoundingBox.containsPosition(cam.bounds, this.settings.origin) && (pos = this.settings.origin), 
                                            this.settings.origin = pos, this.marker.setOptions({
                                                position: pos,
                                                visible: isVisible
                                            }), isVisible && this.options.calculateOnMarkerMove && this.onSearch();
                                        }
                                        if (this.container) {
                                            var display = isVisible ? "" : "none";
                                            [ this.optionSection, this.searchButton, this.cancelButton, this.showArea ].forEach(function(x) {
                                                return x.css(_this.displayPropertyName, "none");
                                            }), this.container.css(this.displayPropertyName, display), isVisible && (this.hideOptionsTimeout = setTimeout(function() {
                                                [ _this.optionSection, _this.searchButton, _this.cancelButton, _this.showArea ].forEach(function(x) {
                                                    return x.css(_this.displayPropertyName, "");
                                                }), _this.hideOptionsTimeout = null;
                                            }, this.showOptionsDelay));
                                        }
                                        this.options.isVisible !== isVisible && isVisible && this.container && this.container.trigger("focus"), 
                                        this.options.isVisible = isVisible;
                                    }, RouteRangeControl.prototype.getOptions = function() {
                                        return (0, tslib_es6.__assign)({}, this.options);
                                    }, RouteRangeControl.prototype.onAdd = function(map, options) {
                                        return this.resource = {
                                            routeRangeDescription: this.host.getLocalizedString("Visual_AzureMapsRouteRangeControl"),
                                            cancel: this.host.getLocalizedString("Cancel_ButtonText"),
                                            close: this.host.getLocalizedString("Close"),
                                            distance: this.host.getLocalizedString("Distance"),
                                            distanceUnits: this.host.getLocalizedString("Visual_AzureMapsRouteRangeDistanceUnits"),
                                            kilometers: this.host.getLocalizedString("Visual_AzureMapsRouteRangeKilometers"),
                                            meters: this.host.getLocalizedString("Visual_MapUnitMeters"),
                                            miles: this.host.getLocalizedString("Visual_AzureMapsRouteRangeMiles"),
                                            error: this.host.getLocalizedString("Visual_AzureMapsRouteRangeError"),
                                            selection: this.host.getLocalizedString("Visual_AzureMapsRouteRangeSelection"),
                                            search: this.host.getLocalizedString("SearchBox_Text"),
                                            selectionArea: this.host.getLocalizedString("Visual_AzureMapsRouteRangeSelectionArea"),
                                            selectOrigin: this.host.getLocalizedString("Visual_AzureMapsRouteRangeSelectOrigin"),
                                            showArea: this.host.getLocalizedString("Visual_AzureMapsRouteRangeShowArea"),
                                            time: this.host.getLocalizedString("DataType_Label_Time"),
                                            title: this.host.getLocalizedString("Visual_AzureMapsRouteRangeTitle"),
                                            travelTime: this.host.getLocalizedString("Visual_AzureMapsRouteRangeTravelTime"),
                                            yards: this.host.getLocalizedString("Visual_AzureMapsRouteRangeYards"),
                                            closeDialog: this.host.getLocalizedString("CloseDialog_ModalHeader")
                                        }, this.map = map, this.marker.setOptions({
                                            visible: this.options.isVisible
                                        }), map.markers.add(this.marker), map.events.add("dragstart", this.marker, this.onMarkerDargStart), 
                                        map.events.add("dragend", this.marker, this.onMarkerDragged), this.createContainer(), 
                                        this.styler ? this.styler.updateMap(map) : this.styler = new ControlStyler(this.container.get(0), map, this.options.style || "light"), 
                                        this.container.get(0);
                                    }, RouteRangeControl.prototype.onRemove = function() {
                                        this.container && (this.container.off("keydown", this.onContainerKeyDown), this.container.remove(), 
                                        this.container = null), this.styler.updateMap(null), this.map.events.remove("resize", this.mapResized), 
                                        this.map.events.remove("dragstart", this.marker, this.onMarkerDargStart), this.map.events.remove("dragend", this.marker, this.onMarkerDragged), 
                                        this.map.markers.remove(this.marker), this.map = null;
                                    }, RouteRangeControl.prototype.getSelectColumn = function(title, options, className, onChange) {
                                        var selectElement = jQuery('<select alt="'.concat(title, '" title="').concat(title, '" class="').concat(className, '"/>'));
                                        return onChange && selectElement.on("change", function() {
                                            var val = selectElement.val().toString();
                                            onChange(val);
                                        }), selectElement.append(this.getSelectOptions(options)), selectElement;
                                    }, RouteRangeControl.prototype.getSelectOptions = function(options) {
                                        var optionElements = [];
                                        return _.forEach(options, function(x) {
                                            optionElements.push(jQuery('<option value="'.concat(x.value, '">').concat(x.title, "</option>")));
                                        }), optionElements;
                                    }, RouteRangeControl.prototype.getInputColumn = function(title, properties, onChange) {
                                        var attributes = "";
                                        _.forEach(properties, function(x) {
                                            attributes = attributes.concat("".concat(x.name, '="').concat(x.value, '"'));
                                        });
                                        var element = jQuery("<input ".concat(attributes, ' alt="').concat(title, '" title="').concat(title, '" class="atlas-route-range-col2">'));
                                        return onChange && element.on("change", function() {
                                            onChange(element);
                                        }), element;
                                    }, RouteRangeControl.prototype.getControlButton = function(title, className) {
                                        return jQuery('<button alt="'.concat(title, '" title="').concat(title, '" class="').concat(className, '">').concat(title, "</button>"));
                                    }, RouteRangeControl.prototype.getControlOptions = function() {
                                        var _this = this, options = jQuery('<div class="atlas-route-range-options"/>'), header = jQuery('<div class="atlas-route-range-row"/>');
                                        options.append(header), header.append(jQuery('<label class="atlas-route-range-option-title-first">'.concat(this.resource.selectionArea, "</label>")));
                                        var distanceTitle = jQuery('<label class="atlas-route-range-option-title">'.concat(this.resource.distance, "</label>"));
                                        distanceTitle.css(this.displayPropertyName, "none"), header.append(distanceTitle);
                                        var travelTimeTitle = jQuery('<label class="atlas-route-range-option-title">'.concat(this.resource.travelTime, "</label>"));
                                        header.append(travelTimeTitle);
                                        var inputRow = jQuery('<div class="atlas-route-range-row"/>');
                                        options.append(inputRow);
                                        var travelTimeJQuery = this.getInputColumn(this.resource.travelTime, [ {
                                            name: "type",
                                            value: "number"
                                        }, {
                                            name: "value",
                                            value: "15"
                                        }, {
                                            name: "min",
                                            value: 1..toString()
                                        }, {
                                            name: "max",
                                            value: 1440..toString()
                                        } ], function(element) {
                                            var value = parseInt(element.val().toString(), 10);
                                            value > 1440 && (value = 1440), value < 1 && (value = 1), element.val(value.toString()), 
                                            _this.settings.travelTime = value;
                                        }), distanceJQuery = this.getInputColumn(this.resource.distance, [ {
                                            name: "type",
                                            value: "number"
                                        }, {
                                            name: "value",
                                            value: "5"
                                        }, {
                                            name: "min",
                                            value: 1..toString()
                                        }, {
                                            name: "max",
                                            value: 1e3.toString()
                                        } ], function(element) {
                                            var value = parseInt(element.val().toString(), 10);
                                            value > 1e3 && (value = 1e3), value < 1 && (value = 1), element.val(value.toString()), 
                                            _this.settings.distance = value;
                                        });
                                        distanceJQuery.css(this.displayPropertyName, "none");
                                        var distanceUnitsJQuery = this.getSelectColumn(this.resource.distanceUnits, [ {
                                            value: "kilometers",
                                            title: this.resource.kilometers,
                                            default: !0
                                        }, {
                                            value: "meters",
                                            title: this.resource.meters
                                        }, {
                                            value: "miles",
                                            title: this.resource.miles
                                        }, {
                                            value: "yards",
                                            title: this.resource.yards
                                        } ], "atlas-route-range-col3", function(val) {
                                            _this.settings.distanceUnits = val.toString();
                                        });
                                        distanceUnitsJQuery.css(this.displayPropertyName, "none");
                                        var selectionColumn = this.getSelectColumn(this.resource.selectionArea, [ {
                                            value: "time",
                                            title: this.resource.time,
                                            default: !0
                                        }, {
                                            value: "distance",
                                            title: this.resource.distance
                                        } ], "atlas-route-range-col1", function(val) {
                                            _this.settings.selectionArea = val.toString();
                                            var isTime = "time" === val, timeDisplayProperty = isTime ? "" : "none";
                                            [ travelTimeTitle, travelTimeJQuery ].forEach(function(x) {
                                                return x.css(_this.displayPropertyName, timeDisplayProperty);
                                            });
                                            var distanceDisplayProperty = isTime ? "none" : "";
                                            [ distanceTitle, distanceJQuery, distanceUnitsJQuery ].forEach(function(x) {
                                                return x.css(_this.displayPropertyName, distanceDisplayProperty);
                                            });
                                        });
                                        return inputRow.append([ selectionColumn, distanceJQuery, distanceUnitsJQuery, travelTimeJQuery ]), 
                                        this.settings = {
                                            selectionArea: "time",
                                            travelTime: 15,
                                            distance: 5,
                                            distanceUnits: atlas.math.DistanceUnits.kilometers,
                                            showArea: !0
                                        }, options;
                                    }, RouteRangeControl;
                                }(atlas.internal.EventEmitter);
                                return new RouteRangeControl(host, rangeOptions);
                            }(this.host, rangeOptions);
                            this.map.controls.add(routeRangeControl, {
                                position: atlas.ControlPosition.TopRight
                            }), this.rangeControl = routeRangeControl, this.map.events.add("resize", this.mapResized), 
                            this.mapResized(), this.map.events.add("rangeCalculated", this.rangeControl, this.searchArea), 
                            this.map.events.add("showRange", this.rangeControl, this.displayRangePolygon);
                        }, SelectionControl.prototype.buildSelectModeBtn = function(name) {
                            var _this = this, title = "";
                            switch (name) {
                              case modesEnum.circle:
                                title = this.host.getLocalizedString("Visual_AzureMapsCircleSelection");
                                break;

                              case modesEnum.polygon:
                                title = this.host.getLocalizedString("Visual_AzureMapsPolygonSelection");
                                break;

                              case modesEnum.rectangle:
                                title = this.host.getLocalizedString("Visual_AzureMapsRectangleSelection");
                                break;

                              case modesEnum.routeRange:
                                title = this.host.getLocalizedString("Visual_AzureMapsRouteRangeSelection");
                                break;

                              default:
                                debug.fF.assertFail('Unknown selection mode "'.concat(name));
                            }
                            var button = jQuery('<button type="button" alt="'.concat(title, '" title="').concat(title, '" class="').concat(SelectionControl.css.button, " ").concat(name, '-selection"></button>'));
                            return button.on("click", function() {
                                _this.clear(), _this.map.events.invoke("click", {
                                    originalEvent: {
                                        ctrlKey: !1,
                                        metaKey: !1
                                    }
                                }), "routeRange" === name ? (_this.rangeControl.setVisible(!0), _this.drawingManager.setOptions({
                                    mode: atlas.drawing.DrawingMode.idle
                                })) : _this.drawingManager.setOptions({
                                    mode: "draw-" + name
                                });
                            }), button;
                        }, SelectionControl.css = {
                            button: "azure-maps-control-button",
                            inUse: "in-use",
                            hidden: "hidden-accessible-element"
                        }, SelectionControl;
                    }(atlas.internal.EventEmitter);
                    return new SelectionControl(host, options);
                }(this.host, {
                    style: "light",
                    sourceIds: [ azureMapConstant.oy, azureMapConstant.Ol, azureMapConstant.HC, azureMapConstant.zD ]
                }), this.barChart3DLayer = new atlas.layer.PolygonExtrusionLayer(azureMapConstant.zD, azureMapConstant.Wv, {
                    height: [ "get", "size" ],
                    fillColor: [ "get", "color" ],
                    base: 0,
                    filter: azureMapExpressionHelper.J.getSelectionFilter(!0),
                    visible: !1
                }), this.unselectedBarChart3DLayer = new atlas.layer.PolygonExtrusionLayer(azureMapConstant.zD, azureMapConstant.TJ, {
                    height: [ "get", "size" ],
                    fillColor: [ "get", "color" ],
                    base: 0,
                    filter: azureMapExpressionHelper.J.getSelectionFilter(!1),
                    visible: !1
                }), this.filledMapFillLayer = new atlas.layer.PolygonLayer(azureMapConstant.HC, azureMapConstant.C_, {
                    fillColor: [ "get", "color" ],
                    visible: !1
                }), this.filledMapOutlineLayer = new atlas.layer.LineLayer(azureMapConstant.HC, azureMapConstant.z8, {
                    visible: !1
                }), this.heatMapLayer = new atlas.layer.HeatMapLayer(azureMapConstant.Ol, azureMapConstant.p5, {
                    visible: !1
                }), this.bubbleLayer = new atlas.layer.BubbleLayer(azureMapConstant.oy, azureMapConstant.yl, {
                    color: [ "get", "color" ],
                    filter: azureMapExpressionHelper.J.bubbleLayerFilter,
                    visible: !1,
                    createIndicators: !0
                }), this.clusterBubbleLayer = new atlas.layer.BubbleLayer(azureMapConstant.oy, azureMapConstant.Jp, {
                    filter: azureMapExpressionHelper.J.clusteredDataFilter,
                    visible: !1,
                    createIndicators: !0,
                    accessibilityIdKey: "cluster_id"
                }), this.clusterSymbolLayer = new atlas.layer.SymbolLayer(azureMapConstant.oy, azureMapConstant._u, {
                    iconOptions: {
                        image: ""
                    },
                    textOptions: {
                        textField: [ "get", "point_count_abbreviated" ],
                        offset: [ 0, .4 ]
                    },
                    visible: !1,
                    filter: azureMapExpressionHelper.J.clusteredDataFilter
                }), this.pieChartSymbolLayer = new atlas.layer.SymbolLayer(azureMapConstant.oy, null, {
                    filter: azureMapExpressionHelper.J.pieLayerFilter,
                    iconOptions: {
                        image: [ "get", "iconId" ],
                        size: 1,
                        allowOverlap: !0
                    },
                    visible: !1
                }), this.referenceLayer = this.featureSwitches.azureMapsCustomFormattingReferenceLayer ? new ReferenceDataLayer(this.referenceDataSource) : new atlas.layer.SimpleDataLayer(this.referenceDataSource, {
                    enablePopups: !1,
                    bubbleRadiusFactor: 4
                });
                var baseLayers = [ this.barChart3DLayer, this.unselectedBarChart3DLayer, this.filledMapFillLayer, this.filledMapOutlineLayer, this.heatMapLayer, this.bubbleLayer, this.pieChartSymbolLayer, this.clusterBubbleLayer, this.clusterSymbolLayer ];
                if (this.featureSwitches.azureMapsCustomFormattingReferenceLayer && this.referenceLayer instanceof ReferenceDataLayer ? (this.mapControl.layers.add((0, 
                tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], baseLayers, !0), this.referenceLayer.getLayers(), !0)), 
                this.referenceLayer.onAdd(this.mapControl)) : this.referenceLayer instanceof atlas.layer.SimpleDataLayer && this.mapControl.layers.add((0, 
                tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], baseLayers, !0), [ this.referenceLayer ], !1)), 
                this.behavior) {
                    var mouseMoveBaseLayers = [ this.barChart3DLayer, this.unselectedBarChart3DLayer, this.filledMapFillLayer, this.filledMapOutlineLayer, this.bubbleLayer, this.clusterBubbleLayer ], clickBaseLayers = [ this.barChart3DLayer, this.unselectedBarChart3DLayer, this.filledMapFillLayer, this.filledMapOutlineLayer, this.bubbleLayer ], mouseOutBaseLayers = [ this.barChart3DLayer, this.unselectedBarChart3DLayer, this.filledMapFillLayer, this.filledMapOutlineLayer, this.bubbleLayer, this.pieChartSymbolLayer, this.clusterBubbleLayer ], contextMenuBaseLayers = [ this.barChart3DLayer, this.unselectedBarChart3DLayer, this.filledMapFillLayer, this.filledMapOutlineLayer, this.bubbleLayer ];
                    this.featureSwitches.azureMapsDataBoundReferenceLayer && this.referenceLayer instanceof ReferenceDataLayer && (mouseMoveBaseLayers = (0, 
                    tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], mouseMoveBaseLayers, !0), this.referenceLayer.getLayers(), !0), 
                    clickBaseLayers = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], clickBaseLayers, !0), this.referenceLayer.getLayers(), !0), 
                    mouseOutBaseLayers = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], mouseOutBaseLayers, !0), this.referenceLayer.getLayers(), !0), 
                    contextMenuBaseLayers = (0, tslib_es6.__spreadArray)((0, tslib_es6.__spreadArray)([], contextMenuBaseLayers, !0), this.referenceLayer.getLayers(), !0)), 
                    this.mapControl.events.add("mousemove", mouseMoveBaseLayers, function(mouseEvent) {
                        return _this.behavior.featureMousemove(mouseEvent, _this.showTooltip);
                    }), this.mapControl.events.add("mouseover", [ this.bubbleLayer ], function(mouseEvent) {
                        return _this.behavior.featureMouseover(mouseEvent);
                    }), this.mapControl.events.add("mousemove", [ this.pieChartSymbolLayer ], this.handleMousemoveOnPie), 
                    this.mapControl.events.add("mouseout", mouseOutBaseLayers, function(mouseEvent) {
                        return _this.behavior.featureMouseout(mouseEvent, _this.hideTooltip);
                    }), this.mapControl.events.remove("click", this.behavior.mapClicked), this.mapControl.events.remove("click", this.behavior.featureClicked), 
                    this.mapControl.events.remove("contextmenu", this.behavior.featureContextClicked), 
                    this.mapControl.events.add("click", function(e) {
                        if (_this.selectionControl.clear(), _this.behavior.mapClicked(e), _this.clickPieState) {
                            var _a = _this.clickPieState;
                            _this.behavior.handleSelection(_a.event, [ _a.dataPointHovered.subDataPoints[_a.idx] ]), 
                            _this.clickPieState = null;
                        } else _this.behavior && _this.behavior.renderSelection(_this.behavior.visualHasSelection());
                    }), this.mapControl.events.add("click", clickBaseLayers, function(e) {
                        _this.selectionControl.clear(), _this.behavior.featureClicked(e);
                    }), this.mapControl.events.add("click", [ this.clusterBubbleLayer ], function(e) {
                        _this.behavior.clusterClicked(e, _this.bubbleDataSource);
                    }), this.mapControl.events.add("contextmenu", contextMenuBaseLayers, this.behavior.featureContextClicked), 
                    this.mapControl.events.add("contextmenu", [ this.pieChartSymbolLayer ], function(_e) {
                        if (_this.clickPieState) {
                            var _a = _this.clickPieState;
                            _this.behavior.handleContextMenu(_a.event, _a.dataPointHovered.subDataPoints[_a.idx]), 
                            _this.clickPieState = null;
                        }
                    }), this.mapControl.events.add("focusin", [ this.bubbleLayer, this.clusterBubbleLayer ], function(evt) {
                        return _this.behavior.featureFocusIn(evt, _this.showTooltip, _this.hideTooltip, _this.tooltipService.visible.bind(_this.tooltipService));
                    }), this.mapControl.events.add("focusout", [ this.bubbleLayer, this.clusterBubbleLayer ], function(evt) {
                        return _this.behavior.featureFocusOut(evt, _this.hideTooltip);
                    });
                }
                this.setupDataLabelLayer(), $(".atlas-map a").attr("tabindex", 0), this.registerArrowKeyStopper(), 
                this.waitForMapA11yContainer().then(function() {
                    var mapControlHelper = _this;
                    $(".accessible-indicator-collection-container").attr("tabindex", "0").attr("focus-nav-mode", "Hierarchy").css({
                        width: "100%",
                        height: "100%",
                        position: "absolute",
                        pointerEvents: "none"
                    }).on("focusin", function(event) {
                        event.target === this && "key" === $("html").attr("data-focus-source") && mapControlHelper.updateCamera([]);
                    });
                });
            }, AzureMapMapControlHelper.prototype.createDataSource = function(sourceId, options) {
                this.mapControl.sources.add(new atlas.source.DataSource(sourceId, options));
            }, AzureMapMapControlHelper.prototype.waitForMapA11yContainer = function() {
                var _this = this;
                return new Promise(function(resolve) {
                    _this.mapControl.events.add("idle", function() {
                        resolve();
                    });
                });
            }, AzureMapMapControlHelper.prototype.registerArrowKeyStopper = function() {
                $(".mapControl.atlas-map").on("keydown", function(eventObj) {
                    (0, keyUtils.Wl)(eventObj.keyCode) && (eventObj.stopPropagation && eventObj.stopPropagation(), 
                    eventObj.preventDefault && eventObj.preventDefault());
                });
            }, AzureMapMapControlHelper.prototype.destroy = function() {
                this.mapControl && this.mapControl.events.remove("move", this.mapControlMoved);
            }, AzureMapMapControlHelper.prototype.setupDataLabelLayer = function() {
                var svg = d3.select(this.mapControl.getMapContainer()).append("svg").style("position", "absolute").style("pointer-events", "none").style("width", "100%").style("height", "100%");
                this.labelBackgroundGraphicsContext = svg.append("g").classed(dataLabelViewModel1Consts.u9.class, !0), 
                this.labelGraphicsContext = svg.append("g").classed(dataLabelViewModel1Consts.ZL.class, !0), 
                this.mapControl.events.add("move", this.mapControlMoved);
            }, AzureMapMapControlHelper.prototype.handleKeyboardShortcuts = function(element) {
                var _this = this;
                this.mapControl.setUserInteraction({
                    keyboardInteraction: !1
                }), element.on("keydown", function(event) {
                    39 === event.keyCode && browserUtils.M.isCtrlOrMeta(event) && (_this.mapControl.setUserInteraction({
                        keyboardInteraction: !0
                    }), element.off("keydown"));
                });
            }, AzureMapMapControlHelper.prototype.setData = function(newData) {
                this.data = newData;
            }, AzureMapMapControlHelper.prototype.updateNonDataBoundProperties = function(previousData, mapControlFactory, warnings) {
                this.mapControlFactory = mapControlFactory;
                var previousProperties = null == previousData ? void 0 : previousData.properties;
                this.updateMapControlProperties(null == previousProperties ? void 0 : previousProperties.mapControls), 
                this.updateTrafficProperties(null == previousProperties ? void 0 : previousProperties.traffic), 
                this.updateTileLayerProperties(null == previousProperties ? void 0 : previousProperties.tile), 
                this.updateReferenceLayer(null == previousProperties ? void 0 : previousProperties.referenceLayer, warnings);
            }, AzureMapMapControlHelper.prototype.clearDataLabels = function() {
                (0, dataLabelRendererEnhanced.gm)({
                    dataLabels: [],
                    labelContext: this.labelGraphicsContext,
                    backgroundContext: this.labelBackgroundGraphicsContext,
                    numeric: !1,
                    formatMode: this.formatMode,
                    onObject: this.featureSwitches.onObject
                });
            }, AzureMapMapControlHelper.prototype.drawDataLabels = function() {
                var _this = this;
                if (this.data) {
                    var dataLabelSettings = this.data.dataLabelSettings;
                    if (this.data.properties.bubble.showBubbleLayer && dataLabelSettings.show) {
                        var camera = this.mapControl.getCamera(), bubbleLayerOptions = this.bubbleLayer.getOptions();
                        if (camera.zoom < bubbleLayerOptions.minZoom || camera.zoom > bubbleLayerOptions.maxZoom) this.clearDataLabels(); else {
                            var fontProperties = dataLabelSettings.fontProperties, centerXY = [ this.viewportSize.width / 2, this.viewportSize.height / 2 ], centerLatlng = camera.center, radiusExp = bubbleLayerOptions.radius, strokeWidth = this.data.properties.bubble.strokeWidth, shouldMeasureRadiusVertically = "map" === bubbleLayerOptions.pitchAlignment, headingAngleTowardsWest = (270 + (shouldMeasureRadiusVertically ? 90 : 0) + camera.bearing) % 360, shouldUseLegacyFormat = this.shouldUseLegacyFormat(), labelDataPoints = this.data.dataPoints.filter(function(dp) {
                                return dp.location;
                            }).map(function(dp) {
                                var _a, datapointValue = dp.subDataPoints[0].size, radiusXY = shouldUseLegacyFormat ? azureMapExpressionHelper.J.LEGACY_evaluateRadiusExpression(radiusExp, camera.zoom, datapointValue) + strokeWidth : (dp.bubbleRadius || 0) + strokeWidth, refPointLatlng = _this.mapControl.pixelsToPositions([ [ centerXY[0] - radiusXY, centerXY[1] ] ])[0], radiusLatlng = atlas.math.getDistanceTo(centerLatlng, refPointLatlng), originLatlng = [ dp.location.longitude, dp.location.latitude ], originXY = _this.mapControl.positionsToPixels([ originLatlng ])[0], originX = originXY[0], originY = originXY[1], circumLatlng = atlas.math.getDestination(originLatlng, headingAngleTowardsWest, radiusLatlng), circumXY = _this.mapControl.positionsToPixels([ circumLatlng ])[0], calibratedRadiusXY = shouldMeasureRadiusVertically ? Math.abs(originY - circumXY[1]) : Math.abs(originX - circumXY[0]), text = dp.categoryValue, properties = (0, 
                                common_fontProperties.qk)(fontProperties, text), textWidth = textMeasurementService.b.measureSvgTextWidth(properties), textHeight = textMeasurementService.b.estimateSvgTextHeight(properties);
                                return {
                                    isPreferred: !0,
                                    text: dp.categoryValue,
                                    textSize: {
                                        width: textWidth,
                                        height: textHeight
                                    },
                                    identity: null,
                                    key: "".concat(text, ":").concat(datapointValue, ":").concat(dp.location.longitude, ":").concat(dp.location.latitude),
                                    fontProperties,
                                    outsideFill: fontProperties.color ? fontProperties.color : "#ffffff",
                                    insideFill: fontProperties.color ? fontProperties.color : "#ffffff",
                                    parentType: 0,
                                    parentShape: {
                                        point: {
                                            x: originX,
                                            y: originY
                                        },
                                        radius: calibratedRadiusXY,
                                        validPositions: [ 1, 2, 4, 8 ]
                                    },
                                    hasBackground: null === (_a = dataLabelSettings.enableBackground) || void 0 === _a || _a,
                                    backgroundColor: dataLabelSettings.backgroundColor,
                                    backgroundTransparency: dataLabelSettings.backgroundTransparency
                                };
                            }), repositionedDataLabels = new labelLayout1.nu({
                                maximumOffset: dataLabelViewModel1Consts.wh,
                                startingOffset: dataLabelViewModel1Consts.ki
                            }).layout([ {
                                labelDataPoints,
                                maxNumberOfLabels: labelDataPoints.length
                            } ], this.viewportSize);
                            (0, dataLabelRendererEnhanced.gm)({
                                dataLabels: repositionedDataLabels,
                                labelContext: this.labelGraphicsContext,
                                backgroundContext: this.labelBackgroundGraphicsContext,
                                numeric: !1,
                                formatMode: !1,
                                onObject: !1
                            });
                        }
                    } else this.clearDataLabels();
                }
            }, AzureMapMapControlHelper.prototype.updateViewportSize = function(mapViewport) {
                this.viewportSize = mapViewport;
            }, AzureMapMapControlHelper.prototype.updateDataLayers = function(previousData, dataFieldsUpdated) {
                this.data.hasXY || this.data.hasCategory ? this.displayData(previousData ? previousData.properties : void 0, dataFieldsUpdated) : (this.bubbleDataSource.clear(), 
                this.heatMapDataSource.clear(), this.filledMapDataSource.clear(), this.barChart3DDataSource.clear(), 
                this.featureSwitches.azureMapsDataBoundReferenceLayer && this.referenceDataMatcher && this.referenceDataMatcher.clearMappings());
            }, AzureMapMapControlHelper.prototype.updateCamera = function(warnings) {
                if (this.data) if (this.data.hasXY || this.data.hasCategory) {
                    var features = this.features, boundingBox = atlas.data.BoundingBox.fromData(features);
                    this.setCamera(boundingBox, features && 1 === features.length && !this.data.properties.filledMap.showFilledMap, warnings);
                } else this.data.properties.mapControls.cameraProperties.autoZoom && this.mapControl.setCamera({
                    type: this.getCurrentCameraType(),
                    zoom: 0,
                    pitch: 0,
                    bearing: 0
                });
            }, AzureMapMapControlHelper.getFirstIdentityKey = function(shape) {
                return shape.getProperties().identityKeys[0];
            }, AzureMapMapControlHelper.prototype.setFormatMode = function(isFormatMode) {
                this.formatMode !== isFormatMode && (this.formatMode = isFormatMode, this.formatMode ? this.attachControlsListeners() : this.removeControlsListeners());
            }, AzureMapMapControlHelper.prototype.displayData = function(previousProperties, dataFieldsUpdated) {
                var _this = this, properties = this.data.properties, commonDataOptions = properties.commonDataOptions, shouldUseLegacyFormat = this.shouldUseLegacyFormat(), filledMapProperties = properties.filledMap;
                if (this.data.shouldRenderFilledMap) {
                    var _a = azureMapExpressionHelper.J.getFilledMapDisplayOptions(filledMapProperties, commonDataOptions, shouldUseLegacyFormat, this.data.hasSize), lineOptions = _a.lineOptions;
                    this.filledMapFillLayer.setOptions(_a.polygonOptions), this.filledMapOutlineLayer.setOptions(lineOptions);
                    var layersToMove = [ azureMapConstant.C_, azureMapConstant.z8 ], position = this.getMapControlLayerName(filledMapProperties.layerPosition);
                    this.moveLayers(layersToMove, position);
                } else this.filledMapFillLayer.setOptions({
                    visible: !1
                }), this.filledMapOutlineLayer.setOptions({
                    visible: !1
                });
                var barChartDataProperties = properties.barChart.dataProperties, barChartPaintProperties = properties.barChart.paintProperties;
                if (barChartDataProperties.showBarChart) {
                    var _b = azureMapExpressionHelper.J.getBarChartDisplayOptions(barChartPaintProperties, commonDataOptions, this.data.maxDataValue, shouldUseLegacyFormat, this.data.hasSize), unselectedOptions = _b.unselectedOptions;
                    this.barChart3DLayer.setOptions(_b.selectedOptions), this.unselectedBarChart3DLayer.setOptions(unselectedOptions), 
                    layersToMove = [ azureMapConstant.Wv, azureMapConstant.TJ ], position = this.getMapControlLayerName(barChartPaintProperties.layerPosition), 
                    this.moveLayers(layersToMove, position), this.mapControl.events.remove("zoomend", this.zoomChanged), 
                    barChartDataProperties.scaleThicknessOnZoom && this.mapControl.events.add("zoomend", this.zoomChanged);
                } else this.barChart3DLayer.setOptions({
                    visible: !1
                }), this.unselectedBarChart3DLayer.setOptions({
                    visible: !1
                });
                var heatMapLayerProperties = properties.heatMap;
                if (heatMapLayerProperties.showHeatMapLayer) {
                    var heatMapOptions = azureMapExpressionHelper.J.getHeatMapDisplayOptions(heatMapLayerProperties, this.data.hasSize).heatMapOptions;
                    this.heatMapLayer.setOptions(heatMapOptions), layersToMove = [ azureMapConstant.p5 ], 
                    position = this.getMapControlLayerName(heatMapLayerProperties.layerPosition), this.moveLayers(layersToMove, position);
                } else this.heatMapLayer.setOptions({
                    visible: !1
                });
                var enableBubbleLayer = this.shouldEnableBubbleLayer(properties, this.data), enablePieChartLayer = this.shouldEnablePieChartLayer(properties, this.data, this.featureSwitches);
                enablePieChartLayer ? this.behavior && this.behavior.setPieChartBehavior(enablePieChartLayer, this.pieFactory, this.pieChartSymbolLayer, shouldUseLegacyFormat) : this.behavior && this.behavior.setPieChartBehavior(enablePieChartLayer, void 0, void 0, shouldUseLegacyFormat);
                var bubbleLayerProperties = properties.bubble;
                if (bubbleLayerProperties.showBubbleLayer) {
                    if (enablePieChartLayer) {
                        dataFieldsUpdated && this.pieFactory.clearAll();
                        var dataPoints = this.data.dataPoints.filter(function(d) {
                            return d.location;
                        });
                        shouldUseLegacyFormat && azureMapExpressionHelper.J.LEGACY_appendPieRadiusToDataPoints(dataPoints, this.data);
                        var pieChartSourceData_1 = [];
                        enableBubbleLayer ? dataPoints.forEach(function(p) {
                            p.subDataPoints.length > 1 && pieChartSourceData_1.push(p);
                        }) : pieChartSourceData_1.push.apply(pieChartSourceData_1, dataPoints), pieChartSourceData_1.forEach(function(p) {
                            return _this.pieFactory.loadIcon(p, bubbleLayerProperties);
                        }), this.clearLastHoverMarker(), this.markerIdentityKeyLastHovered = null, this.svgMarkers = pieChartSourceData_1.map(function(p) {
                            return [ new atlas.HtmlMarker({
                                htmlContent: _this.pieFactory.svgContent(p, bubbleLayerProperties, !0),
                                position: [ p.location.longitude, p.location.latitude ],
                                pixelOffset: new atlas.Pixel(0, 6.5),
                                anchor: "center"
                            }), p ];
                        }).reduce(function(kvo, _a, _index) {
                            var _b, marker = _a[0], p = _a[1];
                            return (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, kvo), ((_b = {})[p.subDataPoints[0].identity.getKey()] = marker, 
                            _b));
                        }, {});
                        var pieChartOptions = azureMapExpressionHelper.J.getPieChartDisplayOptions(bubbleLayerProperties).pieChartOptions;
                        this.pieChartSymbolLayer.setOptions(pieChartOptions), layersToMove = [ this.pieChartSymbolLayer.getId() ], 
                        position = this.getMapControlLayerName(bubbleLayerProperties.layerPosition), this.moveLayers(layersToMove, position);
                    } else this.pieChartSymbolLayer.setOptions({
                        visible: !1
                    });
                    if (enableBubbleLayer) {
                        var bubbleOptions = azureMapExpressionHelper.J.getBubbleDisplayOptions(bubbleLayerProperties, commonDataOptions, shouldUseLegacyFormat, this.data.hasSize, this.data.minDataValue, this.data.maxDataValue).bubbleOptions;
                        if (this.bubbleLayer.setOptions(bubbleOptions), this.featureSwitches.azureMapsBubbleCluster) {
                            if (bubbleLayerProperties.clusteringEnabled) {
                                var _c = azureMapExpressionHelper.J.getBubbleClusterDisplayOptions(bubbleOptions, bubbleLayerProperties), clusterSymbolOptions = _c.clusterSymbolOptions;
                                this.clusterBubbleLayer.setOptions(_c.clusterBubbleOptions), this.clusterSymbolLayer.setOptions(clusterSymbolOptions);
                            } else this.clusterBubbleLayer.setOptions({
                                visible: !1
                            }), this.clusterSymbolLayer.setOptions({
                                visible: !1
                            });
                            (null == previousProperties ? void 0 : previousProperties.bubble.clusteringEnabled) !== this.data.properties.bubble.clusteringEnabled && this.updateDataSourceClusterOptions(azureMapConstant.oy, {
                                cluster: bubbleLayerProperties.clusteringEnabled
                            });
                        }
                        layersToMove = [ azureMapConstant.yl ], position = this.getMapControlLayerName(bubbleLayerProperties.layerPosition), 
                        this.moveLayers(layersToMove, position);
                    } else this.bubbleLayer.setOptions({
                        visible: !1
                    });
                } else this.bubbleLayer.setOptions({
                    visible: !1
                }), this.pieChartSymbolLayer.setOptions({
                    visible: !1
                }), this.clusterBubbleLayer.setOptions({
                    visible: !1
                }), this.clusterSymbolLayer.setOptions({
                    visible: !1
                });
                if (this.featureSwitches.azureMapsDataBoundReferenceLayer) {
                    var referenceLayerProperties = properties.referenceLayer;
                    this.referenceLayer.setOptions({
                        unselectedTransparency: commonDataOptions.unselectedTransparency,
                        bubble: referenceLayerProperties.bubble,
                        polygon: referenceLayerProperties.polygon,
                        line: referenceLayerProperties.line
                    });
                }
                (dataFieldsUpdated || !_.isEqual(null == previousProperties ? void 0 : previousProperties.barChart.dataProperties, barChartDataProperties) || previousProperties.filledMap.showFilledMap !== filledMapProperties.showFilledMap || previousProperties.bubble.showBubbleLayer !== bubbleLayerProperties.showBubbleLayer || enablePieChartLayer && !_.isEqual(previousProperties.bubble, bubbleLayerProperties) || previousProperties.heatMap.showHeatMapLayer !== heatMapLayerProperties.showHeatMapLayer) && this.updateFeatures();
            }, AzureMapMapControlHelper.prototype.updateDataSourceClusterOptions = function(targetSourceId, newClusterProp) {
                var _this = this, dataSource = this.mapControl.sources.getById(targetSourceId), layersUsingTargetSource = this.mapControl.layers.getLayers().filter(isSourceLayer).filter(function(layer) {
                    var source = layer.getSource();
                    return ("string" == typeof source ? source : null == source ? void 0 : source.getId()) === targetSourceId;
                });
                layersUsingTargetSource.forEach(function(layer) {
                    _this.mapControl.layers.remove(layer);
                });
                var newDataSource = new atlas.source.DataSource(targetSourceId, (0, tslib_es6.__assign)((0, 
                tslib_es6.__assign)({}, dataSource.getOptions()), newClusterProp));
                newDataSource.setShapes(dataSource.getShapes()), dataSource.dispose(), this.mapControl.sources.remove(dataSource), 
                this.mapControl.sources.add(newDataSource), layersUsingTargetSource.forEach(function(layer) {
                    layer.setOptions({
                        source: newDataSource
                    });
                }), this.mapControl.layers.add(layersUsingTargetSource);
            }, AzureMapMapControlHelper.prototype.getMapControlLayerName = function(position) {
                switch (position) {
                  case "labels":
                    return "labels";

                  case "transit":
                    return "roads";

                  default:
                    return;
                }
            }, AzureMapMapControlHelper.prototype.moveLayers = function(layerIds, position) {
                for (var _i = 0, layerIds_1 = layerIds; _i < layerIds_1.length; _i++) {
                    var layerId = layerIds_1[_i];
                    this.mapControl.layers.getLayerById(layerId) && this.mapControl.layers.move(layerId, position);
                }
            }, AzureMapMapControlHelper.prototype.updateFeatureDataSource = function(dataSource, shapes) {
                dataSource && (shapes ? dataSource.setShapes(shapes) : dataSource.clear && dataSource.clear());
            }, AzureMapMapControlHelper.prototype.shouldEnableBubbleLayer = function(properties, data) {
                return properties.bubble.showBubbleLayer && !(data.hasCategory && data.hasSeries);
            }, AzureMapMapControlHelper.prototype.shouldEnablePieChartLayer = function(properties, data, featureSwitches) {
                return properties.bubble.showBubbleLayer && (data.hasCategory && data.hasSeries || Boolean(featureSwitches.azureMapsLatLongPieCharts) && data.hasDuplicatedLatLong);
            }, AzureMapMapControlHelper.prototype.shouldEnableHeatMap = function(properties, data) {
                return properties.heatMap.showHeatMapLayer && !data.hasSeries;
            }, AzureMapMapControlHelper.prototype.getSinglePointZoomLevel = function() {
                switch (this.data && this.data.geocodingCategory) {
                  case mapUtil.yV.Continent:
                    return 1;

                  case mapUtil.yV.CountryRegion:
                    return 2;

                  case mapUtil.yV.StateOrProvince:
                    return 3.5;

                  case mapUtil.yV.County:
                    return 5;

                  case mapUtil.yV.City:
                    return 8.5;

                  case mapUtil.yV.PostalCode:
                    return 10;

                  case mapUtil.yV.Place:
                    return 10.5;

                  default:
                    return 15;
                }
            }, AzureMapMapControlHelper.prototype.getCurrentCameraType = function() {
                return this.formatMode ? "jump" : "fly";
            }, AzureMapMapControlHelper.prototype.setCamera = function(boundingBox, singlePoint, warnings) {
                var cameraOptions = {}, cameraPaddingRequired = !1;
                singlePoint ? cameraOptions = {
                    zoom: this.getSinglePointZoomLevel(),
                    center: atlas.data.BoundingBox.getCenter(boundingBox),
                    type: this.getCurrentCameraType()
                } : (!_.isEmpty(boundingBox) && boundingBox[0] > boundingBox[2] && (boundingBox[0] = -180, 
                boundingBox[2] = 180), cameraOptions = {
                    bounds: boundingBox,
                    type: this.getCurrentCameraType()
                }, (this.data.properties.bubble.showBubbleLayer || this.data.properties.heatMap.showHeatMapLayer) && (cameraPaddingRequired = !0)), 
                this.data.properties.filledMap.showFilledMap && (cameraPaddingRequired = !0);
                var mapCanvas = this.mapControl.getCanvas();
                cameraPaddingRequired && 60 < mapCanvas.width && 60 < mapCanvas.height && (cameraOptions.padding = 30);
                var mapPitch = this.mapControl.getCamera().pitch;
                mapPitch !== azureMapConstant.Z$ && this.data.properties.barChart.dataProperties.showBarChart ? cameraOptions.pitch = azureMapConstant.Z$ : 0 === mapPitch || this.data.properties.barChart.dataProperties.showBarChart || (cameraOptions.pitch = 0);
                try {
                    this.mapControl.setCamera(cameraOptions);
                } catch (e) {
                    if (!this.isCameraBoundsError(e)) throw e;
                    warnings.push(new visualWarnings.x8), this.host.setWarnings(warnings);
                }
            }, AzureMapMapControlHelper.prototype.isCameraBoundsError = function(exception) {
                return exception instanceof Error && exception.message.includes("The map cannot be fit to the current canvas with the given CameraBoundsOptions.");
            }, AzureMapMapControlHelper.prototype.getFeatureMapping = function() {
                var dataPoints = this.data.dataPoints, properties = this.data.properties, barChartProperties = properties.barChart.dataProperties, featureMapping = {
                    bubble: null,
                    barChart3D: null,
                    filledMap: null,
                    heatMap: null,
                    reference: null
                }, visualHasSelection = null != this.behavior && this.behavior.visualHasSelection();
                if (this.data.shouldRenderFilledMap && (featureMapping.filledMap = azureMapFeatureHelper.l.getFilledMapMultiPolygonFeature(dataPoints, visualHasSelection)), 
                barChartProperties.showBarChart) {
                    var thicknessScale = barChartProperties.thickness, barShape = barChartProperties.barShape;
                    thicknessScale = Math.max(thicknessScale, .01), void 0 === this.lastDataZoom && (this.lastDataZoom = Math.round(this.mapControl.getCamera().zoom)), 
                    barChartProperties.scaleThicknessOnZoom && (thicknessScale *= Math.pow(2, 19 - this.lastDataZoom) / 20), 
                    featureMapping.barChart3D = azureMapFeatureHelper.l.getPolygonFeature(dataPoints, thicknessScale, barShape, visualHasSelection);
                }
                if (properties.bubble.showBubbleLayer || properties.heatMap.showHeatMapLayer) {
                    var enableBubbleLayer = this.shouldEnableBubbleLayer(properties, this.data), enablePieChartLayer = this.shouldEnablePieChartLayer(properties, this.data, this.featureSwitches), enableHeatMapLayer = this.shouldEnableHeatMap(properties, this.data), dataPoints_1 = this.data.dataPoints.filter(function(d) {
                        return d.location;
                    }), shouldUseLegacyFormat = this.shouldUseLegacyFormat();
                    shouldUseLegacyFormat && azureMapExpressionHelper.J.LEGACY_appendPieRadiusToDataPoints(dataPoints_1, this.data);
                    var points = azureMapFeatureHelper.l.getPointFeatures(dataPoints_1, visualHasSelection, enableBubbleLayer, enablePieChartLayer, properties.bubble, shouldUseLegacyFormat);
                    (enableBubbleLayer || enablePieChartLayer) && (featureMapping.bubble = points), 
                    enableHeatMapLayer && (featureMapping.heatMap = points);
                }
                return this.featureSwitches.azureMapsDataBoundReferenceLayer && (featureMapping.reference = azureMapFeatureHelper.l.getReferenceLayerFeature(this.referenceDataMatcher, visualHasSelection)), 
                featureMapping;
            }, AzureMapMapControlHelper.prototype.updateMapControlProperties = function(previousProperties) {
                this.updateStyles(null == previousProperties ? void 0 : previousProperties.styleProperties), 
                this.updateControls(null == previousProperties ? void 0 : previousProperties.controlToggles), 
                this.updateCameraProperties(null == previousProperties ? void 0 : previousProperties.cameraProperties);
            }, AzureMapMapControlHelper.prototype.updateStyles = function(previousProperties) {
                var _a = this.data.properties.mapControls.styleProperties, defaultStyle = _a.defaultStyle, showLabels = _a.showLabels, worldWrap = _a.worldWrap, activeStyle = this.mapControl.getStyle(), styleOptions = {};
                defaultStyle !== (null == previousProperties ? void 0 : previousProperties.defaultStyle) && defaultStyle !== activeStyle.style && (styleOptions.style = defaultStyle), 
                worldWrap !== (null == previousProperties ? void 0 : previousProperties.worldWrap) && worldWrap !== activeStyle.renderWorldCopies && (styleOptions.renderWorldCopies = worldWrap), 
                showLabels !== (null == previousProperties ? void 0 : previousProperties.showLabels) && showLabels !== activeStyle.showLabels && (styleOptions.showLabels = showLabels), 
                _.isEmpty(styleOptions) || this.mapControl.setStyle(styleOptions);
            }, AzureMapMapControlHelper.prototype.updateControls = function(previousProperties) {
                var newProperties = this.data.properties.mapControls.controlToggles;
                _.isEqual(previousProperties, newProperties) || (this.addRemoveControl(newProperties.showStylePicker, this.styleControl), 
                this.addRemoveControl(newProperties.showNavigationControls, this.zoomControl), this.addRemoveControl(newProperties.showNavigationControls, this.pitchControl), 
                this.addRemoveControl(newProperties.showNavigationControls, this.compassControl), 
                this.addRemoveControl(newProperties.showSelectionControl, this.selectionControl), 
                newProperties.showSelectionControl && this.behavior && (this.mapControl.events.remove("dataSelected", this.selectionControl, this.behavior.dataSelected), 
                this.mapControl.events.add("dataSelected", this.selectionControl, this.behavior.dataSelected)));
            }, AzureMapMapControlHelper.prototype.updateCameraProperties = function(previousProperties) {
                var newProperties = this.data.properties.mapControls.cameraProperties;
                newProperties.autoZoom || _.isEqual(previousProperties, newProperties) || this.mapControl.setCamera({
                    zoom: newProperties.zoom,
                    bearing: newProperties.heading,
                    pitch: newProperties.pitch,
                    center: new atlas.data.Position(newProperties.centerLongitude, newProperties.centerLatitude)
                });
            }, AzureMapMapControlHelper.prototype.updateTrafficProperties = function(previousProperties) {
                var newProperties = this.data.properties.traffic;
                void 0 === previousProperties && (previousProperties = {}), previousProperties.showTraffic === newProperties.showTraffic && previousProperties.showIncidents === newProperties.showIncidents || this.updateTraffic(newProperties);
                var shouldShowTrafficControl = newProperties.showTraffic && newProperties.showTrafficControl;
                previousProperties.showIncidents !== newProperties.showIncidents && (this.addRemoveControl(!1, this.trafficControl), 
                this.trafficControl = this.createTrafficControl(newProperties.showIncidents)), this.addRemoveControl(shouldShowTrafficControl, this.trafficControl);
            }, AzureMapMapControlHelper.prototype.updateTraffic = function(properties) {
                this.mapControl.setTraffic(properties.showTraffic ? {
                    incidents: properties.showIncidents,
                    flow: "relative"
                } : {
                    incidents: !1,
                    flow: "none"
                });
            }, AzureMapMapControlHelper.prototype.createTrafficControl = function(shouldShowIncidents) {
                return new atlas.control.TrafficControl({
                    incidents: shouldShowIncidents,
                    isActive: !0,
                    flow: "relative"
                });
            }, AzureMapMapControlHelper.prototype.updateTileLayerProperties = function(previousProperties) {
                var newProperties = this.data.properties.tile;
                if (null == previousProperties && (previousProperties = {}), !_.isEqual(previousProperties, newProperties) && (void 0 !== this.tileLayerId && this.mapControl.layers.getLayerById(this.tileLayerId) && this.mapControl.layers.remove(this.tileLayerId), 
                newProperties.tileLayerUrl)) {
                    var tileLayer = new atlas.layer.TileLayer({
                        tileUrl: newProperties.tileLayerUrl,
                        opacity: (0, color.TD)(newProperties.transparency),
                        tileSize: newProperties.tileSize,
                        isTMS: newProperties.isTMS,
                        minSourceZoom: newProperties.minZoom,
                        maxSourceZoom: newProperties.maxZoom,
                        bounds: [ newProperties.westBounds, newProperties.southBounds, newProperties.eastBounds, newProperties.northBounds ]
                    });
                    this.mapControl.layers.add(tileLayer, "labels"), this.tileLayerId = tileLayer.getId();
                    var layersToMove = [ tileLayer.getId() ], position = this.getMapControlLayerName(newProperties.layerPosition);
                    this.moveLayers(layersToMove, position);
                }
            }, AzureMapMapControlHelper.prototype.updateReferenceLayer = function(previousProperties, warnings) {
                var newProperties = this.data.properties.referenceLayer;
                if (!_.isEqual(previousProperties, newProperties)) {
                    if (this.featureSwitches.azureMapsMultiDataFormats) {
                        if (newProperties) {
                            var isFileUpload = "file_upload" === newProperties.datasourceType, isUrl = "url" === newProperties.datasourceType, shouldUpdateFileUploadData = !1, shouldUpdateUrlData = !1, noUrlProvided = "url" === newProperties.datasourceType && _.isEmpty(newProperties.referenceLayerUrl), noFileProvided = "file_upload" === newProperties.datasourceType && newProperties.additionalDatasource && newProperties.additionalDatasource.type === geoJson.c1;
                            if (isFileUpload) {
                                var isValidAdditionalDatasource = !_.isEmpty(newProperties.additionalDatasource) && newProperties.additionalDatasource.type === geoJson.BD && null !== newProperties.additionalDatasource.content && null !== newProperties.additionalDatasource.name, hasPreviousProperties = previousProperties && previousProperties.additionalDatasource, isContentChanged = hasPreviousProperties && !_.isEqual(newProperties.additionalDatasource.content, previousProperties.additionalDatasource.content), isTypeChanged = hasPreviousProperties && !_.isEqual(newProperties.datasourceType, previousProperties.datasourceType), isChanged = !hasPreviousProperties || isContentChanged || isTypeChanged;
                                shouldUpdateFileUploadData = isValidAdditionalDatasource && isChanged;
                            } else if (isUrl) {
                                var hasReferenceLayerUrl = !_.isEmpty(newProperties.referenceLayerUrl);
                                isContentChanged = previousProperties && !_.isEqual(newProperties.referenceLayerUrl, previousProperties.referenceLayerUrl), 
                                isTypeChanged = previousProperties && !_.isEqual(newProperties.datasourceType, previousProperties.datasourceType), 
                                isChanged = !previousProperties || isContentChanged || isTypeChanged, shouldUpdateUrlData = hasReferenceLayerUrl && isChanged;
                            }
                            shouldUpdateFileUploadData ? newProperties.additionalDatasource.name.endsWith(".json") || newProperties.additionalDatasource.name.endsWith(".geojson") || this.featureSwitches.azureMapsCsvSupport && newProperties.additionalDatasource.name.endsWith(".csv") ? this.readSpatialData(newProperties.additionalDatasource.content, warnings) : newProperties.additionalDatasource.name.endsWith(".kml") ? this.readKmlData(newProperties.additionalDatasource.content, warnings) : newProperties.additionalDatasource.name.endsWith(".wkt") ? this.readWktData(!1, newProperties.additionalDatasource.content, warnings) : newProperties.additionalDatasource.name.endsWith(".zip") ? this.readShpData(!1, newProperties.additionalDatasource.content, warnings) : (this.referenceDataSource.clear(), 
                            this.referenceDataMatcher && this.referenceDataMatcher.clearMappings(), this.setAzureMapsFileReadWarning("The uploaded file format is not supported", warnings)) : shouldUpdateUrlData ? newProperties.referenceLayerUrl.endsWith(".json") || newProperties.referenceLayerUrl.endsWith(".geojson") || this.featureSwitches.azureMapsCsvSupport && newProperties.referenceLayerUrl.endsWith(".csv") ? this.readSpatialData(newProperties.referenceLayerUrl, warnings) : newProperties.referenceLayerUrl.endsWith(".kml") ? this.readKmlData(newProperties.referenceLayerUrl, warnings) : newProperties.referenceLayerUrl.endsWith(".wkt") ? this.readWktData(!0, newProperties.referenceLayerUrl, warnings) : newProperties.referenceLayerUrl.endsWith(".zip") ? this.readShpData(!0, newProperties.referenceLayerUrl, warnings) : (this.referenceDataSource.clear(), 
                            this.referenceDataMatcher && this.referenceDataMatcher.clearMappings(), this.setAzureMapsFileReadWarning("The uploaded CDN file format is not supported", warnings)) : (noFileProvided || noUrlProvided) && (this.referenceDataSource.clear(), 
                            this.referenceDataMatcher && this.referenceDataMatcher.clearMappings());
                        }
                    } else newProperties && newProperties.additionalDatasource && newProperties.additionalDatasource.type === geoJson.BD && null !== newProperties.additionalDatasource.content ? this.readSpatialData(newProperties.additionalDatasource.content, warnings) : this.referenceDataSource.clear();
                    this.featureSwitches.azureMapsCustomFormattingReferenceLayer && this.referenceLayer.setOptions({
                        unselectedTransparency: this.data.properties.commonDataOptions.unselectedTransparency,
                        bubble: newProperties.bubble,
                        polygon: newProperties.polygon,
                        line: newProperties.line,
                        style: this.style
                    });
                }
            }, AzureMapMapControlHelper.prototype.updateReferenceDataMappings = function(shapes) {
                this.featureSwitches.azureMapsDataBoundReferenceLayer && (this.referenceDataMatcher ? (this.referenceDataMatcher.setShapes(shapes), 
                this.referenceDataMatcher.createShapeDataMappings()) : this.referenceDataMatcher = new ReferenceDataShapeMatcher(shapes, this.data.dataPoints), 
                this.updateFeatures());
            }, AzureMapMapControlHelper.prototype.setShpfileShapesToDataSource = function(data) {
                var features = data.flatMap(function(item) {
                    return item.features;
                });
                this.referenceDataSource.setShapes(features), this.updateReferenceDataMappings(features);
            }, AzureMapMapControlHelper.prototype.parseShpfileToGeoJSON = function(shpJs, content, warnings) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var geojson, error_1;
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        switch (_a.label) {
                          case 0:
                            return _a.trys.push([ 0, 2, , 3 ]), [ 4, shpJs(content) ];

                          case 1:
                            return (geojson = _a.sent()) instanceof Array || (geojson = [ geojson ]), [ 2, geojson ];

                          case 2:
                            return error_1 = _a.sent(), this.setAzureMapsFileReadWarning(error_1 + "Failed to parse shapefile", warnings), 
                            [ 3, 3 ];

                          case 3:
                            return [ 2, [] ];
                        }
                    });
                });
            }, AzureMapMapControlHelper.prototype.dataUri2ArrayBuffer = function(dataUri, warnings) {
                try {
                    for (var dataPart = dataUri.split(",")[1], decodedData = atob(dataPart), arrayBuffer = new ArrayBuffer(decodedData.length), uint8Array = new Uint8Array(arrayBuffer), i = 0; i < decodedData.length; i++) uint8Array[i] = decodedData.charCodeAt(i);
                    return arrayBuffer;
                } catch (error) {
                    return this.setAzureMapsFileReadWarning(error + "Failed to decode the data part of the Data URI", warnings), 
                    null;
                }
            }, AzureMapMapControlHelper.prototype.readShpData = function(isUrl, content, warnings) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var shpJs_1, shpContent_1, error_2, _this = this;
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        switch (_a.label) {
                          case 0:
                            return _a.trys.push([ 0, 2, , 3 ]), debug.fF.assertValue(this.mapControlFactory, "mapControlFactory"), 
                            [ 4, this.mapControlFactory.loadShpJs() ];

                          case 1:
                            return shpJs_1 = _a.sent(), shpContent_1 = content, isUrl || (shpContent_1 = this.dataUri2ArrayBuffer(content, warnings)), 
                            shpContent_1 && (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                var geojson;
                                return (0, tslib_es6.__generator)(this, function(_a) {
                                    switch (_a.label) {
                                      case 0:
                                        return [ 4, this.parseShpfileToGeoJSON(shpJs_1, shpContent_1, warnings) ];

                                      case 1:
                                        return (geojson = _a.sent()) && this.setShpfileShapesToDataSource(geojson), [ 2 ];
                                    }
                                });
                            }), [ 3, 3 ];

                          case 2:
                            return error_2 = _a.sent(), this.setAzureMapsFileReadWarning(error_2 + "Failed to load shpjs lib", warnings), 
                            [ 3, 3 ];

                          case 3:
                            return [ 2 ];
                        }
                    });
                });
            }, AzureMapMapControlHelper.prototype.readKmlData = function(content, warnings) {
                var _this = this, map = this.mapControl;
                atlas.io.read(content).then(function(data) {
                    return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                        var imagePromises_1, keys;
                        return (0, tslib_es6.__generator)(this, function(_a) {
                            switch (_a.label) {
                              case 0:
                                return data && data.features && data.features.length > 0 ? data.icons ? (imagePromises_1 = [], 
                                0 === (keys = Object.keys(data.icons)).length ? [ 3, 2 ] : (keys.forEach(function(key) {
                                    return imagePromises_1.push(map.imageSprite.add(key, data.icons[key]));
                                }), [ 4, Promise.all(imagePromises_1) ])) : [ 3, 2 ] : [ 3, 3 ];

                              case 1:
                                _a.sent(), _a.label = 2;

                              case 2:
                                return this.referenceDataSource.setShapes(data.features), this.updateReferenceDataMappings(data.features), 
                                [ 3, 4 ];

                              case 3:
                                this.setAzureMapsFileReadWarning("The uploaded KML could not be converted into a SpatialDataSet object or lacks geometric data", warnings), 
                                _a.label = 4;

                              case 4:
                                return [ 2 ];
                            }
                        });
                    });
                }, function(_error) {
                    _this.setAzureMapsFileReadWarning(_error + "Invalid KML format", warnings);
                });
            }, AzureMapMapControlHelper.prototype.readWktData = function(isUrl, content, warnings) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var data, _this = this;
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        switch (_a.label) {
                          case 0:
                            return isUrl ? [ 4, fetch(content).then(function(response) {
                                return response.text();
                            }).catch(function(error) {
                                _this.setAzureMapsFileReadWarning(error + "Unable to fetch data from this URL", warnings);
                            }).then(function(result) {
                                result && (data = atlas.io.ogc.WKT.read(result));
                            }) ] : [ 3, 2 ];

                          case 1:
                            return _a.sent(), [ 3, 3 ];

                          case 2:
                            data = atlas.io.ogc.WKT.read(content), _a.label = 3;

                          case 3:
                            return data && data.length > 0 ? this.referenceDataSource.setShapes(data) : this.setAzureMapsFileReadWarning("Invalid WKT formats", warnings), 
                            [ 2 ];
                        }
                    });
                });
            }, AzureMapMapControlHelper.prototype.readSpatialData = function(content, warnings) {
                var _this = this;
                atlas.io.read(content, {
                    maxFeatures: 3e4,
                    maxNetworkLinks: 0
                }).then(function(data) {
                    data && data.features && data.features.length > 0 ? (_this.referenceDataSource.setShapes(data.features), 
                    _this.updateReferenceDataMappings(data.features)) : _this.setAzureMapsFileReadWarning("The uploaded file could not be converted into a SpatialDataSet object or lacks geometric data", warnings);
                }, function(_error) {
                    _this.setAzureMapsFileReadWarning(_error + "Invalid file format", warnings);
                });
            }, AzureMapMapControlHelper.prototype.setAzureMapsFileReadWarning = function(msg, warnings) {
                trace.f.error(msg, !0, void 0, {}), null == warnings && (warnings = []), warnings.push(new visualWarnings.$B), 
                this.host.setWarnings(warnings);
            }, AzureMapMapControlHelper.prototype.addRemoveControl = function(showControl, control) {
                if (control) {
                    var controlExists = -1 !== this.mapControl.controls.getControls().indexOf(control);
                    showControl && !controlExists && (this.mapControl.controls.add(control, {
                        position: atlas.ControlPosition.TopRight
                    }), this.setControlsContainer(control)), !showControl && controlExists && this.mapControl.controls.remove(control);
                }
            }, AzureMapMapControlHelper.prototype.setControlsContainer = function(control) {
                var _a, singleControlContainer, controlElement = control;
                control === this.selectionControl ? singleControlContainer = this.selectionControl.getContainer() : (null === (_a = controlElement._container) || void 0 === _a ? void 0 : _a.classList.contains("azure-maps-control-container")) && (singleControlContainer = controlElement._container), 
                singleControlContainer && (this.controlsContainer = singleControlContainer.parentElement, 
                d3.select(this.controlsContainer).attr("focus-nav-mode", "Hierarchy"), d3.select(this.controlsContainer).attr(htmlSubSelectionHelper.Ez, "controls"), 
                d3.select(this.controlsContainer).attr(htmlSubSelectionHelper.CK, "Visual_MapControls"), 
                d3.select(this.controlsContainer).attr(htmlSubSelectionHelper.QZ, 3), d3.select(this.controlsContainer).classed(htmlSubSelectionHelper.cy, !0), 
                this.formatMode && this.attachControlsListeners());
            }, AzureMapMapControlHelper.prototype.attachControlsListeners = function() {
                !this.iscontrolsListenersAttached && this.controlsContainer && (this.controlsContainer.style.pointerEvents = "auto", 
                this.controlsContainer.addEventListener("mouseenter", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.addEventListener("mouseover", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.addEventListener("focusin", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.addEventListener("focusout", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.classList.add("disable-azure-maps-controls-tooltips"), this.iscontrolsListenersAttached = !0);
            }, AzureMapMapControlHelper.prototype.removeControlsListeners = function() {
                this.iscontrolsListenersAttached && this.controlsContainer && (this.controlsContainer.removeEventListener("mouseenter", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.removeEventListener("mouseover", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.removeEventListener("focusin", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.removeEventListener("focusout", this.disableControlsDefaultEvent, !0), 
                this.controlsContainer.classList.remove("disable-azure-maps-controls-tooltips"), 
                this.iscontrolsListenersAttached = !1);
            }, AzureMapMapControlHelper;
        }(), AzureMapObjectEnumerationHelper = function() {
            function AzureMapObjectEnumerationHelper() {}
            return AzureMapObjectEnumerationHelper.enumerateMapControlProperties = function(enumeration, properties, featureSwitches) {
                var azureMapsGeocoding = featureSwitches.azureMapsGeocoding, azureMapsShowLabels = featureSwitches.azureMapsShowLabels, mapControlProperties = {
                    autoZoom: properties.mapControls.cameraProperties.autoZoom,
                    worldWrap: properties.mapControls.styleProperties.worldWrap,
                    showStylePicker: properties.mapControls.controlToggles.showStylePicker,
                    showNavigationControls: properties.mapControls.controlToggles.showNavigationControls,
                    defaultStyle: properties.mapControls.styleProperties.defaultStyle,
                    showSelectionControl: properties.mapControls.controlToggles.showSelectionControl
                };
                properties.mapControls.cameraProperties.autoZoom || (mapControlProperties.zoom = properties.mapControls.cameraProperties.zoom, 
                mapControlProperties.centerLatitude = properties.mapControls.cameraProperties.centerLatitude, 
                mapControlProperties.centerLongitude = properties.mapControls.cameraProperties.centerLongitude, 
                mapControlProperties.heading = properties.mapControls.cameraProperties.heading, 
                mapControlProperties.pitch = properties.mapControls.cameraProperties.pitch), azureMapsGeocoding && (mapControlProperties.geocodingCulture = properties.mapControls.geocodingCulture), 
                azureMapsShowLabels && (mapControlProperties.showLabels = properties.mapControls.styleProperties.showLabels), 
                enumeration.pushInstance({
                    selector: null,
                    properties: mapControlProperties,
                    validValues: {
                        centerLatitude: {
                            numberRange: {
                                min: azureMapConstant.U1,
                                max: azureMapConstant.hW
                            }
                        },
                        centerLongitude: {
                            numberRange: {
                                min: azureMapConstant.Nq,
                                max: azureMapConstant.Yi
                            }
                        },
                        zoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        },
                        heading: {
                            numberRange: {
                                min: azureMapConstant.Yl,
                                max: azureMapConstant.Ix
                            }
                        },
                        pitch: {
                            numberRange: {
                                min: azureMapConstant.WL,
                                max: azureMapConstant.a_
                            }
                        }
                    },
                    objectName: azureMap_capabilities.Do.mapControls
                });
            }, AzureMapObjectEnumerationHelper.enumerateTrafficProperties = function(enumeration, properties) {
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: properties.traffic.showTraffic,
                        showIncidents: properties.traffic.showIncidents,
                        showTrafficControl: properties.traffic.showTrafficControl
                    },
                    objectName: azureMap_capabilities.Do.traffic
                });
            }, AzureMapObjectEnumerationHelper.enumerateTileLayerProperties = function(enumeration, properties) {
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        tileLayerUrl: properties.tile.tileLayerUrl,
                        tileSize: properties.tile.tileSize,
                        northBounds: properties.tile.northBounds,
                        southBounds: properties.tile.southBounds,
                        eastBounds: properties.tile.eastBounds,
                        westBounds: properties.tile.westBounds,
                        mapTransparency: properties.tile.transparency,
                        isTMS: properties.tile.isTMS,
                        minZoom: properties.tile.minZoom,
                        maxZoom: properties.tile.maxZoom,
                        layerPosition: properties.tile.layerPosition
                    },
                    validValues: {
                        tileSize: {
                            numberRange: {
                                min: azureMapConstant.nv,
                                max: azureMapConstant.Co
                            }
                        },
                        northBounds: {
                            numberRange: {
                                min: azureMapConstant.U1,
                                max: azureMapConstant.hW
                            }
                        },
                        southBounds: {
                            numberRange: {
                                min: azureMapConstant.U1,
                                max: azureMapConstant.hW
                            }
                        },
                        eastBounds: {
                            numberRange: {
                                min: azureMapConstant.Nq,
                                max: azureMapConstant.Yi
                            }
                        },
                        westBounds: {
                            numberRange: {
                                min: azureMapConstant.Nq,
                                max: azureMapConstant.Yi
                            }
                        },
                        minZoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        },
                        maxZoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        }
                    },
                    objectName: azureMap_capabilities.Do.tileLayer
                });
            }, AzureMapObjectEnumerationHelper.enumerateFilledMapProperties = function(enumeration, properties, hasSize, enable) {
                !hasSize && enable && enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: properties.filledMap.showFilledMap,
                        mapTransparency: properties.filledMap.transparency,
                        strokeColor: properties.filledMap.strokeColor,
                        strokeTransparency: properties.filledMap.strokeTransparency,
                        strokeWidth: properties.filledMap.strokeWidth,
                        minZoom: properties.filledMap.minZoom,
                        maxZoom: properties.filledMap.maxZoom,
                        layerPosition: properties.filledMap.layerPosition
                    },
                    validValues: {
                        minZoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        },
                        maxZoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        },
                        strokeWidth: {
                            numberRange: {
                                min: azureMapConstant.Bc,
                                max: azureMapConstant.Qv
                            }
                        }
                    },
                    objectName: azureMap_capabilities.Do.filledMap
                });
            }, AzureMapObjectEnumerationHelper.enumerateBubbleLayerProperties = function(enumeration, properties, hasSize, hasPieChart) {
                var bubbleLayerProperties = {
                    show: properties.bubble.showBubbleLayer
                };
                if (hasSize && !hasPieChart) {
                    bubbleLayerProperties.minBubbleRadius = properties.bubble.minRadius, bubbleLayerProperties.maxRadius = properties.bubble.maxRadius;
                    var radiusScalingMethod = properties.bubble.radiusScalingMethod;
                    bubbleLayerProperties.radiusScalingMethod = radiusScalingMethod, 1 === radiusScalingMethod && (bubbleLayerProperties.logScale = properties.bubble.logScale), 
                    2 === radiusScalingMethod && (bubbleLayerProperties.x1 = properties.bubble.x1, bubbleLayerProperties.x2 = properties.bubble.x2, 
                    bubbleLayerProperties.y1 = properties.bubble.y1, bubbleLayerProperties.y2 = properties.bubble.y2);
                } else bubbleLayerProperties.bubbleRadius = properties.bubble.radius;
                bubbleLayerProperties.mapTransparency = properties.bubble.transparency, hasPieChart || (bubbleLayerProperties.autoStrokeColor = properties.bubble.autoStrokeColor), 
                properties.bubble.autoStrokeColor && !hasPieChart || (bubbleLayerProperties.strokeColor = properties.bubble.strokeColor), 
                bubbleLayerProperties.strokeTransparency = properties.bubble.strokeTransparency, 
                bubbleLayerProperties.bubbleStrokeWidth = properties.bubble.strokeWidth, hasPieChart || (bubbleLayerProperties.pitchAlignment = properties.bubble.pitchAlignment, 
                bubbleLayerProperties.blur = properties.bubble.blur, bubbleLayerProperties.zoomScaleFactor = properties.bubble.zoomScaleFactor), 
                bubbleLayerProperties.minZoom = properties.bubble.minZoom, bubbleLayerProperties.maxZoom = properties.bubble.maxZoom, 
                bubbleLayerProperties.layerPosition = properties.bubble.layerPosition, enumeration.pushInstance({
                    selector: null,
                    properties: bubbleLayerProperties,
                    validValues: {
                        bubbleRadius: {
                            numberRange: {
                                min: azureMapConstant.Fw,
                                max: azureMapConstant.rn
                            }
                        },
                        minBubbleRadius: {
                            numberRange: {
                                min: azureMapConstant.Fw,
                                max: azureMapConstant.rn
                            }
                        },
                        maxRadius: {
                            numberRange: {
                                min: azureMapConstant.Fw,
                                max: azureMapConstant.rn
                            }
                        },
                        minZoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        },
                        maxZoom: {
                            numberRange: {
                                min: azureMapConstant.JX,
                                max: azureMapConstant.Yd
                            }
                        },
                        x1: {
                            numberRange: {
                                min: azureMapConstant.nB,
                                max: azureMapConstant.NR
                            }
                        },
                        x2: {
                            numberRange: {
                                min: azureMapConstant.nB,
                                max: azureMapConstant.NR
                            }
                        },
                        y1: {
                            numberRange: {
                                min: azureMapConstant.nB,
                                max: azureMapConstant.NR
                            }
                        },
                        y2: {
                            numberRange: {
                                min: azureMapConstant.nB,
                                max: azureMapConstant.NR
                            }
                        },
                        logScale: {
                            numberRange: {
                                min: azureMapConstant.pi,
                                max: azureMapConstant.I9
                            }
                        },
                        bubbleStrokeWidth: {
                            numberRange: {
                                min: azureMapConstant.Bc,
                                max: azureMapConstant.Qv
                            }
                        },
                        zoomScaleFactor: {
                            numberRange: {
                                min: azureMapConstant.Ng,
                                max: azureMapConstant.fI
                            }
                        }
                    },
                    objectName: azureMap_capabilities.Do.bubbleLayer
                });
            }, AzureMapObjectEnumerationHelper.enumerateHeatMapProperties = function(enumeration, properties, hasSize, hasSeries) {
                if (!hasSeries) {
                    var heatMapLayerProperties = {
                        show: properties.heatMap.showHeatMapLayer
                    };
                    heatMapLayerProperties.heatMapRadius = properties.heatMap.heatMapRadius, heatMapLayerProperties.heatMapRadiusUnit = properties.heatMap.heatMapRadiusUnit, 
                    heatMapLayerProperties.mapTransparency = properties.heatMap.heatMapTransparency, 
                    heatMapLayerProperties.heatMapIntensity = properties.heatMap.heatMapIntensity, hasSize && (heatMapLayerProperties.heatMapUseSize = properties.heatMap.heatMapUseSize), 
                    heatMapLayerProperties.heatMapColorLow = properties.heatMap.heatMapColorLow, heatMapLayerProperties.heatMapColorCenter = properties.heatMap.heatMapColorCenter, 
                    heatMapLayerProperties.heatMapColorHigh = properties.heatMap.heatMapColorHigh, heatMapLayerProperties.minZoom = properties.heatMap.minZoom, 
                    heatMapLayerProperties.maxZoom = properties.heatMap.maxZoom, heatMapLayerProperties.layerPosition = properties.heatMap.layerPosition;
                    var maxHeatMapRadius = azureMapConstant.OH;
                    "meters" === heatMapLayerProperties.heatMapRadiusUnit && (maxHeatMapRadius = azureMapConstant.NI), 
                    enumeration.pushInstance({
                        selector: null,
                        properties: heatMapLayerProperties,
                        validValues: {
                            heatMapRadius: {
                                numberRange: {
                                    min: azureMapConstant._0,
                                    max: maxHeatMapRadius
                                }
                            },
                            heatMapIntensity: {
                                numberRange: {
                                    min: azureMapConstant.x6,
                                    max: azureMapConstant.Dz
                                }
                            },
                            minZoom: {
                                numberRange: {
                                    min: azureMapConstant.JX,
                                    max: azureMapConstant.Yd
                                }
                            },
                            maxZoom: {
                                numberRange: {
                                    min: azureMapConstant.JX,
                                    max: azureMapConstant.Yd
                                }
                            }
                        },
                        objectName: azureMap_capabilities.Do.heatMapLayer
                    });
                }
            }, AzureMapObjectEnumerationHelper.enumerateBarChartProperties = function(enumeration, properties, disable) {
                if (!disable) {
                    var dataProperties = properties.barChart.dataProperties, paintProperties = properties.barChart.paintProperties, enumerationProperties = {
                        show: dataProperties.showBarChart,
                        barShape: dataProperties.barShape,
                        barHeight: paintProperties.height,
                        scaleHeightOnZoom: paintProperties.scaleHeightOnZoom,
                        thickness: dataProperties.thickness,
                        scaleThicknessOnZoom: dataProperties.scaleThicknessOnZoom
                    };
                    enumerationProperties.mapTransparency = paintProperties.transparency, enumerationProperties.minZoom = paintProperties.minZoom, 
                    enumerationProperties.maxZoom = paintProperties.maxZoom, enumerationProperties.layerPosition = paintProperties.layerPosition, 
                    enumeration.pushInstance({
                        selector: null,
                        properties: enumerationProperties,
                        validValues: {
                            minZoom: {
                                numberRange: {
                                    min: azureMapConstant.JX,
                                    max: azureMapConstant.Yd
                                }
                            },
                            maxZoom: {
                                numberRange: {
                                    min: azureMapConstant.JX,
                                    max: azureMapConstant.Yd
                                }
                            },
                            barHeight: {
                                numberRange: {
                                    min: azureMapConstant.Z3,
                                    max: azureMapConstant.t
                                }
                            },
                            thickness: {
                                numberRange: {
                                    min: azureMapConstant.z$,
                                    max: azureMapConstant.W5
                                }
                            }
                        },
                        objectName: azureMap_capabilities.Do.barChart
                    });
                }
            }, AzureMapObjectEnumerationHelper.enumerateCommonDataLayerProperties = function(enumeration, properties, hasSize, hasPieChart) {
                var enumerationProperties = {
                    unselectedTransparency: properties.commonDataOptions.unselectedTransparency
                };
                hasSize && !hasPieChart && (enumerationProperties.showZeros = properties.commonDataOptions.showZeros, 
                enumerationProperties.showNegatives = properties.commonDataOptions.showNegatives, 
                enumerationProperties.minDataValue = properties.commonDataOptions.minDataValue, 
                enumerationProperties.maxDataValue = properties.commonDataOptions.maxDataValue), 
                enumeration.pushInstance({
                    selector: null,
                    properties: enumerationProperties,
                    objectName: azureMap_capabilities.Do.commonDataOptions
                });
            }, AzureMapObjectEnumerationHelper.enumerateReferenceLayerProperties = function(enumeration, properties, referenceExists) {
                enumeration.pushInstance(referenceExists ? {
                    selector: null,
                    properties: {
                        additionalDatasource: properties.referenceLayer.additionalDatasource
                    },
                    objectName: azureMap_capabilities.Do.referenceLayer
                } : {
                    selector: null,
                    properties: {
                        additionalDatasource: {}
                    },
                    objectName: azureMap_capabilities.Do.referenceLayer
                });
            }, AzureMapObjectEnumerationHelper;
        }(), azureMapOnObjectUtil = __webpack_require__(19076), AzureMapSasTokenHelper = function() {
            function AzureMapSasTokenHelper() {}
            return AzureMapSasTokenHelper.buildSasTokenWarning = function(code) {
                switch (code) {
                  case "UndefinedToken":
                    return new visualWarnings.U9;

                  case "RequestError":
                    return new visualWarnings.ij;

                  default:
                    return new visualWarnings.Vt;
                }
            }, AzureMapSasTokenHelper.isSasTokenWarning = function(warning) {
                switch (warning.code) {
                  case "UndefinedToken":
                  case "UnrecognizedCode":
                  case "RequestError":
                    return !0;

                  default:
                    return !1;
                }
            }, AzureMapSasTokenHelper.logTelemetry = function(code, telemetryService) {
                telemetryService && telemetryService.trace(3, "AzureMapSasToken".concat(code)), 
                trace.f.assertFail("The Azure map SAS token generation failed with error ".concat(code));
            }, AzureMapSasTokenHelper;
        }(), AzureMap = function() {
            function AzureMap(options) {
                this.isDestroyed = !1, this.warnings = [], debug.fF.assertValue(options, "options"), 
                this.featureSwitches = options.featureSwitches || {}, this.mapControlFactory = options.mapControlFactory, 
                this.behavior = options.behavior, AzureMap.MapContainer = (0, CssConstants.CH)("mapControl"), 
                this.rescaleMap = options.rescaleMap, this.isTouchEvent = !0 === options.isTouchEvent, 
                this.mapControlFactory && this.ensureAzureMapScripts(this.mapControlFactory, this.featureSwitches.azureMapsUseMapControlV3);
            }
            return AzureMap.prototype.init = function(options) {
                var _this = this;
                if (debug.fF.assertValue(options, "options"), this.element = options.element, this.style = options.style, 
                this.host = options.host, this.featureSwitches = options.featureSwitches || {}, 
                this.behavior && (this.interactivityService = (0, interactivityService.ub)(this.host, options.featureSwitches)), 
                this.promiseFactory = this.host.promiseFactory(), this.host.locale && (this.locale = this.host.locale()), 
                this.currentViewport = options.viewport, this.currentViewport.scale = this.currentViewport.scale || 1, 
                this.landingPage = new AzureMapLandingPage(this.element), this.featureSwitches.azureMapsUseMapControlV3 || (this.rescaleMap = !0), 
                this.legend = (0, legend.OG)(this.element, !1, this.interactivityService, !!this.behavior, void 0, this.style, this.host), 
                this.blockExtendedLocations = !this.featureSwitches.azureMapsRegionalDataProcessingConsentEnabled, 
                this.geocoder = this.host.geocoder(), this.geoTaggingAnalyzerService = (0, geoTaggingAnalyzerService.P)().create(options.host.getLocalizedString.bind(options.host)), 
                this.pendingGeocodingRender = 0, this.isDestroyed = !1, this.enableFilledMap = this.featureSwitches.azureMapsFilledMap, 
                this.featureSwitches.onObject && this.interactivityService) {
                    var subSelectionHostService = this.host.getSubSelectionService(), renderer = null != subSelectionHostService ? subSelectionHostService : subSelectionOutlineRenderer.D.createWithDefaultHost();
                    this.subSelectionHelper = htmlSubSelectionHelper.O5.createHtmlSubselectionHelper({
                        hostElement: this.element.get(0),
                        hostServices: this.host,
                        renderer,
                        targetSource: "format",
                        scale: function() {
                            return _this.currentViewport.scale;
                        }
                    }), this.interactivityService.setSubSelectionHelper(this.subSelectionHelper), this.behavior && this.behavior.setSubSelectionHelper(this.subSelectionHelper);
                }
                this.geocodeBackend = 1, this.featureSwitches.azureMapsDataResidency && this.listenForUrlChange(), 
                this.ensureMap(!1);
            }, AzureMap.prototype.destroy = function() {
                if (this.isDestroyed = !0, this.mapControl) try {
                    this.mapControl.dispose();
                } catch (_a) {}
                if (this.mapControlHelper) try {
                    this.mapControlHelper.destroy();
                } catch (_b) {}
                this.pendingGeocodingRender && (clearTimeout(this.pendingGeocodingRender), this.pendingGeocodingRender = 0), 
                this.geocodingContext && this.geocodingContext.timeout && this.geocodingContext.timeout.resolve(null), 
                this.urlChangeSubscription && this.urlChangeSubscription.unsubscribe();
            }, AzureMap.prototype.getFormattingModel = function() {
                var _this = this;
                if (this.data && !this.isDestroyed) {
                    var mapProperties = this.data.properties, dataLabelSettings = this.data.dataLabelSettings, localize = function(key) {
                        return _this.host.getLocalizedString(key);
                    }, categoryOptionsBuilder = function(groupBuilder) {
                        return {
                            groupBuilder,
                            colorProps: azureMap_capabilities.MC.dataPoint,
                            featureSwitches: _this.featureSwitches,
                            hostService: _this.host,
                            options: {
                                dataView: _this.dataView,
                                style: _this.style,
                                categories: _.map(_this.data.dataPoints, function(dataPoint) {
                                    var subDataPoint = dataPoint.subDataPoints[0];
                                    return {
                                        color: (0, color.ci)(subDataPoint.color),
                                        displayName: dataPoint.categoryValue,
                                        identity: subDataPoint.identity
                                    };
                                }),
                                fillInstanceKind: 3
                            }
                        };
                    }, seriesOptionsBuilder = function(groupBuilder) {
                        return {
                            groupBuilder,
                            dataPoints: (0, legend_formatting.l3)(_this.data.legendData),
                            seriesColorProps: azureMap_capabilities.MC.dataPoint,
                            localize,
                            featureSwitches: _this.featureSwitches
                        };
                    };
                    return new build_control_util.Nq(function() {
                        return AzureMapFormatModelHelper.getMapSettingsCard(mapProperties, _this.featureSwitches, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getLayerSettingsCard(_this.data, mapProperties, _this.featureSwitches, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getLegendCard(_this.host, _this.data.legendData, _this.featureSwitches, _this.data);
                    }, function() {
                        return AzureMapFormatModelHelper.getFilledMapCard(_this.data, _this.dataView, mapProperties, _this.enableFilledMap, seriesOptionsBuilder, categoryOptionsBuilder, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getBubbleCard(_this.data, _this.dataView, mapProperties, seriesOptionsBuilder, categoryOptionsBuilder, _this.featureSwitches, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getBubbleClusteringCard(_this.data, _this.dataView, mapProperties, _this.featureSwitches, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getCategoryLabelCard(_this.data, mapProperties, dataLabelSettings, _this.style, _this.featureSwitches, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getHeatMapCard(_this.data, mapProperties, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getBarChartCard(_this.data, _this.dataView, mapProperties, seriesOptionsBuilder, categoryOptionsBuilder, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getReferenceLayerCard(mapProperties, _this.featureSwitches, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getTrafficCard(mapProperties, localize);
                    }, function() {
                        return AzureMapFormatModelHelper.getTileLayerCard(mapProperties, localize);
                    }).build();
                }
            }, AzureMap.prototype.enumerateObjectInstances = function(options) {
                if (this.dataView && this.data) {
                    var enumeration = new objectEnumerationBuilder.G, mapProperties = this.data.properties, hasPieChart = this.data.hasCategory && this.data.hasSeries;
                    switch (options.objectName) {
                      case azureMap_capabilities.Do.mapControls:
                        AzureMapObjectEnumerationHelper.enumerateMapControlProperties(enumeration, mapProperties, this.featureSwitches);
                        break;

                      case azureMap_capabilities.Do.traffic:
                        AzureMapObjectEnumerationHelper.enumerateTrafficProperties(enumeration, mapProperties);
                        break;

                      case azureMap_capabilities.Do.tileLayer:
                        AzureMapObjectEnumerationHelper.enumerateTileLayerProperties(enumeration, mapProperties);
                        break;

                      case azureMap_capabilities.Do.commonDataOptions:
                        AzureMapObjectEnumerationHelper.enumerateCommonDataLayerProperties(enumeration, mapProperties, this.data.hasSize, hasPieChart);
                        break;

                      case azureMap_capabilities.Do.filledMap:
                        this.data && this.data.dataPoints && 0 !== this.data.dataPoints.length && AzureMapObjectEnumerationHelper.enumerateFilledMapProperties(enumeration, mapProperties, this.data.hasSize, this.enableFilledMap);
                        break;

                      case azureMap_capabilities.Do.bubbleLayer:
                        this.data && this.data.dataPoints && 0 !== this.data.dataPoints.length && AzureMapObjectEnumerationHelper.enumerateBubbleLayerProperties(enumeration, mapProperties, this.data.hasSize, hasPieChart);
                        break;

                      case azureMap_capabilities.Do.heatMapLayer:
                        this.data && this.data.dataPoints && 0 !== this.data.dataPoints.length && AzureMapObjectEnumerationHelper.enumerateHeatMapProperties(enumeration, mapProperties, this.data.hasSize, this.data.hasSeries);
                        break;

                      case azureMap_capabilities.Do.barChart:
                        this.data && this.data.dataPoints && 0 !== this.data.dataPoints.length && AzureMapObjectEnumerationHelper.enumerateBarChartProperties(enumeration, mapProperties, hasPieChart);
                        break;

                      case azureMap_capabilities.Do.referenceLayer:
                        AzureMapObjectEnumerationHelper.enumerateReferenceLayerProperties(enumeration, mapProperties, null !== mapProperties.referenceLayer.additionalDatasource);
                    }
                    return enumeration.complete();
                }
            }, AzureMap.prototype.getSubSelectionStyles = function(subSelections) {
                var visualObject, selectorsByColumn, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0 && !_.isEmpty(visualObjects[0])) {
                    selectorsByColumn = (visualObject = visualObjects[0]).selectorsByColumn;
                    var objectName = visualObject.objectName;
                    switch (objectName.startsWith("bubbles") && (objectName = objectName.split("-")[0]), 
                    objectName) {
                      case "legend-title":
                        return (0, legend_formatting.aJ)();

                      case "legend-items":
                        return (0, legend_formatting.Gh)(this.host);

                      case "bubbles":
                        return azureMapOnObjectUtil.E.getBubblesSubSelectionStyles(this.host, selectorsByColumn);

                      default:
                        return;
                    }
                }
            }, AzureMap.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                if (this.featureSwitches.onObject && !filter && !this.isDestroyed) {
                    var visualObjects = _.first(subSelections).visualObjects;
                    if (visualObjects.length > 0 && !_.isEmpty(visualObjects[0])) {
                        var objectName = visualObjects[0].objectName;
                        switch (objectName.startsWith("bubbles") && (objectName = objectName.split("-")[0]), 
                        objectName) {
                          case "legend-title":
                            return (0, legend_formatting.tV)(this.host);

                          case "legend-items":
                            return (0, legend_formatting.tY)({
                                hostServices: this.host,
                                showSort: !1
                            });

                          case "controls":
                            var controlsGroupUid = "".concat("mapControls", "-").concat("controls");
                            return [ {
                                type: 0,
                                relatedResetFormattingIds: [ azureMap_capabilities.MC.mapControls.worldWrap, azureMap_capabilities.MC.mapControls.showStylePicker, azureMap_capabilities.MC.mapControls.showNavigationControls, azureMap_capabilities.MC.mapControls.showSelectionControl, azureMap_capabilities.MC.mapControls.geocodingCulture ]
                            }, {
                                type: 1,
                                destinationInfo: {
                                    cardUid: "".concat("Visual", "-").concat("mapControls"),
                                    groupUid: controlsGroupUid
                                },
                                label: this.host.getLocalizedString("Format_Controls")
                            } ];

                          case "map":
                            var mapGroupUid = "".concat("mapControls", "-").concat("style");
                            return [ {
                                type: 0,
                                relatedResetFormattingIds: [ azureMap_capabilities.MC.mapControls.defaultStyle ]
                            }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                                type: 3
                            }, azureMap_capabilities.MC.mapControls.defaultStyle), {
                                label: this.host.getLocalizedString("Visual_AzureMapsDefaultStyle")
                            }), {
                                type: 1,
                                destinationInfo: {
                                    cardUid: "".concat("Visual", "-").concat("mapControls"),
                                    groupUid: mapGroupUid
                                },
                                label: this.host.getLocalizedString("Format_Map")
                            } ];

                          case "bubbles":
                            return azureMapOnObjectUtil.E.getBubblesSubSelectionShortcuts(this.host);

                          default:
                            return;
                        }
                    }
                }
            }, AzureMap.prototype.getSubSelectables = function(filterType) {
                return azureMapOnObjectUtil.E.getAllSubSelectables(this.data, this.host, this.subSelectionHelper, filterType);
            }, AzureMap.prototype.getNextSubSelectable = function(currentSubSelectable, backwards) {
                return azureMapOnObjectUtil.E.getNextSubSelectable(this.data, this.host, this.subSelectionHelper, currentSubSelectable, backwards);
            }, AzureMap.prototype.onViewModeChanged = function(viewMode) {
                1 === viewMode && this.mapControlHelper && this.mapControlHelper.handleKeyboardShortcuts(this.element);
            }, AzureMap.prototype.onRestoreSelection = function(options) {
                return !!this.interactivityService && this.interactivityService.restoreSelection(options.selection);
            }, AzureMap.prototype.update = function(options) {
                var _a, _b, _c;
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var formatMode, previousData, shouldUpdateOnResize, dataPoints, selectableDataPoints, _i, dataPoints_1, _this = this;
                    return (0, tslib_es6.__generator)(this, function(_d) {
                        switch (_d.label) {
                          case 0:
                            return debug.fF.assertValue(options, "options"), this.visualUpdateOptions = options, 
                            this.visualSubSelections = options.subSelections, this.featureSwitches.onObject && this.subSelectionHelper && this.formatMode !== (formatMode = options.formatMode) && (this.formatMode = formatMode, 
                            this.subSelectionHelper.setFormatMode(formatMode), this.interactivityService && this.interactivityService.setFormatMode(formatMode), 
                            this.mapControlHelper && (this.mapControlHelper.setFormatMode(formatMode), this.subSelectionHelper.setCustomOutlineCallback(this.mapControlHelper.updateOutlinesFromSubSelections)), 
                            this.behavior && this.behavior.setFormatMode(formatMode)), this.dataView = options && options.dataViews && options.dataViews[0], 
                            previousData = this.data, this.warnings = _.filter(this.warnings, function(warning) {
                                return AzureMapSasTokenHelper.isSasTokenWarning(warning);
                            }), debug.fF.assert(function() {
                                return _this.warnings.length <= 1;
                            }, "There should be at most 1 SAS token warning - on update"), this.warnings.length > 0 && this.host.setWarnings(this.warnings), 
                            this.dataView ? (this.toggleLandingPage(!1), options.type & enums.EP.Resize || (this.data = AzureMapConverter.converter({
                                dataView: this.dataView,
                                style: this.style,
                                geoTaggingAnalyzerService: this.geoTaggingAnalyzerService,
                                interactivityService: this.interactivityService,
                                featureSwitches: this.featureSwitches
                            })), (null === (_a = this.data) || void 0 === _a ? void 0 : _a.hasInvalidGeocodingCulture) && (this.warnings.push(new visualWarnings.aV), 
                            this.host.setWarnings(this.warnings)), (null === (_b = this.data) || void 0 === _b ? void 0 : _b.hasInvalidLatLong) && (this.warnings.push(new visualWarnings.zX), 
                            this.host.setWarnings(this.warnings)), shouldUpdateOnResize = !1, options.resizeMode || (options.type & enums.EP.FormattingSubSelectionChange) === enums.EP.FormattingSubSelectionChange && this.featureSwitches.onObject || (shouldUpdateOnResize = !0), 
                            this.updateCurrentViewport(options.viewport), shouldUpdateOnResize ? [ 4, this.ensureMap(!1) ] : [ 3, 2 ]) : [ 3, 3 ];

                          case 1:
                            if (_d.sent(), null === (_c = this.data) || void 0 === _c ? void 0 : _c.dataPoints) {
                                for (selectableDataPoints = [], _i = 0, dataPoints_1 = dataPoints = this.data.dataPoints; _i < dataPoints_1.length; _i++) selectableDataPoints.push.apply(selectableDataPoints, dataPoints_1[_i].subDataPoints);
                                this.interactivityService && this.interactivityService.bind(selectableDataPoints, this.behavior, {
                                    selectableDataPoints,
                                    mapControl: this.mapControl,
                                    data: this.data,
                                    dataPoints,
                                    hostServices: this.host
                                }, {
                                    pointSourceKey: "azure-map"
                                });
                            }
                            this.isDestroyed || this.onDataChangedInternal(previousData), _d.label = 2;

                          case 2:
                            return this.updateMapScaleAndLegend(), this.mapControl && AzureMap.shouldCameraBeUpdated(this.data) && options.type !== enums.EP.FormattingSubSelectionChange && this.mapControlHelper && this.mapControlHelper.updateCamera(this.warnings), 
                            this.updateSubSelection(options), [ 3, 4 ];

                          case 3:
                            1 !== options.viewMode || options.visualHasData || this.toggleLandingPage(!0), _d.label = 4;

                          case 4:
                            return [ 2 ];
                        }
                    });
                });
            }, AzureMap.shouldCameraBeUpdated = function(newData) {
                return newData.properties.mapControls.cameraProperties.autoZoom && (newData.properties.bubble.showBubbleLayer || newData.properties.filledMap.showFilledMap || newData.properties.barChart.dataProperties.showBarChart || newData.properties.heatMap.showHeatMapLayer);
            }, AzureMap.prototype.listenForUrlChange = function() {
                var _this = this, initUpdate = !0;
                this.urlChangeSubscription = this.host.azureMapsEndpoint().getDomainUrl$().subscribe(function() {
                    return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                        return (0, tslib_es6.__generator)(this, function(_a) {
                            switch (_a.label) {
                              case 0:
                                return initUpdate ? (initUpdate = !1, [ 2 ]) : [ 4, this.ensureMap(!0) ];

                              case 1:
                                return _a.sent(), this.isDestroyed || this.host.triggerUpdate(), [ 2 ];
                            }
                        });
                    });
                });
            }, AzureMap.prototype.toggleLandingPage = function(add) {
                var visibility = "hidden";
                add ? this.landingPage.display() : (this.landingPage.remove(), visibility = "visible"), 
                this.root && (this.root[0].style.visibility = visibility);
            }, AzureMap.prototype.updateCurrentViewport = function(newScaleViewport) {
                newScaleViewport.scale = newScaleViewport.scale || 1, this.currentViewport.width === newScaleViewport.width && this.currentViewport.height === newScaleViewport.height && this.currentViewport.scale === newScaleViewport.scale || (this.currentViewport = newScaleViewport);
            }, AzureMap.prototype.updateMapScaleAndLegend = function() {
                this.mapControl && this.renderLegend();
                var mapViewport = this.getMapViewPort();
                if (this.mapControlHelper && this.mapControlHelper.updateViewportSize(mapViewport), 
                this.mapControl && this.mapControl.resize(mapViewport.height, mapViewport.width), 
                this.rescaleMap) {
                    var mapDiv = this.element.children(AzureMap.MapContainer.selector);
                    mapDiv.css("transform", "scale(" + 1 / this.currentViewport.scale + ")"), mapDiv.css("transform-origin", "left top");
                } else {
                    var pixelRatio = (window.devicePixelRatio || 1) * this.currentViewport.scale;
                    this.mapControl && this.mapControl._getMap().setPixelRatio(pixelRatio);
                }
            }, AzureMap.prototype.updateSubSelection = function(options, shouldUpdate) {
                if (this.mapControlHelper && this.subSelectionHelper && !this.isDestroyed && this.featureSwitches.onObject && (options.type & enums.EP.Data || options.type & enums.EP.FormattingSubSelectionChange || options.type & enums.EP.Resize || shouldUpdate)) {
                    var subSelections = options.subSelections;
                    if (this.subSelectionHelper.updateOutlinesFromSubSelections(subSelections, !0), 
                    this.host.alertScreenReader && options.type & enums.EP.FormattingSubSelectionChange) {
                        var message = void 0;
                        Array.isArray(subSelections) && (message = subSelections.map(function(subSelection) {
                            return subSelection.displayName;
                        }).join(" ")), message && this.host.alertScreenReader(message);
                    }
                }
            }, AzureMap.prototype.getMapViewPort = function() {
                var currentViewport = this.currentViewport, legendMargins = this.legend.getMargins();
                if (this.rescaleMap) {
                    var scale = this.currentViewport.scale;
                    if (scale) return {
                        width: (currentViewport.width - legendMargins.width) * scale,
                        height: (currentViewport.height - legendMargins.height) * scale
                    };
                }
                return {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height
                };
            }, AzureMap.prototype.onDataChangedInternal = function(previousData) {
                var shouldSkipGeocoding = !this.data.hasCategory || this.data.hasXY && !this.data.shouldRenderFilledMap || 0 === this.data.dataPoints.length;
                if (this.mapControl) {
                    this.mapControlHelper.setData(this.data), this.mapControlHelper.updateNonDataBoundProperties(previousData, this.mapControlFactory, this.warnings);
                    var dataFieldsUpdated = AzureMap.haveDataFieldsBeenUpdated(previousData, this.data);
                    AzureMap.shouldDataLayersBeUpdated(previousData, this.data, dataFieldsUpdated) && shouldSkipGeocoding && this.mapControlHelper.updateDataLayers(previousData, dataFieldsUpdated), 
                    AzureMap.shouldRedrawDataLabel(previousData, this.data, dataFieldsUpdated) && this.mapControlHelper.drawDataLabels();
                }
                if (!shouldSkipGeocoding) {
                    var shouldRenderFilledMap = this.data.shouldRenderFilledMap;
                    shouldRenderFilledMap && !AzureMap.isDataRepresentableByFilledMap(this.data.hasSeries, this.data.dataPoints) && (this.warnings.push(new visualWarnings.Sm), 
                    this.host.setWarnings(this.warnings)), this.geocodingContext && this.geocodingContext.timeout && this.geocodingContext.timeout.resolve(null), 
                    this.geocodingContext = {
                        timeout: this.promiseFactory.defer(),
                        dataPointsRemaining: 0
                    }, this.geocodingCategory = this.data.geocodingCategory;
                    var params = shouldRenderFilledMap ? (0, mapUtil.o)(this.data.geocodingCategory, this.data.dataPoints.length) : null;
                    this.geocodingContext.dataPointsRemaining = this.data.dataPoints.length;
                    for (var _i = 0, _a = this.data.dataPoints; _i < _a.length; _i++) {
                        var dataPoint = _a[_i];
                        dataPoint.location ? shouldRenderFilledMap && !dataPoint.paths ? this.enqueueGeoShape(this.geocodingContext, dataPoint, params) : this.increaseGeocodingCountAndRedraw(this.geocodingContext) : dataPoint.queryLocation ? shouldRenderFilledMap ? this.enqueueGeocodingAndGeoShape(this.geocodingContext, dataPoint, params, this.data) : this.enqueueGeocoding(this.geocodingContext, dataPoint, this.data) : this.geocodingFailed(this.geocodingContext);
                    }
                }
            }, AzureMap.prototype.enqueueGeocoding = function(geocodingContext, dataPoint, data) {
                var _this = this, completionFunction = function(location) {
                    _this.completeGeocoding(geocodingContext, dataPoint, location);
                };
                this.geocoder.tryGeocodeImmediate(dataPoint.queryLocation, this.geocodeBackend, this.featureSwitches.geocoderIndexedDB, this.host.geocoderIndexedDB(), this.blockExtendedLocations).then(function(location) {
                    _this.initiateGeocoding(location, completionFunction, dataPoint, geocodingContext, data);
                }, function(_error) {
                    _this.initiateGeocoding(void 0, completionFunction, dataPoint, geocodingContext, data);
                });
            }, AzureMap.prototype.enqueueGeoShape = function(geocodingContext, dataPoint, params) {
                var _this = this;
                debug.fF.assertValue(dataPoint.location, "cachedLocation"), this.geocoder.tryGeocodeBoundaryImmediate({
                    latitude: dataPoint.location.latitude,
                    longitude: dataPoint.location.longitude,
                    category: this.geocodingCategory,
                    levelOfDetail: params.level,
                    maxGeoData: params.maxPolygons,
                    entityType: dataPoint.location.entityType
                }, this.geocodeBackend, this.featureSwitches.geocoderIndexedDB, this.host.geocoderIndexedDB()).then(function(result) {
                    _this.initiateGeoboundary(result, dataPoint, geocodingContext, params);
                }, function(_error) {
                    _this.initiateGeoboundary(void 0, dataPoint, geocodingContext, params);
                });
            }, AzureMap.prototype.enqueueGeocodingAndGeoShape = function(geocodingContext, dataPoint, params, data) {
                var _this = this, completionFunction = function(location) {
                    _this.completeGeoCodeAndGeoShape(geocodingContext, dataPoint, params, location);
                };
                this.geocoder.tryGeocodeImmediate(dataPoint.queryLocation, this.geocodeBackend, this.featureSwitches.geocoderIndexedDB, this.host.geocoderIndexedDB(), this.blockExtendedLocations).then(function(location) {
                    _this.initiateGeocoding(location, completionFunction, dataPoint, geocodingContext, data);
                }, function(_error) {
                    _this.initiateGeocoding(void 0, completionFunction, dataPoint, geocodingContext, data);
                });
            }, AzureMap.prototype.initiateGeocoding = function(location, completionFunction, dataPoint, geocodingContext, data) {
                var _this = this;
                location ? void 0 === location.latitude || void 0 === location.longitude ? this.geocodingFailed(geocodingContext) : completionFunction(location) : this.getBackendCredential().then(function(_a) {
                    var credentials = _a.credentials, credentialType = _a.credentialType;
                    _this.isDestroyed || _this.geocoder.geocode(dataPoint.queryLocation, _this.geocodeBackend, _this.featureSwitches.geocoderIndexedDB, _this.host.geocoderIndexedDB(), {
                        timeout: geocodingContext.timeout.promise,
                        credentials,
                        credentialType,
                        instanceId: _this.host.instanceId
                    }, _this.blockExtendedLocations).then(function(result) {
                        _this.isDestroyed || geocodingContext !== _this.geocodingContext || ((0, mapUtil.N2)(result, !0) ? (data.hasInvalidLatLong || (_this.warnings.push(new visualWarnings.zI), 
                        _this.host.setWarnings(_this.warnings)), data.hasInvalidLatLong = !0, _this.geocodingFailed(geocodingContext)) : completionFunction(result));
                    }, function(_reason) {
                        return _this.geocodingFailed(geocodingContext);
                    });
                });
            }, AzureMap.prototype.initiateGeoboundary = function(result, dataPoint, geocodingContext, params) {
                var _this = this;
                result ? this.completeGeoShape(geocodingContext, dataPoint, result) : this.getBackendCredential().then(function(_a) {
                    var credentials = _a.credentials, credentialType = _a.credentialType;
                    _this.isDestroyed || _this.geocoder.geocodeBoundary({
                        latitude: dataPoint.location.latitude,
                        longitude: dataPoint.location.longitude,
                        category: _this.geocodingCategory,
                        levelOfDetail: params.level,
                        maxGeoData: params.maxPolygons,
                        entityType: dataPoint.location.entityType
                    }, _this.geocodeBackend, _this.featureSwitches.geocoderIndexedDB, _this.host.geocoderIndexedDB(), {
                        timeout: geocodingContext.timeout.promise,
                        credentials,
                        credentialType
                    }).then(function(result) {
                        !_this.isDestroyed && result && geocodingContext === _this.geocodingContext && _this.completeGeoShape(geocodingContext, dataPoint, result);
                    }, function(_reason) {
                        return _this.geocodingFailed(geocodingContext);
                    });
                });
            }, AzureMap.prototype.getBackendCredential = function() {
                var _this = this;
                return new Promise(function(resolve, reject) {
                    _this.sasTokenCallback(resolve, reject, null);
                }).then(function(credentials) {
                    return {
                        credentials,
                        credentialType: "sasToken"
                    };
                });
            }, AzureMap.prototype.completeGeocoding = function(geocodingContext, dataPoint, location) {
                dataPoint.location = location, this.increaseGeocodingCountAndRedraw(geocodingContext);
            }, AzureMap.prototype.completeGeoShape = function(geocodingContext, dataPoint, result) {
                if (1 === this.geocodeBackend) dataPoint.geojsonPolygons = result.geoJsonPolygons; else {
                    dataPoint.paths = [];
                    for (var _i = 0, _a = result.locations; _i < _a.length; _i++) {
                        var location_1 = _a[_i];
                        location_1.nativeBing && !location_1.geographic && (location_1.geographic = (0, 
                        mapUtil.Bo)(location_1.nativeBing)), location_1.geographic && location_1.geographic.length > 2 && dataPoint.paths.push(location_1);
                    }
                }
                this.increaseGeocodingCountAndRedraw(geocodingContext);
            }, AzureMap.prototype.completeGeoCodeAndGeoShape = function(geocodingContext, dataPoint, params, location) {
                dataPoint.location = location, this.enqueueGeoShape(geocodingContext, dataPoint, params);
            }, AzureMap.prototype.increaseGeocodingCountAndRedraw = function(geocodingContext) {
                geocodingContext === this.geocodingContext && (--geocodingContext.dataPointsRemaining, 
                this.scheduleRedraw());
            }, AzureMap.prototype.geocodingFailed = function(geocodingContext) {
                this.isDestroyed || geocodingContext !== this.geocodingContext || --geocodingContext.dataPointsRemaining <= 0 && this.scheduleRedraw();
            }, AzureMap.prototype.scheduleRedraw = function() {
                var _this = this;
                this.pendingGeocodingRender && this.geocodingContext && this.geocodingContext.dataPointsRemaining <= 0 && (clearTimeout(this.pendingGeocodingRender), 
                this.pendingGeocodingRender = 0), this.pendingGeocodingRender || (this.pendingGeocodingRender = setTimeout(function() {
                    _this.mapControlHelper.updateDataLayers(null, !0), AzureMap.shouldCameraBeUpdated(_this.data) && _this.mapControlHelper.updateCamera(_this.warnings), 
                    _this.mapControlHelper.drawDataLabels(), _this.pendingGeocodingRender = 0;
                }, this.geocodingContext && this.geocodingContext.dataPointsRemaining <= 0 ? 0 : AzureMap.ScheduleRedrawInterval));
            }, AzureMap.prototype.renderLegend = function() {
                var _a, legendData = null === (_a = this.data) || void 0 === _a ? void 0 : _a.legendData;
                legendData && (this.legend.setPosition(legendData.position), this.legend.drawLegend({
                    data: legendData,
                    parentViewport: this.currentViewport,
                    onObject: this.featureSwitches.onObject,
                    titleSliceUid: "".concat("legend", "-").concat("title", "-titleText")
                }), (0, legend_util.xz)(d3.select(this.element.children(AzureMap.MapContainer.selector)[0]), this.legend));
            }, AzureMap.haveDataFieldsBeenUpdated = function(prevData, newData) {
                var _this = this;
                return !(!_.isEmpty(prevData) && prevData.dataPoints.length === newData.dataPoints.length) || prevData.hasCategory !== newData.hasCategory || prevData.hasSeries !== newData.hasSeries || newData.dataPoints.some(function(newPoint, i) {
                    return _this.isPointUpdated(prevData.dataPoints[i], newPoint);
                });
            }, AzureMap.isPointUpdated = function(prevPoint, newPoint) {
                var _this = this;
                return newPoint.bubbleRadius !== prevPoint.bubbleRadius || this.isLocationUpdated(prevPoint.location, newPoint.location) || newPoint.subDataPoints.length !== prevPoint.subDataPoints.length || newPoint.subDataPoints.some(function(newSubPoint, j) {
                    return _this.isSubPointUpdated(prevPoint.subDataPoints[j], newSubPoint);
                });
            }, AzureMap.isSubPointUpdated = function(prevSubPoint, newSubPoint) {
                return newSubPoint.size !== prevSubPoint.size || newSubPoint.color !== prevSubPoint.color || !newSubPoint.identity.equals(prevSubPoint.identity);
            }, AzureMap.isLocationUpdated = function(prevLocation, newLocation) {
                return !(!prevLocation && !newLocation || prevLocation && newLocation && prevLocation.latitude === newLocation.latitude && prevLocation.longitude === newLocation.longitude);
            }, AzureMap.shouldDataLayersBeUpdated = function(previousData, newData, dataFieldsUpdated) {
                return dataFieldsUpdated || !_.isEqual(previousData.properties.filledMap, newData.properties.filledMap) || !_.isEqual(previousData.properties.barChart, newData.properties.barChart) || !_.isEqual(previousData.properties.bubble, newData.properties.bubble) || !_.isEqual(previousData.properties.heatMap, newData.properties.heatMap) || !_.isEqual(previousData.properties.commonDataOptions, newData.properties.commonDataOptions);
            }, AzureMap.shouldRedrawDataLabel = function(previousData, newData, dataFieldsUpdated) {
                return dataFieldsUpdated || _.isEmpty(previousData) || !_.isEqual(previousData.dataLabelSettings, newData.dataLabelSettings) || !_.isEqual(previousData.properties.bubble, newData.properties.bubble);
            }, AzureMap.prototype.ensureAzureMapScripts = function(mapControlFactory, shouldUseMapControlV3) {
                return this.isSdkReady || (this.isSdkReady = mapControlFactory.loadAzureMapScripts(shouldUseMapControlV3)), 
                this.isSdkReady;
            }, AzureMap.prototype.ensureMap = function(forceReload) {
                var _this = this;
                return this.ensuringAzMap && !forceReload || (this.mapControlFactory || (this.mapControlFactory = (0, 
                mapUtil.$f)(this.promiseFactory, this.host.loader())), this.ensuringAzMap = this.ensureAzureMapScripts(this.mapControlFactory, this.featureSwitches.azureMapsUseMapControlV3).then(function(r) {
                    return _this.createMapControl();
                }, function(error) {
                    return _this.showMapLoadError();
                })), this.ensuringAzMap;
            }, AzureMap.prototype.showMapLoadError = function() {
                this.isDestroyed || (trace.f.error("The Azure Map control could not be loaded", !0, void 0, {}), 
                this.warnings.push(new visualWarnings._7), this.host.setWarnings(this.warnings));
            }, AzureMap.isDataRepresentableByFilledMap = function(hasSeries, dataPoints) {
                if (!hasSeries) return !0;
                for (var _loop_1 = function(dataPoint) {
                    var colors = dataPoint.subDataPoints.map(function(sp) {
                        return sp.color;
                    });
                    if (!colors.every(function(c) {
                        return c === colors[0];
                    })) return {
                        value: !1
                    };
                }, _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var state_1 = _loop_1(dataPoints_2[_i]);
                    if ("object" == typeof state_1) return state_1.value;
                }
                return !0;
            }, AzureMap.prototype.createMapControl = function() {
                var _a, _this = this, promise = this.promiseFactory.defer();
                if (this.isDestroyed) return promise.resolve(), promise.promise;
                if (this.mapControlFactory.isAzureMapSupported()) {
                    this.root || (this.root = (0, DomFactory.hi)().addClass(AzureMap.MapContainer.class).css("position", "absolute").css("width", "100%").css("height", "100%").appendTo(this.element[0])), 
                    this.root[0].setAttribute("visibility", "visible");
                    var defaultStyle = (_a = this.data && this.data.properties && this.data.properties.mapControls && this.data.properties.mapControls.styleProperties || {}).defaultStyle, showLabels = _a.showLabels, worldWrap = _a.worldWrap, controlOptions = {
                        element: this.root[0],
                        locale: this.locale,
                        sasTokenCallback: function(resolve, reject, map) {
                            return _this.sasTokenCallback(resolve, reject, map);
                        },
                        azureMapsDataResidency: this.featureSwitches.azureMapsDataResidency,
                        azureMapsEndpoint: this.host.azureMapsEndpoint(),
                        isScreenshotWorkload: this.featureSwitches.azureMapsScreenshot && this.host.isScreenshotWorkload(),
                        progressiveLoading: this.featureSwitches.azureMapsProgressiveLoading,
                        defaultStyle,
                        showLabels,
                        renderWorldCopies: worldWrap,
                        preserveDrawingBufferForExport: this.featureSwitches.azureMapsPreserveDrawingBufferForExport
                    }, mapControl_1 = this.mapControlFactory.createAzureMapControl(controlOptions), mapContainer = mapControl_1.getMapContainer();
                    mapContainer.setAttribute("drag-resize-disabled", "true"), d3.select(mapContainer).attr(htmlSubSelectionHelper.Ez, "map"), 
                    d3.select(mapContainer).attr(htmlSubSelectionHelper.CK, "Map_ToolTip"), d3.select(mapContainer).attr(htmlSubSelectionHelper.QZ, 3), 
                    d3.select(mapContainer).classed(htmlSubSelectionHelper.cy, !0), d3.select(mapContainer).attr("focus-nav-mode", "HierarchicalTabOrder"), 
                    $(".atlas-map-canvas").attr("focus-nav-mode", "Browser");
                    var thisAzureMap_1 = this;
                    mapControl_1.events.add("ready", function() {
                        thisAzureMap_1.mapControl = mapControl_1, thisAzureMap_1.mapControlHelper = new AzureMapMapControlHelper(mapControl_1, thisAzureMap_1.host, thisAzureMap_1.featureSwitches, thisAzureMap_1.behavior, thisAzureMap_1.style, thisAzureMap_1.isTouchEvent), 
                        thisAzureMap_1.mapControlHelper.setupMap(thisAzureMap_1.element), thisAzureMap_1.root.children(".atlas-control-container").css("z-index", "1"), 
                        promise.resolve();
                    }), mapControl_1.events.add("movestart", function(e) {
                        return _this.updateSubSelectionOnMapInteraction([]);
                    }), mapControl_1.events.add("moveend", function(e) {
                        return _this.updateSubSelectionOnMapInteraction(_this.visualSubSelections);
                    });
                } else trace.f.error("The browser is not supported by the current Azure Maps control, skipping map load", !0, void 0, {
                    browser: window.navigator.userAgent
                }), this.warnings.push(new visualWarnings.aj), this.host.setWarnings(this.warnings), 
                promise.reject();
                return promise.promise;
            }, AzureMap.prototype.updateSubSelectionOnMapInteraction = function(subSelection) {
                this.visualUpdateOptions.subSelections = subSelection, this.updateSubSelection(this.visualUpdateOptions, !0);
            }, AzureMap.prototype.sasTokenCallback = function(resolve, reject, _map) {
                var _this = this;
                this.isDestroyed || this.host.getAzureMapToken().then(function(result) {
                    if (result && result.accountSasToken) {
                        var removedWarnings_1 = _.remove(_this.warnings, function(warning) {
                            return AzureMapSasTokenHelper.isSasTokenWarning(warning);
                        });
                        debug.fF.assert(function() {
                            return removedWarnings_1.length <= 1;
                        }, "There should be at most 1 SAS token warning - on success"), removedWarnings_1.length > 0 && _this.host.setWarnings(_this.warnings), 
                        resolve(result.accountSasToken);
                    } else _this.rejectSasTokenWithWarning(result && result.error ? result.error : "UndefinedToken", reject);
                }, function(error) {
                    _this.rejectSasTokenWithWarning(error, reject);
                });
            }, AzureMap.prototype.rejectSasTokenWithWarning = function(code, reject) {
                var removedWarnings = _.remove(this.warnings, function(warning) {
                    return AzureMapSasTokenHelper.isSasTokenWarning(warning);
                });
                debug.fF.assert(function() {
                    return removedWarnings.length <= 1;
                }, "There should be at most 1 SAS token warning - on failure");
                var warning = AzureMapSasTokenHelper.buildSasTokenWarning(code);
                this.warnings.push(warning), this.host.setWarnings(this.warnings), AzureMapSasTokenHelper.logTelemetry(code, this.host.telemetry()), 
                reject(code);
            }, AzureMap.prototype.setMapControl = function(mapControl) {
                this.mapControl = mapControl;
            }, AzureMap.prototype.setMapControlHelper = function(mapControlHelper) {
                this.mapControlHelper = mapControlHelper;
            }, AzureMap.ScheduleRedrawInterval = 3e3, AzureMap;
        }();
        function createAzureMapBehavior() {
            return new azureMapBehaviors.AzureMapBehavior;
        }
        function createAzureMap(options) {
            return new AzureMap(options);
        }
    },
    35824: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            AzureMapBehavior: function() {
                return AzureMapBehavior;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(81337), _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66232), _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30237), _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38400), _VisualsCommon_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(64067), _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62458), _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59107), _azureMapConstant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70508), _azureMapExpressionHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72118), _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81293), _azureMapOnObjectUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19076), _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(49988);
        function isClusterFeature(feature) {
            var _a;
            return feature && !0 === (null === (_a = feature.properties) || void 0 === _a ? void 0 : _a.cluster);
        }
        function isShape(shape) {
            return shape && void 0 !== shape.getProperties;
        }
        var AzureMapBehavior = function() {
            function AzureMapBehavior() {
                var _this = this;
                this.hasSelection = !1, this.visualHasSelection = function() {
                    return _this.hasSelection;
                }, this.featureMouseover = function(mouseEvent) {
                    var _a;
                    if (_this.formatMode) {
                        _this.mapControl.getCanvasContainer().style.cursor = "pointer";
                        var identifiedDataPoint = _this.findSubDataPointByMouseEvent(mouseEvent);
                        if (identifiedDataPoint) {
                            var subSelection = _this.createVisualSubSelection(mouseEvent, identifiedDataPoint, !0), subSelectableObject = null === (_a = _.first(subSelection.visualObjects)) || void 0 === _a ? void 0 : _a.objectName, regionOutline = _this.subSelectionHelper.getRegionOutline(subSelectableObject);
                            regionOutline && 0 !== regionOutline.visibility || (_this.subSelectionHelper.updateCustomOutlinesFromSubSelections([ subSelection ], 1), 
                            _this.subSelectionHelper.renderOutlines());
                        }
                    }
                }, this.featureMousemove = function(mouseEvent, showTooltipsCallback) {
                    if (!_this.formatMode) {
                        var identifiedDataPoint = _this.findSubDataPointByMouseEvent(mouseEvent);
                        if (identifiedDataPoint) {
                            _this.mapControl.getCanvasContainer().style.cursor = "pointer";
                            var originalEvent = mouseEvent.originalEvent;
                            (null == identifiedDataPoint ? void 0 : identifiedDataPoint.tooltipInfo) && showTooltipsCallback([ originalEvent.x, originalEvent.y ], identifiedDataPoint);
                        }
                    }
                }, this.featureMouseout = function(mouseEvent, hideTooltipsCallback) {
                    if (_this.mapControl.getCanvasContainer().style.cursor = "grab", _this.formatMode) {
                        var originalEvent = mouseEvent.originalEvent;
                        (0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(originalEvent), 
                        originalEvent.preventDefault(), _this.subSelectionHelper.clearHoveredOutline();
                    } else hideTooltipsCallback();
                }, this.mapClicked = function(mouseEvent) {
                    _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(mouseEvent.originalEvent) || _this.selectionHandler.handleClearSelection();
                }, this.featureClicked = function(mouseEvent) {
                    if (mouseEvent) {
                        var shapes = _.filter(mouseEvent.shapes, isShape), pointsToBeSelected = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findDataPointsByShapes(_this.selectableDataPoints, shapes);
                        if (_this.formatMode) {
                            var originalEvent = mouseEvent.originalEvent;
                            (0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(originalEvent), 
                            originalEvent.preventDefault();
                            var topMostPoint = _.last(pointsToBeSelected);
                            if (topMostPoint) {
                                var identifiedDataPoint = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findFirstDataPointByKey(_this.selectableDataPoints, topMostPoint.identity.getKey()), subSelection = _this.createVisualSubSelection(mouseEvent, identifiedDataPoint, !1);
                                _this.subSelectionHelper.subSelect(subSelection);
                            }
                        } else _this.handleSelection(mouseEvent.originalEvent, pointsToBeSelected);
                    }
                }, this.featureContextClicked = function(mouseEvent) {
                    if (mouseEvent) {
                        var originalEvent = mouseEvent.originalEvent;
                        if (!_VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(originalEvent)) {
                            var shape = _.find(mouseEvent.shapes, isShape);
                            if (shape) {
                                var selectedShapeKey = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.getFirstIdentityKey(shape), selectedDataPoint = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findFirstDataPointByKey(_this.selectableDataPoints, selectedShapeKey);
                                if ((0, _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(originalEvent), 
                                originalEvent.preventDefault(), _this.formatMode) {
                                    if (selectedDataPoint) {
                                        for (var identifiedSubDataPoint = void 0, key = selectedDataPoint.identity.getKey(), _i = 0, _a = _this.data.dataPoints; _i < _a.length && !(identifiedSubDataPoint = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findFirstDataPointByKey(_a[_i].subDataPoints, key)); _i++) ;
                                        var subSelection = _this.createVisualSubSelection(mouseEvent, identifiedSubDataPoint, !0);
                                        _this.subSelectionHelper.subSelect(subSelection);
                                    }
                                } else selectedDataPoint && _this.selectionHandler.handleContextMenu(selectedDataPoint, {
                                    x: originalEvent.clientX,
                                    y: originalEvent.clientY
                                });
                            }
                        }
                    }
                }, this.handleContextMenu = function(event, point) {
                    event && !_VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(event) && ((0, 
                    _Visuals_common_eventBubblingUtil__WEBPACK_IMPORTED_MODULE_0__.n)(event), event.preventDefault(), 
                    _this.formatMode || _this.selectionHandler.handleContextMenu(point, {
                        x: event.clientX,
                        y: event.clientY
                    }));
                }, this.createFocusInCallback = function(toolTipCoordinates, identifiedDataPoint, showTooltipsCallback, hideTooltipsCallback, isTooltipsVisible) {
                    return function(e) {
                        _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_1__.M.isCtrlOrMeta(e) && 72 === e.keyCode && (isTooltipsVisible() ? hideTooltipsCallback() : showTooltipsCallback(toolTipCoordinates, identifiedDataPoint), 
                        e.preventDefault());
                    };
                }, this.featureFocusIn = function(focusEvent, showTooltipsCallback, hideTooltipsCallback, isTooltipsVisible) {
                    var identifiedDataPoint;
                    if (!_this.formatMode && focusEvent.shape && (_this.setFeatureFocusedState(focusEvent, !0), 
                    (identifiedDataPoint = isClusterFeature(focusEvent.shape) ? _this.findSubDataPointByClusterFeature(focusEvent.shape) : _this.findSubDataPointByShape(focusEvent.shape)) && identifiedDataPoint.tooltipInfo)) {
                        var _a = _this.mapControl.getCanvasContainer().getBoundingClientRect(), _b = focusEvent.pixel;
                        _this.focusInCallback = _this.createFocusInCallback([ _b[0] + _a.x, _b[1] + _a.y ], identifiedDataPoint, showTooltipsCallback, hideTooltipsCallback, isTooltipsVisible), 
                        focusEvent.target.addEventListener("keydown", _this.focusInCallback), focusEvent.target.setAttribute("aria-label", isClusterFeature(focusEvent.shape) ? identifiedDataPoint.tooltipInfo[0].header : (0, 
                        _Visuals_common_tooltipUtils__WEBPACK_IMPORTED_MODULE_3__.X)(identifiedDataPoint.tooltipInfo));
                    }
                }, this.featureFocusOut = function(focusEvent, hideTooltipCallback) {
                    _this.formatMode || (_this.setFeatureFocusedState(focusEvent, !1), focusEvent.target.removeEventListener("keydown", _this.focusInCallback), 
                    hideTooltipCallback());
                }, this.setFeatureFocusedState = function(focusEvent, focused) {
                    var feature = focusEvent.shape, featureId = isClusterFeature(feature) ? feature.id.toString() : feature.getId().toString();
                    _this.mapControl.sources.setFeatureState(featureId, _azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.oy, {
                        focused
                    });
                }, this.createVisualSubSelection = function(mouseEvent, dataPoint, showUI) {
                    var originalEvent = mouseEvent.originalEvent, shape = _.find(mouseEvent.shapes, function(s) {
                        return s && s.getProperties;
                    });
                    _VisualsCommon_debug__WEBPACK_IMPORTED_MODULE_5__.fF.assertValue(shape, "azureMap ".concat(mouseEvent.type, ": expected to find the shape"));
                    var series, subSelectableRegion = _azureMapOnObjectUtil__WEBPACK_IMPORTED_MODULE_6__.E.getSubSelectableRegionFromLayerId(mouseEvent.layerId), seriesIndex = shape.getProperties().seriesIndex, subSelectableObject = "".concat(subSelectableRegion) + (void 0 === seriesIndex ? "" : "-series-".concat(seriesIndex)), selectionOrigin = {
                        x: originalEvent.clientX,
                        y: originalEvent.clientY
                    };
                    return _this.data.hasSeries && dataPoint && !_.isUndefined(dataPoint.seriesIndex) && (series = _this.data.series[dataPoint.seriesIndex]), 
                    _azureMapOnObjectUtil__WEBPACK_IMPORTED_MODULE_6__.E.createAzureMapSubSelection(subSelectableObject, showUI, _this.hostServices, selectionOrigin, series);
                }, this.dataSelected = function(selectedShapes) {
                    if (!_this.formatMode) {
                        var pointsToBeSelected = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.findDataPointsByShapes(_this.selectableDataPoints, selectedShapes);
                        _this.handleSelection(void 0, pointsToBeSelected, 1);
                    }
                }, this.handleSelection = function(event, points, mode) {
                    void 0 !== mode ? (0, _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_7__.tn)(points, mode, _this.selectionHandler) : (0, 
                    _Visuals_common_interactivityUtils__WEBPACK_IMPORTED_MODULE_7__.ct)(event, points, _this.selectionHandler);
                }, this.clusterClicked = function(mouseEvent, dataSource) {
                    var clusterFeature = _.find(mouseEvent.shapes, isClusterFeature);
                    clusterFeature && dataSource.getClusterExpansionZoom(clusterFeature.properties.cluster_id).then(function(zoom) {
                        _this.mapControl.setCamera({
                            center: clusterFeature.geometry.coordinates,
                            zoom,
                            type: "ease",
                            duration: 200
                        });
                    }).catch(function(error) {});
                }, this.updateDataSourceWithSelection = function() {
                    return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(_this, void 0, void 0, function() {
                        var allShapes, selectedDataPoints, selectedFeatures_1, pendingPromises, expressionOptionArray_1, _i, _a, shape, featureId, featureProps, _this = this;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__generator)(this, function(_b) {
                            if ((this.bubbleDataSource || this.heatMapDataSource || this.filledMapDataSource || this.barChart3DDataSource || this.referenceDataSource) && (allShapes = (0, 
                            tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                            tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                            tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([], this.bubbleDataSource.getShapes(), !0), this.heatMapDataSource.getShapes(), !0), this.filledMapDataSource.getShapes(), !0), this.barChart3DDataSource.getShapes(), !0), this.referenceDataSource.getShapes(), !0), 
                            this.hasSelection ? (selectedDataPoints = _.filter(this.selectableDataPoints, function(x) {
                                return x.selected;
                            }), selectedFeatures_1 = _.map(selectedDataPoints, function(x) {
                                return x.identity.getKey();
                            }), allShapes.forEach(function(shape) {
                                var props = shape.getProperties(), isSelected = selectedFeatures_1.indexOf(props.identityKeys[0]) > -1;
                                shape.addProperty("selected", isSelected);
                            })) : allShapes.forEach(function(shape) {
                                shape.addProperty("selected", !0);
                            }), this.showPieChart)) {
                                for (pendingPromises = [], expressionOptionArray_1 = [], _i = 0, _a = allShapes.filter(function(s) {
                                    return s && s.getProperties().showPie;
                                }); _i < _a.length; _i++) featureId = (shape = _a[_i]).getId(), featureProps = shape.getProperties(), 
                                pendingPromises.push(this.loadIcon(featureId, featureProps.identityKeys[0], expressionOptionArray_1));
                                Promise.allSettled(pendingPromises).then(function() {
                                    _this.composeAndUpdatePieExpression(expressionOptionArray_1);
                                });
                            }
                            return [ 2 ];
                        });
                    });
                }, this.loadIcon = function(featureId, featureIdentityKey, expressionOptionArray) {
                    return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(_this, void 0, void 0, function() {
                        var selectedIndexes, dataPoint, index, hash;
                        return (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__generator)(this, function(_a) {
                            switch (_a.label) {
                              case 0:
                                if (selectedIndexes = [], dataPoint = _.find(this.dataPoints, function(dp) {
                                    return (null == dp ? void 0 : dp.location) && (null == dp ? void 0 : dp.subDataPoints.length) > 0 && dp.subDataPoints[0].identity.getKey() === featureIdentityKey;
                                }), this.shouldUseLegacyFormat && _azureMapExpressionHelper__WEBPACK_IMPORTED_MODULE_9__.J.LEGACY_appendPieRadiusToDataPoints([ dataPoint ], this.data), 
                                !dataPoint) return [ 3, 2 ];
                                for (index = 0; index < dataPoint.subDataPoints.length; index++) this.hasSelection ? dataPoint.subDataPoints[index].selected && selectedIndexes.push(index) : selectedIndexes.push(index);
                                return hash = _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_10__.t.hash(dataPoint, this.data.properties.bubble, selectedIndexes), 
                                [ 4, this.pieChartFactory.loadIcon(dataPoint, this.data.properties.bubble, selectedIndexes, hash) ];

                              case 1:
                                _a.sent(), selectedIndexes.length > 0 && expressionOptionArray.push({
                                    dataPoint,
                                    hash,
                                    markerShapeId: featureId,
                                    selectedIndexes
                                }), _a.label = 2;

                              case 2:
                                return [ 2 ];
                            }
                        });
                    });
                }, this.composeAndUpdatePieExpression = function(expressionOptionArray) {
                    for (var opacityFilterMarkerIds = [ "literal", [] ], iconImageCaseExpressions = [], _i = 0, expressionOptionArray_2 = expressionOptionArray; _i < expressionOptionArray_2.length; _i++) {
                        var options = expressionOptionArray_2[_i], dataPoint = options.dataPoint, hash = options.hash, markerShapeId = options.markerShapeId, selectedIndexes = options.selectedIndexes;
                        opacityFilterMarkerIds[1].push(markerShapeId), dataPoint.subDataPoints.length !== selectedIndexes.length && iconImageCaseExpressions.push([ "==", [ "get", "_azureMapsShapeId" ], markerShapeId ], "".concat(hash));
                    }
                    var iconImageExpression = iconImageCaseExpressions.length > 0 ? (0, tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)((0, 
                    tslib__WEBPACK_IMPORTED_MODULE_8__.__spreadArray)([ "case" ], iconImageCaseExpressions, !0), [ [ "get", "iconId" ] ], !1) : [ "get", "iconId" ], opacityExpression = [ "case", [ "in", [ "get", "_azureMapsShapeId" ], opacityFilterMarkerIds ], (0, 
                    _VisualsCommon_color__WEBPACK_IMPORTED_MODULE_11__.TD)(_this.data.properties.bubble.transparency), (0, 
                    _VisualsCommon_color__WEBPACK_IMPORTED_MODULE_11__.TD)(_this.data.properties.commonDataOptions.unselectedTransparency) ];
                    _this.pieChartSymbolLayer.setOptions({
                        iconOptions: {
                            image: iconImageExpression,
                            opacity: opacityExpression
                        }
                    });
                };
            }
            return Object.defineProperty(AzureMapBehavior.prototype, "bubbleDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.oy);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "heatMapDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.Ol);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "filledMapDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.HC);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "barChart3DDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.zD);
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(AzureMapBehavior.prototype, "referenceDataSource", {
                get: function() {
                    return this.mapControl.sources.getById(_azureMapConstant__WEBPACK_IMPORTED_MODULE_4__.uL);
                },
                enumerable: !1,
                configurable: !0
            }), AzureMapBehavior.prototype.bindEvents = function(options, selectionHandler, _dataPointNavigationManagerWithKey) {
                this.mapControl = options.mapControl, this.selectableDataPoints = options.selectableDataPoints, 
                this.selectionHandler = selectionHandler, this.data = options.data, this.dataPoints = options.dataPoints, 
                this.hostServices = options.hostServices;
            }, AzureMapBehavior.prototype.setFormatMode = function(isFormatMode) {
                this.formatMode = isFormatMode;
            }, AzureMapBehavior.prototype.setSubSelectionHelper = function(subSelectionHelper) {
                this.subSelectionHelper = subSelectionHelper;
            }, AzureMapBehavior.prototype.renderSelection = function(hasSelection) {
                this.hasSelection = hasSelection, this.updateDataSourceWithSelection();
            }, AzureMapBehavior.prototype.setPieChartBehavior = function(showPieChart, pieChartFactory, pieChartSymbolLayer, shouldUseLegacyFormat) {
                void 0 === shouldUseLegacyFormat && (shouldUseLegacyFormat = !0), this.showPieChart = showPieChart, 
                this.pieChartFactory = pieChartFactory, this.pieChartSymbolLayer = pieChartSymbolLayer, 
                this.shouldUseLegacyFormat = shouldUseLegacyFormat;
            }, AzureMapBehavior.prototype.findSubDataPointByMouseEvent = function(mouseEvent) {
                if (mouseEvent) {
                    var clusterFeature = _.find(mouseEvent.shapes, isClusterFeature);
                    if (clusterFeature) return this.findSubDataPointByClusterFeature(clusterFeature);
                    var shape = _.find(mouseEvent.shapes, isShape);
                    return shape ? this.findSubDataPointByShape(shape) : void 0;
                }
            }, AzureMapBehavior.prototype.findSubDataPointByShape = function(shape) {
                for (var key = _azureMapFeatureHelper__WEBPACK_IMPORTED_MODULE_2__.l.getFirstIdentityKey(shape), subDataPoint = void 0, _i = 0, _a = this.data.dataPoints; _i < _a.length && !(subDataPoint = _a[_i].subDataPoints.find(function(p) {
                    return p.identity.getKey() === key;
                })); _i++) ;
                return subDataPoint;
            }, AzureMapBehavior.prototype.findSubDataPointByClusterFeature = function(clusterFeature) {
                var clusterProp = clusterFeature.properties, clusterTooltip = {
                    header: this.hostServices.getLocalizedString("Visual_AzureMapsCluster_TooltipInfo", clusterProp.point_count),
                    displayName: ""
                };
                return {
                    size: clusterProp.size,
                    color: "",
                    selected: !1,
                    identity: null,
                    tooltipInfo: [ clusterTooltip ]
                };
            }, AzureMapBehavior;
        }();
    },
    70508: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Bc: function() {
                return minStrokeWidth;
            },
            C_: function() {
                return filledMapFillLayerId;
            },
            Co: function() {
                return maxTileSize;
            },
            Dy: function() {
                return defaultLabelBackgroundColorName;
            },
            Dz: function() {
                return maxHeatMapIntensity;
            },
            Fw: function() {
                return minBubbleRadius;
            },
            HC: function() {
                return filledMapDataSourceId;
            },
            I9: function() {
                return maxLogScale;
            },
            Ix: function() {
                return maxHeading;
            },
            JX: function() {
                return minLayerZoom;
            },
            Jp: function() {
                return clusterBubbleLayerId;
            },
            NI: function() {
                return maxHeatMapRadiusMeters;
            },
            NR: function() {
                return maxBezier;
            },
            Ng: function() {
                return minZoomScale;
            },
            Nq: function() {
                return minLongitude;
            },
            OH: function() {
                return maxHeatMapRadiusPixels;
            },
            Ol: function() {
                return heatMapDataSourceId;
            },
            Qv: function() {
                return maxStrokeWidth;
            },
            TJ: function() {
                return unselectedBarChart3DLayerId;
            },
            U1: function() {
                return minLatitude;
            },
            W5: function() {
                return maxBarThickness;
            },
            W8: function() {
                return accessibleIndicatorEnforcedStyles;
            },
            WL: function() {
                return minPitch;
            },
            Wv: function() {
                return barChart3DLayerId;
            },
            Y4: function() {
                return maxSafeNumber;
            },
            Yd: function() {
                return maxLayerZoom;
            },
            Yi: function() {
                return maxLongitude;
            },
            Yl: function() {
                return minHeading;
            },
            Z$: function() {
                return barChartDefaultPitch;
            },
            Z3: function() {
                return minBarHeight;
            },
            _0: function() {
                return minHeatMapRadius;
            },
            _O: function() {
                return defaultLabelBackgroundTransparency;
            },
            _u: function() {
                return clusterSymbolLayerId;
            },
            a_: function() {
                return maxPitch;
            },
            c8: function() {
                return defaultHeatMapUnit;
            },
            fI: function() {
                return maxZoomScale;
            },
            fN: function() {
                return percentMin;
            },
            fQ: function() {
                return percentMax;
            },
            hW: function() {
                return maxLatitude;
            },
            nB: function() {
                return minBezier;
            },
            nv: function() {
                return minTileSize;
            },
            oy: function() {
                return bubbleDataSourceId;
            },
            p5: function() {
                return heatMapLayerId;
            },
            pi: function() {
                return minLogScale;
            },
            rn: function() {
                return maxBubbleRadius;
            },
            t: function() {
                return maxBarHeight;
            },
            uL: function() {
                return referenceDataSourceId;
            },
            x6: function() {
                return minHeatMapIntensity;
            },
            yl: function() {
                return bubbleLayerId;
            },
            z$: function() {
                return minBarThickness;
            },
            z8: function() {
                return filledMapOutlineLayerId;
            },
            zD: function() {
                return barChart3DDataSourceId;
            }
        });
        var minPitch = 0, maxPitch = 60, minHeading = 0, maxHeading = 360, minLayerZoom = 0, maxLayerZoom = 22, maxZoomScale = 10, minZoomScale = 1, minBubbleRadius = 1, maxBubbleRadius = 50, minLogScale = 1, maxLogScale = 10, minStrokeWidth = 0, maxStrokeWidth = 20, minBezier = 0, maxBezier = 1, barChartDefaultPitch = 60, defaultLabelBackgroundColorName = "backgroundDark", defaultLabelBackgroundTransparency = .5, minBarHeight = 0, maxBarHeight = 5, minBarThickness = 0, maxBarThickness = 5, defaultHeatMapUnit = "pixels", minHeatMapRadius = 1, maxHeatMapRadiusPixels = 200, maxHeatMapRadiusMeters = 4e6, minHeatMapIntensity = 0, maxHeatMapIntensity = 5, maxTileSize = 5e3, minTileSize = 128, percentMax = 100, percentMin = 0, minLongitude = -180, maxLongitude = 180, minLatitude = -90, maxLatitude = 90, maxSafeNumber = Math.pow(2, 53) - 1, bubbleDataSourceId = "bubbleDataSource", heatMapDataSourceId = "heatMapDataSource", filledMapDataSourceId = "filledMapDataSource", barChart3DDataSourceId = "barChart3DDataSource", referenceDataSourceId = "referenceDataSource", bubbleLayerId = "bubbleLayer", heatMapLayerId = "heatMapLayer", barChart3DLayerId = "barChart3DLayer", unselectedBarChart3DLayerId = "unselectedBarChart3DLayer", filledMapFillLayerId = "filledMapFillLayer", filledMapOutlineLayerId = "filledMapOutlineLayer", clusterBubbleLayerId = "clusterBubbleLayer", clusterSymbolLayerId = "clusterSymbolLayer", accessibleIndicatorEnforcedStyles = {
            bubbleStrokeOpacity: 1,
            bubbleStrokeWidth: 2
        };
    },
    72118: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            J: function() {
                return AzureMapExpressionHelper;
            }
        });
        var tslib_es6 = __webpack_require__(81337), color = __webpack_require__(64067), CubicBezierScaler = function() {
            function CubicBezierScaler(x1, y1, x2, y2) {
                this.epsilon = 1e-5, this.cx1 = 0, this.cx2 = 0, this.cx3 = 0, this.cy1 = 0, this.cy2 = 0, 
                this.cy3 = 0, this.computeCoefficient(x1, y1, x2, y2);
            }
            return CubicBezierScaler.prototype.computeCoefficient = function(x1, y1, x2, y2) {
                this.cx3 = 1 + 3 * x1 - 3 * x2, this.cx2 = 3 * x2 - 6 * x1, this.cx1 = 3 * x1, this.cy3 = 1 + 3 * y1 - 3 * y2, 
                this.cy2 = 3 * y2 - 6 * y1, this.cy1 = 3 * y1;
            }, CubicBezierScaler.prototype.getXByT = function(t) {
                return this.cx3 * Math.pow(t, 3) + this.cx2 * Math.pow(t, 2) + this.cx1 * t;
            }, CubicBezierScaler.prototype.getYByT = function(t) {
                return this.cy3 * Math.pow(t, 3) + this.cy2 * Math.pow(t, 2) + this.cy1 * t;
            }, CubicBezierScaler.prototype.estimateTByX = function(x, precision) {
                void 0 === precision && (precision = .01);
                for (var low = 0, high = 1, t = x; low < high; ) {
                    var estimatedX = this.getXByT(t);
                    if (Math.abs(x - estimatedX) <= precision) return t;
                    estimatedX < x ? low = t : high = t, t = .5 * (low + high);
                }
                return x;
            }, CubicBezierScaler.prototype.scale = function(x) {
                if (x < this.epsilon) return 0;
                if (1 - x < this.epsilon) return 1;
                var t = this.estimateTByX(x);
                return this.getYByT(t);
            }, CubicBezierScaler;
        }(), colorUtility = __webpack_require__(1521), azureMapConstant = __webpack_require__(70508), FilterProperty = function(FilterProperty) {
            return FilterProperty.bubble = "showBubble", FilterProperty.pie = "showPie", FilterProperty.barChart3D = "showBarChart3D", 
            FilterProperty.filledMap = "showFilledMap", FilterProperty.heatMap = "showHeatMap", 
            FilterProperty;
        }({}), pixelsPerMeterZoom24 = 12776044915782906e-21 * Math.pow(2, 24), AzureMapExpressionHelper = function() {
            function AzureMapExpressionHelper() {}
            var _a;
            return AzureMapExpressionHelper.getBubbleDisplayOptions = function(properties, commonProperties, useLegacyFormat, hasSize, minValue, maxValue) {
                var radiusExpression = useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getRadiusExpression(properties, commonProperties, hasSize, minValue, maxValue) : AzureMapExpressionHelper.getRadiusExpression(properties.radius, hasSize, minValue, maxValue), colorExpression = [ "get", "color" ], strokeColorExpression = AzureMapExpressionHelper.getStrokeColor(properties.autoStrokeColor, properties.strokeColor, colorExpression), opacityFilter = [ "case", AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.transparency), (0, color.TD)(commonProperties.unselectedTransparency) ], strokeWidthExpression = properties.strokeWidth < azureMapConstant.W8.bubbleStrokeWidth ? [ "case", [ "boolean", [ "feature-state", "focused" ], !1 ], azureMapConstant.W8.bubbleStrokeWidth, properties.strokeWidth ] : properties.strokeWidth, strokeOpacityExpression = [ "case", [ "boolean", [ "feature-state", "focused" ], !1 ], azureMapConstant.W8.bubbleStrokeOpacity, AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.strokeTransparency), (0, color.TD)(commonProperties.unselectedTransparency) ], filter = useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getBubbleFilter(!0, hasSize ? commonProperties : void 0) : AzureMapExpressionHelper.bubbleLayerFilter;
                return {
                    bubbleOptions: {
                        radius: radiusExpression,
                        strokeColor: strokeColorExpression,
                        strokeWidth: strokeWidthExpression,
                        strokeOpacity: strokeOpacityExpression,
                        blur: properties.blur / 100,
                        pitchAlignment: properties.pitchAlignment,
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        color: colorExpression,
                        filter,
                        opacity: opacityFilter,
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getBubbleClusterDisplayOptions = function(bubbleOptions, properties) {
                var strokeWidthExpression = properties.clusteredBubbleStrokeWidth < azureMapConstant.W8.bubbleStrokeWidth ? [ "case", [ "boolean", [ "feature-state", "focused" ], !1 ], azureMapConstant.W8.bubbleStrokeWidth, properties.clusteredBubbleStrokeWidth ] : properties.clusteredBubbleStrokeWidth;
                return {
                    clusterBubbleOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, bubbleOptions), {
                        radius: properties.clusteredBubbleRadius,
                        color: properties.clusteredBubbleFillColor,
                        strokeColor: properties.clusteredBubbleStrokeColor,
                        strokeWidth: strokeWidthExpression,
                        filter: AzureMapExpressionHelper.clusteredDataFilter
                    }),
                    clusterSymbolOptions: {
                        visible: !0,
                        textOptions: {
                            color: properties.clusteredBubbleFontColor,
                            size: properties.clusteredBubbleFontSize
                        }
                    }
                };
            }, AzureMapExpressionHelper.getPieChartDisplayOptions = function(properties) {
                return {
                    pieChartOptions: {
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        iconOptions: {
                            pitchAlignment: "viewport",
                            anchor: "center"
                        },
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getHeatMapDisplayOptions = function(properties, hasSize) {
                var colorExpression = [ "interpolate", [ "linear" ], [ "heatmap-density" ], 0, (0, 
                colorUtility.cD)(properties.heatMapColorLow, 0), .1, properties.heatMapColorLow, .5, properties.heatMapColorCenter, 1, properties.heatMapColorHigh ], radiusExpression = "pixels" === properties.heatMapRadiusUnit ? properties.heatMapRadius : [ "interpolate", [ "exponential", 2 ], [ "zoom" ], 0, [ "*", properties.heatMapRadius, 12776044915782906e-21 ], 24, [ "*", properties.heatMapRadius, pixelsPerMeterZoom24 ] ], weightExpression = hasSize && properties.heatMapUseSize ? [ "get", "size" ] : 1;
                return {
                    heatMapOptions: {
                        color: colorExpression,
                        intensity: properties.heatMapIntensity,
                        opacity: (0, color.TD)(properties.heatMapTransparency),
                        radius: radiusExpression,
                        weight: weightExpression,
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getBarChartDisplayOptions = function(paintProperties, commonProperties, maxHeight, useLegacyFormat, hasSize) {
                var relativeScale = paintProperties.height / maxHeight, heightGetter = [ "get", "size" ], heightExp = [ "*", heightGetter, 100 * relativeScale ];
                paintProperties.scaleHeightOnZoom && (heightExp = [ "interpolate", [ "exponential", .5 ], [ "zoom" ], 0, [ "*", heightGetter, 2e6 * relativeScale ], 22, [ "*", heightGetter, 20 * relativeScale ] ]);
                var baseOptions = {
                    minZoom: paintProperties.minZoom,
                    maxZoom: paintProperties.maxZoom,
                    fillColor: [ "get", "color" ],
                    visible: !0
                };
                return {
                    selectedOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, baseOptions), {
                        height: heightExp,
                        fillOpacity: (0, color.TD)(paintProperties.transparency),
                        filter: useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getBarChart3DFilter(!0, hasSize ? commonProperties : void 0) : AzureMapExpressionHelper.getSelectionFilter(!0)
                    }),
                    unselectedOptions: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, baseOptions), {
                        height: 0,
                        fillOpacity: (0, color.TD)(commonProperties.unselectedTransparency),
                        filter: useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getBarChart3DFilter(!1, hasSize ? commonProperties : void 0) : AzureMapExpressionHelper.getSelectionFilter(!1)
                    })
                };
            }, AzureMapExpressionHelper.getFilledMapDisplayOptions = function(properties, commonProperties, useLegacyFormat, hasSize) {
                var fillOpacityFilter = [ "case", AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.transparency), (0, color.TD)(commonProperties.unselectedTransparency) ], strokeOpacityFilter = [ "case", AzureMapExpressionHelper.getSelectionFilter(!0), (0, 
                color.TD)(properties.strokeTransparency), (0, color.TD)(commonProperties.unselectedTransparency) ], filledMapFilter = useLegacyFormat ? AzureMapExpressionHelper.LEGACY_getFilledMapFilter(!0, hasSize ? commonProperties : void 0) : void 0;
                return {
                    polygonOptions: {
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        fillColor: [ "get", "color" ],
                        fillOpacity: fillOpacityFilter,
                        filter: filledMapFilter,
                        visible: !0
                    },
                    lineOptions: {
                        minZoom: properties.minZoom,
                        maxZoom: properties.maxZoom,
                        strokeColor: properties.strokeColor,
                        strokeOpacity: strokeOpacityFilter,
                        strokeWidth: properties.strokeWidth,
                        filter: filledMapFilter,
                        visible: !0
                    }
                };
            }, AzureMapExpressionHelper.getSelectionFilter = function(selectionLayer) {
                return selectionLayer ? [ "get", "selected" ] : [ "!", [ "get", "selected" ] ];
            }, AzureMapExpressionHelper.LEGACY_getBubbleFilter = function(selectionLayer, dataOptions) {
                var filter = this.LEGACY_getLayerFilter(selectionLayer, dataOptions) || [ "all" ];
                return filter.push([ "==", [ "get", "showBubble" ], !0 ]), filter.push([ "!", this.clusteredDataFilter ]), 
                filter;
            }, AzureMapExpressionHelper.LEGACY_getBarChart3DFilter = function(selectionLayer, dataOptions) {
                return this.LEGACY_getLayerFilter(selectionLayer, dataOptions, !0);
            }, AzureMapExpressionHelper.LEGACY_getFilledMapFilter = function(selectionLayer, dataOptions) {
                return this.LEGACY_getLayerFilter(selectionLayer, dataOptions);
            }, AzureMapExpressionHelper.LEGACY_getLayerFilter = function(selectionLayer, dataOptions, addSelectionFilter) {
                void 0 === addSelectionFilter && (addSelectionFilter = !1);
                var filterCollections = [];
                if (addSelectionFilter && filterCollections.push(this.getSelectionFilter(selectionLayer)), 
                _.isEmpty(dataOptions) || (dataOptions.showZeros || filterCollections.push([ "!=", [ "get", "size" ], 0 ]), 
                dataOptions.showNegatives || filterCollections.push([ "!", [ "<", [ "get", "size" ], 0 ] ])), 
                0 !== filterCollections.length) return 1 === filterCollections.length ? filterCollections[0] : (0, 
                tslib_es6.__spreadArray)([ "all" ], filterCollections, !0);
            }, AzureMapExpressionHelper.getRadiusExpression = function(defaultRadius, hasSize, minDataValue, maxDataValue) {
                return hasSize && minDataValue !== maxDataValue ? [ "get", "size" ] : defaultRadius;
            }, AzureMapExpressionHelper.LEGACY_getRadiusExpression = function(bubbleLayerProperties, commonDataOptions, hasSize, minDataValue, maxDataValue) {
                var radiusExp, radius = hasSize ? bubbleLayerProperties.minRadius : bubbleLayerProperties.radius, scaleFactor = bubbleLayerProperties.zoomScaleFactor;
                if (hasSize) {
                    var radiusScaleMethod = bubbleLayerProperties.radiusScalingMethod, interpolation = [ "linear" ];
                    if (1 === radiusScaleMethod ? interpolation = [ "exponential", bubbleLayerProperties.logScale ] : 2 === radiusScaleMethod && (interpolation = [ "cubic-bezier", bubbleLayerProperties.x1, bubbleLayerProperties.y1, bubbleLayerProperties.x2, bubbleLayerProperties.y2 ]), 
                    minDataValue === maxDataValue) radiusExp = [ "interpolate", interpolation, [ "zoom" ], 12, radius, 20, radius * scaleFactor ]; else {
                        var sizeGetter = [ "get", "size" ];
                        commonDataOptions.showNegatives && (sizeGetter = [ "abs", sizeGetter ]), radiusExp = [ "interpolate", interpolation, sizeGetter, minDataValue, radius, maxDataValue, bubbleLayerProperties.maxRadius ], 
                        1 !== scaleFactor && (radiusExp = [ "let", "radiusSize", radiusExp, [ "interpolate", [ "linear" ], [ "zoom" ], 12, [ "var", "radiusSize" ], 20, [ "*", scaleFactor, [ "var", "radiusSize" ] ] ] ]);
                    }
                } else radiusExp = 1 !== scaleFactor ? [ "interpolate", [ "linear" ], [ "zoom" ], 12, radius, 20, radius * scaleFactor ] : radius;
                return radiusExp;
            }, AzureMapExpressionHelper.LEGACY_evaluateRadiusExpression = function(radiusExp, cameraZoom, datapointValue) {
                if ("number" == typeof radiusExp) return radiusExp;
                if (Array.isArray(radiusExp)) if ("interpolate" === radiusExp[0]) {
                    var scalingMethod = radiusExp[1], minValue = radiusExp[3], minRadius = radiusExp[4], maxValue = radiusExp[5], maxRadius = radiusExp[6], shouldTakeZoomAsInput = _.isEqual(radiusExp[2], [ "zoom" ]);
                    shouldTakeZoomAsInput && (!_.isFinite(cameraZoom) || cameraZoom < 0) && (cameraZoom = 1);
                    var ratio = (_.clamp(shouldTakeZoomAsInput ? cameraZoom : datapointValue, minValue, maxValue) - minValue) / (maxValue - minValue);
                    if ("linear" === scalingMethod[0]) return ratio * (maxRadius - minRadius) + minRadius;
                    if ("exponential" === scalingMethod[0]) {
                        var base = scalingMethod[1];
                        return (1 === base ? ratio : (Math.pow(base, ratio) - 1) / (base - 1)) * (maxRadius - minRadius) + minRadius;
                    }
                    if ("cubic-bezier" === scalingMethod[0]) return new CubicBezierScaler(scalingMethod[1], scalingMethod[2], scalingMethod[3], scalingMethod[4]).scale(ratio) * (maxRadius - minRadius) + minRadius;
                } else if ("let" === radiusExp[0] && "radiusSize" === radiusExp[1]) {
                    var radius = this.LEGACY_evaluateRadiusExpression(radiusExp[2], cameraZoom, datapointValue), interpolationExp = _.cloneDeep(radiusExp[3]);
                    return interpolationExp[4] = radius, interpolationExp[6] = radius * interpolationExp[6][1], 
                    this.LEGACY_evaluateRadiusExpression(interpolationExp, cameraZoom, datapointValue);
                }
                return 0;
            }, AzureMapExpressionHelper.LEGACY_appendPieRadiusToDataPoints = function(dataPoints, azureMapData) {
                var radiusExpression = AzureMapExpressionHelper.LEGACY_getRadiusExpression(azureMapData.properties.bubble, azureMapData.properties.commonDataOptions, azureMapData.hasSize, azureMapData.minDataValue, azureMapData.maxDataValue);
                dataPoints.forEach(function(dataPoint) {
                    var size = dataPoint.subDataPoints.reduce(function(total, subDataPoint) {
                        return total + subDataPoint.size;
                    }, 0), radiusInPixel = AzureMapExpressionHelper.LEGACY_evaluateRadiusExpression(radiusExpression, void 0, size);
                    dataPoint.bubbleRadius = radiusInPixel;
                });
            }, _a = AzureMapExpressionHelper, AzureMapExpressionHelper.getStrokeColor = function(autoStrokeColor, strokeColor, colorExpression) {
                var color = strokeColor;
                if (autoStrokeColor) {
                    var fillColorFilter = [ "var", "fillColor" ];
                    color = [ "let", "fillColor", [ "to-rgba", [ "to-color", colorExpression ] ], [ "case", [ ">", [ "sqrt", [ "+", [ "*", .299, [ "^", [ "at", 0, fillColorFilter ], 2 ] ], [ "*", .587, [ "^", [ "at", 1, fillColorFilter ], 2 ] ], [ "*", .114, [ "^", [ "at", 2, fillColorFilter ], 2 ] ] ] ], 127 ], [ "to-color", [ "rgb", [ "*", .5, [ "at", 0, fillColorFilter ] ], [ "*", .5, [ "at", 1, fillColorFilter ] ], [ "*", .5, [ "at", 2, fillColorFilter ] ] ] ], [ "to-color", [ "rgb", [ "max", 127, [ "min", 255, [ "*", 1.5, [ "at", 0, fillColorFilter ] ] ] ], [ "max", 127, [ "min", 255, [ "*", 1.5, [ "at", 1, fillColorFilter ] ] ] ], [ "max", 127, [ "min", 255, [ "*", 1.5, [ "at", 2, fillColorFilter ] ] ] ] ] ] ] ];
                }
                return color;
            }, AzureMapExpressionHelper.clusteredDataFilter = [ "has", "point_count" ], AzureMapExpressionHelper.bubbleLayerFilter = [ "all", [ "==", [ "get", FilterProperty.bubble ], !0 ], [ "!", _a.clusteredDataFilter ] ], 
            AzureMapExpressionHelper.pieLayerFilter = [ "all", [ "==", [ "get", FilterProperty.pie ], !0 ], [ "!", _a.clusteredDataFilter ] ], 
            AzureMapExpressionHelper;
        }();
    },
    81293: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            l: function() {
                return AzureMapFeatureHelper;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81337), _MapMath_mapMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2379), _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49988), Degree = .0174532925, AzureMapFeatureHelper = function() {
            function AzureMapFeatureHelper() {}
            return AzureMapFeatureHelper.getPointFeatures = function(dataPoints, visualHasSelection, enableBubbleLayer, enablePieChartLayer, options, shouldUseLegacyFormat) {
                var _this = this, enableBothBubblePie = enableBubbleLayer && enablePieChartLayer;
                return dataPoints.filter(function(d) {
                    return d.location && d.subDataPoints && d.subDataPoints.length > 0;
                }).map(function(d) {
                    return new atlas.data.Feature(new atlas.data.Point(new atlas.data.Position(d.location.longitude, d.location.latitude)), (0, 
                    tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
                        coordinates: [ d.location.longitude, d.location.latitude ],
                        size: shouldUseLegacyFormat ? d.subDataPoints[0].size || 0 : d.bubbleRadius || 0,
                        color: d.subDataPoints[0].color,
                        identityKeys: d.subDataPoints.map(function(sp) {
                            return sp.identity.getKey();
                        }),
                        selected: !visualHasSelection || d.subDataPoints[0].selected
                    }, (enableBubbleLayer || enablePieChartLayer) && {
                        showBubble: _this.bubbleVisibility(d, enableBothBubblePie, enableBubbleLayer),
                        showPie: _this.pieVisibility(d, enableBothBubblePie, enablePieChartLayer)
                    }), {
                        iconId: enablePieChartLayer ? _PieChart_pieChartFactory__WEBPACK_IMPORTED_MODULE_1__.t.hash(d, options) : void 0,
                        seriesIndex: d.subDataPoints[0].seriesIndex
                    }));
                });
            }, AzureMapFeatureHelper.bubbleVisibility = function(dataPoint, enableBothBubblePie, enableBubbleLayer) {
                return !(enableBothBubblePie || !enableBubbleLayer) || !(!enableBothBubblePie || 1 !== dataPoint.subDataPoints.length);
            }, AzureMapFeatureHelper.pieVisibility = function(dataPoint, enableBothBubblePie, enablePieChartLayer) {
                return !(enableBothBubblePie || !enablePieChartLayer) || !!(enableBothBubblePie && dataPoint.subDataPoints.length > 1);
            }, AzureMapFeatureHelper.getReferenceLayerFeature = function(matcher, visualHasSelection) {
                if (!matcher) return [];
                var features = matcher.getShapes(), output = [];
                return features.forEach(function(feature) {
                    var dp = matcher.getDataPointFromShape(feature);
                    output.push(dp ? new atlas.data.Feature(feature.geometry, (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
                        coordinates: dp.location ? [ dp.location.longitude, dp.location.latitude ] : [],
                        identityKeys: dp.subDataPoints.map(function(sp) {
                            var _a;
                            return null === (_a = sp.identity) || void 0 === _a ? void 0 : _a.getKey();
                        }),
                        selected: !visualHasSelection || dp.subDataPoints[0].selected
                    }, feature.properties)) : new atlas.data.Feature(feature.geometry, (0, tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({
                        identityKeys: []
                    }, feature.properties)));
                }), output;
            }, AzureMapFeatureHelper.getPolygonFeature = function(centers, scale, barShape, visualHasSelection) {
                var _this = this;
                return centers.filter(function(center) {
                    return center.location;
                }).map(function(center) {
                    return new atlas.data.Feature(1 === barShape ? _this.getCirclePolygon(center, scale) : _this.getSquarePolygon(center, scale), {
                        coordinates: [ center.location.longitude, center.location.latitude ],
                        size: center.subDataPoints[0].size || 0,
                        color: center.subDataPoints[0].color,
                        identityKeys: center.subDataPoints.map(function(sp) {
                            return sp.identity.getKey();
                        }),
                        selected: !visualHasSelection || center.subDataPoints[0].selected
                    });
                });
            }, AzureMapFeatureHelper.getFilledMapMultiPolygonFeature = function(dataPoints, visualHasSelection) {
                return dataPoints.filter(function(d) {
                    return d.geojsonPolygons;
                }).map(function(d) {
                    return new atlas.data.Feature(new atlas.data.MultiPolygon(_MapMath_mapMath__WEBPACK_IMPORTED_MODULE_2__.b.combineMultiPolygonCoordinatesAtAntimeridian(d.location, d.geojsonPolygons.map(function(p) {
                        return p.coordinates;
                    }))), {
                        coordinates: [ d.location.longitude, d.location.latitude ],
                        size: d.subDataPoints[0].size || 0,
                        color: d.subDataPoints[0].color,
                        identityKeys: d.subDataPoints.map(function(sp) {
                            return sp.identity.getKey();
                        }),
                        selected: !visualHasSelection || d.subDataPoints[0].selected
                    });
                });
            }, AzureMapFeatureHelper.getCirclePolygon = function(center, scale) {
                for (var radius = 1e-4 * scale, latitudeScale = Math.cos(center.location.latitude * Degree), coordinates = [], i = 0; i < 18; i++) coordinates.push([ center.location.longitude + radius * Math.cos(20 * i * Degree), center.location.latitude + radius * latitudeScale * Math.sin(20 * i * Degree) ]);
                return coordinates.push([ center.location.longitude + radius, center.location.latitude ]), 
                new atlas.data.Polygon([ coordinates ]);
            }, AzureMapFeatureHelper.getSquarePolygon = function(center, scale) {
                var xOffset = 1e-4 * scale, yOffset = xOffset * Math.cos(center.location.latitude * Degree);
                return new atlas.data.Polygon([ [ [ center.location.longitude + xOffset, center.location.latitude + yOffset ], [ center.location.longitude - xOffset, center.location.latitude + yOffset ], [ center.location.longitude - xOffset, center.location.latitude - yOffset ], [ center.location.longitude + xOffset, center.location.latitude - yOffset ], [ center.location.longitude + xOffset, center.location.latitude + yOffset ] ] ]);
            }, AzureMapFeatureHelper.getIdentityKeys = function(shape) {
                return shape.getProperties().identityKeys;
            }, AzureMapFeatureHelper.getFirstIdentityKey = function(shape) {
                return this.getIdentityKeys(shape)[0];
            }, AzureMapFeatureHelper.findFirstDataPointByKey = function(selectableDataPoints, key) {
                return selectableDataPoints.find(function(dataPoint) {
                    return key === dataPoint.identity.getKey();
                });
            }, AzureMapFeatureHelper.findDataPointsByKeys = function(selectableDataPoint, keys) {
                var pointsToBeSelected = [];
                if (keys.length === selectableDataPoint.length) return selectableDataPoint;
                for (var _i = 0, selectableDataPoint_1 = selectableDataPoint; _i < selectableDataPoint_1.length; _i++) {
                    var dataPoint = selectableDataPoint_1[_i], key = dataPoint.identity.getKey();
                    if (keys.indexOf(key) >= 0 && (pointsToBeSelected.push(dataPoint), pointsToBeSelected.length === keys.length)) break;
                }
                return pointsToBeSelected;
            }, AzureMapFeatureHelper.findDataPointsByShapes = function(selectableDataPoint, shapes) {
                for (var featureKeys = [], _i = 0, shapes_1 = shapes; _i < shapes_1.length; _i++) featureKeys.push.apply(featureKeys, this.getIdentityKeys(shapes_1[_i]));
                return this.findDataPointsByKeys(selectableDataPoint, featureKeys);
            }, AzureMapFeatureHelper;
        }();
    },
    19076: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            E: function() {
                return AzureMapOnObjectUtil;
            }
        });
        var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81337), _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60637), _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32379), _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96915), _azureMapConstant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70508), selectorsByColumnForAllBubbles = {
            dataMap: {
                allData: [ (0, _VisualsData_dataView_dataViewWildcard__WEBPACK_IMPORTED_MODULE_0__.Ue)(1) ]
            }
        }, AzureMapOnObjectUtil = function() {
            function AzureMapOnObjectUtil() {}
            return AzureMapOnObjectUtil.getSubSelectableRegionFromLayerId = function(layerId) {
                return layerId === _azureMapConstant__WEBPACK_IMPORTED_MODULE_1__.yl ? "bubbles" : "map";
            }, AzureMapOnObjectUtil.createAzureMapSubSelection = function(selectableObject, showUI, hostServices, selectionOrigin, series) {
                var displayName = "", selectorsByColumn = {};
                return "bubbles" === selectableObject.split("-")[0] && (series ? (displayName = hostServices.getLocalizedString("MiniToolbar_Bubbles", series.value), 
                selectorsByColumn = series.identity.getSelectorsByColumn()) : (displayName = hostServices.getLocalizedString("Visual_Bubbles"), 
                selectorsByColumn = selectorsByColumnForAllBubbles)), {
                    visualObjects: [ {
                        objectName: selectableObject,
                        selectorsByColumn
                    } ],
                    showUI,
                    displayName,
                    subSelectionType: 3,
                    selectionOrigin
                };
            }, AzureMapOnObjectUtil.getAllSubSelectables = function(data, hostServices, subSelectionHelper, filterType) {
                var subSelectables = subSelectionHelper.getAllSubSelectables(filterType);
                return (null == data ? void 0 : data.properties.bubble) && data.properties.bubble.showBubbleLayer && data.hasSeries && !_.isEmpty(data.series) && subSelectables.push.apply(subSelectables, data.series.map(function(series, seriesIndex) {
                    return AzureMapOnObjectUtil.createAzureMapSubSelection("".concat("bubbles", "-series-").concat(seriesIndex), !1, hostServices, void 0, series);
                })), subSelectables;
            }, AzureMapOnObjectUtil.getNextSubSelectable = function(data, hostServices, subSelectionHelper, currentSubSelectable, backwards) {
                var subselectableObjects = AzureMapOnObjectUtil.getAllSubSelectables(data, hostServices, subSelectionHelper);
                if (subselectableObjects.length) {
                    var nextSubSelectable;
                    if (!currentSubSelectable) return backwards ? _.last(subselectableObjects) : _.first(subselectableObjects);
                    var index = _.findIndex(subselectableObjects, function(subSelectable) {
                        return _.isEqual(currentSubSelectable, subSelectable);
                    });
                    if (index > -1) {
                        var nextIndex = backwards ? index - 1 : index + 1;
                        nextIndex > -1 && nextIndex < subselectableObjects.length && (nextSubSelectable = subselectableObjects[nextIndex]);
                    }
                    return nextSubSelectable;
                }
            }, AzureMapOnObjectUtil.getBubblesSubSelectionStyles = function(hostServices, selectorsByColumn) {
                return void 0 === selectorsByColumn && (selectorsByColumn = {}), {
                    type: 3,
                    fill: {
                        reference: (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.dataPoint.fill), {
                            selector: (0, _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_4__.fd)((0, 
                            _VisualsData_contracts_selector__WEBPACK_IMPORTED_MODULE_4__.tV)(selectorsByColumn))
                        }),
                        label: hostServices.getLocalizedString("Visual_Fill")
                    },
                    stroke: {
                        reference: _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.strokeColor,
                        label: hostServices.getLocalizedString("Visual_Border")
                    }
                };
            }, AzureMapOnObjectUtil.getBubblesSubSelectionShortcuts = function(hostServices) {
                return [ {
                    type: 0,
                    relatedResetFormattingIds: [ _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.dataPoint.fill, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.strokeColor, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.layerPosition ]
                }, (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({
                    type: 3
                }, _Visuals_capabilities_azureMap_capabilities__WEBPACK_IMPORTED_MODULE_3__.MC.bubbleLayer.layerPosition), {
                    label: hostServices.getLocalizedString("Visual_AzureMapsLayerPosition")
                }), {
                    type: 1,
                    destinationInfo: {
                        cardUid: "".concat("Visual", "-").concat(_azureMapConstant__WEBPACK_IMPORTED_MODULE_1__.yl),
                        groupUid: "".concat(_azureMapConstant__WEBPACK_IMPORTED_MODULE_1__.yl, "-size")
                    },
                    label: hostServices.getLocalizedString("Format_Bubbles")
                } ];
            }, AzureMapOnObjectUtil;
        }();
    }
} ]);