(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "json-schema-validation-lazy" ], {
    31984: function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
        const core_1 = __webpack_require__(6565), draft7_1 = __webpack_require__(49045), discriminator_1 = __webpack_require__(57180), draft7MetaSchema = __webpack_require__(70425), META_SUPPORT_DATA = [ "/properties" ], META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
        class Ajv extends core_1.default {
            _addVocabularies() {
                super._addVocabularies(), draft7_1.default.forEach(v => this.addVocabulary(v)), 
                this.opts.discriminator && this.addKeyword(discriminator_1.default);
            }
            _addDefaultMetaSchema() {
                if (super._addDefaultMetaSchema(), !this.opts.meta) return;
                const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
                this.addMetaSchema(metaSchema, META_SCHEMA_ID, !1), this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
            }
            defaultMeta() {
                return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
            }
        }
        module.exports = exports = Ajv, Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = Ajv;
        var validate_1 = __webpack_require__(44340);
        Object.defineProperty(exports, "KeywordCxt", {
            enumerable: !0,
            get: function() {
                return validate_1.KeywordCxt;
            }
        });
        var codegen_1 = __webpack_require__(87948);
        Object.defineProperty(exports, "_", {
            enumerable: !0,
            get: function() {
                return codegen_1._;
            }
        }), Object.defineProperty(exports, "str", {
            enumerable: !0,
            get: function() {
                return codegen_1.str;
            }
        }), Object.defineProperty(exports, "stringify", {
            enumerable: !0,
            get: function() {
                return codegen_1.stringify;
            }
        }), Object.defineProperty(exports, "nil", {
            enumerable: !0,
            get: function() {
                return codegen_1.nil;
            }
        }), Object.defineProperty(exports, "Name", {
            enumerable: !0,
            get: function() {
                return codegen_1.Name;
            }
        }), Object.defineProperty(exports, "CodeGen", {
            enumerable: !0,
            get: function() {
                return codegen_1.CodeGen;
            }
        });
    },
    39764: function(__unused_webpack_module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
        class _CodeOrName {}
        exports._CodeOrName = _CodeOrName, exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class Name extends _CodeOrName {
            constructor(s) {
                if (super(), !exports.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
                this.str = s;
            }
            toString() {
                return this.str;
            }
            emptyStr() {
                return !1;
            }
            get names() {
                return {
                    [this.str]: 1
                };
            }
        }
        exports.Name = Name;
        class _Code extends _CodeOrName {
            constructor(code) {
                super(), this._items = "string" == typeof code ? [ code ] : code;
            }
            toString() {
                return this.str;
            }
            emptyStr() {
                if (this._items.length > 1) return !1;
                const item = this._items[0];
                return "" === item || '""' === item;
            }
            get str() {
                var _a;
                return null !== (_a = this._str) && void 0 !== _a ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
            }
            get names() {
                var _a;
                return null !== (_a = this._names) && void 0 !== _a ? _a : this._names = this._items.reduce((names, c) => (c instanceof Name && (names[c.str] = (names[c.str] || 0) + 1), 
                names), {});
            }
        }
        function _(strs, ...args) {
            const code = [ strs[0] ];
            let i = 0;
            for (;i < args.length; ) addCodeArg(code, args[i]), code.push(strs[++i]);
            return new _Code(code);
        }
        exports._Code = _Code, exports.nil = new _Code(""), exports._ = _;
        const plus = new _Code("+");
        function str(strs, ...args) {
            const expr = [ safeStringify(strs[0]) ];
            let i = 0;
            for (;i < args.length; ) expr.push(plus), addCodeArg(expr, args[i]), expr.push(plus, safeStringify(strs[++i]));
            return function(expr) {
                let i = 1;
                for (;i < expr.length - 1; ) {
                    if (expr[i] === plus) {
                        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
                        if (void 0 !== res) {
                            expr.splice(i - 1, 3, res);
                            continue;
                        }
                        expr[i++] = "+";
                    }
                    i++;
                }
            }(expr), new _Code(expr);
        }
        function addCodeArg(code, arg) {
            var x;
            arg instanceof _Code ? code.push(...arg._items) : code.push(arg instanceof Name ? arg : "number" == typeof (x = arg) || "boolean" == typeof x || null === x ? x : safeStringify(Array.isArray(x) ? x.join(",") : x));
        }
        function mergeExprItems(a, b) {
            if ('""' === b) return a;
            if ('""' === a) return b;
            if ("string" == typeof a) {
                if (b instanceof Name || '"' !== a[a.length - 1]) return;
                return "string" != typeof b ? `${a.slice(0, -1)}${b}"` : '"' === b[0] ? a.slice(0, -1) + b.slice(1) : void 0;
            }
            return "string" != typeof b || '"' !== b[0] || a instanceof Name ? void 0 : `"${a}${b.slice(1)}`;
        }
        function safeStringify(x) {
            return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        exports.str = str, exports.addCodeArg = addCodeArg, exports.strConcat = function(c1, c2) {
            return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
        }, exports.stringify = function(x) {
            return new _Code(safeStringify(x));
        }, exports.safeStringify = safeStringify, exports.getProperty = function(key) {
            return "string" == typeof key && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
        }, exports.getEsmExportName = function(key) {
            if ("string" == typeof key && exports.IDENTIFIER.test(key)) return new _Code(`${key}`);
            throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
        }, exports.regexpCode = function(rx) {
            return new _Code(rx.toString());
        };
    },
    87948: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
        const code_1 = __webpack_require__(39764), scope_1 = __webpack_require__(32316);
        var code_2 = __webpack_require__(39764);
        Object.defineProperty(exports, "_", {
            enumerable: !0,
            get: function() {
                return code_2._;
            }
        }), Object.defineProperty(exports, "str", {
            enumerable: !0,
            get: function() {
                return code_2.str;
            }
        }), Object.defineProperty(exports, "strConcat", {
            enumerable: !0,
            get: function() {
                return code_2.strConcat;
            }
        }), Object.defineProperty(exports, "nil", {
            enumerable: !0,
            get: function() {
                return code_2.nil;
            }
        }), Object.defineProperty(exports, "getProperty", {
            enumerable: !0,
            get: function() {
                return code_2.getProperty;
            }
        }), Object.defineProperty(exports, "stringify", {
            enumerable: !0,
            get: function() {
                return code_2.stringify;
            }
        }), Object.defineProperty(exports, "regexpCode", {
            enumerable: !0,
            get: function() {
                return code_2.regexpCode;
            }
        }), Object.defineProperty(exports, "Name", {
            enumerable: !0,
            get: function() {
                return code_2.Name;
            }
        });
        var scope_2 = __webpack_require__(32316);
        Object.defineProperty(exports, "Scope", {
            enumerable: !0,
            get: function() {
                return scope_2.Scope;
            }
        }), Object.defineProperty(exports, "ValueScope", {
            enumerable: !0,
            get: function() {
                return scope_2.ValueScope;
            }
        }), Object.defineProperty(exports, "ValueScopeName", {
            enumerable: !0,
            get: function() {
                return scope_2.ValueScopeName;
            }
        }), Object.defineProperty(exports, "varKinds", {
            enumerable: !0,
            get: function() {
                return scope_2.varKinds;
            }
        }), exports.operators = {
            GT: new code_1._Code(">"),
            GTE: new code_1._Code(">="),
            LT: new code_1._Code("<"),
            LTE: new code_1._Code("<="),
            EQ: new code_1._Code("==="),
            NEQ: new code_1._Code("!=="),
            NOT: new code_1._Code("!"),
            OR: new code_1._Code("||"),
            AND: new code_1._Code("&&"),
            ADD: new code_1._Code("+")
        };
        class Node {
            optimizeNodes() {
                return this;
            }
            optimizeNames(_names, _constants) {
                return this;
            }
        }
        class Def extends Node {
            constructor(varKind, name, rhs) {
                super(), this.varKind = varKind, this.name = name, this.rhs = rhs;
            }
            render({es5, _n}) {
                return `${es5 ? scope_1.varKinds.var : this.varKind} ${this.name}${void 0 === this.rhs ? "" : ` = ${this.rhs}`};` + _n;
            }
            optimizeNames(names, constants) {
                if (names[this.name.str]) return this.rhs && (this.rhs = optimizeExpr(this.rhs, names, constants)), 
                this;
            }
            get names() {
                return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
            }
        }
        class Assign extends Node {
            constructor(lhs, rhs, sideEffects) {
                super(), this.lhs = lhs, this.rhs = rhs, this.sideEffects = sideEffects;
            }
            render({_n}) {
                return `${this.lhs} = ${this.rhs};` + _n;
            }
            optimizeNames(names, constants) {
                if (!(this.lhs instanceof code_1.Name) || names[this.lhs.str] || this.sideEffects) return this.rhs = optimizeExpr(this.rhs, names, constants), 
                this;
            }
            get names() {
                return addExprNames(this.lhs instanceof code_1.Name ? {} : {
                    ...this.lhs.names
                }, this.rhs);
            }
        }
        class AssignOp extends Assign {
            constructor(lhs, op, rhs, sideEffects) {
                super(lhs, rhs, sideEffects), this.op = op;
            }
            render({_n}) {
                return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
            }
        }
        class Label extends Node {
            constructor(label) {
                super(), this.label = label, this.names = {};
            }
            render({_n}) {
                return `${this.label}:` + _n;
            }
        }
        class Break extends Node {
            constructor(label) {
                super(), this.label = label, this.names = {};
            }
            render({_n}) {
                return `break${this.label ? ` ${this.label}` : ""};` + _n;
            }
        }
        class Throw extends Node {
            constructor(error) {
                super(), this.error = error;
            }
            render({_n}) {
                return `throw ${this.error};` + _n;
            }
            get names() {
                return this.error.names;
            }
        }
        class AnyCode extends Node {
            constructor(code) {
                super(), this.code = code;
            }
            render({_n}) {
                return `${this.code};` + _n;
            }
            optimizeNodes() {
                return `${this.code}` ? this : void 0;
            }
            optimizeNames(names, constants) {
                return this.code = optimizeExpr(this.code, names, constants), this;
            }
            get names() {
                return this.code instanceof code_1._CodeOrName ? this.code.names : {};
            }
        }
        class ParentNode extends Node {
            constructor(nodes = []) {
                super(), this.nodes = nodes;
            }
            render(opts) {
                return this.nodes.reduce((code, n) => code + n.render(opts), "");
            }
            optimizeNodes() {
                const {nodes} = this;
                let i = nodes.length;
                for (;i--; ) {
                    const n = nodes[i].optimizeNodes();
                    Array.isArray(n) ? nodes.splice(i, 1, ...n) : n ? nodes[i] = n : nodes.splice(i, 1);
                }
                return nodes.length > 0 ? this : void 0;
            }
            optimizeNames(names, constants) {
                const {nodes} = this;
                let i = nodes.length;
                for (;i--; ) {
                    const n = nodes[i];
                    n.optimizeNames(names, constants) || (subtractNames(names, n.names), nodes.splice(i, 1));
                }
                return nodes.length > 0 ? this : void 0;
            }
            get names() {
                return this.nodes.reduce((names, n) => addNames(names, n.names), {});
            }
        }
        class BlockNode extends ParentNode {
            render(opts) {
                return "{" + opts._n + super.render(opts) + "}" + opts._n;
            }
        }
        class Root extends ParentNode {}
        class Else extends BlockNode {}
        Else.kind = "else";
        class If extends BlockNode {
            constructor(condition, nodes) {
                super(nodes), this.condition = condition;
            }
            render(opts) {
                let code = `if(${this.condition})` + super.render(opts);
                return this.else && (code += "else " + this.else.render(opts)), code;
            }
            optimizeNodes() {
                super.optimizeNodes();
                const cond = this.condition;
                if (!0 === cond) return this.nodes;
                let e = this.else;
                if (e) {
                    const ns = e.optimizeNodes();
                    e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
                }
                return e ? !1 === cond ? e instanceof If ? e : e.nodes : this.nodes.length ? this : new If(not(cond), e instanceof If ? [ e ] : e.nodes) : !1 !== cond && this.nodes.length ? this : void 0;
            }
            optimizeNames(names, constants) {
                var _a;
                if (this.else = null === (_a = this.else) || void 0 === _a ? void 0 : _a.optimizeNames(names, constants), 
                super.optimizeNames(names, constants) || this.else) return this.condition = optimizeExpr(this.condition, names, constants), 
                this;
            }
            get names() {
                const names = super.names;
                return addExprNames(names, this.condition), this.else && addNames(names, this.else.names), 
                names;
            }
        }
        If.kind = "if";
        class For extends BlockNode {}
        For.kind = "for";
        class ForLoop extends For {
            constructor(iteration) {
                super(), this.iteration = iteration;
            }
            render(opts) {
                return `for(${this.iteration})` + super.render(opts);
            }
            optimizeNames(names, constants) {
                if (super.optimizeNames(names, constants)) return this.iteration = optimizeExpr(this.iteration, names, constants), 
                this;
            }
            get names() {
                return addNames(super.names, this.iteration.names);
            }
        }
        class ForRange extends For {
            constructor(varKind, name, from, to) {
                super(), this.varKind = varKind, this.name = name, this.from = from, this.to = to;
            }
            render(opts) {
                const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind, {name, from, to} = this;
                return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
            }
            get names() {
                const names = addExprNames(super.names, this.from);
                return addExprNames(names, this.to);
            }
        }
        class ForIter extends For {
            constructor(loop, varKind, name, iterable) {
                super(), this.loop = loop, this.varKind = varKind, this.name = name, this.iterable = iterable;
            }
            render(opts) {
                return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
            }
            optimizeNames(names, constants) {
                if (super.optimizeNames(names, constants)) return this.iterable = optimizeExpr(this.iterable, names, constants), 
                this;
            }
            get names() {
                return addNames(super.names, this.iterable.names);
            }
        }
        class Func extends BlockNode {
            constructor(name, args, async) {
                super(), this.name = name, this.args = args, this.async = async;
            }
            render(opts) {
                return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
            }
        }
        Func.kind = "func";
        class Return extends ParentNode {
            render(opts) {
                return "return " + super.render(opts);
            }
        }
        Return.kind = "return";
        class Try extends BlockNode {
            render(opts) {
                let code = "try" + super.render(opts);
                return this.catch && (code += this.catch.render(opts)), this.finally && (code += this.finally.render(opts)), 
                code;
            }
            optimizeNodes() {
                var _a, _b;
                return super.optimizeNodes(), null === (_a = this.catch) || void 0 === _a || _a.optimizeNodes(), 
                null === (_b = this.finally) || void 0 === _b || _b.optimizeNodes(), this;
            }
            optimizeNames(names, constants) {
                var _a, _b;
                return super.optimizeNames(names, constants), null === (_a = this.catch) || void 0 === _a || _a.optimizeNames(names, constants), 
                null === (_b = this.finally) || void 0 === _b || _b.optimizeNames(names, constants), 
                this;
            }
            get names() {
                const names = super.names;
                return this.catch && addNames(names, this.catch.names), this.finally && addNames(names, this.finally.names), 
                names;
            }
        }
        class Catch extends BlockNode {
            constructor(error) {
                super(), this.error = error;
            }
            render(opts) {
                return `catch(${this.error})` + super.render(opts);
            }
        }
        Catch.kind = "catch";
        class Finally extends BlockNode {
            render(opts) {
                return "finally" + super.render(opts);
            }
        }
        function addNames(names, from) {
            for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);
            return names;
        }
        function addExprNames(names, from) {
            return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
        }
        function optimizeExpr(expr, names, constants) {
            return expr instanceof code_1.Name ? replaceName(expr) : (e = expr) instanceof code_1._Code && e._items.some(c => c instanceof code_1.Name && 1 === names[c.str] && void 0 !== constants[c.str]) ? new code_1._Code(expr._items.reduce((items, c) => (c instanceof code_1.Name && (c = replaceName(c)), 
            c instanceof code_1._Code ? items.push(...c._items) : items.push(c), items), [])) : expr;
            var e;
            function replaceName(n) {
                const c = constants[n.str];
                return void 0 === c || 1 !== names[n.str] ? n : (delete names[n.str], c);
            }
        }
        function subtractNames(names, from) {
            for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);
        }
        function not(x) {
            return "boolean" == typeof x || "number" == typeof x || null === x ? !x : code_1._`!${par(x)}`;
        }
        Finally.kind = "finally", exports.CodeGen = class {
            constructor(extScope, opts = {}) {
                this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = {
                    ...opts,
                    _n: opts.lines ? "\n" : ""
                }, this._extScope = extScope, this._scope = new scope_1.Scope({
                    parent: extScope
                }), this._nodes = [ new Root ];
            }
            toString() {
                return this._root.render(this.opts);
            }
            name(prefix) {
                return this._scope.name(prefix);
            }
            scopeName(prefix) {
                return this._extScope.name(prefix);
            }
            scopeValue(prefixOrName, value) {
                const name = this._extScope.value(prefixOrName, value);
                return (this._values[name.prefix] || (this._values[name.prefix] = new Set)).add(name), 
                name;
            }
            getScopeValue(prefix, keyOrRef) {
                return this._extScope.getValue(prefix, keyOrRef);
            }
            scopeRefs(scopeName) {
                return this._extScope.scopeRefs(scopeName, this._values);
            }
            scopeCode() {
                return this._extScope.scopeCode(this._values);
            }
            _def(varKind, nameOrPrefix, rhs, constant) {
                const name = this._scope.toName(nameOrPrefix);
                return void 0 !== rhs && constant && (this._constants[name.str] = rhs), this._leafNode(new Def(varKind, name, rhs)), 
                name;
            }
            const(nameOrPrefix, rhs, _constant) {
                return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
            }
            let(nameOrPrefix, rhs, _constant) {
                return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
            }
            var(nameOrPrefix, rhs, _constant) {
                return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
            }
            assign(lhs, rhs, sideEffects) {
                return this._leafNode(new Assign(lhs, rhs, sideEffects));
            }
            add(lhs, rhs) {
                return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
            }
            code(c) {
                return "function" == typeof c ? c() : c !== code_1.nil && this._leafNode(new AnyCode(c)), 
                this;
            }
            object(...keyValues) {
                const code = [ "{" ];
                for (const [key, value] of keyValues) code.length > 1 && code.push(","), code.push(key), 
                (key !== value || this.opts.es5) && (code.push(":"), (0, code_1.addCodeArg)(code, value));
                return code.push("}"), new code_1._Code(code);
            }
            if(condition, thenBody, elseBody) {
                if (this._blockNode(new If(condition)), thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf(); else if (thenBody) this.code(thenBody).endIf(); else if (elseBody) throw new Error('CodeGen: "else" body without "then" body');
                return this;
            }
            elseIf(condition) {
                return this._elseNode(new If(condition));
            }
            else() {
                return this._elseNode(new Else);
            }
            endIf() {
                return this._endBlockNode(If, Else);
            }
            _for(node, forBody) {
                return this._blockNode(node), forBody && this.code(forBody).endFor(), this;
            }
            for(iteration, forBody) {
                return this._for(new ForLoop(iteration), forBody);
            }
            forRange(nameOrPrefix, from, to, forBody, varKind = (this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let)) {
                const name = this._scope.toName(nameOrPrefix);
                return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
            }
            forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
                const name = this._scope.toName(nameOrPrefix);
                if (this.opts.es5) {
                    const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
                    return this.forRange("_i", 0, code_1._`${arr}.length`, i => {
                        this.var(name, code_1._`${arr}[${i}]`), forBody(name);
                    });
                }
                return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
            }
            forIn(nameOrPrefix, obj, forBody, varKind = (this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const)) {
                if (this.opts.ownProperties) return this.forOf(nameOrPrefix, code_1._`Object.keys(${obj})`, forBody);
                const name = this._scope.toName(nameOrPrefix);
                return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
            }
            endFor() {
                return this._endBlockNode(For);
            }
            label(label) {
                return this._leafNode(new Label(label));
            }
            break(label) {
                return this._leafNode(new Break(label));
            }
            return(value) {
                const node = new Return;
                if (this._blockNode(node), this.code(value), 1 !== node.nodes.length) throw new Error('CodeGen: "return" should have one node');
                return this._endBlockNode(Return);
            }
            try(tryBody, catchCode, finallyCode) {
                if (!catchCode && !finallyCode) throw new Error('CodeGen: "try" without "catch" and "finally"');
                const node = new Try;
                if (this._blockNode(node), this.code(tryBody), catchCode) {
                    const error = this.name("e");
                    this._currNode = node.catch = new Catch(error), catchCode(error);
                }
                return finallyCode && (this._currNode = node.finally = new Finally, this.code(finallyCode)), 
                this._endBlockNode(Catch, Finally);
            }
            throw(error) {
                return this._leafNode(new Throw(error));
            }
            block(body, nodeCount) {
                return this._blockStarts.push(this._nodes.length), body && this.code(body).endBlock(nodeCount), 
                this;
            }
            endBlock(nodeCount) {
                const len = this._blockStarts.pop();
                if (void 0 === len) throw new Error("CodeGen: not in self-balancing block");
                const toClose = this._nodes.length - len;
                if (toClose < 0 || void 0 !== nodeCount && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
                return this._nodes.length = len, this;
            }
            func(name, args = code_1.nil, async, funcBody) {
                return this._blockNode(new Func(name, args, async)), funcBody && this.code(funcBody).endFunc(), 
                this;
            }
            endFunc() {
                return this._endBlockNode(Func);
            }
            optimize(n = 1) {
                for (;n-- > 0; ) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
            }
            _leafNode(node) {
                return this._currNode.nodes.push(node), this;
            }
            _blockNode(node) {
                this._currNode.nodes.push(node), this._nodes.push(node);
            }
            _endBlockNode(N1, N2) {
                const n = this._currNode;
                if (n instanceof N1 || N2 && n instanceof N2) return this._nodes.pop(), this;
                throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
            }
            _elseNode(node) {
                const n = this._currNode;
                if (!(n instanceof If)) throw new Error('CodeGen: "else" without "if"');
                return this._currNode = n.else = node, this;
            }
            get _root() {
                return this._nodes[0];
            }
            get _currNode() {
                const ns = this._nodes;
                return ns[ns.length - 1];
            }
            set _currNode(node) {
                const ns = this._nodes;
                ns[ns.length - 1] = node;
            }
        }, exports.not = not;
        const andCode = mappend(exports.operators.AND);
        exports.and = function(...args) {
            return args.reduce(andCode);
        };
        const orCode = mappend(exports.operators.OR);
        function mappend(op) {
            return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : code_1._`${par(x)} ${op} ${par(y)}`;
        }
        function par(x) {
            return x instanceof code_1.Name ? x : code_1._`(${x})`;
        }
        exports.or = function(...args) {
            return args.reduce(orCode);
        };
    },
    32316: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
        const code_1 = __webpack_require__(39764);
        class ValueError extends Error {
            constructor(name) {
                super(`CodeGen: "code" for ${name} not defined`), this.value = name.value;
            }
        }
        var UsedValueState;
        !function(UsedValueState) {
            UsedValueState[UsedValueState.Started = 0] = "Started", UsedValueState[UsedValueState.Completed = 1] = "Completed";
        }(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {})), exports.varKinds = {
            const: new code_1.Name("const"),
            let: new code_1.Name("let"),
            var: new code_1.Name("var")
        };
        class Scope {
            constructor({prefixes, parent} = {}) {
                this._names = {}, this._prefixes = prefixes, this._parent = parent;
            }
            toName(nameOrPrefix) {
                return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
            }
            name(prefix) {
                return new code_1.Name(this._newName(prefix));
            }
            _newName(prefix) {
                return `${prefix}${(this._names[prefix] || this._nameGroup(prefix)).index++}`;
            }
            _nameGroup(prefix) {
                var _a, _b;
                if ((null === (_b = null === (_a = this._parent) || void 0 === _a ? void 0 : _a._prefixes) || void 0 === _b ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
                return this._names[prefix] = {
                    prefix,
                    index: 0
                };
            }
        }
        exports.Scope = Scope;
        class ValueScopeName extends code_1.Name {
            constructor(prefix, nameStr) {
                super(nameStr), this.prefix = prefix;
            }
            setValue(value, {property, itemIndex}) {
                this.value = value, this.scopePath = code_1._`.${new code_1.Name(property)}[${itemIndex}]`;
            }
        }
        exports.ValueScopeName = ValueScopeName;
        const line = code_1._`\n`;
        exports.ValueScope = class extends Scope {
            constructor(opts) {
                super(opts), this._values = {}, this._scope = opts.scope, this.opts = {
                    ...opts,
                    _n: opts.lines ? line : code_1.nil
                };
            }
            get() {
                return this._scope;
            }
            name(prefix) {
                return new ValueScopeName(prefix, this._newName(prefix));
            }
            value(nameOrPrefix, value) {
                var _a;
                if (void 0 === value.ref) throw new Error("CodeGen: ref must be passed in value");
                const name = this.toName(nameOrPrefix), {prefix} = name, valueKey = null !== (_a = value.key) && void 0 !== _a ? _a : value.ref;
                let vs = this._values[prefix];
                if (vs) {
                    const _name = vs.get(valueKey);
                    if (_name) return _name;
                } else vs = this._values[prefix] = new Map;
                vs.set(valueKey, name);
                const s = this._scope[prefix] || (this._scope[prefix] = []), itemIndex = s.length;
                return s[itemIndex] = value.ref, name.setValue(value, {
                    property: prefix,
                    itemIndex
                }), name;
            }
            getValue(prefix, keyOrRef) {
                const vs = this._values[prefix];
                if (vs) return vs.get(keyOrRef);
            }
            scopeRefs(scopeName, values = this._values) {
                return this._reduceValues(values, name => {
                    if (void 0 === name.scopePath) throw new Error(`CodeGen: name "${name}" has no value`);
                    return code_1._`${scopeName}${name.scopePath}`;
                });
            }
            scopeCode(values = this._values, usedValues, getCode) {
                return this._reduceValues(values, name => {
                    if (void 0 === name.value) throw new Error(`CodeGen: name "${name}" has no value`);
                    return name.value.code;
                }, usedValues, getCode);
            }
            _reduceValues(values, valueCode, usedValues = {}, getCode) {
                let code = code_1.nil;
                for (const prefix in values) {
                    const vs = values[prefix];
                    if (!vs) continue;
                    const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
                    vs.forEach(name => {
                        if (nameSet.has(name)) return;
                        nameSet.set(name, UsedValueState.Started);
                        let c = valueCode(name);
                        if (c) code = code_1._`${code}${this.opts.es5 ? exports.varKinds.var : exports.varKinds.const} ${name} = ${c};${this.opts._n}`; else {
                            if (!(c = null == getCode ? void 0 : getCode(name))) throw new ValueError(name);
                            code = code_1._`${code}${c}${this.opts._n}`;
                        }
                        nameSet.set(name, UsedValueState.Completed);
                    });
                }
                return code;
            }
        };
    },
    58710: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), names_1 = __webpack_require__(82257);
        function addError(gen, errObj) {
            const err = gen.const("err", errObj);
            gen.if(codegen_1._`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen_1._`[${err}]`), codegen_1._`${names_1.default.vErrors}.push(${err})`), 
            gen.code(codegen_1._`${names_1.default.errors}++`);
        }
        function returnErrors(it, errs) {
            const {gen, validateName, schemaEnv} = it;
            schemaEnv.$async ? gen.throw(codegen_1._`new ${it.ValidationError}(${errs})`) : (gen.assign(codegen_1._`${validateName}.errors`, errs), 
            gen.return(!1));
        }
        exports.keywordError = {
            message: ({keyword}) => codegen_1.str`must pass "${keyword}" keyword validation`
        }, exports.keyword$DataError = {
            message: ({keyword, schemaType}) => schemaType ? codegen_1.str`"${keyword}" keyword must be ${schemaType} ($data)` : codegen_1.str`"${keyword}" keyword is invalid ($data)`
        }, exports.reportError = function(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
            const {it} = cxt, {gen, compositeRule, allErrors} = it, errObj = errorObjectCode(cxt, error, errorPaths);
            (null != overrideAllErrors ? overrideAllErrors : compositeRule || allErrors) ? addError(gen, errObj) : returnErrors(it, codegen_1._`[${errObj}]`);
        }, exports.reportExtraError = function(cxt, error = exports.keywordError, errorPaths) {
            const {it} = cxt, {gen, compositeRule, allErrors} = it;
            addError(gen, errorObjectCode(cxt, error, errorPaths)), compositeRule || allErrors || returnErrors(it, names_1.default.vErrors);
        }, exports.resetErrorsCount = function(gen, errsCount) {
            gen.assign(names_1.default.errors, errsCount), gen.if(codegen_1._`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_1._`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
        }, exports.extendErrors = function({gen, keyword, schemaValue, data, errsCount, it}) {
            if (void 0 === errsCount) throw new Error("ajv implementation error");
            const err = gen.name("err");
            gen.forRange("i", errsCount, names_1.default.errors, i => {
                gen.const(err, codegen_1._`${names_1.default.vErrors}[${i}]`), gen.if(codegen_1._`${err}.instancePath === undefined`, () => gen.assign(codegen_1._`${err}.instancePath`, (0, 
                codegen_1.strConcat)(names_1.default.instancePath, it.errorPath))), gen.assign(codegen_1._`${err}.schemaPath`, codegen_1.str`${it.errSchemaPath}/${keyword}`), 
                it.opts.verbose && (gen.assign(codegen_1._`${err}.schema`, schemaValue), gen.assign(codegen_1._`${err}.data`, data));
            });
        };
        const E = {
            keyword: new codegen_1.Name("keyword"),
            schemaPath: new codegen_1.Name("schemaPath"),
            params: new codegen_1.Name("params"),
            propertyName: new codegen_1.Name("propertyName"),
            message: new codegen_1.Name("message"),
            schema: new codegen_1.Name("schema"),
            parentSchema: new codegen_1.Name("parentSchema")
        };
        function errorObjectCode(cxt, error, errorPaths) {
            const {createErrors} = cxt.it;
            return !1 === createErrors ? codegen_1._`{}` : function(cxt, error, errorPaths = {}) {
                const {gen, it} = cxt, keyValues = [ errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths) ];
                return function(cxt, {params, message}, keyValues) {
                    const {keyword, data, schemaValue, it} = cxt, {opts, propertyName, topSchemaRef, schemaPath} = it;
                    keyValues.push([ E.keyword, keyword ], [ E.params, "function" == typeof params ? params(cxt) : params || codegen_1._`{}` ]), 
                    opts.messages && keyValues.push([ E.message, "function" == typeof message ? message(cxt) : message ]), 
                    opts.verbose && keyValues.push([ E.schema, schemaValue ], [ E.parentSchema, codegen_1._`${topSchemaRef}${schemaPath}` ], [ names_1.default.data, data ]), 
                    propertyName && keyValues.push([ E.propertyName, propertyName ]);
                }(cxt, error, keyValues), gen.object(...keyValues);
            }(cxt, error, errorPaths);
        }
        function errorInstancePath({errorPath}, {instancePath}) {
            const instPath = instancePath ? codegen_1.str`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
            return [ names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath) ];
        }
        function errorSchemaPath({keyword, it: {errSchemaPath}}, {schemaPath, parentSchema}) {
            let schPath = parentSchema ? errSchemaPath : codegen_1.str`${errSchemaPath}/${keyword}`;
            return schemaPath && (schPath = codegen_1.str`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`), 
            [ E.schemaPath, schPath ];
        }
    },
    89831: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
        const codegen_1 = __webpack_require__(87948), validation_error_1 = __webpack_require__(76698), names_1 = __webpack_require__(82257), resolve_1 = __webpack_require__(33766), util_1 = __webpack_require__(36128), validate_1 = __webpack_require__(44340);
        class SchemaEnv {
            constructor(env) {
                var _a;
                let schema;
                this.refs = {}, this.dynamicAnchors = {}, "object" == typeof env.schema && (schema = env.schema), 
                this.schema = env.schema, this.schemaId = env.schemaId, this.root = env.root || this, 
                this.baseId = null !== (_a = env.baseId) && void 0 !== _a ? _a : (0, resolve_1.normalizeId)(null == schema ? void 0 : schema[env.schemaId || "$id"]), 
                this.schemaPath = env.schemaPath, this.localRefs = env.localRefs, this.meta = env.meta, 
                this.$async = null == schema ? void 0 : schema.$async, this.refs = {};
            }
        }
        function compileSchema(sch) {
            const _sch = getCompilingSchema.call(this, sch);
            if (_sch) return _sch;
            const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId), {es5, lines} = this.opts.code, {ownProperties} = this.opts, gen = new codegen_1.CodeGen(this.scope, {
                es5,
                lines,
                ownProperties
            });
            let _ValidationError;
            sch.$async && (_ValidationError = gen.scopeValue("Error", {
                ref: validation_error_1.default,
                code: codegen_1._`require("ajv/dist/runtime/validation_error").default`
            }));
            const validateName = gen.scopeName("validate");
            sch.validateName = validateName;
            const schemaCxt = {
                gen,
                allErrors: this.opts.allErrors,
                data: names_1.default.data,
                parentData: names_1.default.parentData,
                parentDataProperty: names_1.default.parentDataProperty,
                dataNames: [ names_1.default.data ],
                dataPathArr: [ codegen_1.nil ],
                dataLevel: 0,
                dataTypes: [],
                definedProperties: new Set,
                topSchemaRef: gen.scopeValue("schema", !0 === this.opts.code.source ? {
                    ref: sch.schema,
                    code: (0, codegen_1.stringify)(sch.schema)
                } : {
                    ref: sch.schema
                }),
                validateName,
                ValidationError: _ValidationError,
                schema: sch.schema,
                schemaEnv: sch,
                rootId,
                baseId: sch.baseId || rootId,
                schemaPath: codegen_1.nil,
                errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
                errorPath: codegen_1._`""`,
                opts: this.opts,
                self: this
            };
            let sourceCode;
            try {
                this._compilations.add(sch), (0, validate_1.validateFunctionCode)(schemaCxt), gen.optimize(this.opts.code.optimize);
                const validateCode = gen.toString();
                sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`, this.opts.code.process && (sourceCode = this.opts.code.process(sourceCode, sch));
                const validate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode)(this, this.scope.get());
                if (this.scope.value(validateName, {
                    ref: validate
                }), validate.errors = null, validate.schema = sch.schema, validate.schemaEnv = sch, 
                sch.$async && (validate.$async = !0), !0 === this.opts.code.source && (validate.source = {
                    validateName,
                    validateCode,
                    scopeValues: gen._values
                }), this.opts.unevaluated) {
                    const {props, items} = schemaCxt;
                    validate.evaluated = {
                        props: props instanceof codegen_1.Name ? void 0 : props,
                        items: items instanceof codegen_1.Name ? void 0 : items,
                        dynamicProps: props instanceof codegen_1.Name,
                        dynamicItems: items instanceof codegen_1.Name
                    }, validate.source && (validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated));
                }
                return sch.validate = validate, sch;
            } catch (e) {
                throw delete sch.validate, delete sch.validateName, sourceCode && this.logger.error("Error compiling schema, function code:", sourceCode), 
                e;
            } finally {
                this._compilations.delete(sch);
            }
        }
        function inlineOrCompile(sch) {
            return (0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs) ? sch.schema : sch.validate ? sch : compileSchema.call(this, sch);
        }
        function getCompilingSchema(schEnv) {
            for (const sch of this._compilations) if ((s1 = sch).schema === (s2 = schEnv).schema && s1.root === s2.root && s1.baseId === s2.baseId) return sch;
            var s1, s2;
        }
        function resolve(root, ref) {
            let sch;
            for (;"string" == typeof (sch = this.refs[ref]); ) ref = sch;
            return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
        }
        function resolveSchema(root, ref) {
            const p = this.opts.uriResolver.parse(ref), refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
            let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
            if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
            const id = (0, resolve_1.normalizeId)(refPath), schOrRef = this.refs[id] || this.schemas[id];
            if ("string" == typeof schOrRef) {
                const sch = resolveSchema.call(this, root, schOrRef);
                if ("object" != typeof (null == sch ? void 0 : sch.schema)) return;
                return getJsonPointer.call(this, p, sch);
            }
            if ("object" == typeof (null == schOrRef ? void 0 : schOrRef.schema)) {
                if (schOrRef.validate || compileSchema.call(this, schOrRef), id === (0, resolve_1.normalizeId)(ref)) {
                    const {schema} = schOrRef, {schemaId} = this.opts, schId = schema[schemaId];
                    return schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId)), 
                    new SchemaEnv({
                        schema,
                        schemaId,
                        root,
                        baseId
                    });
                }
                return getJsonPointer.call(this, p, schOrRef);
            }
        }
        exports.SchemaEnv = SchemaEnv, exports.compileSchema = compileSchema, exports.resolveRef = function(root, baseId, ref) {
            var _a;
            ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
            const schOrFunc = root.refs[ref];
            if (schOrFunc) return schOrFunc;
            let _sch = resolve.call(this, root, ref);
            if (void 0 === _sch) {
                const schema = null === (_a = root.localRefs) || void 0 === _a ? void 0 : _a[ref], {schemaId} = this.opts;
                schema && (_sch = new SchemaEnv({
                    schema,
                    schemaId,
                    root,
                    baseId
                }));
            }
            return void 0 !== _sch ? root.refs[ref] = inlineOrCompile.call(this, _sch) : void 0;
        }, exports.getCompilingSchema = getCompilingSchema, exports.resolveSchema = resolveSchema;
        const PREVENT_SCOPE_CHANGE = new Set([ "properties", "patternProperties", "enum", "dependencies", "definitions" ]);
        function getJsonPointer(parsedRef, {baseId, schema, root}) {
            var _a;
            if ("/" !== (null === (_a = parsedRef.fragment) || void 0 === _a ? void 0 : _a[0])) return;
            for (const part of parsedRef.fragment.slice(1).split("/")) {
                if ("boolean" == typeof schema) return;
                const partSchema = schema[(0, util_1.unescapeFragment)(part)];
                if (void 0 === partSchema) return;
                const schId = "object" == typeof (schema = partSchema) && schema[this.opts.schemaId];
                !PREVENT_SCOPE_CHANGE.has(part) && schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId));
            }
            let env;
            if ("boolean" != typeof schema && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
                const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
                env = resolveSchema.call(this, root, $ref);
            }
            const {schemaId} = this.opts;
            return env = env || new SchemaEnv({
                schema,
                schemaId,
                root,
                baseId
            }), env.schema !== env.root.schema ? env : void 0;
        }
    },
    82257: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), names = {
            data: new codegen_1.Name("data"),
            valCxt: new codegen_1.Name("valCxt"),
            instancePath: new codegen_1.Name("instancePath"),
            parentData: new codegen_1.Name("parentData"),
            parentDataProperty: new codegen_1.Name("parentDataProperty"),
            rootData: new codegen_1.Name("rootData"),
            dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
            vErrors: new codegen_1.Name("vErrors"),
            errors: new codegen_1.Name("errors"),
            this: new codegen_1.Name("this"),
            self: new codegen_1.Name("self"),
            scope: new codegen_1.Name("scope"),
            json: new codegen_1.Name("json"),
            jsonPos: new codegen_1.Name("jsonPos"),
            jsonLen: new codegen_1.Name("jsonLen"),
            jsonPart: new codegen_1.Name("jsonPart")
        };
        exports.default = names;
    },
    54065: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const resolve_1 = __webpack_require__(33766);
        class MissingRefError extends Error {
            constructor(resolver, baseId, ref, msg) {
                super(msg || `can't resolve reference ${ref} from id ${baseId}`), this.missingRef = (0, 
                resolve_1.resolveUrl)(resolver, baseId, ref), this.missingSchema = (0, resolve_1.normalizeId)((0, 
                resolve_1.getFullPath)(resolver, this.missingRef));
            }
        }
        exports.default = MissingRefError;
    },
    33766: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
        const util_1 = __webpack_require__(36128), equal = __webpack_require__(60165), traverse = __webpack_require__(36011), SIMPLE_INLINED = new Set([ "type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const" ]);
        exports.inlineRef = function(schema, limit = !0) {
            return "boolean" == typeof schema || (!0 === limit ? !hasRef(schema) : !!limit && countKeys(schema) <= limit);
        };
        const REF_KEYWORDS = new Set([ "$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor" ]);
        function hasRef(schema) {
            for (const key in schema) {
                if (REF_KEYWORDS.has(key)) return !0;
                const sch = schema[key];
                if (Array.isArray(sch) && sch.some(hasRef)) return !0;
                if ("object" == typeof sch && hasRef(sch)) return !0;
            }
            return !1;
        }
        function countKeys(schema) {
            let count = 0;
            for (const key in schema) {
                if ("$ref" === key) return 1 / 0;
                if (count++, !SIMPLE_INLINED.has(key) && ("object" == typeof schema[key] && (0, 
                util_1.eachItem)(schema[key], sch => count += countKeys(sch)), count === 1 / 0)) return 1 / 0;
            }
            return count;
        }
        function getFullPath(resolver, id = "", normalize) {
            !1 !== normalize && (id = normalizeId(id));
            const p = resolver.parse(id);
            return _getFullPath(resolver, p);
        }
        function _getFullPath(resolver, p) {
            return resolver.serialize(p).split("#")[0] + "#";
        }
        exports.getFullPath = getFullPath, exports._getFullPath = _getFullPath;
        const TRAILING_SLASH_HASH = /#\/?$/;
        function normalizeId(id) {
            return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
        }
        exports.normalizeId = normalizeId, exports.resolveUrl = function(resolver, baseId, id) {
            return id = normalizeId(id), resolver.resolve(baseId, id);
        };
        const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
        exports.getSchemaRefs = function(schema, baseId) {
            if ("boolean" == typeof schema) return {};
            const {schemaId, uriResolver} = this.opts, schId = normalizeId(schema[schemaId] || baseId), baseIds = {
                "": schId
            }, pathPrefix = getFullPath(uriResolver, schId, !1), localRefs = {}, schemaRefs = new Set;
            return traverse(schema, {
                allKeys: !0
            }, (sch, jsonPtr, _, parentJsonPtr) => {
                if (void 0 === parentJsonPtr) return;
                const fullPath = pathPrefix + jsonPtr;
                let baseId = baseIds[parentJsonPtr];
                function addRef(ref) {
                    if (ref = normalizeId(baseId ? (0, this.opts.uriResolver.resolve)(baseId, ref) : ref), 
                    schemaRefs.has(ref)) throw ambiguos(ref);
                    schemaRefs.add(ref);
                    let schOrRef = this.refs[ref];
                    return "string" == typeof schOrRef && (schOrRef = this.refs[schOrRef]), "object" == typeof schOrRef ? checkAmbiguosRef(sch, schOrRef.schema, ref) : ref !== normalizeId(fullPath) && ("#" === ref[0] ? (checkAmbiguosRef(sch, localRefs[ref], ref), 
                    localRefs[ref] = sch) : this.refs[ref] = fullPath), ref;
                }
                function addAnchor(anchor) {
                    if ("string" == typeof anchor) {
                        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
                        addRef.call(this, `#${anchor}`);
                    }
                }
                "string" == typeof sch[schemaId] && (baseId = addRef.call(this, sch[schemaId])), 
                addAnchor.call(this, sch.$anchor), addAnchor.call(this, sch.$dynamicAnchor), baseIds[jsonPtr] = baseId;
            }), localRefs;
            function checkAmbiguosRef(sch1, sch2, ref) {
                if (void 0 !== sch2 && !equal(sch1, sch2)) throw ambiguos(ref);
            }
            function ambiguos(ref) {
                return new Error(`reference "${ref}" resolves to more than one schema`);
            }
        };
    },
    39775: function(__unused_webpack_module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getRules = exports.isJSONType = void 0;
        const jsonTypes = new Set([ "string", "number", "integer", "boolean", "null", "object", "array" ]);
        exports.isJSONType = function(x) {
            return "string" == typeof x && jsonTypes.has(x);
        }, exports.getRules = function() {
            const groups = {
                number: {
                    type: "number",
                    rules: []
                },
                string: {
                    type: "string",
                    rules: []
                },
                array: {
                    type: "array",
                    rules: []
                },
                object: {
                    type: "object",
                    rules: []
                }
            };
            return {
                types: {
                    ...groups,
                    integer: !0,
                    boolean: !0,
                    null: !0
                },
                rules: [ {
                    rules: []
                }, groups.number, groups.string, groups.array, groups.object ],
                post: {
                    rules: []
                },
                all: {},
                keywords: {}
            };
        };
    },
    36128: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
        const codegen_1 = __webpack_require__(87948), code_1 = __webpack_require__(39764);
        function checkUnknownRules(it, schema = it.schema) {
            const {opts, self} = it;
            if (!opts.strictSchema) return;
            if ("boolean" == typeof schema) return;
            const rules = self.RULES.keywords;
            for (const key in schema) rules[key] || checkStrictMode(it, `unknown keyword: "${key}"`);
        }
        function schemaHasRules(schema, rules) {
            if ("boolean" == typeof schema) return !schema;
            for (const key in schema) if (rules[key]) return !0;
            return !1;
        }
        function escapeJsonPointer(str) {
            return "number" == typeof str ? `${str}` : str.replace(/~/g, "~0").replace(/\//g, "~1");
        }
        function unescapeJsonPointer(str) {
            return str.replace(/~1/g, "/").replace(/~0/g, "~");
        }
        function makeMergeEvaluated({mergeNames, mergeToName, mergeValues, resultToName}) {
            return (gen, from, to, toName) => {
                const res = void 0 === to ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), 
                to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
                return toName !== codegen_1.Name || res instanceof codegen_1.Name ? res : resultToName(gen, res);
            };
        }
        function evaluatedPropsToName(gen, ps) {
            if (!0 === ps) return gen.var("props", !0);
            const props = gen.var("props", codegen_1._`{}`);
            return void 0 !== ps && setEvaluated(gen, props, ps), props;
        }
        function setEvaluated(gen, props, ps) {
            Object.keys(ps).forEach(p => gen.assign(codegen_1._`${props}${(0, codegen_1.getProperty)(p)}`, !0));
        }
        exports.toHash = function(arr) {
            const hash = {};
            for (const item of arr) hash[item] = !0;
            return hash;
        }, exports.alwaysValidSchema = function(it, schema) {
            return "boolean" == typeof schema ? schema : 0 === Object.keys(schema).length || (checkUnknownRules(it, schema), 
            !schemaHasRules(schema, it.self.RULES.all));
        }, exports.checkUnknownRules = checkUnknownRules, exports.schemaHasRules = schemaHasRules, 
        exports.schemaHasRulesButRef = function(schema, RULES) {
            if ("boolean" == typeof schema) return !schema;
            for (const key in schema) if ("$ref" !== key && RULES.all[key]) return !0;
            return !1;
        }, exports.schemaRefOrVal = function({topSchemaRef, schemaPath}, schema, keyword, $data) {
            if (!$data) {
                if ("number" == typeof schema || "boolean" == typeof schema) return schema;
                if ("string" == typeof schema) return codegen_1._`${schema}`;
            }
            return codegen_1._`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
        }, exports.unescapeFragment = function(str) {
            return unescapeJsonPointer(decodeURIComponent(str));
        }, exports.escapeFragment = function(str) {
            return encodeURIComponent(escapeJsonPointer(str));
        }, exports.escapeJsonPointer = escapeJsonPointer, exports.unescapeJsonPointer = unescapeJsonPointer, 
        exports.eachItem = function(xs, f) {
            if (Array.isArray(xs)) for (const x of xs) f(x); else f(xs);
        }, exports.mergeEvaluated = {
            props: makeMergeEvaluated({
                mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => {
                    gen.if(codegen_1._`${from} === true`, () => gen.assign(to, !0), () => gen.assign(to, codegen_1._`${to} || {}`).code(codegen_1._`Object.assign(${to}, ${from})`));
                }),
                mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => {
                    !0 === from ? gen.assign(to, !0) : (gen.assign(to, codegen_1._`${to} || {}`), setEvaluated(gen, to, from));
                }),
                mergeValues: (from, to) => !0 === from || {
                    ...from,
                    ...to
                },
                resultToName: evaluatedPropsToName
            }),
            items: makeMergeEvaluated({
                mergeNames: (gen, from, to) => gen.if(codegen_1._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_1._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
                mergeToName: (gen, from, to) => gen.if(codegen_1._`${to} !== true`, () => gen.assign(to, !0 === from || codegen_1._`${to} > ${from} ? ${to} : ${from}`)),
                mergeValues: (from, to) => !0 === from || Math.max(from, to),
                resultToName: (gen, items) => gen.var("items", items)
            })
        }, exports.evaluatedPropsToName = evaluatedPropsToName, exports.setEvaluated = setEvaluated;
        const snippets = {};
        var Type;
        function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
            if (mode) {
                if (msg = `strict mode: ${msg}`, !0 === mode) throw new Error(msg);
                it.self.logger.warn(msg);
            }
        }
        exports.useFunc = function(gen, f) {
            return gen.scopeValue("func", {
                ref: f,
                code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
            });
        }, function(Type) {
            Type[Type.Num = 0] = "Num", Type[Type.Str = 1] = "Str";
        }(Type = exports.Type || (exports.Type = {})), exports.getErrorPath = function(dataProp, dataPropType, jsPropertySyntax) {
            if (dataProp instanceof codegen_1.Name) {
                const isNumber = dataPropType === Type.Num;
                return jsPropertySyntax ? isNumber ? codegen_1._`"[" + ${dataProp} + "]"` : codegen_1._`"['" + ${dataProp} + "']"` : isNumber ? codegen_1._`"/" + ${dataProp}` : codegen_1._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
            }
            return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
        }, exports.checkStrictMode = checkStrictMode;
    },
    70830: function(__unused_webpack_module, exports) {
        "use strict";
        function shouldUseGroup(schema, group) {
            return group.rules.some(rule => shouldUseRule(schema, rule));
        }
        function shouldUseRule(schema, rule) {
            var _a;
            return void 0 !== schema[rule.keyword] || (null === (_a = rule.definition.implements) || void 0 === _a ? void 0 : _a.some(kwd => void 0 !== schema[kwd]));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0, 
        exports.schemaHasRulesForType = function({schema, self}, type) {
            const group = self.RULES.types[type];
            return group && !0 !== group && shouldUseGroup(schema, group);
        }, exports.shouldUseGroup = shouldUseGroup, exports.shouldUseRule = shouldUseRule;
    },
    15227: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
        const errors_1 = __webpack_require__(58710), codegen_1 = __webpack_require__(87948), names_1 = __webpack_require__(82257), boolError = {
            message: "boolean schema is false"
        };
        function falseSchemaError(it, overrideAllErrors) {
            const {gen, data} = it;
            (0, errors_1.reportError)({
                gen,
                keyword: "false schema",
                data,
                schema: !1,
                schemaCode: !1,
                schemaValue: !1,
                params: {},
                it
            }, boolError, void 0, overrideAllErrors);
        }
        exports.topBoolOrEmptySchema = function(it) {
            const {gen, schema, validateName} = it;
            !1 === schema ? falseSchemaError(it, !1) : "object" == typeof schema && !0 === schema.$async ? gen.return(names_1.default.data) : (gen.assign(codegen_1._`${validateName}.errors`, null), 
            gen.return(!0));
        }, exports.boolOrEmptySchema = function(it, valid) {
            const {gen, schema} = it;
            !1 === schema ? (gen.var(valid, !1), falseSchemaError(it)) : gen.var(valid, !0);
        };
    },
    68095: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
        const rules_1 = __webpack_require__(39775), applicability_1 = __webpack_require__(70830), errors_1 = __webpack_require__(58710), codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        var DataType;
        function getJSONTypes(ts) {
            const types = Array.isArray(ts) ? ts : ts ? [ ts ] : [];
            if (types.every(rules_1.isJSONType)) return types;
            throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
        }
        !function(DataType) {
            DataType[DataType.Correct = 0] = "Correct", DataType[DataType.Wrong = 1] = "Wrong";
        }(DataType = exports.DataType || (exports.DataType = {})), exports.getSchemaTypes = function(schema) {
            const types = getJSONTypes(schema.type);
            if (types.includes("null")) {
                if (!1 === schema.nullable) throw new Error("type: null contradicts nullable: false");
            } else {
                if (!types.length && void 0 !== schema.nullable) throw new Error('"nullable" cannot be used without "type"');
                !0 === schema.nullable && types.push("null");
            }
            return types;
        }, exports.getJSONTypes = getJSONTypes, exports.coerceAndCheckDataType = function(it, types) {
            const {gen, data, opts} = it, coerceTo = function(types, coerceTypes) {
                return coerceTypes ? types.filter(t => COERCIBLE.has(t) || "array" === coerceTypes && "array" === t) : [];
            }(types, opts.coerceTypes), checkTypes = types.length > 0 && !(0 === coerceTo.length && 1 === types.length && (0, 
            applicability_1.schemaHasRulesForType)(it, types[0]));
            if (checkTypes) {
                const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
                gen.if(wrongType, () => {
                    coerceTo.length ? function(it, types, coerceTo) {
                        const {gen, data, opts} = it, dataType = gen.let("dataType", codegen_1._`typeof ${data}`), coerced = gen.let("coerced", codegen_1._`undefined`);
                        "array" === opts.coerceTypes && gen.if(codegen_1._`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_1._`${data}[0]`).assign(dataType, codegen_1._`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))), 
                        gen.if(codegen_1._`${coerced} !== undefined`);
                        for (const t of coerceTo) (COERCIBLE.has(t) || "array" === t && "array" === opts.coerceTypes) && coerceSpecificType(t);
                        function coerceSpecificType(t) {
                            switch (t) {
                              case "string":
                                return void gen.elseIf(codegen_1._`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, codegen_1._`"" + ${data}`).elseIf(codegen_1._`${data} === null`).assign(coerced, codegen_1._`""`);

                              case "number":
                                return void gen.elseIf(codegen_1._`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_1._`+${data}`);

                              case "integer":
                                return void gen.elseIf(codegen_1._`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_1._`+${data}`);

                              case "boolean":
                                return void gen.elseIf(codegen_1._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, !1).elseIf(codegen_1._`${data} === "true" || ${data} === 1`).assign(coerced, !0);

                              case "null":
                                return gen.elseIf(codegen_1._`${data} === "" || ${data} === 0 || ${data} === false`), 
                                void gen.assign(coerced, null);

                              case "array":
                                gen.elseIf(codegen_1._`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, codegen_1._`[${data}]`);
                            }
                        }
                        gen.else(), reportTypeError(it), gen.endIf(), gen.if(codegen_1._`${coerced} !== undefined`, () => {
                            gen.assign(data, coerced), function({gen, parentData, parentDataProperty}, expr) {
                                gen.if(codegen_1._`${parentData} !== undefined`, () => gen.assign(codegen_1._`${parentData}[${parentDataProperty}]`, expr));
                            }(it, coerced);
                        });
                    }(it, types, coerceTo) : reportTypeError(it);
                });
            }
            return checkTypes;
        };
        const COERCIBLE = new Set([ "string", "number", "integer", "boolean", "null" ]);
        function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
            const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
            let cond;
            switch (dataType) {
              case "null":
                return codegen_1._`${data} ${EQ} null`;

              case "array":
                cond = codegen_1._`Array.isArray(${data})`;
                break;

              case "object":
                cond = codegen_1._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
                break;

              case "integer":
                cond = numCond(codegen_1._`!(${data} % 1) && !isNaN(${data})`);
                break;

              case "number":
                cond = numCond();
                break;

              default:
                return codegen_1._`typeof ${data} ${EQ} ${dataType}`;
            }
            return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
            function numCond(_cond = codegen_1.nil) {
                return (0, codegen_1.and)(codegen_1._`typeof ${data} == "number"`, _cond, strictNums ? codegen_1._`isFinite(${data})` : codegen_1.nil);
            }
        }
        function checkDataTypes(dataTypes, data, strictNums, correct) {
            if (1 === dataTypes.length) return checkDataType(dataTypes[0], data, strictNums, correct);
            let cond;
            const types = (0, util_1.toHash)(dataTypes);
            if (types.array && types.object) {
                const notObj = codegen_1._`typeof ${data} != "object"`;
                cond = types.null ? notObj : codegen_1._`!${data} || ${notObj}`, delete types.null, 
                delete types.array, delete types.object;
            } else cond = codegen_1.nil;
            types.number && delete types.integer;
            for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
            return cond;
        }
        exports.checkDataType = checkDataType, exports.checkDataTypes = checkDataTypes;
        const typeError = {
            message: ({schema}) => `must be ${schema}`,
            params: ({schema, schemaValue}) => "string" == typeof schema ? codegen_1._`{type: ${schema}}` : codegen_1._`{type: ${schemaValue}}`
        };
        function reportTypeError(it) {
            const cxt = function(it) {
                const {gen, data, schema} = it, schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
                return {
                    gen,
                    keyword: "type",
                    data,
                    schema: schema.type,
                    schemaCode,
                    schemaValue: schemaCode,
                    parentSchema: schema,
                    params: {},
                    it
                };
            }(it);
            (0, errors_1.reportError)(cxt, typeError);
        }
        exports.reportTypeError = reportTypeError;
    },
    115: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.assignDefaults = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        function assignDefault(it, prop, defaultValue) {
            const {gen, compositeRule, data, opts} = it;
            if (void 0 === defaultValue) return;
            const childData = codegen_1._`${data}${(0, codegen_1.getProperty)(prop)}`;
            if (compositeRule) return void (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
            let condition = codegen_1._`${childData} === undefined`;
            "empty" === opts.useDefaults && (condition = codegen_1._`${condition} || ${childData} === null || ${childData} === ""`), 
            gen.if(condition, codegen_1._`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
        }
        exports.assignDefaults = function(it, ty) {
            const {properties, items} = it.schema;
            if ("object" === ty && properties) for (const key in properties) assignDefault(it, key, properties[key].default); else "array" === ty && Array.isArray(items) && items.forEach((sch, i) => assignDefault(it, i, sch.default));
        };
    },
    44340: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
        const boolSchema_1 = __webpack_require__(15227), dataType_1 = __webpack_require__(68095), applicability_1 = __webpack_require__(70830), dataType_2 = __webpack_require__(68095), defaults_1 = __webpack_require__(115), keyword_1 = __webpack_require__(82715), subschema_1 = __webpack_require__(25799), codegen_1 = __webpack_require__(87948), names_1 = __webpack_require__(82257), resolve_1 = __webpack_require__(33766), util_1 = __webpack_require__(36128), errors_1 = __webpack_require__(58710);
        function validateFunction({gen, validateName, schema, schemaEnv, opts}, body) {
            opts.code.es5 ? gen.func(validateName, codegen_1._`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
                gen.code(codegen_1._`"use strict"; ${funcSourceUrl(schema, opts)}`), function(gen, opts) {
                    gen.if(names_1.default.valCxt, () => {
                        gen.var(names_1.default.instancePath, codegen_1._`${names_1.default.valCxt}.${names_1.default.instancePath}`), 
                        gen.var(names_1.default.parentData, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentData}`), 
                        gen.var(names_1.default.parentDataProperty, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`), 
                        gen.var(names_1.default.rootData, codegen_1._`${names_1.default.valCxt}.${names_1.default.rootData}`), 
                        opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, codegen_1._`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
                    }, () => {
                        gen.var(names_1.default.instancePath, codegen_1._`""`), gen.var(names_1.default.parentData, codegen_1._`undefined`), 
                        gen.var(names_1.default.parentDataProperty, codegen_1._`undefined`), gen.var(names_1.default.rootData, names_1.default.data), 
                        opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, codegen_1._`{}`);
                    });
                }(gen, opts), gen.code(body);
            }) : gen.func(validateName, codegen_1._`${names_1.default.data}, ${function(opts) {
                return codegen_1._`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
            }(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
        }
        function funcSourceUrl(schema, opts) {
            const schId = "object" == typeof schema && schema[opts.schemaId];
            return schId && (opts.code.source || opts.code.process) ? codegen_1._`/*# sourceURL=${schId} */` : codegen_1.nil;
        }
        function schemaCxtHasRules({schema, self}) {
            if ("boolean" == typeof schema) return !schema;
            for (const key in schema) if (self.RULES.all[key]) return !0;
            return !1;
        }
        function isSchemaObj(it) {
            return "boolean" != typeof it.schema;
        }
        function checkKeywords(it) {
            (0, util_1.checkUnknownRules)(it), function(it) {
                const {schema, errSchemaPath, opts, self} = it;
                schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES) && self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
            }(it);
        }
        function typeAndKeywords(it, errsCount) {
            if (it.opts.jtd) return schemaKeywords(it, [], !1, errsCount);
            const types = (0, dataType_1.getSchemaTypes)(it.schema);
            schemaKeywords(it, types, !(0, dataType_1.coerceAndCheckDataType)(it, types), errsCount);
        }
        function commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}) {
            const msg = schema.$comment;
            if (!0 === opts.$comment) gen.code(codegen_1._`${names_1.default.self}.logger.log(${msg})`); else if ("function" == typeof opts.$comment) {
                const schemaPath = codegen_1.str`${errSchemaPath}/$comment`, rootName = gen.scopeValue("root", {
                    ref: schemaEnv.root
                });
                gen.code(codegen_1._`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
            }
        }
        function schemaKeywords(it, types, typeErrors, errsCount) {
            const {gen, schema, data, allErrors, opts, self} = it, {RULES} = self;
            function groupKeywords(group) {
                (0, applicability_1.shouldUseGroup)(schema, group) && (group.type ? (gen.if((0, 
                dataType_2.checkDataType)(group.type, data, opts.strictNumbers)), iterateKeywords(it, group), 
                1 === types.length && types[0] === group.type && typeErrors && (gen.else(), (0, 
                dataType_2.reportTypeError)(it)), gen.endIf()) : iterateKeywords(it, group), allErrors || gen.if(codegen_1._`${names_1.default.errors} === ${errsCount || 0}`));
            }
            !schema.$ref || !opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, RULES) ? (opts.jtd || function(it, types) {
                !it.schemaEnv.meta && it.opts.strictTypes && (function(it, types) {
                    types.length && (it.dataTypes.length ? (types.forEach(t => {
                        includesType(it.dataTypes, t) || strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
                    }), it.dataTypes = it.dataTypes.filter(t => includesType(types, t))) : it.dataTypes = types);
                }(it, types), it.opts.allowUnionTypes || function(it, ts) {
                    ts.length > 1 && (2 !== ts.length || !ts.includes("null")) && strictTypesError(it, "use allowUnionTypes to allow union type keyword");
                }(it, types), function(it, ts) {
                    const rules = it.self.RULES.all;
                    for (const keyword in rules) {
                        const rule = rules[keyword];
                        if ("object" == typeof rule && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
                            const {type} = rule.definition;
                            type.length && !type.some(t => {
                                return (schTs = ts).includes(kwdT = t) || "number" === kwdT && schTs.includes("integer");
                                var schTs, kwdT;
                            }) && strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
                        }
                    }
                }(it, it.dataTypes));
            }(it, types), gen.block(() => {
                for (const group of RULES.rules) groupKeywords(group);
                groupKeywords(RULES.post);
            })) : gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        }
        function iterateKeywords(it, group) {
            const {gen, schema, opts: {useDefaults}} = it;
            useDefaults && (0, defaults_1.assignDefaults)(it, group.type), gen.block(() => {
                for (const rule of group.rules) (0, applicability_1.shouldUseRule)(schema, rule) && keywordCode(it, rule.keyword, rule.definition, group.type);
            });
        }
        function includesType(ts, t) {
            return ts.includes(t) || "integer" === t && ts.includes("number");
        }
        function strictTypesError(it, msg) {
            (0, util_1.checkStrictMode)(it, msg += ` at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictTypes)`, it.opts.strictTypes);
        }
        exports.validateFunctionCode = function(it) {
            isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it)) ? function(it) {
                const {schema, opts, gen} = it;
                validateFunction(it, () => {
                    opts.$comment && schema.$comment && commentKeyword(it), function(it) {
                        const {schema, opts} = it;
                        void 0 !== schema.default && opts.useDefaults && opts.strictSchema && (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
                    }(it), gen.let(names_1.default.vErrors, null), gen.let(names_1.default.errors, 0), 
                    opts.unevaluated && function(it) {
                        const {gen, validateName} = it;
                        it.evaluated = gen.const("evaluated", codegen_1._`${validateName}.evaluated`), gen.if(codegen_1._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._`${it.evaluated}.props`, codegen_1._`undefined`)), 
                        gen.if(codegen_1._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._`${it.evaluated}.items`, codegen_1._`undefined`));
                    }(it), typeAndKeywords(it), function(it) {
                        const {gen, schemaEnv, validateName, ValidationError, opts} = it;
                        schemaEnv.$async ? gen.if(codegen_1._`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._`new ${ValidationError}(${names_1.default.vErrors})`)) : (gen.assign(codegen_1._`${validateName}.errors`, names_1.default.vErrors), 
                        opts.unevaluated && function({gen, evaluated, props, items}) {
                            props instanceof codegen_1.Name && gen.assign(codegen_1._`${evaluated}.props`, props), 
                            items instanceof codegen_1.Name && gen.assign(codegen_1._`${evaluated}.items`, items);
                        }(it), gen.return(codegen_1._`${names_1.default.errors} === 0`));
                    }(it);
                });
            }(it) : validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
        };
        class KeywordCxt {
            constructor(it, def, keyword) {
                if ((0, keyword_1.validateKeywordUsage)(it, def, keyword), this.gen = it.gen, this.allErrors = it.allErrors, 
                this.keyword = keyword, this.data = it.data, this.schema = it.schema[keyword], this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data, 
                this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data), 
                this.schemaType = def.schemaType, this.parentSchema = it.schema, this.params = {}, 
                this.it = it, this.def = def, this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it)); else if (this.schemaCode = this.schemaValue, 
                !(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
                ("code" in def ? def.trackErrors : !1 !== def.errors) && (this.errsCount = it.gen.const("_errs", names_1.default.errors));
            }
            result(condition, successAction, failAction) {
                this.failResult((0, codegen_1.not)(condition), successAction, failAction);
            }
            failResult(condition, successAction, failAction) {
                this.gen.if(condition), failAction ? failAction() : this.error(), successAction ? (this.gen.else(), 
                successAction(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
            }
            pass(condition, failAction) {
                this.failResult((0, codegen_1.not)(condition), void 0, failAction);
            }
            fail(condition) {
                if (void 0 === condition) return this.error(), void (this.allErrors || this.gen.if(!1));
                this.gen.if(condition), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
            }
            fail$data(condition) {
                if (!this.$data) return this.fail(condition);
                const {schemaCode} = this;
                this.fail(codegen_1._`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
            }
            error(append, errorParams, errorPaths) {
                if (errorParams) return this.setParams(errorParams), this._error(append, errorPaths), 
                void this.setParams({});
                this._error(append, errorPaths);
            }
            _error(append, errorPaths) {
                (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
            }
            $dataError() {
                (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
            }
            reset() {
                if (void 0 === this.errsCount) throw new Error('add "trackErrors" to keyword definition');
                (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
            }
            ok(cond) {
                this.allErrors || this.gen.if(cond);
            }
            setParams(obj, assign) {
                assign ? Object.assign(this.params, obj) : this.params = obj;
            }
            block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
                this.gen.block(() => {
                    this.check$data(valid, $dataValid), codeBlock();
                });
            }
            check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
                if (!this.$data) return;
                const {gen, schemaCode, schemaType, def} = this;
                gen.if((0, codegen_1.or)(codegen_1._`${schemaCode} === undefined`, $dataValid)), 
                valid !== codegen_1.nil && gen.assign(valid, !0), (schemaType.length || def.validateSchema) && (gen.elseIf(this.invalid$data()), 
                this.$dataError(), valid !== codegen_1.nil && gen.assign(valid, !1)), gen.else();
            }
            invalid$data() {
                const {gen, schemaCode, schemaType, def, it} = this;
                return (0, codegen_1.or)(function() {
                    if (schemaType.length) {
                        if (!(schemaCode instanceof codegen_1.Name)) throw new Error("ajv implementation error");
                        const st = Array.isArray(schemaType) ? schemaType : [ schemaType ];
                        return codegen_1._`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
                    }
                    return codegen_1.nil;
                }(), function() {
                    if (def.validateSchema) {
                        const validateSchemaRef = gen.scopeValue("validate$data", {
                            ref: def.validateSchema
                        });
                        return codegen_1._`!${validateSchemaRef}(${schemaCode})`;
                    }
                    return codegen_1.nil;
                }());
            }
            subschema(appl, valid) {
                const subschema = (0, subschema_1.getSubschema)(this.it, appl);
                (0, subschema_1.extendSubschemaData)(subschema, this.it, appl), (0, subschema_1.extendSubschemaMode)(subschema, appl);
                const nextContext = {
                    ...this.it,
                    ...subschema,
                    items: void 0,
                    props: void 0
                };
                return function(it, valid) {
                    isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it)) ? function(it, valid) {
                        const {schema, gen, opts} = it;
                        opts.$comment && schema.$comment && commentKeyword(it), function(it) {
                            const schId = it.schema[it.opts.schemaId];
                            schId && (it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId));
                        }(it), function(it) {
                            if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
                        }(it);
                        const errsCount = gen.const("_errs", names_1.default.errors);
                        typeAndKeywords(it, errsCount), gen.var(valid, codegen_1._`${errsCount} === ${names_1.default.errors}`);
                    }(it, valid) : (0, boolSchema_1.boolOrEmptySchema)(it, valid);
                }(nextContext, valid), nextContext;
            }
            mergeEvaluated(schemaCxt, toName) {
                const {it, gen} = this;
                it.opts.unevaluated && (!0 !== it.props && void 0 !== schemaCxt.props && (it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)), 
                !0 !== it.items && void 0 !== schemaCxt.items && (it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)));
            }
            mergeValidEvaluated(schemaCxt, valid) {
                const {it, gen} = this;
                if (it.opts.unevaluated && (!0 !== it.props || !0 !== it.items)) return gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name)), 
                !0;
            }
        }
        function keywordCode(it, keyword, def, ruleType) {
            const cxt = new KeywordCxt(it, def, keyword);
            "code" in def ? def.code(cxt, ruleType) : cxt.$data && def.validate ? (0, keyword_1.funcKeywordCode)(cxt, def) : "macro" in def ? (0, 
            keyword_1.macroKeywordCode)(cxt, def) : (def.compile || def.validate) && (0, keyword_1.funcKeywordCode)(cxt, def);
        }
        exports.KeywordCxt = KeywordCxt;
        const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
        function getData($data, {dataLevel, dataNames, dataPathArr}) {
            let jsonPointer, data;
            if ("" === $data) return names_1.default.rootData;
            if ("/" === $data[0]) {
                if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
                jsonPointer = $data, data = names_1.default.rootData;
            } else {
                const matches = RELATIVE_JSON_POINTER.exec($data);
                if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
                const up = +matches[1];
                if (jsonPointer = matches[2], "#" === jsonPointer) {
                    if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
                    return dataPathArr[dataLevel - up];
                }
                if (up > dataLevel) throw new Error(errorMsg("data", up));
                if (data = dataNames[dataLevel - up], !jsonPointer) return data;
            }
            let expr = data;
            const segments = jsonPointer.split("/");
            for (const segment of segments) segment && (data = codegen_1._`${data}${(0, codegen_1.getProperty)((0, 
            util_1.unescapeJsonPointer)(segment))}`, expr = codegen_1._`${expr} && ${data}`);
            return expr;
            function errorMsg(pointerType, up) {
                return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
            }
        }
        exports.getData = getData;
    },
    82715: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
        const codegen_1 = __webpack_require__(87948), names_1 = __webpack_require__(82257), code_1 = __webpack_require__(52102), errors_1 = __webpack_require__(58710);
        function modifyData(cxt) {
            const {gen, data, it} = cxt;
            gen.if(it.parentData, () => gen.assign(data, codegen_1._`${it.parentData}[${it.parentDataProperty}]`));
        }
        function useKeyword(gen, keyword, result) {
            if (void 0 === result) throw new Error(`keyword "${keyword}" failed to compile`);
            return gen.scopeValue("keyword", "function" == typeof result ? {
                ref: result
            } : {
                ref: result,
                code: (0, codegen_1.stringify)(result)
            });
        }
        exports.macroKeywordCode = function(cxt, def) {
            const {gen, keyword, schema, parentSchema, it} = cxt, macroSchema = def.macro.call(it.self, schema, parentSchema, it), schemaRef = useKeyword(gen, keyword, macroSchema);
            !1 !== it.opts.validateSchema && it.self.validateSchema(macroSchema, !0);
            const valid = gen.name("valid");
            cxt.subschema({
                schema: macroSchema,
                schemaPath: codegen_1.nil,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
                topSchemaRef: schemaRef,
                compositeRule: !0
            }, valid), cxt.pass(valid, () => cxt.error(!0));
        }, exports.funcKeywordCode = function(cxt, def) {
            var _a;
            const {gen, keyword, schema, parentSchema, $data, it} = cxt;
            !function({schemaEnv}, def) {
                if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
            }(it, def);
            const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate, validateRef = useKeyword(gen, keyword, validate), valid = gen.let("valid");
            function assignValid(_await = (def.async ? codegen_1._`await ` : codegen_1.nil)) {
                gen.assign(valid, codegen_1._`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, it.opts.passContext ? names_1.default.this : names_1.default.self, !("compile" in def && !$data || !1 === def.schema))}`, def.modifying);
            }
            function reportErrs(errors) {
                var _a;
                gen.if((0, codegen_1.not)(null !== (_a = def.valid) && void 0 !== _a ? _a : valid), errors);
            }
            cxt.block$data(valid, function() {
                if (!1 === def.errors) assignValid(), def.modifying && modifyData(cxt), reportErrs(() => cxt.error()); else {
                    const ruleErrs = def.async ? function() {
                        const ruleErrs = gen.let("ruleErrs", null);
                        return gen.try(() => assignValid(codegen_1._`await `), e => gen.assign(valid, !1).if(codegen_1._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._`${e}.errors`), () => gen.throw(e))), 
                        ruleErrs;
                    }() : function() {
                        const validateErrs = codegen_1._`${validateRef}.errors`;
                        return gen.assign(validateErrs, null), assignValid(codegen_1.nil), validateErrs;
                    }();
                    def.modifying && modifyData(cxt), reportErrs(() => function(cxt, errs) {
                        const {gen} = cxt;
                        gen.if(codegen_1._`Array.isArray(${errs})`, () => {
                            gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`), 
                            (0, errors_1.extendErrors)(cxt);
                        }, () => cxt.error());
                    }(cxt, ruleErrs));
                }
            }), cxt.ok(null !== (_a = def.valid) && void 0 !== _a ? _a : valid);
        }, exports.validSchemaType = function(schema, schemaType, allowUndefined = !1) {
            return !schemaType.length || schemaType.some(st => "array" === st ? Array.isArray(schema) : "object" === st ? schema && "object" == typeof schema && !Array.isArray(schema) : typeof schema == st || allowUndefined && void 0 === schema);
        }, exports.validateKeywordUsage = function({schema, opts, self, errSchemaPath}, def, keyword) {
            if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) throw new Error("ajv implementation error");
            const deps = def.dependencies;
            if (null == deps ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
            if (def.validateSchema && !def.validateSchema(schema[keyword])) {
                const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
                if ("log" !== opts.validateSchema) throw new Error(msg);
                self.logger.error(msg);
            }
        };
    },
    25799: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        exports.getSubschema = function(it, {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}) {
            if (void 0 !== keyword && void 0 !== schema) throw new Error('both "keyword" and "schema" passed, only one allowed');
            if (void 0 !== keyword) {
                const sch = it.schema[keyword];
                return void 0 === schemaProp ? {
                    schema: sch,
                    schemaPath: codegen_1._`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
                    errSchemaPath: `${it.errSchemaPath}/${keyword}`
                } : {
                    schema: sch[schemaProp],
                    schemaPath: codegen_1._`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, 
                    codegen_1.getProperty)(schemaProp)}`,
                    errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
                };
            }
            if (void 0 !== schema) {
                if (void 0 === schemaPath || void 0 === errSchemaPath || void 0 === topSchemaRef) throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
                return {
                    schema,
                    schemaPath,
                    topSchemaRef,
                    errSchemaPath
                };
            }
            throw new Error('either "keyword" or "schema" must be passed');
        }, exports.extendSubschemaData = function(subschema, it, {dataProp, dataPropType: dpType, data, dataTypes, propertyName}) {
            if (void 0 !== data && void 0 !== dataProp) throw new Error('both "data" and "dataProp" passed, only one allowed');
            const {gen} = it;
            if (void 0 !== dataProp) {
                const {errorPath, dataPathArr, opts} = it;
                dataContextProps(gen.let("data", codegen_1._`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, !0)), 
                subschema.errorPath = codegen_1.str`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`, 
                subschema.parentDataProperty = codegen_1._`${dataProp}`, subschema.dataPathArr = [ ...dataPathArr, subschema.parentDataProperty ];
            }
            function dataContextProps(_nextData) {
                subschema.data = _nextData, subschema.dataLevel = it.dataLevel + 1, subschema.dataTypes = [], 
                it.definedProperties = new Set, subschema.parentData = it.data, subschema.dataNames = [ ...it.dataNames, _nextData ];
            }
            void 0 !== data && (dataContextProps(data instanceof codegen_1.Name ? data : gen.let("data", data, !0)), 
            void 0 !== propertyName && (subschema.propertyName = propertyName)), dataTypes && (subschema.dataTypes = dataTypes);
        }, exports.extendSubschemaMode = function(subschema, {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}) {
            void 0 !== compositeRule && (subschema.compositeRule = compositeRule), void 0 !== createErrors && (subschema.createErrors = createErrors), 
            void 0 !== allErrors && (subschema.allErrors = allErrors), subschema.jtdDiscriminator = jtdDiscriminator, 
            subschema.jtdMetadata = jtdMetadata;
        };
    },
    6565: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        var _asyncToGenerator = __webpack_require__(61107).default;
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
        var validate_1 = __webpack_require__(44340);
        Object.defineProperty(exports, "KeywordCxt", {
            enumerable: !0,
            get: function() {
                return validate_1.KeywordCxt;
            }
        });
        var codegen_1 = __webpack_require__(87948);
        Object.defineProperty(exports, "_", {
            enumerable: !0,
            get: function() {
                return codegen_1._;
            }
        }), Object.defineProperty(exports, "str", {
            enumerable: !0,
            get: function() {
                return codegen_1.str;
            }
        }), Object.defineProperty(exports, "stringify", {
            enumerable: !0,
            get: function() {
                return codegen_1.stringify;
            }
        }), Object.defineProperty(exports, "nil", {
            enumerable: !0,
            get: function() {
                return codegen_1.nil;
            }
        }), Object.defineProperty(exports, "Name", {
            enumerable: !0,
            get: function() {
                return codegen_1.Name;
            }
        }), Object.defineProperty(exports, "CodeGen", {
            enumerable: !0,
            get: function() {
                return codegen_1.CodeGen;
            }
        });
        const validation_error_1 = __webpack_require__(76698), ref_error_1 = __webpack_require__(54065), rules_1 = __webpack_require__(39775), compile_1 = __webpack_require__(89831), codegen_2 = __webpack_require__(87948), resolve_1 = __webpack_require__(33766), dataType_1 = __webpack_require__(68095), util_1 = __webpack_require__(36128), $dataRefSchema = __webpack_require__(95512), uri_1 = __webpack_require__(90010), defaultRegExp = (str, flags) => new RegExp(str, flags);
        defaultRegExp.code = "new RegExp";
        const META_IGNORE_OPTIONS = [ "removeAdditional", "useDefaults", "coerceTypes" ], EXT_SCOPE_NAMES = new Set([ "validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error" ]), removedOptions = {
            errorDataPath: "",
            format: "`validateFormats: false` can be used instead.",
            nullable: '"nullable" keyword is supported by default.',
            jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
            extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
            missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
            processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
            sourceCode: "Use option `code: {source: true}`",
            strictDefaults: "It is default now, see option `strict`.",
            strictKeywords: "It is default now, see option `strict`.",
            uniqueItems: '"uniqueItems" keyword is always validated.',
            unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
            cache: "Map is used as cache, schema object as key.",
            serialize: "Map is used as cache, schema object as key.",
            ajvErrors: "It is default now."
        }, deprecatedOptions = {
            ignoreKeywordsWithRef: "",
            jsPropertySyntax: "",
            unicode: '"minLength"/"maxLength" account for unicode characters by default.'
        };
        function requiredOptions(o) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
            const s = o.strict, _optz = null === (_a = o.code) || void 0 === _a ? void 0 : _a.optimize, optimize = !0 === _optz || void 0 === _optz ? 1 : _optz || 0, regExp = null !== (_c = null === (_b = o.code) || void 0 === _b ? void 0 : _b.regExp) && void 0 !== _c ? _c : defaultRegExp, uriResolver = null !== (_d = o.uriResolver) && void 0 !== _d ? _d : uri_1.default;
            return {
                strictSchema: null === (_f = null !== (_e = o.strictSchema) && void 0 !== _e ? _e : s) || void 0 === _f || _f,
                strictNumbers: null === (_h = null !== (_g = o.strictNumbers) && void 0 !== _g ? _g : s) || void 0 === _h || _h,
                strictTypes: null !== (_k = null !== (_j = o.strictTypes) && void 0 !== _j ? _j : s) && void 0 !== _k ? _k : "log",
                strictTuples: null !== (_m = null !== (_l = o.strictTuples) && void 0 !== _l ? _l : s) && void 0 !== _m ? _m : "log",
                strictRequired: null !== (_p = null !== (_o = o.strictRequired) && void 0 !== _o ? _o : s) && void 0 !== _p && _p,
                code: o.code ? {
                    ...o.code,
                    optimize,
                    regExp
                } : {
                    optimize,
                    regExp
                },
                loopRequired: null !== (_q = o.loopRequired) && void 0 !== _q ? _q : 200,
                loopEnum: null !== (_r = o.loopEnum) && void 0 !== _r ? _r : 200,
                meta: null === (_s = o.meta) || void 0 === _s || _s,
                messages: null === (_t = o.messages) || void 0 === _t || _t,
                inlineRefs: null === (_u = o.inlineRefs) || void 0 === _u || _u,
                schemaId: null !== (_v = o.schemaId) && void 0 !== _v ? _v : "$id",
                addUsedSchema: null === (_w = o.addUsedSchema) || void 0 === _w || _w,
                validateSchema: null === (_x = o.validateSchema) || void 0 === _x || _x,
                validateFormats: null === (_y = o.validateFormats) || void 0 === _y || _y,
                unicodeRegExp: null === (_z = o.unicodeRegExp) || void 0 === _z || _z,
                int32range: null === (_0 = o.int32range) || void 0 === _0 || _0,
                uriResolver
            };
        }
        class Ajv {
            constructor(opts = {}) {
                this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = new Set, 
                this._loading = {}, this._cache = new Map, opts = this.opts = {
                    ...opts,
                    ...requiredOptions(opts)
                };
                const {es5, lines} = this.opts.code;
                this.scope = new codegen_2.ValueScope({
                    scope: {},
                    prefixes: EXT_SCOPE_NAMES,
                    es5,
                    lines
                }), this.logger = function(logger) {
                    if (!1 === logger) return noLogs;
                    if (void 0 === logger) return console;
                    if (logger.log && logger.warn && logger.error) return logger;
                    throw new Error("logger must implement log, warn and error methods");
                }(opts.logger);
                const formatOpt = opts.validateFormats;
                opts.validateFormats = !1, this.RULES = (0, rules_1.getRules)(), checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED"), 
                checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn"), this._metaOpts = getMetaSchemaOptions.call(this), 
                opts.formats && addInitialFormats.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), 
                opts.keywords && addInitialKeywords.call(this, opts.keywords), "object" == typeof opts.meta && this.addMetaSchema(opts.meta), 
                addInitialSchemas.call(this), opts.validateFormats = formatOpt;
            }
            _addVocabularies() {
                this.addKeyword("$async");
            }
            _addDefaultMetaSchema() {
                const {$data, meta, schemaId} = this.opts;
                let _dataRefSchema = $dataRefSchema;
                "id" === schemaId && (_dataRefSchema = {
                    ...$dataRefSchema
                }, _dataRefSchema.id = _dataRefSchema.$id, delete _dataRefSchema.$id), meta && $data && this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], !1);
            }
            defaultMeta() {
                const {meta, schemaId} = this.opts;
                return this.opts.defaultMeta = "object" == typeof meta ? meta[schemaId] || meta : void 0;
            }
            validate(schemaKeyRef, data) {
                let v;
                if ("string" == typeof schemaKeyRef) {
                    if (v = this.getSchema(schemaKeyRef), !v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
                } else v = this.compile(schemaKeyRef);
                const valid = v(data);
                return "$async" in v || (this.errors = v.errors), valid;
            }
            compile(schema, _meta) {
                const sch = this._addSchema(schema, _meta);
                return sch.validate || this._compileSchemaEnv(sch);
            }
            compileAsync(schema, meta) {
                if ("function" != typeof this.opts.loadSchema) throw new Error("options.loadSchema should be a function");
                const {loadSchema} = this.opts;
                return runCompileAsync.call(this, schema, meta);
                function runCompileAsync(_x2, _x3) {
                    return _runCompileAsync.apply(this, arguments);
                }
                function _runCompileAsync() {
                    return (_runCompileAsync = _asyncToGenerator(function*(_schema, _meta) {
                        yield loadMetaSchema.call(this, _schema.$schema);
                        const sch = this._addSchema(_schema, _meta);
                        return sch.validate || _compileAsync.call(this, sch);
                    })).apply(this, arguments);
                }
                function loadMetaSchema(_x4) {
                    return _loadMetaSchema.apply(this, arguments);
                }
                function _loadMetaSchema() {
                    return (_loadMetaSchema = _asyncToGenerator(function*($ref) {
                        $ref && !this.getSchema($ref) && (yield runCompileAsync.call(this, {
                            $ref
                        }, !0));
                    })).apply(this, arguments);
                }
                function _compileAsync(_x5) {
                    return _compileAsync2.apply(this, arguments);
                }
                function _compileAsync2() {
                    return (_compileAsync2 = _asyncToGenerator(function*(sch) {
                        try {
                            return this._compileSchemaEnv(sch);
                        } catch (e) {
                            if (!(e instanceof ref_error_1.default)) throw e;
                            return checkLoaded.call(this, e), yield loadMissingSchema.call(this, e.missingSchema), 
                            _compileAsync.call(this, sch);
                        }
                    })).apply(this, arguments);
                }
                function checkLoaded({missingSchema: ref, missingRef}) {
                    if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
                }
                function loadMissingSchema(_x6) {
                    return _loadMissingSchema.apply(this, arguments);
                }
                function _loadMissingSchema() {
                    return (_loadMissingSchema = _asyncToGenerator(function*(ref) {
                        const _schema = yield _loadSchema.call(this, ref);
                        this.refs[ref] || (yield loadMetaSchema.call(this, _schema.$schema)), this.refs[ref] || this.addSchema(_schema, ref, meta);
                    })).apply(this, arguments);
                }
                function _loadSchema(_x7) {
                    return _loadSchema2.apply(this, arguments);
                }
                function _loadSchema2() {
                    return (_loadSchema2 = _asyncToGenerator(function*(ref) {
                        const p = this._loading[ref];
                        if (p) return p;
                        try {
                            return yield this._loading[ref] = loadSchema(ref);
                        } finally {
                            delete this._loading[ref];
                        }
                    })).apply(this, arguments);
                }
            }
            addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
                if (Array.isArray(schema)) {
                    for (const sch of schema) this.addSchema(sch, void 0, _meta, _validateSchema);
                    return this;
                }
                let id;
                if ("object" == typeof schema) {
                    const {schemaId} = this.opts;
                    if (id = schema[schemaId], void 0 !== id && "string" != typeof id) throw new Error(`schema ${schemaId} must be string`);
                }
                return key = (0, resolve_1.normalizeId)(key || id), this._checkUnique(key), this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, !0), 
                this;
            }
            addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
                return this.addSchema(schema, key, !0, _validateSchema), this;
            }
            validateSchema(schema, throwOrLogError) {
                if ("boolean" == typeof schema) return !0;
                let $schema;
                if ($schema = schema.$schema, void 0 !== $schema && "string" != typeof $schema) throw new Error("$schema must be a string");
                if ($schema = $schema || this.opts.defaultMeta || this.defaultMeta(), !$schema) return this.logger.warn("meta-schema not available"), 
                this.errors = null, !0;
                const valid = this.validate($schema, schema);
                if (!valid && throwOrLogError) {
                    const message = "schema is invalid: " + this.errorsText();
                    if ("log" !== this.opts.validateSchema) throw new Error(message);
                    this.logger.error(message);
                }
                return valid;
            }
            getSchema(keyRef) {
                let sch;
                for (;"string" == typeof (sch = getSchEnv.call(this, keyRef)); ) keyRef = sch;
                if (void 0 === sch) {
                    const {schemaId} = this.opts, root = new compile_1.SchemaEnv({
                        schema: {},
                        schemaId
                    });
                    if (sch = compile_1.resolveSchema.call(this, root, keyRef), !sch) return;
                    this.refs[keyRef] = sch;
                }
                return sch.validate || this._compileSchemaEnv(sch);
            }
            removeSchema(schemaKeyRef) {
                if (schemaKeyRef instanceof RegExp) return this._removeAllSchemas(this.schemas, schemaKeyRef), 
                this._removeAllSchemas(this.refs, schemaKeyRef), this;
                switch (typeof schemaKeyRef) {
                  case "undefined":
                    return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), 
                    this._cache.clear(), this;

                  case "string":
                    {
                        const sch = getSchEnv.call(this, schemaKeyRef);
                        return "object" == typeof sch && this._cache.delete(sch.schema), delete this.schemas[schemaKeyRef], 
                        delete this.refs[schemaKeyRef], this;
                    }

                  case "object":
                    {
                        this._cache.delete(schemaKeyRef);
                        let id = schemaKeyRef[this.opts.schemaId];
                        return id && (id = (0, resolve_1.normalizeId)(id), delete this.schemas[id], delete this.refs[id]), 
                        this;
                    }

                  default:
                    throw new Error("ajv.removeSchema: invalid parameter");
                }
            }
            addVocabulary(definitions) {
                for (const def of definitions) this.addKeyword(def);
                return this;
            }
            addKeyword(kwdOrDef, def) {
                let keyword;
                if ("string" == typeof kwdOrDef) keyword = kwdOrDef, "object" == typeof def && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), 
                def.keyword = keyword); else {
                    if ("object" != typeof kwdOrDef || void 0 !== def) throw new Error("invalid addKeywords parameters");
                    if (keyword = (def = kwdOrDef).keyword, Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
                }
                if (checkKeyword.call(this, keyword, def), !def) return (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd)), 
                this;
                keywordMetaschema.call(this, def);
                const definition = {
                    ...def,
                    type: (0, dataType_1.getJSONTypes)(def.type),
                    schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
                };
                return (0, util_1.eachItem)(keyword, 0 === definition.type.length ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t))), 
                this;
            }
            getKeyword(keyword) {
                const rule = this.RULES.all[keyword];
                return "object" == typeof rule ? rule.definition : !!rule;
            }
            removeKeyword(keyword) {
                const {RULES} = this;
                delete RULES.keywords[keyword], delete RULES.all[keyword];
                for (const group of RULES.rules) {
                    const i = group.rules.findIndex(rule => rule.keyword === keyword);
                    i >= 0 && group.rules.splice(i, 1);
                }
                return this;
            }
            addFormat(name, format) {
                return "string" == typeof format && (format = new RegExp(format)), this.formats[name] = format, 
                this;
            }
            errorsText(errors = this.errors, {separator = ", ", dataVar = "data"} = {}) {
                return errors && 0 !== errors.length ? errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg) : "No errors";
            }
            $dataMetaSchema(metaSchema, keywordsJsonPointers) {
                const rules = this.RULES.all;
                metaSchema = JSON.parse(JSON.stringify(metaSchema));
                for (const jsonPointer of keywordsJsonPointers) {
                    const segments = jsonPointer.split("/").slice(1);
                    let keywords = metaSchema;
                    for (const seg of segments) keywords = keywords[seg];
                    for (const key in rules) {
                        const rule = rules[key];
                        if ("object" != typeof rule) continue;
                        const {$data} = rule.definition, schema = keywords[key];
                        $data && schema && (keywords[key] = schemaOrData(schema));
                    }
                }
                return metaSchema;
            }
            _removeAllSchemas(schemas, regex) {
                for (const keyRef in schemas) {
                    const sch = schemas[keyRef];
                    regex && !regex.test(keyRef) || ("string" == typeof sch ? delete schemas[keyRef] : sch && !sch.meta && (this._cache.delete(sch.schema), 
                    delete schemas[keyRef]));
                }
            }
            _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
                let id;
                const {schemaId} = this.opts;
                if ("object" == typeof schema) id = schema[schemaId]; else {
                    if (this.opts.jtd) throw new Error("schema must be object");
                    if ("boolean" != typeof schema) throw new Error("schema must be object or boolean");
                }
                let sch = this._cache.get(schema);
                if (void 0 !== sch) return sch;
                baseId = (0, resolve_1.normalizeId)(id || baseId);
                const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
                return sch = new compile_1.SchemaEnv({
                    schema,
                    schemaId,
                    meta,
                    baseId,
                    localRefs
                }), this._cache.set(sch.schema, sch), addSchema && !baseId.startsWith("#") && (baseId && this._checkUnique(baseId), 
                this.refs[baseId] = sch), validateSchema && this.validateSchema(schema, !0), sch;
            }
            _checkUnique(id) {
                if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
            }
            _compileSchemaEnv(sch) {
                if (sch.meta ? this._compileMetaSchema(sch) : compile_1.compileSchema.call(this, sch), 
                !sch.validate) throw new Error("ajv implementation error");
                return sch.validate;
            }
            _compileMetaSchema(sch) {
                const currentOpts = this.opts;
                this.opts = this._metaOpts;
                try {
                    compile_1.compileSchema.call(this, sch);
                } finally {
                    this.opts = currentOpts;
                }
            }
        }
        function checkOptions(checkOpts, options, msg, log = "error") {
            for (const key in checkOpts) key in options && this.logger[log](`${msg}: option ${key}. ${checkOpts[key]}`);
        }
        function getSchEnv(keyRef) {
            return keyRef = (0, resolve_1.normalizeId)(keyRef), this.schemas[keyRef] || this.refs[keyRef];
        }
        function addInitialSchemas() {
            const optsSchemas = this.opts.schemas;
            if (optsSchemas) if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas); else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);
        }
        function addInitialFormats() {
            for (const name in this.opts.formats) {
                const format = this.opts.formats[name];
                format && this.addFormat(name, format);
            }
        }
        function addInitialKeywords(defs) {
            if (Array.isArray(defs)) this.addVocabulary(defs); else {
                this.logger.warn("keywords option as map is deprecated, pass array");
                for (const keyword in defs) {
                    const def = defs[keyword];
                    def.keyword || (def.keyword = keyword), this.addKeyword(def);
                }
            }
        }
        function getMetaSchemaOptions() {
            const metaOpts = {
                ...this.opts
            };
            for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];
            return metaOpts;
        }
        exports.default = Ajv, Ajv.ValidationError = validation_error_1.default, Ajv.MissingRefError = ref_error_1.default;
        const noLogs = {
            log() {},
            warn() {},
            error() {}
        }, KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
        function checkKeyword(keyword, def) {
            const {RULES} = this;
            if ((0, util_1.eachItem)(keyword, kwd => {
                if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
                if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
            }), def && def.$data && !("code" in def) && !("validate" in def)) throw new Error('$data keyword must have "code" or "validate" function');
        }
        function addRule(keyword, definition, dataType) {
            var _a;
            const post = null == definition ? void 0 : definition.post;
            if (dataType && post) throw new Error('keyword with "post" flag cannot have "type"');
            const {RULES} = this;
            let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType);
            if (ruleGroup || (ruleGroup = {
                type: dataType,
                rules: []
            }, RULES.rules.push(ruleGroup)), RULES.keywords[keyword] = !0, !definition) return;
            const rule = {
                keyword,
                definition: {
                    ...definition,
                    type: (0, dataType_1.getJSONTypes)(definition.type),
                    schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
                }
            };
            definition.before ? addBeforeRule.call(this, ruleGroup, rule, definition.before) : ruleGroup.rules.push(rule), 
            RULES.all[keyword] = rule, null === (_a = definition.implements) || void 0 === _a || _a.forEach(kwd => this.addKeyword(kwd));
        }
        function addBeforeRule(ruleGroup, rule, before) {
            const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);
            i >= 0 ? ruleGroup.rules.splice(i, 0, rule) : (ruleGroup.rules.push(rule), this.logger.warn(`rule ${before} is not defined`));
        }
        function keywordMetaschema(def) {
            let {metaSchema} = def;
            void 0 !== metaSchema && (def.$data && this.opts.$data && (metaSchema = schemaOrData(metaSchema)), 
            def.validateSchema = this.compile(metaSchema, !0));
        }
        const $dataRef = {
            $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        };
        function schemaOrData(schema) {
            return {
                anyOf: [ schema, $dataRef ]
            };
        }
    },
    16561: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const equal = __webpack_require__(60165);
        equal.code = 'require("ajv/dist/runtime/equal").default', exports.default = equal;
    },
    17560: function(__unused_webpack_module, exports) {
        "use strict";
        function ucs2length(str) {
            const len = str.length;
            let value, length = 0, pos = 0;
            for (;pos < len; ) length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), 
            56320 == (64512 & value) && pos++);
            return length;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = ucs2length, ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
    },
    90010: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const uri = __webpack_require__(49223);
        uri.code = 'require("ajv/dist/runtime/uri").default', exports.default = uri;
    },
    76698: function(__unused_webpack_module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        class ValidationError extends Error {
            constructor(errors) {
                super("validation failed"), this.errors = errors, this.ajv = this.validation = !0;
            }
        }
        exports.default = ValidationError;
    },
    88170: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateAdditionalItems = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), def = {
            keyword: "additionalItems",
            type: "array",
            schemaType: [ "boolean", "object" ],
            before: "uniqueItems",
            error: {
                message: ({params: {len}}) => codegen_1.str`must NOT have more than ${len} items`,
                params: ({params: {len}}) => codegen_1._`{limit: ${len}}`
            },
            code(cxt) {
                const {parentSchema, it} = cxt, {items} = parentSchema;
                Array.isArray(items) ? validateAdditionalItems(cxt, items) : (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            }
        };
        function validateAdditionalItems(cxt, items) {
            const {gen, schema, data, keyword, it} = cxt;
            it.items = !0;
            const len = gen.const("len", codegen_1._`${data}.length`);
            if (!1 === schema) cxt.setParams({
                len: items.length
            }), cxt.pass(codegen_1._`${len} <= ${items.length}`); else if ("object" == typeof schema && !(0, 
            util_1.alwaysValidSchema)(it, schema)) {
                const valid = gen.var("valid", codegen_1._`${len} <= ${items.length}`);
                gen.if((0, codegen_1.not)(valid), () => function(valid) {
                    gen.forRange("i", items.length, len, i => {
                        cxt.subschema({
                            keyword,
                            dataProp: i,
                            dataPropType: util_1.Type.Num
                        }, valid), it.allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break());
                    });
                }(valid)), cxt.ok(valid);
            }
        }
        exports.validateAdditionalItems = validateAdditionalItems, exports.default = def;
    },
    13929: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const code_1 = __webpack_require__(52102), codegen_1 = __webpack_require__(87948), names_1 = __webpack_require__(82257), util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "additionalProperties",
            type: [ "object" ],
            schemaType: [ "boolean", "object" ],
            allowUndefined: !0,
            trackErrors: !0,
            error: {
                message: "must NOT have additional properties",
                params: ({params}) => codegen_1._`{additionalProperty: ${params.additionalProperty}}`
            },
            code(cxt) {
                const {gen, schema, parentSchema, data, errsCount, it} = cxt;
                if (!errsCount) throw new Error("ajv implementation error");
                const {allErrors, opts} = it;
                if (it.props = !0, "all" !== opts.removeAdditional && (0, util_1.alwaysValidSchema)(it, schema)) return;
                const props = (0, code_1.allSchemaProperties)(parentSchema.properties), patProps = (0, 
                code_1.allSchemaProperties)(parentSchema.patternProperties);
                function deleteAdditional(key) {
                    gen.code(codegen_1._`delete ${data}[${key}]`);
                }
                function additionalPropertyCode(key) {
                    if ("all" === opts.removeAdditional || opts.removeAdditional && !1 === schema) deleteAdditional(key); else {
                        if (!1 === schema) return cxt.setParams({
                            additionalProperty: key
                        }), cxt.error(), void (allErrors || gen.break());
                        if ("object" == typeof schema && !(0, util_1.alwaysValidSchema)(it, schema)) {
                            const valid = gen.name("valid");
                            "failing" === opts.removeAdditional ? (applyAdditionalSchema(key, valid, !1), gen.if((0, 
                            codegen_1.not)(valid), () => {
                                cxt.reset(), deleteAdditional(key);
                            })) : (applyAdditionalSchema(key, valid), allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break()));
                        }
                    }
                }
                function applyAdditionalSchema(key, valid, errors) {
                    const subschema = {
                        keyword: "additionalProperties",
                        dataProp: key,
                        dataPropType: util_1.Type.Str
                    };
                    !1 === errors && Object.assign(subschema, {
                        compositeRule: !0,
                        createErrors: !1,
                        allErrors: !1
                    }), cxt.subschema(subschema, valid);
                }
                gen.forIn("key", data, key => {
                    props.length || patProps.length ? gen.if(function(key) {
                        let definedProp;
                        if (props.length > 8) {
                            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
                            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
                        } else definedProp = props.length ? (0, codegen_1.or)(...props.map(p => codegen_1._`${key} === ${p}`)) : codegen_1.nil;
                        return patProps.length && (definedProp = (0, codegen_1.or)(definedProp, ...patProps.map(p => codegen_1._`${(0, 
                        code_1.usePattern)(cxt, p)}.test(${key})`))), (0, codegen_1.not)(definedProp);
                    }(key), () => additionalPropertyCode(key)) : additionalPropertyCode(key);
                }), cxt.ok(codegen_1._`${errsCount} === ${names_1.default.errors}`);
            }
        };
    },
    52028: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "allOf",
            schemaType: "array",
            code(cxt) {
                const {gen, schema, it} = cxt;
                if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                const valid = gen.name("valid");
                schema.forEach((sch, i) => {
                    if ((0, util_1.alwaysValidSchema)(it, sch)) return;
                    const schCxt = cxt.subschema({
                        keyword: "allOf",
                        schemaProp: i
                    }, valid);
                    cxt.ok(valid), cxt.mergeEvaluated(schCxt);
                });
            }
        };
    },
    54215: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const code_1 = __webpack_require__(52102);
        exports.default = {
            keyword: "anyOf",
            schemaType: "array",
            trackErrors: !0,
            code: code_1.validateUnion,
            error: {
                message: "must match a schema in anyOf"
            }
        };
    },
    41295: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "contains",
            type: "array",
            schemaType: [ "object", "boolean" ],
            before: "uniqueItems",
            trackErrors: !0,
            error: {
                message: ({params: {min, max}}) => void 0 === max ? codegen_1.str`must contain at least ${min} valid item(s)` : codegen_1.str`must contain at least ${min} and no more than ${max} valid item(s)`,
                params: ({params: {min, max}}) => void 0 === max ? codegen_1._`{minContains: ${min}}` : codegen_1._`{minContains: ${min}, maxContains: ${max}}`
            },
            code(cxt) {
                const {gen, schema, parentSchema, data, it} = cxt;
                let min, max;
                const {minContains, maxContains} = parentSchema;
                it.opts.next ? (min = void 0 === minContains ? 1 : minContains, max = maxContains) : min = 1;
                const len = gen.const("len", codegen_1._`${data}.length`);
                if (cxt.setParams({
                    min,
                    max
                }), void 0 === max && 0 === min) return void (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
                if (void 0 !== max && min > max) return (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid'), 
                void cxt.fail();
                if ((0, util_1.alwaysValidSchema)(it, schema)) {
                    let cond = codegen_1._`${len} >= ${min}`;
                    return void 0 !== max && (cond = codegen_1._`${cond} && ${len} <= ${max}`), void cxt.pass(cond);
                }
                it.items = !0;
                const valid = gen.name("valid");
                function validateItemsWithCount() {
                    const schValid = gen.name("_valid"), count = gen.let("count", 0);
                    validateItems(schValid, () => gen.if(schValid, () => function(count) {
                        gen.code(codegen_1._`${count}++`), void 0 === max ? gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, !0).break()) : (gen.if(codegen_1._`${count} > ${max}`, () => gen.assign(valid, !1).break()), 
                        1 === min ? gen.assign(valid, !0) : gen.if(codegen_1._`${count} >= ${min}`, () => gen.assign(valid, !0)));
                    }(count)));
                }
                function validateItems(_valid, block) {
                    gen.forRange("i", 0, len, i => {
                        cxt.subschema({
                            keyword: "contains",
                            dataProp: i,
                            dataPropType: util_1.Type.Num,
                            compositeRule: !0
                        }, _valid), block();
                    });
                }
                void 0 === max && 1 === min ? validateItems(valid, () => gen.if(valid, () => gen.break())) : 0 === min ? (gen.let(valid, !0), 
                void 0 !== max && gen.if(codegen_1._`${data}.length > 0`, validateItemsWithCount)) : (gen.let(valid, !1), 
                validateItemsWithCount()), cxt.result(valid, () => cxt.reset());
            }
        };
    },
    62529: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), code_1 = __webpack_require__(52102);
        exports.error = {
            message: ({params: {property, depsCount, deps}}) => codegen_1.str`must have ${1 === depsCount ? "property" : "properties"} ${deps} when property ${property} is present`,
            params: ({params: {property, depsCount, deps, missingProperty}}) => codegen_1._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        };
        const def = {
            keyword: "dependencies",
            type: "object",
            schemaType: "object",
            error: exports.error,
            code(cxt) {
                const [propDeps, schDeps] = function({schema}) {
                    const propertyDeps = {}, schemaDeps = {};
                    for (const key in schema) "__proto__" !== key && ((Array.isArray(schema[key]) ? propertyDeps : schemaDeps)[key] = schema[key]);
                    return [ propertyDeps, schemaDeps ];
                }(cxt);
                validatePropertyDeps(cxt, propDeps), validateSchemaDeps(cxt, schDeps);
            }
        };
        function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
            const {gen, data, it} = cxt;
            if (0 === Object.keys(propertyDeps).length) return;
            const missing = gen.let("missing");
            for (const prop in propertyDeps) {
                const deps = propertyDeps[prop];
                if (0 === deps.length) continue;
                const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
                cxt.setParams({
                    property: prop,
                    depsCount: deps.length,
                    deps: deps.join(", ")
                }), it.allErrors ? gen.if(hasProperty, () => {
                    for (const depProp of deps) (0, code_1.checkReportMissingProp)(cxt, depProp);
                }) : (gen.if(codegen_1._`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`), 
                (0, code_1.reportMissingProp)(cxt, missing), gen.else());
            }
        }
        function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
            const {gen, data, keyword, it} = cxt, valid = gen.name("valid");
            for (const prop in schemaDeps) (0, util_1.alwaysValidSchema)(it, schemaDeps[prop]) || (gen.if((0, 
            code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
                const schCxt = cxt.subschema({
                    keyword,
                    schemaProp: prop
                }, valid);
                cxt.mergeValidEvaluated(schCxt, valid);
            }, () => gen.var(valid, !0)), cxt.ok(valid));
        }
        exports.validatePropertyDeps = validatePropertyDeps, exports.validateSchemaDeps = validateSchemaDeps, 
        exports.default = def;
    },
    84594: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        function hasSchema(it, keyword) {
            const schema = it.schema[keyword];
            return void 0 !== schema && !(0, util_1.alwaysValidSchema)(it, schema);
        }
        exports.default = {
            keyword: "if",
            schemaType: [ "object", "boolean" ],
            trackErrors: !0,
            error: {
                message: ({params}) => codegen_1.str`must match "${params.ifClause}" schema`,
                params: ({params}) => codegen_1._`{failingKeyword: ${params.ifClause}}`
            },
            code(cxt) {
                const {gen, parentSchema, it} = cxt;
                void 0 === parentSchema.then && void 0 === parentSchema.else && (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
                const hasThen = hasSchema(it, "then"), hasElse = hasSchema(it, "else");
                if (!hasThen && !hasElse) return;
                const valid = gen.let("valid", !0), schValid = gen.name("_valid");
                if (function() {
                    const schCxt = cxt.subschema({
                        keyword: "if",
                        compositeRule: !0,
                        createErrors: !1,
                        allErrors: !1
                    }, schValid);
                    cxt.mergeEvaluated(schCxt);
                }(), cxt.reset(), hasThen && hasElse) {
                    const ifClause = gen.let("ifClause");
                    cxt.setParams({
                        ifClause
                    }), gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
                } else hasThen ? gen.if(schValid, validateClause("then")) : gen.if((0, codegen_1.not)(schValid), validateClause("else"));
                function validateClause(keyword, ifClause) {
                    return () => {
                        const schCxt = cxt.subschema({
                            keyword
                        }, schValid);
                        gen.assign(valid, schValid), cxt.mergeValidEvaluated(schCxt, valid), ifClause ? gen.assign(ifClause, codegen_1._`${keyword}`) : cxt.setParams({
                            ifClause: keyword
                        });
                    };
                }
                cxt.pass(valid, () => cxt.error(!0));
            }
        };
    },
    20557: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const additionalItems_1 = __webpack_require__(88170), prefixItems_1 = __webpack_require__(67057), items_1 = __webpack_require__(80021), items2020_1 = __webpack_require__(88375), contains_1 = __webpack_require__(41295), dependencies_1 = __webpack_require__(62529), propertyNames_1 = __webpack_require__(49710), additionalProperties_1 = __webpack_require__(13929), properties_1 = __webpack_require__(88694), patternProperties_1 = __webpack_require__(26003), not_1 = __webpack_require__(54004), anyOf_1 = __webpack_require__(54215), oneOf_1 = __webpack_require__(66411), allOf_1 = __webpack_require__(52028), if_1 = __webpack_require__(84594), thenElse_1 = __webpack_require__(58863);
        exports.default = function(draft2020 = !1) {
            const applicator = [ not_1.default, anyOf_1.default, oneOf_1.default, allOf_1.default, if_1.default, thenElse_1.default, propertyNames_1.default, additionalProperties_1.default, dependencies_1.default, properties_1.default, patternProperties_1.default ];
            return draft2020 ? applicator.push(prefixItems_1.default, items2020_1.default) : applicator.push(additionalItems_1.default, items_1.default), 
            applicator.push(contains_1.default), applicator;
        };
    },
    80021: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateTuple = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), code_1 = __webpack_require__(52102), def = {
            keyword: "items",
            type: "array",
            schemaType: [ "object", "array", "boolean" ],
            before: "uniqueItems",
            code(cxt) {
                const {schema, it} = cxt;
                if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
                it.items = !0, (0, util_1.alwaysValidSchema)(it, schema) || cxt.ok((0, code_1.validateArray)(cxt));
            }
        };
        function validateTuple(cxt, extraItems, schArr = cxt.schema) {
            const {gen, parentSchema, data, keyword, it} = cxt;
            !function(sch) {
                const {opts, errSchemaPath} = it, l = schArr.length;
                opts.strictTuples && (l !== sch.minItems || l !== sch.maxItems && !1 !== sch[extraItems]) && (0, 
                util_1.checkStrictMode)(it, `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`, opts.strictTuples);
            }(parentSchema), it.opts.unevaluated && schArr.length && !0 !== it.items && (it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items));
            const valid = gen.name("valid"), len = gen.const("len", codegen_1._`${data}.length`);
            schArr.forEach((sch, i) => {
                (0, util_1.alwaysValidSchema)(it, sch) || (gen.if(codegen_1._`${len} > ${i}`, () => cxt.subschema({
                    keyword,
                    schemaProp: i,
                    dataProp: i
                }, valid)), cxt.ok(valid));
            });
        }
        exports.validateTuple = validateTuple, exports.default = def;
    },
    88375: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), code_1 = __webpack_require__(52102), additionalItems_1 = __webpack_require__(88170);
        exports.default = {
            keyword: "items",
            type: "array",
            schemaType: [ "object", "boolean" ],
            before: "uniqueItems",
            error: {
                message: ({params: {len}}) => codegen_1.str`must NOT have more than ${len} items`,
                params: ({params: {len}}) => codegen_1._`{limit: ${len}}`
            },
            code(cxt) {
                const {schema, parentSchema, it} = cxt, {prefixItems} = parentSchema;
                it.items = !0, (0, util_1.alwaysValidSchema)(it, schema) || (prefixItems ? (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems) : cxt.ok((0, 
                code_1.validateArray)(cxt)));
            }
        };
    },
    54004: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "not",
            schemaType: [ "object", "boolean" ],
            trackErrors: !0,
            code(cxt) {
                const {gen, schema, it} = cxt;
                if ((0, util_1.alwaysValidSchema)(it, schema)) return void cxt.fail();
                const valid = gen.name("valid");
                cxt.subschema({
                    keyword: "not",
                    compositeRule: !0,
                    createErrors: !1,
                    allErrors: !1
                }, valid), cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
            },
            error: {
                message: "must NOT be valid"
            }
        };
    },
    66411: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "oneOf",
            schemaType: "array",
            trackErrors: !0,
            error: {
                message: "must match exactly one schema in oneOf",
                params: ({params}) => codegen_1._`{passingSchemas: ${params.passing}}`
            },
            code(cxt) {
                const {gen, schema, parentSchema, it} = cxt;
                if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                if (it.opts.discriminator && parentSchema.discriminator) return;
                const schArr = schema, valid = gen.let("valid", !1), passing = gen.let("passing", null), schValid = gen.name("_valid");
                cxt.setParams({
                    passing
                }), gen.block(function() {
                    schArr.forEach((sch, i) => {
                        let schCxt;
                        (0, util_1.alwaysValidSchema)(it, sch) ? gen.var(schValid, !0) : schCxt = cxt.subschema({
                            keyword: "oneOf",
                            schemaProp: i,
                            compositeRule: !0
                        }, schValid), i > 0 && gen.if(codegen_1._`${schValid} && ${valid}`).assign(valid, !1).assign(passing, codegen_1._`[${passing}, ${i}]`).else(), 
                        gen.if(schValid, () => {
                            gen.assign(valid, !0), gen.assign(passing, i), schCxt && cxt.mergeEvaluated(schCxt, codegen_1.Name);
                        });
                    });
                }), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
            }
        };
    },
    26003: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const code_1 = __webpack_require__(52102), codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), util_2 = __webpack_require__(36128);
        exports.default = {
            keyword: "patternProperties",
            type: "object",
            schemaType: "object",
            code(cxt) {
                const {gen, schema, data, parentSchema, it} = cxt, {opts} = it, patterns = (0, code_1.allSchemaProperties)(schema), alwaysValidPatterns = patterns.filter(p => (0, 
                util_1.alwaysValidSchema)(it, schema[p]));
                if (0 === patterns.length || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || !0 === it.props)) return;
                const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties, valid = gen.name("valid");
                !0 === it.props || it.props instanceof codegen_1.Name || (it.props = (0, util_2.evaluatedPropsToName)(gen, it.props));
                const {props} = it;
                function checkMatchingProperties(pat) {
                    for (const prop in checkProperties) new RegExp(pat).test(prop) && (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
                function validateProperties(pat) {
                    gen.forIn("key", data, key => {
                        gen.if(codegen_1._`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                            const alwaysValid = alwaysValidPatterns.includes(pat);
                            alwaysValid || cxt.subschema({
                                keyword: "patternProperties",
                                schemaProp: pat,
                                dataProp: key,
                                dataPropType: util_2.Type.Str
                            }, valid), it.opts.unevaluated && !0 !== props ? gen.assign(codegen_1._`${props}[${key}]`, !0) : alwaysValid || it.allErrors || gen.if((0, 
                            codegen_1.not)(valid), () => gen.break());
                        });
                    });
                }
                !function() {
                    for (const pat of patterns) checkProperties && checkMatchingProperties(pat), it.allErrors ? validateProperties(pat) : (gen.var(valid, !0), 
                    validateProperties(pat), gen.if(valid));
                }();
            }
        };
    },
    67057: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const items_1 = __webpack_require__(80021);
        exports.default = {
            keyword: "prefixItems",
            type: "array",
            schemaType: [ "array" ],
            before: "uniqueItems",
            code: cxt => (0, items_1.validateTuple)(cxt, "items")
        };
    },
    88694: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const validate_1 = __webpack_require__(44340), code_1 = __webpack_require__(52102), util_1 = __webpack_require__(36128), additionalProperties_1 = __webpack_require__(13929);
        exports.default = {
            keyword: "properties",
            type: "object",
            schemaType: "object",
            code(cxt) {
                const {gen, schema, parentSchema, data, it} = cxt;
                "all" === it.opts.removeAdditional && void 0 === parentSchema.additionalProperties && additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
                const allProps = (0, code_1.allSchemaProperties)(schema);
                for (const prop of allProps) it.definedProperties.add(prop);
                it.opts.unevaluated && allProps.length && !0 !== it.props && (it.props = util_1.mergeEvaluated.props(gen, (0, 
                util_1.toHash)(allProps), it.props));
                const properties = allProps.filter(p => !(0, util_1.alwaysValidSchema)(it, schema[p]));
                if (0 === properties.length) return;
                const valid = gen.name("valid");
                for (const prop of properties) hasDefault(prop) ? applyPropertySchema(prop) : (gen.if((0, 
                code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)), applyPropertySchema(prop), 
                it.allErrors || gen.else().var(valid, !0), gen.endIf()), cxt.it.definedProperties.add(prop), 
                cxt.ok(valid);
                function hasDefault(prop) {
                    return it.opts.useDefaults && !it.compositeRule && void 0 !== schema[prop].default;
                }
                function applyPropertySchema(prop) {
                    cxt.subschema({
                        keyword: "properties",
                        schemaProp: prop,
                        dataProp: prop
                    }, valid);
                }
            }
        };
    },
    49710: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "propertyNames",
            type: "object",
            schemaType: [ "object", "boolean" ],
            error: {
                message: "property name must be valid",
                params: ({params}) => codegen_1._`{propertyName: ${params.propertyName}}`
            },
            code(cxt) {
                const {gen, schema, data, it} = cxt;
                if ((0, util_1.alwaysValidSchema)(it, schema)) return;
                const valid = gen.name("valid");
                gen.forIn("key", data, key => {
                    cxt.setParams({
                        propertyName: key
                    }), cxt.subschema({
                        keyword: "propertyNames",
                        data: key,
                        dataTypes: [ "string" ],
                        propertyName: key,
                        compositeRule: !0
                    }, valid), gen.if((0, codegen_1.not)(valid), () => {
                        cxt.error(!0), it.allErrors || gen.break();
                    });
                }), cxt.ok(valid);
            }
        };
    },
    58863: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: [ "then", "else" ],
            schemaType: [ "object", "boolean" ],
            code({keyword, parentSchema, it}) {
                void 0 === parentSchema.if && (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
            }
        };
    },
    52102: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), names_1 = __webpack_require__(82257), util_2 = __webpack_require__(36128);
        function hasPropFunc(gen) {
            return gen.scopeValue("func", {
                ref: Object.prototype.hasOwnProperty,
                code: codegen_1._`Object.prototype.hasOwnProperty`
            });
        }
        function isOwnProperty(gen, data, property) {
            return codegen_1._`${hasPropFunc(gen)}.call(${data}, ${property})`;
        }
        function noPropertyInData(gen, data, property, ownProperties) {
            const cond = codegen_1._`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
            return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
        }
        function allSchemaProperties(schemaMap) {
            return schemaMap ? Object.keys(schemaMap).filter(p => "__proto__" !== p) : [];
        }
        exports.checkReportMissingProp = function(cxt, prop) {
            const {gen, data, it} = cxt;
            gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
                cxt.setParams({
                    missingProperty: codegen_1._`${prop}`
                }, !0), cxt.error();
            });
        }, exports.checkMissingProp = function({gen, data, it: {opts}}, properties, missing) {
            return (0, codegen_1.or)(...properties.map(prop => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), codegen_1._`${missing} = ${prop}`)));
        }, exports.reportMissingProp = function(cxt, missing) {
            cxt.setParams({
                missingProperty: missing
            }, !0), cxt.error();
        }, exports.hasPropFunc = hasPropFunc, exports.isOwnProperty = isOwnProperty, exports.propertyInData = function(gen, data, property, ownProperties) {
            const cond = codegen_1._`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
            return ownProperties ? codegen_1._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
        }, exports.noPropertyInData = noPropertyInData, exports.allSchemaProperties = allSchemaProperties, 
        exports.schemaProperties = function(it, schemaMap) {
            return allSchemaProperties(schemaMap).filter(p => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
        }, exports.callValidateCode = function({schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}, func, context, passSchema) {
            const dataAndSchema = passSchema ? codegen_1._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data, valCxt = [ [ names_1.default.instancePath, (0, 
            codegen_1.strConcat)(names_1.default.instancePath, errorPath) ], [ names_1.default.parentData, it.parentData ], [ names_1.default.parentDataProperty, it.parentDataProperty ], [ names_1.default.rootData, names_1.default.rootData ] ];
            it.opts.dynamicRef && valCxt.push([ names_1.default.dynamicAnchors, names_1.default.dynamicAnchors ]);
            const args = codegen_1._`${dataAndSchema}, ${gen.object(...valCxt)}`;
            return context !== codegen_1.nil ? codegen_1._`${func}.call(${context}, ${args})` : codegen_1._`${func}(${args})`;
        };
        const newRegExp = codegen_1._`new RegExp`;
        exports.usePattern = function({gen, it: {opts}}, pattern) {
            const u = opts.unicodeRegExp ? "u" : "", {regExp} = opts.code, rx = regExp(pattern, u);
            return gen.scopeValue("pattern", {
                key: rx.toString(),
                ref: rx,
                code: codegen_1._`${"new RegExp" === regExp.code ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
            });
        }, exports.validateArray = function(cxt) {
            const {gen, data, keyword, it} = cxt, valid = gen.name("valid");
            if (it.allErrors) {
                const validArr = gen.let("valid", !0);
                return validateItems(() => gen.assign(validArr, !1)), validArr;
            }
            return gen.var(valid, !0), validateItems(() => gen.break()), valid;
            function validateItems(notValid) {
                const len = gen.const("len", codegen_1._`${data}.length`);
                gen.forRange("i", 0, len, i => {
                    cxt.subschema({
                        keyword,
                        dataProp: i,
                        dataPropType: util_1.Type.Num
                    }, valid), gen.if((0, codegen_1.not)(valid), notValid);
                });
            }
        }, exports.validateUnion = function(cxt) {
            const {gen, schema, keyword, it} = cxt;
            if (!Array.isArray(schema)) throw new Error("ajv implementation error");
            if (schema.some(sch => (0, util_1.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated) return;
            const valid = gen.let("valid", !1), schValid = gen.name("_valid");
            gen.block(() => schema.forEach((_sch, i) => {
                const schCxt = cxt.subschema({
                    keyword,
                    schemaProp: i,
                    compositeRule: !0
                }, schValid);
                gen.assign(valid, codegen_1._`${valid} || ${schValid}`), cxt.mergeValidEvaluated(schCxt, schValid) || gen.if((0, 
                codegen_1.not)(valid));
            })), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
        };
    },
    87837: function(__unused_webpack_module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = {
            keyword: "id",
            code() {
                throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
            }
        };
    },
    26552: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const id_1 = __webpack_require__(87837), ref_1 = __webpack_require__(48270);
        exports.default = [ "$schema", "$id", "$defs", "$vocabulary", {
            keyword: "$comment"
        }, "definitions", id_1.default, ref_1.default ];
    },
    48270: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.callRef = exports.getValidate = void 0;
        const ref_error_1 = __webpack_require__(54065), code_1 = __webpack_require__(52102), codegen_1 = __webpack_require__(87948), names_1 = __webpack_require__(82257), compile_1 = __webpack_require__(89831), util_1 = __webpack_require__(36128), def = {
            keyword: "$ref",
            schemaType: "string",
            code(cxt) {
                const {gen, schema: $ref, it} = cxt, {baseId, schemaEnv: env, validateName, opts, self} = it, {root} = env;
                if (("#" === $ref || "#/" === $ref) && baseId === root.baseId) return function() {
                    if (env === root) return callRef(cxt, validateName, env, env.$async);
                    const rootName = gen.scopeValue("root", {
                        ref: root
                    });
                    return callRef(cxt, codegen_1._`${rootName}.validate`, root, root.$async);
                }();
                const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
                if (void 0 === schOrEnv) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
                return schOrEnv instanceof compile_1.SchemaEnv ? function(sch) {
                    const v = getValidate(cxt, sch);
                    callRef(cxt, v, sch, sch.$async);
                }(schOrEnv) : function(sch) {
                    const schName = gen.scopeValue("schema", !0 === opts.code.source ? {
                        ref: sch,
                        code: (0, codegen_1.stringify)(sch)
                    } : {
                        ref: sch
                    }), valid = gen.name("valid"), schCxt = cxt.subschema({
                        schema: sch,
                        dataTypes: [],
                        schemaPath: codegen_1.nil,
                        topSchemaRef: schName,
                        errSchemaPath: $ref
                    }, valid);
                    cxt.mergeEvaluated(schCxt), cxt.ok(valid);
                }(schOrEnv);
            }
        };
        function getValidate(cxt, sch) {
            const {gen} = cxt;
            return sch.validate ? gen.scopeValue("validate", {
                ref: sch.validate
            }) : codegen_1._`${gen.scopeValue("wrapper", {
                ref: sch
            })}.validate`;
        }
        function callRef(cxt, v, sch, $async) {
            const {gen, it} = cxt, {allErrors, schemaEnv: env, opts} = it, passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
            function addErrorsFrom(source) {
                const errs = codegen_1._`${source}.errors`;
                gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`), 
                gen.assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);
            }
            function addEvaluatedFrom(source) {
                var _a;
                if (!it.opts.unevaluated) return;
                const schEvaluated = null === (_a = null == sch ? void 0 : sch.validate) || void 0 === _a ? void 0 : _a.evaluated;
                if (!0 !== it.props) if (schEvaluated && !schEvaluated.dynamicProps) void 0 !== schEvaluated.props && (it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props)); else {
                    const props = gen.var("props", codegen_1._`${source}.evaluated.props`);
                    it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
                }
                if (!0 !== it.items) if (schEvaluated && !schEvaluated.dynamicItems) void 0 !== schEvaluated.items && (it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items)); else {
                    const items = gen.var("items", codegen_1._`${source}.evaluated.items`);
                    it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
                }
            }
            $async ? function() {
                if (!env.$async) throw new Error("async schema referenced by sync schema");
                const valid = gen.let("valid");
                gen.try(() => {
                    gen.code(codegen_1._`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`), addEvaluatedFrom(v), 
                    allErrors || gen.assign(valid, !0);
                }, e => {
                    gen.if(codegen_1._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e)), 
                    addErrorsFrom(e), allErrors || gen.assign(valid, !1);
                }), cxt.ok(valid);
            }() : cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
        }
        exports.getValidate = getValidate, exports.callRef = callRef, exports.default = def;
    },
    57180: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), types_1 = __webpack_require__(81754), compile_1 = __webpack_require__(89831), util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "discriminator",
            type: "object",
            schemaType: "object",
            error: {
                message: ({params: {discrError, tagName}}) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
                params: ({params: {discrError, tag, tagName}}) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
            },
            code(cxt) {
                const {gen, data, schema, parentSchema, it} = cxt, {oneOf} = parentSchema;
                if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
                const tagName = schema.propertyName;
                if ("string" != typeof tagName) throw new Error("discriminator: requires propertyName");
                if (schema.mapping) throw new Error("discriminator: mapping is not supported");
                if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
                const valid = gen.let("valid", !1), tag = gen.const("tag", codegen_1._`${data}${(0, 
                codegen_1.getProperty)(tagName)}`);
                function applyTagSchema(schemaProp) {
                    const _valid = gen.name("valid"), schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp
                    }, _valid);
                    return cxt.mergeEvaluated(schCxt, codegen_1.Name), _valid;
                }
                gen.if(codegen_1._`typeof ${tag} == "string"`, () => function() {
                    const mapping = function() {
                        var _a;
                        const oneOfMapping = {}, topRequired = hasRequired(parentSchema);
                        let tagRequired = !0;
                        for (let i = 0; i < oneOf.length; i++) {
                            let sch = oneOf[i];
                            (null == sch ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES) && (sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, null == sch ? void 0 : sch.$ref), 
                            sch instanceof compile_1.SchemaEnv && (sch = sch.schema));
                            const propSch = null === (_a = null == sch ? void 0 : sch.properties) || void 0 === _a ? void 0 : _a[tagName];
                            if ("object" != typeof propSch) throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                            tagRequired = tagRequired && (topRequired || hasRequired(sch)), addMappings(propSch, i);
                        }
                        if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
                        return oneOfMapping;
                        function hasRequired({required}) {
                            return Array.isArray(required) && required.includes(tagName);
                        }
                        function addMappings(sch, i) {
                            if (sch.const) addMapping(sch.const, i); else {
                                if (!sch.enum) throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                                for (const tagValue of sch.enum) addMapping(tagValue, i);
                            }
                        }
                        function addMapping(tagValue, i) {
                            if ("string" != typeof tagValue || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                            oneOfMapping[tagValue] = i;
                        }
                    }();
                    gen.if(!1);
                    for (const tagValue in mapping) gen.elseIf(codegen_1._`${tag} === ${tagValue}`), 
                    gen.assign(valid, applyTagSchema(mapping[tagValue]));
                    gen.else(), cxt.error(!1, {
                        discrError: types_1.DiscrError.Mapping,
                        tag,
                        tagName
                    }), gen.endIf();
                }(), () => cxt.error(!1, {
                    discrError: types_1.DiscrError.Tag,
                    tag,
                    tagName
                })), cxt.ok(valid);
            }
        };
    },
    81754: function(__unused_webpack_module, exports) {
        "use strict";
        var DiscrError;
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DiscrError = void 0, (DiscrError = exports.DiscrError || (exports.DiscrError = {})).Tag = "tag", 
        DiscrError.Mapping = "mapping";
    },
    49045: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const core_1 = __webpack_require__(26552), validation_1 = __webpack_require__(64730), applicator_1 = __webpack_require__(20557), format_1 = __webpack_require__(77233), metadata_1 = __webpack_require__(83669), draft7Vocabularies = [ core_1.default, validation_1.default, (0, 
        applicator_1.default)(), format_1.default, metadata_1.metadataVocabulary, metadata_1.contentVocabulary ];
        exports.default = draft7Vocabularies;
    },
    91388: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948);
        exports.default = {
            keyword: "format",
            type: [ "number", "string" ],
            schemaType: "string",
            $data: !0,
            error: {
                message: ({schemaCode}) => codegen_1.str`must match format "${schemaCode}"`,
                params: ({schemaCode}) => codegen_1._`{format: ${schemaCode}}`
            },
            code(cxt, ruleType) {
                const {gen, data, $data, schema, schemaCode, it} = cxt, {opts, errSchemaPath, schemaEnv, self} = it;
                opts.validateFormats && ($data ? function() {
                    const fmts = gen.scopeValue("formats", {
                        ref: self.formats,
                        code: opts.code.formats
                    }), fDef = gen.const("fDef", codegen_1._`${fmts}[${schemaCode}]`), fType = gen.let("fType"), format = gen.let("format");
                    gen.if(codegen_1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1._`${fDef}.type || "string"`).assign(format, codegen_1._`${fDef}.validate`), () => gen.assign(fType, codegen_1._`"string"`).assign(format, fDef)), 
                    cxt.fail$data((0, codegen_1.or)(!1 === opts.strictSchema ? codegen_1.nil : codegen_1._`${schemaCode} && !${format}`, function() {
                        const callFormat = schemaEnv.$async ? codegen_1._`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : codegen_1._`${format}(${data})`, validData = codegen_1._`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                        return codegen_1._`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
                    }()));
                }() : function() {
                    const formatDef = self.formats[schema];
                    if (!formatDef) return void function() {
                        if (!1 !== opts.strictSchema) throw new Error(unknownMsg());
                        function unknownMsg() {
                            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                        }
                        self.logger.warn(unknownMsg());
                    }();
                    if (!0 === formatDef) return;
                    const [fmtType, format, fmtRef] = function(fmtDef) {
                        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? codegen_1._`${opts.code.formats}${(0, 
                        codegen_1.getProperty)(schema)}` : void 0, fmt = gen.scopeValue("formats", {
                            key: schema,
                            ref: fmtDef,
                            code
                        });
                        return "object" != typeof fmtDef || fmtDef instanceof RegExp ? [ "string", fmtDef, fmt ] : [ fmtDef.type || "string", fmtDef.validate, codegen_1._`${fmt}.validate` ];
                    }(formatDef);
                    fmtType === ruleType && cxt.pass(function() {
                        if ("object" == typeof formatDef && !(formatDef instanceof RegExp) && formatDef.async) {
                            if (!schemaEnv.$async) throw new Error("async format in sync schema");
                            return codegen_1._`await ${fmtRef}(${data})`;
                        }
                        return "function" == typeof format ? codegen_1._`${fmtRef}(${data})` : codegen_1._`${fmtRef}.test(${data})`;
                    }());
                }());
            }
        };
    },
    77233: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const format_1 = __webpack_require__(91388);
        exports.default = [ format_1.default ];
    },
    83669: function(__unused_webpack_module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.contentVocabulary = exports.metadataVocabulary = void 0, exports.metadataVocabulary = [ "title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples" ], 
        exports.contentVocabulary = [ "contentMediaType", "contentEncoding", "contentSchema" ];
    },
    76808: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), equal_1 = __webpack_require__(16561);
        exports.default = {
            keyword: "const",
            $data: !0,
            error: {
                message: "must be equal to constant",
                params: ({schemaCode}) => codegen_1._`{allowedValue: ${schemaCode}}`
            },
            code(cxt) {
                const {gen, data, $data, schemaCode, schema} = cxt;
                $data || schema && "object" == typeof schema ? cxt.fail$data(codegen_1._`!${(0, 
                util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`) : cxt.fail(codegen_1._`${schema} !== ${data}`);
            }
        };
    },
    23072: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), equal_1 = __webpack_require__(16561);
        exports.default = {
            keyword: "enum",
            schemaType: "array",
            $data: !0,
            error: {
                message: "must be equal to one of the allowed values",
                params: ({schemaCode}) => codegen_1._`{allowedValues: ${schemaCode}}`
            },
            code(cxt) {
                const {gen, data, $data, schema, schemaCode, it} = cxt;
                if (!$data && 0 === schema.length) throw new Error("enum must have non-empty array");
                let eql;
                const getEql = () => null != eql ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
                let valid;
                if (schema.length >= it.opts.loopEnum || $data) valid = gen.let("valid"), cxt.block$data(valid, function() {
                    gen.assign(valid, !1), gen.forOf("v", schemaCode, v => gen.if(codegen_1._`${getEql()}(${data}, ${v})`, () => gen.assign(valid, !0).break()));
                }); else {
                    if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                    const vSchema = gen.const("vSchema", schemaCode);
                    valid = (0, codegen_1.or)(...schema.map((_x, i) => function(vSchema, i) {
                        const sch = schema[i];
                        return "object" == typeof sch && null !== sch ? codegen_1._`${getEql()}(${data}, ${vSchema}[${i}])` : codegen_1._`${data} === ${sch}`;
                    }(vSchema, i)));
                }
                cxt.pass(valid);
            }
        };
    },
    64730: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const limitNumber_1 = __webpack_require__(6605), multipleOf_1 = __webpack_require__(7916), limitLength_1 = __webpack_require__(39623), pattern_1 = __webpack_require__(81745), limitProperties_1 = __webpack_require__(5114), required_1 = __webpack_require__(36371), limitItems_1 = __webpack_require__(53359), uniqueItems_1 = __webpack_require__(94997), const_1 = __webpack_require__(76808), enum_1 = __webpack_require__(23072);
        exports.default = [ limitNumber_1.default, multipleOf_1.default, limitLength_1.default, pattern_1.default, limitProperties_1.default, required_1.default, limitItems_1.default, uniqueItems_1.default, {
            keyword: "type",
            schemaType: [ "string", "array" ]
        }, {
            keyword: "nullable",
            schemaType: "boolean"
        }, const_1.default, enum_1.default ];
    },
    53359: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948);
        exports.default = {
            keyword: [ "maxItems", "minItems" ],
            type: "array",
            schemaType: "number",
            $data: !0,
            error: {
                message: ({keyword, schemaCode}) => codegen_1.str`must NOT have ${"maxItems" === keyword ? "more" : "fewer"} than ${schemaCode} items`,
                params: ({schemaCode}) => codegen_1._`{limit: ${schemaCode}}`
            },
            code(cxt) {
                const {keyword, data, schemaCode} = cxt;
                cxt.fail$data(codegen_1._`${data}.length ${"maxItems" === keyword ? codegen_1.operators.GT : codegen_1.operators.LT} ${schemaCode}`);
            }
        };
    },
    39623: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), ucs2length_1 = __webpack_require__(17560);
        exports.default = {
            keyword: [ "maxLength", "minLength" ],
            type: "string",
            schemaType: "number",
            $data: !0,
            error: {
                message: ({keyword, schemaCode}) => codegen_1.str`must NOT have ${"maxLength" === keyword ? "more" : "fewer"} than ${schemaCode} characters`,
                params: ({schemaCode}) => codegen_1._`{limit: ${schemaCode}}`
            },
            code(cxt) {
                const {keyword, data, schemaCode, it} = cxt, op = "maxLength" === keyword ? codegen_1.operators.GT : codegen_1.operators.LT, len = !1 === it.opts.unicode ? codegen_1._`${data}.length` : codegen_1._`${(0, 
                util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
                cxt.fail$data(codegen_1._`${len} ${op} ${schemaCode}`);
            }
        };
    },
    6605: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948), ops = codegen_1.operators, KWDs = {
            maximum: {
                okStr: "<=",
                ok: ops.LTE,
                fail: ops.GT
            },
            minimum: {
                okStr: ">=",
                ok: ops.GTE,
                fail: ops.LT
            },
            exclusiveMaximum: {
                okStr: "<",
                ok: ops.LT,
                fail: ops.GTE
            },
            exclusiveMinimum: {
                okStr: ">",
                ok: ops.GT,
                fail: ops.LTE
            }
        }, error = {
            message: ({keyword, schemaCode}) => codegen_1.str`must be ${KWDs[keyword].okStr} ${schemaCode}`,
            params: ({keyword, schemaCode}) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
        }, def = {
            keyword: Object.keys(KWDs),
            type: "number",
            schemaType: "number",
            $data: !0,
            error,
            code(cxt) {
                const {keyword, data, schemaCode} = cxt;
                cxt.fail$data(codegen_1._`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
            }
        };
        exports.default = def;
    },
    5114: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948);
        exports.default = {
            keyword: [ "maxProperties", "minProperties" ],
            type: "object",
            schemaType: "number",
            $data: !0,
            error: {
                message: ({keyword, schemaCode}) => codegen_1.str`must NOT have ${"maxProperties" === keyword ? "more" : "fewer"} than ${schemaCode} properties`,
                params: ({schemaCode}) => codegen_1._`{limit: ${schemaCode}}`
            },
            code(cxt) {
                const {keyword, data, schemaCode} = cxt;
                cxt.fail$data(codegen_1._`Object.keys(${data}).length ${"maxProperties" === keyword ? codegen_1.operators.GT : codegen_1.operators.LT} ${schemaCode}`);
            }
        };
    },
    7916: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const codegen_1 = __webpack_require__(87948);
        exports.default = {
            keyword: "multipleOf",
            type: "number",
            schemaType: "number",
            $data: !0,
            error: {
                message: ({schemaCode}) => codegen_1.str`must be multiple of ${schemaCode}`,
                params: ({schemaCode}) => codegen_1._`{multipleOf: ${schemaCode}}`
            },
            code(cxt) {
                const {gen, data, schemaCode, it} = cxt, prec = it.opts.multipleOfPrecision, res = gen.let("res"), invalid = prec ? codegen_1._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1._`${res} !== parseInt(${res})`;
                cxt.fail$data(codegen_1._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
            }
        };
    },
    81745: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const code_1 = __webpack_require__(52102), codegen_1 = __webpack_require__(87948);
        exports.default = {
            keyword: "pattern",
            type: "string",
            schemaType: "string",
            $data: !0,
            error: {
                message: ({schemaCode}) => codegen_1.str`must match pattern "${schemaCode}"`,
                params: ({schemaCode}) => codegen_1._`{pattern: ${schemaCode}}`
            },
            code(cxt) {
                const {data, $data, schema, schemaCode, it} = cxt, regExp = $data ? codegen_1._`(new RegExp(${schemaCode}, ${it.opts.unicodeRegExp ? "u" : ""}))` : (0, 
                code_1.usePattern)(cxt, schema);
                cxt.fail$data(codegen_1._`!${regExp}.test(${data})`);
            }
        };
    },
    36371: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const code_1 = __webpack_require__(52102), codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128);
        exports.default = {
            keyword: "required",
            type: "object",
            schemaType: "array",
            $data: !0,
            error: {
                message: ({params: {missingProperty}}) => codegen_1.str`must have required property '${missingProperty}'`,
                params: ({params: {missingProperty}}) => codegen_1._`{missingProperty: ${missingProperty}}`
            },
            code(cxt) {
                const {gen, schema, schemaCode, data, $data, it} = cxt, {opts} = it;
                if (!$data && 0 === schema.length) return;
                const useLoop = schema.length >= opts.loopRequired;
                if (it.allErrors ? function() {
                    if (useLoop || $data) cxt.block$data(codegen_1.nil, loopAllRequired); else for (const prop of schema) (0, 
                    code_1.checkReportMissingProp)(cxt, prop);
                }() : function() {
                    const missing = gen.let("missing");
                    if (useLoop || $data) {
                        const valid = gen.let("valid", !0);
                        cxt.block$data(valid, () => function(missing, valid) {
                            cxt.setParams({
                                missingProperty: missing
                            }), gen.forOf(missing, schemaCode, () => {
                                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties)), 
                                gen.if((0, codegen_1.not)(valid), () => {
                                    cxt.error(), gen.break();
                                });
                            }, codegen_1.nil);
                        }(missing, valid)), cxt.ok(valid);
                    } else gen.if((0, code_1.checkMissingProp)(cxt, schema, missing)), (0, code_1.reportMissingProp)(cxt, missing), 
                    gen.else();
                }(), opts.strictRequired) {
                    const props = cxt.parentSchema.properties, {definedProperties} = cxt.it;
                    for (const requiredKey of schema) void 0 !== (null == props ? void 0 : props[requiredKey]) || definedProperties.has(requiredKey) || (0, 
                    util_1.checkStrictMode)(it, `required property "${requiredKey}" is not defined at "${it.schemaEnv.baseId + it.errSchemaPath}" (strictRequired)`, it.opts.strictRequired);
                }
                function loopAllRequired() {
                    gen.forOf("prop", schemaCode, prop => {
                        cxt.setParams({
                            missingProperty: prop
                        }), gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
                    });
                }
            }
        };
    },
    94997: function(__unused_webpack_module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        const dataType_1 = __webpack_require__(68095), codegen_1 = __webpack_require__(87948), util_1 = __webpack_require__(36128), equal_1 = __webpack_require__(16561);
        exports.default = {
            keyword: "uniqueItems",
            type: "array",
            schemaType: "boolean",
            $data: !0,
            error: {
                message: ({params: {i, j}}) => codegen_1.str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
                params: ({params: {i, j}}) => codegen_1._`{i: ${i}, j: ${j}}`
            },
            code(cxt) {
                const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt;
                if (!$data && !schema) return;
                const valid = gen.let("valid"), itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
                function loopN(i, j) {
                    const item = gen.name("item"), wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong), indices = gen.const("indices", codegen_1._`{}`);
                    gen.for(codegen_1._`;${i}--;`, () => {
                        gen.let(item, codegen_1._`${data}[${i}]`), gen.if(wrongType, codegen_1._`continue`), 
                        itemTypes.length > 1 && gen.if(codegen_1._`typeof ${item} == "string"`, codegen_1._`${item} += "_"`), 
                        gen.if(codegen_1._`typeof ${indices}[${item}] == "number"`, () => {
                            gen.assign(j, codegen_1._`${indices}[${item}]`), cxt.error(), gen.assign(valid, !1).break();
                        }).code(codegen_1._`${indices}[${item}] = ${i}`);
                    });
                }
                function loopN2(i, j) {
                    const eql = (0, util_1.useFunc)(gen, equal_1.default), outer = gen.name("outer");
                    gen.label(outer).for(codegen_1._`;${i}--;`, () => gen.for(codegen_1._`${j} = ${i}; ${j}--;`, () => gen.if(codegen_1._`${eql}(${data}[${i}], ${data}[${j}])`, () => {
                        cxt.error(), gen.assign(valid, !1).break(outer);
                    })));
                }
                cxt.block$data(valid, function() {
                    const i = gen.let("i", codegen_1._`${data}.length`), j = gen.let("j");
                    cxt.setParams({
                        i,
                        j
                    }), gen.assign(valid, !0), gen.if(codegen_1._`${i} > 1`, () => (itemTypes.length > 0 && !itemTypes.some(t => "object" === t || "array" === t) ? loopN : loopN2)(i, j));
                }, codegen_1._`${schemaCode} === false`), cxt.ok(valid);
            }
        };
    },
    60165: function(module) {
        "use strict";
        module.exports = function equal(a, b) {
            if (a === b) return !0;
            if (a && b && "object" == typeof a && "object" == typeof b) {
                if (a.constructor !== b.constructor) return !1;
                var length, i, keys;
                if (Array.isArray(a)) {
                    if ((length = a.length) != b.length) return !1;
                    for (i = length; 0 != i--; ) if (!equal(a[i], b[i])) return !1;
                    return !0;
                }
                if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
                if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
                if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
                if ((length = (keys = Object.keys(a)).length) !== Object.keys(b).length) return !1;
                for (i = length; 0 != i--; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
                for (i = length; 0 != i--; ) {
                    var key = keys[i];
                    if (!equal(a[key], b[key])) return !1;
                }
                return !0;
            }
            return a != a && b != b;
        };
    },
    36011: function(module) {
        "use strict";
        var traverse = module.exports = function(schema, opts, cb) {
            "function" == typeof opts && (cb = opts, opts = {}), _traverse(opts, "function" == typeof (cb = opts.cb || cb) ? cb : cb.pre || function() {}, cb.post || function() {}, schema, "", schema);
        };
        function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
            if (schema && "object" == typeof schema && !Array.isArray(schema)) {
                for (var key in pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex), 
                schema) {
                    var sch = schema[key];
                    if (Array.isArray(sch)) {
                        if (key in traverse.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
                    } else if (key in traverse.propsKeywords) {
                        if (sch && "object" == typeof sch) for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + prop.replace(/~/g, "~0").replace(/\//g, "~1"), rootSchema, jsonPtr, key, schema, prop);
                    } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
                }
                post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
            }
        }
        traverse.keywords = {
            additionalItems: !0,
            items: !0,
            contains: !0,
            additionalProperties: !0,
            propertyNames: !0,
            not: !0,
            if: !0,
            then: !0,
            else: !0
        }, traverse.arrayKeywords = {
            items: !0,
            allOf: !0,
            anyOf: !0,
            oneOf: !0
        }, traverse.propsKeywords = {
            $defs: !0,
            definitions: !0,
            properties: !0,
            patternProperties: !0,
            dependencies: !0
        }, traverse.skipKeywords = {
            default: !0,
            enum: !0,
            const: !0,
            required: !0,
            maximum: !0,
            minimum: !0,
            exclusiveMaximum: !0,
            exclusiveMinimum: !0,
            multipleOf: !0,
            maxLength: !0,
            minLength: !0,
            pattern: !0,
            format: !0,
            maxItems: !0,
            minItems: !0,
            uniqueItems: !0,
            maxProperties: !0,
            minProperties: !0
        };
    },
    49223: function(__unused_webpack_module, exports) {
        !function(exports) {
            "use strict";
            function merge() {
                for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) sets[_key] = arguments[_key];
                if (sets.length > 1) {
                    sets[0] = sets[0].slice(0, -1);
                    for (var xl = sets.length - 1, x = 1; x < xl; ++x) sets[x] = sets[x].slice(1, -1);
                    return sets[xl] = sets[xl].slice(1), sets.join("");
                }
                return sets[0];
            }
            function subexp(str) {
                return "(?:" + str + ")";
            }
            function typeOf(o) {
                return void 0 === o ? "undefined" : null === o ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
            }
            function toUpperCase(str) {
                return str.toUpperCase();
            }
            function buildExps(isIRI) {
                var HEXDIG$$ = merge("[0-9]", "[A-Fa-f]"), PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge("[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$), IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$ = merge("[A-Za-z]", "[0-9]", "[\\-\\.\\_\\~]", isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"), SCHEME$ = subexp("[A-Za-z]" + merge("[A-Za-z]", "[0-9]", "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET_RELAXED$ = (subexp(subexp("25[0-5]") + "|" + subexp("2[0-4][0-9]") + "|" + subexp("1[0-9][0-9]") + "|" + subexp("[1-9][0-9]") + "|[0-9]"), 
                subexp(subexp("25[0-5]") + "|" + subexp("2[0-4][0-9]") + "|" + subexp("1[0-9][0-9]") + "|" + subexp("0?[1-9][0-9]") + "|0?0?[0-9]")), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([ IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$ ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), IPV6ADDRZ_RELAXED$ = (subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), 
                subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$)), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp("[0-9]*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", QUERY$ = (subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), 
                subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*")), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?");
                return subexp(URI$ + "|" + RELATIVE$), subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), 
                subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")"), 
                subexp("\\?(" + QUERY$ + ")"), subexp("\\#(" + FRAGMENT$ + ")"), subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")"), 
                subexp("\\?(" + QUERY$ + ")"), subexp("\\#(" + FRAGMENT$ + ")"), subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")"), 
                subexp("\\?(" + QUERY$ + ")"), subexp("\\#(" + FRAGMENT$ + ")"), subexp("(" + USERINFO$ + ")@"), 
                subexp("\\:(" + PORT$ + ")"), {
                    NOT_SCHEME: new RegExp(merge("[^]", "[A-Za-z]", "[0-9]", "[\\+\\-\\.]"), "g"),
                    NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                    NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                    NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                    NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                    NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
                    NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
                    ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                    UNRESERVED: new RegExp(UNRESERVED$$, "g"),
                    OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
                    PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
                    IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
                    IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
                };
            }
            var URI_PROTOCOL = buildExps(!1), IRI_PROTOCOL = buildExps(!0), slicedToArray = function(arr, i) {
                if (Array.isArray(arr)) return arr;
                if (Symbol.iterator in Object(arr)) return function(arr, i) {
                    var _arr = [], _n = !0, _d = !1, _e = void 0;
                    try {
                        for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                        !i || _arr.length !== i); _n = !0) ;
                    } catch (err) {
                        _d = !0, _e = err;
                    } finally {
                        try {
                            !_n && _i.return && _i.return();
                        } finally {
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }(arr, i);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }, maxInt = 2147483647, regexPunycode = /^xn--/, regexNonASCII = /[^\0-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, floor = Math.floor, stringFromCharCode = String.fromCharCode;
            function error$1(type) {
                throw new RangeError(errors[type]);
            }
            function mapDomain(string, fn) {
                var parts = string.split("@"), result = "";
                return parts.length > 1 && (result = parts[0] + "@", string = parts[1]), result + function(array, fn) {
                    for (var result = [], length = array.length; length--; ) result[length] = fn(array[length]);
                    return result;
                }((string = string.replace(regexSeparators, ".")).split("."), fn).join(".");
            }
            function ucs2decode(string) {
                for (var output = [], counter = 0, length = string.length; counter < length; ) {
                    var value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                        var extra = string.charCodeAt(counter++);
                        56320 == (64512 & extra) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), 
                        counter--);
                    } else output.push(value);
                }
                return output;
            }
            var digitToBasic = function(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
            }, adapt = function(delta, numPoints, firstTime) {
                var k = 0;
                for (delta = firstTime ? floor(delta / 700) : delta >> 1, delta += floor(delta / numPoints); delta > 455; k += 36) delta = floor(delta / 35);
                return floor(k + 36 * delta / (delta + 38));
            }, decode = function(input) {
                var codePoint, output = [], inputLength = input.length, i = 0, n = 128, bias = 72, basic = input.lastIndexOf("-");
                basic < 0 && (basic = 0);
                for (var j = 0; j < basic; ++j) input.charCodeAt(j) >= 128 && error$1("not-basic"), 
                output.push(input.charCodeAt(j));
                for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                    for (var oldi = i, w = 1, k = 36; ;k += 36) {
                        index >= inputLength && error$1("invalid-input");
                        var digit = (codePoint = input.charCodeAt(index++)) - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : 36;
                        (digit >= 36 || digit > floor((maxInt - i) / w)) && error$1("overflow"), i += digit * w;
                        var t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                        if (digit < t) break;
                        var baseMinusT = 36 - t;
                        w > floor(maxInt / baseMinusT) && error$1("overflow"), w *= baseMinusT;
                    }
                    var out = output.length + 1;
                    bias = adapt(i - oldi, out, 0 == oldi), floor(i / out) > maxInt - n && error$1("overflow"), 
                    n += floor(i / out), i %= out, output.splice(i++, 0, n);
                }
                return String.fromCodePoint.apply(String, output);
            }, encode = function(input) {
                var output = [], inputLength = (input = ucs2decode(input)).length, n = 128, delta = 0, bias = 72, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
                try {
                    for (var _step, _iterator = input[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                        var _currentValue2 = _step.value;
                        _currentValue2 < 128 && output.push(stringFromCharCode(_currentValue2));
                    }
                } catch (err) {
                    _didIteratorError = !0, _iteratorError = err;
                } finally {
                    try {
                        !_iteratorNormalCompletion && _iterator.return && _iterator.return();
                    } finally {
                        if (_didIteratorError) throw _iteratorError;
                    }
                }
                var basicLength = output.length, handledCPCount = basicLength;
                for (basicLength && output.push("-"); handledCPCount < inputLength; ) {
                    var m = maxInt, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                    try {
                        for (var _step2, _iterator2 = input[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                            var currentValue = _step2.value;
                            currentValue >= n && currentValue < m && (m = currentValue);
                        }
                    } catch (err) {
                        _didIteratorError2 = !0, _iteratorError2 = err;
                    } finally {
                        try {
                            !_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return();
                        } finally {
                            if (_didIteratorError2) throw _iteratorError2;
                        }
                    }
                    var handledCPCountPlusOne = handledCPCount + 1;
                    m - n > floor((maxInt - delta) / handledCPCountPlusOne) && error$1("overflow"), 
                    delta += (m - n) * handledCPCountPlusOne, n = m;
                    var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
                    try {
                        for (var _step3, _iterator3 = input[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
                            var _currentValue = _step3.value;
                            if (_currentValue < n && ++delta > maxInt && error$1("overflow"), _currentValue == n) {
                                for (var q = delta, k = 36; ;k += 36) {
                                    var t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                                    if (q < t) break;
                                    var qMinusT = q - t, baseMinusT = 36 - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);
                                }
                                output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), 
                                delta = 0, ++handledCPCount;
                            }
                        }
                    } catch (err) {
                        _didIteratorError3 = !0, _iteratorError3 = err;
                    } finally {
                        try {
                            !_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return();
                        } finally {
                            if (_didIteratorError3) throw _iteratorError3;
                        }
                    }
                    ++delta, ++n;
                }
                return output.join("");
            }, punycode = {
                version: "2.1.0",
                ucs2: {
                    decode: ucs2decode,
                    encode: function(array) {
                        return String.fromCodePoint.apply(String, function(arr) {
                            if (Array.isArray(arr)) {
                                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                                return arr2;
                            }
                            return Array.from(arr);
                        }(array));
                    }
                },
                decode,
                encode,
                toASCII: function(input) {
                    return mapDomain(input, function(string) {
                        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                    });
                },
                toUnicode: function(input) {
                    return mapDomain(input, function(string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }
            }, SCHEMES = {};
            function pctEncChar(chr) {
                var c = chr.charCodeAt(0);
                return c < 16 ? "%0" + c.toString(16).toUpperCase() : c < 128 ? "%" + c.toString(16).toUpperCase() : c < 2048 ? "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & c | 128).toString(16).toUpperCase() : "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & c | 128).toString(16).toUpperCase();
            }
            function pctDecChars(str) {
                for (var newStr = "", i = 0, il = str.length; i < il; ) {
                    var c = parseInt(str.substr(i + 1, 2), 16);
                    if (c < 128) newStr += String.fromCharCode(c), i += 3; else if (c >= 194 && c < 224) {
                        if (il - i >= 6) {
                            var c2 = parseInt(str.substr(i + 4, 2), 16);
                            newStr += String.fromCharCode((31 & c) << 6 | 63 & c2);
                        } else newStr += str.substr(i, 6);
                        i += 6;
                    } else if (c >= 224) {
                        if (il - i >= 9) {
                            var _c = parseInt(str.substr(i + 4, 2), 16), c3 = parseInt(str.substr(i + 7, 2), 16);
                            newStr += String.fromCharCode((15 & c) << 12 | (63 & _c) << 6 | 63 & c3);
                        } else newStr += str.substr(i, 9);
                        i += 9;
                    } else newStr += str.substr(i, 3), i += 3;
                }
                return newStr;
            }
            function _normalizeComponentEncoding(components, protocol) {
                function decodeUnreserved(str) {
                    var decStr = pctDecChars(str);
                    return decStr.match(protocol.UNRESERVED) ? decStr : str;
                }
                return components.scheme && (components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "")), 
                void 0 !== components.userinfo && (components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
                void 0 !== components.host && (components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
                void 0 !== components.path && (components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
                void 0 !== components.query && (components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
                void 0 !== components.fragment && (components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
                components;
            }
            function _stripLeadingZeros(str) {
                return str.replace(/^0*(.*)/, "$1") || "0";
            }
            function _normalizeIPv4(host, protocol) {
                var matches = host.match(protocol.IPV4ADDRESS) || [], address = slicedToArray(matches, 2)[1];
                return address ? address.split(".").map(_stripLeadingZeros).join(".") : host;
            }
            function _normalizeIPv6(host, protocol) {
                var matches = host.match(protocol.IPV6ADDRESS) || [], _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
                if (address) {
                    for (var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1], firstFields = first ? first.split(":").map(_stripLeadingZeros) : [], lastFields = last.split(":").map(_stripLeadingZeros), isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]), fieldCount = isLastFieldIPv4Address ? 7 : 8, lastFieldsStart = lastFields.length - fieldCount, fields = Array(fieldCount), x = 0; x < fieldCount; ++x) fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
                    isLastFieldIPv4Address && (fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol));
                    var longestZeroFields = fields.reduce(function(acc, field, index) {
                        if (!field || "0" === field) {
                            var lastLongest = acc[acc.length - 1];
                            lastLongest && lastLongest.index + lastLongest.length === index ? lastLongest.length++ : acc.push({
                                index,
                                length: 1
                            });
                        }
                        return acc;
                    }, []).sort(function(a, b) {
                        return b.length - a.length;
                    })[0], newHost = void 0;
                    if (longestZeroFields && longestZeroFields.length > 1) {
                        var newFirst = fields.slice(0, longestZeroFields.index), newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                        newHost = newFirst.join(":") + "::" + newLast.join(":");
                    } else newHost = fields.join(":");
                    return zone && (newHost += "%" + zone), newHost;
                }
                return host;
            }
            var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, NO_MATCH_IS_UNDEFINED = void 0 === "".match(/(){0}/)[1];
            function parse(uriString) {
                var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, components = {}, protocol = !1 !== options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
                "suffix" === options.reference && (uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString);
                var matches = uriString.match(URI_PARSE);
                if (matches) {
                    NO_MATCH_IS_UNDEFINED ? (components.scheme = matches[1], components.userinfo = matches[3], 
                    components.host = matches[4], components.port = parseInt(matches[5], 10), components.path = matches[6] || "", 
                    components.query = matches[7], components.fragment = matches[8], isNaN(components.port) && (components.port = matches[5])) : (components.scheme = matches[1] || void 0, 
                    components.userinfo = -1 !== uriString.indexOf("@") ? matches[3] : void 0, components.host = -1 !== uriString.indexOf("//") ? matches[4] : void 0, 
                    components.port = parseInt(matches[5], 10), components.path = matches[6] || "", 
                    components.query = -1 !== uriString.indexOf("?") ? matches[7] : void 0, components.fragment = -1 !== uriString.indexOf("#") ? matches[8] : void 0, 
                    isNaN(components.port) && (components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0)), 
                    components.host && (components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol)), 
                    components.reference = void 0 !== components.scheme || void 0 !== components.userinfo || void 0 !== components.host || void 0 !== components.port || components.path || void 0 !== components.query ? void 0 === components.scheme ? "relative" : void 0 === components.fragment ? "absolute" : "uri" : "same-document", 
                    options.reference && "suffix" !== options.reference && options.reference !== components.reference && (components.error = components.error || "URI is not a " + options.reference + " reference.");
                    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                    if (options.unicodeSupport || schemeHandler && schemeHandler.unicodeSupport) _normalizeComponentEncoding(components, protocol); else {
                        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) try {
                            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                        } catch (e) {
                            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                        }
                        _normalizeComponentEncoding(components, URI_PROTOCOL);
                    }
                    schemeHandler && schemeHandler.parse && schemeHandler.parse(components, options);
                } else components.error = components.error || "URI can not be parsed.";
                return components;
            }
            var RDS1 = /^\.\.?\//, RDS2 = /^\/\.(\/|$)/, RDS3 = /^\/\.\.(\/|$)/, RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
            function removeDotSegments(input) {
                for (var output = []; input.length; ) if (input.match(RDS1)) input = input.replace(RDS1, ""); else if (input.match(RDS2)) input = input.replace(RDS2, "/"); else if (input.match(RDS3)) input = input.replace(RDS3, "/"), 
                output.pop(); else if ("." === input || ".." === input) input = ""; else {
                    var im = input.match(RDS5);
                    if (!im) throw new Error("Unexpected dot segment condition");
                    var s = im[0];
                    input = input.slice(s.length), output.push(s);
                }
                return output.join("");
            }
            function serialize(components) {
                var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL, uriTokens = [], schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                if (schemeHandler && schemeHandler.serialize && schemeHandler.serialize(components, options), 
                components.host) if (protocol.IPV6ADDRESS.test(components.host)) ; else if (options.domainHost || schemeHandler && schemeHandler.domainHost) try {
                    components.host = options.iri ? punycode.toUnicode(components.host) : punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (options.iri ? "Unicode" : "ASCII") + " via punycode: " + e;
                }
                _normalizeComponentEncoding(components, protocol), "suffix" !== options.reference && components.scheme && (uriTokens.push(components.scheme), 
                uriTokens.push(":"));
                var authority = function(components, options) {
                    var protocol = !1 !== options.iri ? IRI_PROTOCOL : URI_PROTOCOL, uriTokens = [];
                    return void 0 !== components.userinfo && (uriTokens.push(components.userinfo), uriTokens.push("@")), 
                    void 0 !== components.host && uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
                        return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
                    })), "number" != typeof components.port && "string" != typeof components.port || (uriTokens.push(":"), 
                    uriTokens.push(String(components.port))), uriTokens.length ? uriTokens.join("") : void 0;
                }(components, options);
                if (void 0 !== authority && ("suffix" !== options.reference && uriTokens.push("//"), 
                uriTokens.push(authority), components.path && "/" !== components.path.charAt(0) && uriTokens.push("/")), 
                void 0 !== components.path) {
                    var s = components.path;
                    options.absolutePath || schemeHandler && schemeHandler.absolutePath || (s = removeDotSegments(s)), 
                    void 0 === authority && (s = s.replace(/^\/\//, "/%2F")), uriTokens.push(s);
                }
                return void 0 !== components.query && (uriTokens.push("?"), uriTokens.push(components.query)), 
                void 0 !== components.fragment && (uriTokens.push("#"), uriTokens.push(components.fragment)), 
                uriTokens.join("");
            }
            function resolveComponents(base, relative) {
                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, target = {};
                return arguments[3] || (base = parse(serialize(base, options), options), relative = parse(serialize(relative, options), options)), 
                !(options = options || {}).tolerant && relative.scheme ? (target.scheme = relative.scheme, 
                target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, 
                target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (void 0 !== relative.userinfo || void 0 !== relative.host || void 0 !== relative.port ? (target.userinfo = relative.userinfo, 
                target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), 
                target.query = relative.query) : (relative.path ? ("/" === relative.path.charAt(0) ? target.path = removeDotSegments(relative.path) : (target.path = void 0 === base.userinfo && void 0 === base.host && void 0 === base.port || base.path ? base.path ? base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : relative.path : "/" + relative.path, 
                target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, 
                target.query = void 0 !== relative.query ? relative.query : base.query), target.userinfo = base.userinfo, 
                target.host = base.host, target.port = base.port), target.scheme = base.scheme), 
                target.fragment = relative.fragment, target;
            }
            function unescapeComponent(str, options) {
                return str && str.toString().replace(options && options.iri ? IRI_PROTOCOL.PCT_ENCODED : URI_PROTOCOL.PCT_ENCODED, pctDecChars);
            }
            var handler = {
                scheme: "http",
                domainHost: !0,
                parse: function(components, options) {
                    return components.host || (components.error = components.error || "HTTP URIs must have a host."), 
                    components;
                },
                serialize: function(components, options) {
                    var secure = "https" === String(components.scheme).toLowerCase();
                    return components.port !== (secure ? 443 : 80) && "" !== components.port || (components.port = void 0), 
                    components.path || (components.path = "/"), components;
                }
            }, handler$1 = {
                scheme: "https",
                domainHost: handler.domainHost,
                parse: handler.parse,
                serialize: handler.serialize
            };
            function isSecure(wsComponents) {
                return "boolean" == typeof wsComponents.secure ? wsComponents.secure : "wss" === String(wsComponents.scheme).toLowerCase();
            }
            var handler$2 = {
                scheme: "ws",
                domainHost: !0,
                parse: function(components, options) {
                    var wsComponents = components;
                    return wsComponents.secure = isSecure(wsComponents), wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : ""), 
                    wsComponents.path = void 0, wsComponents.query = void 0, wsComponents;
                },
                serialize: function(wsComponents, options) {
                    if (wsComponents.port !== (isSecure(wsComponents) ? 443 : 80) && "" !== wsComponents.port || (wsComponents.port = void 0), 
                    "boolean" == typeof wsComponents.secure && (wsComponents.scheme = wsComponents.secure ? "wss" : "ws", 
                    wsComponents.secure = void 0), wsComponents.resourceName) {
                        var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
                        wsComponents.path = path && "/" !== path ? path : void 0, wsComponents.query = query, 
                        wsComponents.resourceName = void 0;
                    }
                    return wsComponents.fragment = void 0, wsComponents;
                }
            }, handler$3 = {
                scheme: "wss",
                domainHost: handler$2.domainHost,
                parse: handler$2.parse,
                serialize: handler$2.serialize
            }, O = {}, UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", HEXDIG$$ = "[0-9A-Fa-f]", PCT_ENCODED$ = subexp(subexp("%[EFef][0-9A-Fa-f]%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f][0-9A-Fa-f]%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), VCHAR$$ = merge("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), UNRESERVED = new RegExp(UNRESERVED$$, "g"), PCT_ENCODED = new RegExp(PCT_ENCODED$, "g"), NOT_LOCAL_PART = new RegExp(merge("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', VCHAR$$), "g"), NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), NOT_HFVALUE = NOT_HFNAME;
            function decodeUnreserved(str) {
                var decStr = pctDecChars(str);
                return decStr.match(UNRESERVED) ? decStr : str;
            }
            var handler$4 = {
                scheme: "mailto",
                parse: function(components, options) {
                    var mailtoComponents = components, to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
                    if (mailtoComponents.path = void 0, mailtoComponents.query) {
                        for (var unknownHeaders = !1, headers = {}, hfields = mailtoComponents.query.split("&"), x = 0, xl = hfields.length; x < xl; ++x) {
                            var hfield = hfields[x].split("=");
                            switch (hfield[0]) {
                              case "to":
                                for (var toAddrs = hfield[1].split(","), _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) to.push(toAddrs[_x]);
                                break;

                              case "subject":
                                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                                break;

                              case "body":
                                mailtoComponents.body = unescapeComponent(hfield[1], options);
                                break;

                              default:
                                unknownHeaders = !0, headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                            }
                        }
                        unknownHeaders && (mailtoComponents.headers = headers);
                    }
                    mailtoComponents.query = void 0;
                    for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                        var addr = to[_x2].split("@");
                        if (addr[0] = unescapeComponent(addr[0]), options.unicodeSupport) addr[1] = unescapeComponent(addr[1], options).toLowerCase(); else try {
                            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                        } catch (e) {
                            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                        }
                        to[_x2] = addr.join("@");
                    }
                    return mailtoComponents;
                },
                serialize: function(mailtoComponents, options) {
                    var obj, components = mailtoComponents, to = null != (obj = mailtoComponents.to) ? obj instanceof Array ? obj : "number" != typeof obj.length || obj.split || obj.setInterval || obj.call ? [ obj ] : Array.prototype.slice.call(obj) : [];
                    if (to) {
                        for (var x = 0, xl = to.length; x < xl; ++x) {
                            var toAddr = String(to[x]), atIdx = toAddr.lastIndexOf("@"), localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar), domain = toAddr.slice(atIdx + 1);
                            try {
                                domain = options.iri ? punycode.toUnicode(domain) : punycode.toASCII(unescapeComponent(domain, options).toLowerCase());
                            } catch (e) {
                                components.error = components.error || "Email address's domain name can not be converted to " + (options.iri ? "Unicode" : "ASCII") + " via punycode: " + e;
                            }
                            to[x] = localPart + "@" + domain;
                        }
                        components.path = to.join(",");
                    }
                    var headers = mailtoComponents.headers = mailtoComponents.headers || {};
                    mailtoComponents.subject && (headers.subject = mailtoComponents.subject), mailtoComponents.body && (headers.body = mailtoComponents.body);
                    var fields = [];
                    for (var name in headers) headers[name] !== O[name] && fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                    return fields.length && (components.query = fields.join("&")), components;
                }
            }, URN_PARSE = /^([^\:]+)\:(.*)/, handler$5 = {
                scheme: "urn",
                parse: function(components, options) {
                    var matches = components.path && components.path.match(URN_PARSE), urnComponents = components;
                    if (matches) {
                        var scheme = options.scheme || urnComponents.scheme || "urn", nid = matches[1].toLowerCase(), nss = matches[2], schemeHandler = SCHEMES[scheme + ":" + (options.nid || nid)];
                        urnComponents.nid = nid, urnComponents.nss = nss, urnComponents.path = void 0, schemeHandler && (urnComponents = schemeHandler.parse(urnComponents, options));
                    } else urnComponents.error = urnComponents.error || "URN can not be parsed.";
                    return urnComponents;
                },
                serialize: function(urnComponents, options) {
                    var nid = urnComponents.nid, schemeHandler = SCHEMES[(options.scheme || urnComponents.scheme || "urn") + ":" + (options.nid || nid)];
                    schemeHandler && (urnComponents = schemeHandler.serialize(urnComponents, options));
                    var uriComponents = urnComponents;
                    return uriComponents.path = (nid || options.nid) + ":" + urnComponents.nss, uriComponents;
                }
            }, UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, handler$6 = {
                scheme: "urn:uuid",
                parse: function(urnComponents, options) {
                    var uuidComponents = urnComponents;
                    return uuidComponents.uuid = uuidComponents.nss, uuidComponents.nss = void 0, options.tolerant || uuidComponents.uuid && uuidComponents.uuid.match(UUID) || (uuidComponents.error = uuidComponents.error || "UUID is not valid."), 
                    uuidComponents;
                },
                serialize: function(uuidComponents, options) {
                    var urnComponents = uuidComponents;
                    return urnComponents.nss = (uuidComponents.uuid || "").toLowerCase(), urnComponents;
                }
            };
            SCHEMES[handler.scheme] = handler, SCHEMES[handler$1.scheme] = handler$1, SCHEMES[handler$2.scheme] = handler$2, 
            SCHEMES[handler$3.scheme] = handler$3, SCHEMES[handler$4.scheme] = handler$4, SCHEMES[handler$5.scheme] = handler$5, 
            SCHEMES[handler$6.scheme] = handler$6, exports.SCHEMES = SCHEMES, exports.pctEncChar = pctEncChar, 
            exports.pctDecChars = pctDecChars, exports.parse = parse, exports.removeDotSegments = removeDotSegments, 
            exports.serialize = serialize, exports.resolveComponents = resolveComponents, exports.resolve = function(baseURI, relativeURI, options) {
                var schemelessOptions = function(target, source) {
                    var obj = {
                        scheme: "null"
                    };
                    if (source) for (var key in source) obj[key] = source[key];
                    return obj;
                }(0, options);
                return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, !0), schemelessOptions);
            }, exports.normalize = function(uri, options) {
                return "string" == typeof uri ? uri = serialize(parse(uri, options), options) : "object" === typeOf(uri) && (uri = parse(serialize(uri, options), options)), 
                uri;
            }, exports.equal = function(uriA, uriB, options) {
                return "string" == typeof uriA ? uriA = serialize(parse(uriA, options), options) : "object" === typeOf(uriA) && (uriA = serialize(uriA, options)), 
                "string" == typeof uriB ? uriB = serialize(parse(uriB, options), options) : "object" === typeOf(uriB) && (uriB = serialize(uriB, options)), 
                uriA === uriB;
            }, exports.escapeComponent = function(str, options) {
                return str && str.toString().replace(options && options.iri ? IRI_PROTOCOL.ESCAPE : URI_PROTOCOL.ESCAPE, pctEncChar);
            }, exports.unescapeComponent = unescapeComponent, Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }(exports);
    },
    98909: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            JsonSchemaValidationLazyModule: function() {
                return JsonSchemaValidationLazyModule;
            }
        });
        var common = __webpack_require__(77476), lazy_load_module = __webpack_require__(82156), lazy_load_routes = __webpack_require__(8483), dist_ajv = __webpack_require__(31984), ajv_default = __webpack_require__.n(dist_ajv), typings = __webpack_require__(36731), core = __webpack_require__(50423), JsonSchemaValidationService = function() {
            function JsonSchemaValidationService() {
                this.compiledSchemas = new Map;
            }
            return JsonSchemaValidationService.prototype.registerSchema = function(schemaName, schema, validationOptions) {
                void 0 === validationOptions && (validationOptions = typings.D), this.compiledSchemas.has(schemaName) || this.compiledSchemas.set(schemaName, new (ajv_default())(validationOptions).compile(schema));
            }, JsonSchemaValidationService.prototype.validate = function(arg0, data, validationOptions) {
                var _a, schemaValidator;
                if (void 0 === validationOptions && (validationOptions = typings.D), "string" == typeof arg0) {
                    if (!this.compiledSchemas.has(arg0)) return {
                        isValid: !1,
                        errors: [ "Schema ".concat(arg0, " not registered.") ]
                    };
                    schemaValidator = this.compiledSchemas.get(arg0);
                } else {
                    var schema = arg0;
                    schemaValidator = new (ajv_default())(validationOptions).compile(schema);
                }
                return {
                    isValid: schemaValidator(data),
                    errors: null !== (_a = schemaValidator.errors) && void 0 !== _a ? _a : null
                };
            }, JsonSchemaValidationService.\u0275prov = core["\u0275\u0275defineInjectable"]({
                token: JsonSchemaValidationService,
                factory: JsonSchemaValidationService.\u0275fac = function(t) {
                    return new (t || JsonSchemaValidationService);
                },
                providedIn: "root"
            }), JsonSchemaValidationService;
        }(), JsonSchemaValidationLazyModule = function() {
            function JsonSchemaValidationLazyModule() {}
            return JsonSchemaValidationLazyModule.\u0275fac = function(t) {
                return new (t || JsonSchemaValidationLazyModule);
            }, JsonSchemaValidationLazyModule.\u0275mod = core["\u0275\u0275defineNgModule"]({
                type: JsonSchemaValidationLazyModule
            }), JsonSchemaValidationLazyModule.\u0275inj = core["\u0275\u0275defineInjector"]({
                providers: [ lazy_load_module.N.withLazyService(lazy_load_routes.yO, JsonSchemaValidationService) ],
                imports: [ common.CommonModule, lazy_load_module.N ]
            }), JsonSchemaValidationLazyModule;
        }();
    },
    36731: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            D: function() {
                return DefaultValidationOptions;
            }
        });
        var DefaultValidationOptions = {
            allErrors: !0,
            verbose: !0,
            allowUnionTypes: !0,
            validateSchema: "log"
        };
    },
    61107: function(module) {
        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
                var info = gen[key](arg), value = info.value;
            } catch (error) {
                return void reject(error);
            }
            info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
        }
        module.exports = function(fn) {
            return function() {
                var self = this, args = arguments;
                return new Promise(function(resolve, reject) {
                    var gen = fn.apply(self, args);
                    function _next(value) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                    }
                    function _throw(err) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                    }
                    _next(void 0);
                });
            };
        }, module.exports.__esModule = !0, module.exports.default = module.exports;
    },
    95512: function(module) {
        "use strict";
        module.exports = JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');
    },
    70425: function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');
    }
} ]);