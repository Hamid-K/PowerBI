(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "slicer" ], {
    45863: function(module, exports) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function() {
            "use strict";
            var VERSION = "14.6.2";
            function removeElement(el) {
                el.parentElement.removeChild(el);
            }
            function isSet(value) {
                return null != value;
            }
            function preventDefault(e) {
                e.preventDefault();
            }
            function isNumeric(a) {
                return "number" == typeof a && !isNaN(a) && isFinite(a);
            }
            function addClassFor(element, className, duration) {
                duration > 0 && (addClass(element, className), setTimeout(function() {
                    removeClass(element, className);
                }, duration));
            }
            function limit(a) {
                return Math.max(Math.min(a, 100), 0);
            }
            function asArray(a) {
                return Array.isArray(a) ? a : [ a ];
            }
            function countDecimals(numStr) {
                var pieces = (numStr = String(numStr)).split(".");
                return pieces.length > 1 ? pieces[1].length : 0;
            }
            function addClass(el, className) {
                el.classList && !/\s/.test(className) ? el.classList.add(className) : el.className += " " + className;
            }
            function removeClass(el, className) {
                el.classList && !/\s/.test(className) ? el.classList.remove(className) : el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
            }
            function getPageOffset(doc) {
                var supportPageOffset = void 0 !== window.pageXOffset, isCSS1Compat = "CSS1Compat" === (doc.compatMode || "");
                return {
                    x: supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft,
                    y: supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop
                };
            }
            function subRangeRatio(pa, pb) {
                return 100 / (pb - pa);
            }
            function fromPercentage(range, value, startRange) {
                return 100 * value / (range[startRange + 1] - range[startRange]);
            }
            function getJ(value, arr) {
                for (var j = 1; value >= arr[j]; ) j += 1;
                return j;
            }
            function handleEntryPoint(index, value, that) {
                var percentage;
                if ("number" == typeof value && (value = [ value ]), !Array.isArray(value)) throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
                if (!isNumeric(percentage = "min" === index ? 0 : "max" === index ? 100 : parseFloat(index)) || !isNumeric(value[0])) throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
                that.xPct.push(percentage), that.xVal.push(value[0]), percentage ? that.xSteps.push(!isNaN(value[1]) && value[1]) : isNaN(value[1]) || (that.xSteps[0] = value[1]), 
                that.xHighestCompleteStep.push(0);
            }
            function handleStepPoint(i, n, that) {
                if (n) if (that.xVal[i] !== that.xVal[i + 1]) {
                    that.xSteps[i] = fromPercentage([ that.xVal[i], that.xVal[i + 1] ], n, 0) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);
                    var highestStep = Math.ceil(Number(((that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i]).toFixed(3)) - 1);
                    that.xHighestCompleteStep[i] = that.xVal[i] + that.xNumSteps[i] * highestStep;
                } else that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];
            }
            function Spectrum(entry, snap, singleStep) {
                var index;
                this.xPct = [], this.xVal = [], this.xSteps = [ singleStep || !1 ], this.xNumSteps = [ !1 ], 
                this.xHighestCompleteStep = [], this.snap = snap;
                var ordered = [];
                for (index in entry) entry.hasOwnProperty(index) && ordered.push([ entry[index], index ]);
                for (ordered.sort(ordered.length && "object" == typeof ordered[0][0] ? function(a, b) {
                    return a[0][0] - b[0][0];
                } : function(a, b) {
                    return a[0] - b[0];
                }), index = 0; index < ordered.length; index++) handleEntryPoint(ordered[index][1], ordered[index][0], this);
                for (this.xNumSteps = this.xSteps.slice(0), index = 0; index < this.xNumSteps.length; index++) handleStepPoint(index, this.xNumSteps[index], this);
            }
            Spectrum.prototype.getDistance = function(value) {
                var index, distances = [];
                for (index = 0; index < this.xNumSteps.length - 1; index++) {
                    var step = this.xNumSteps[index];
                    if (step && value / step % 1 != 0) throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' of " + this.xPct[index] + "% range must be divisible by step.");
                    distances[index] = fromPercentage(this.xVal, value, index);
                }
                return distances;
            }, Spectrum.prototype.getAbsoluteDistance = function(value, distances, direction) {
                var start_factor, xPct_index = 0;
                if (value < this.xPct[this.xPct.length - 1]) for (;value > this.xPct[xPct_index + 1]; ) xPct_index++; else value === this.xPct[this.xPct.length - 1] && (xPct_index = this.xPct.length - 2);
                direction || value !== this.xPct[xPct_index + 1] || xPct_index++;
                var rest_factor = 1, rest_rel_distance = distances[xPct_index], range_pct = 0, rel_range_distance = 0, abs_distance_counter = 0, range_counter = 0;
                for (start_factor = direction ? (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]) : (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]); rest_rel_distance > 0; ) range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter], 
                distances[xPct_index + range_counter] * rest_factor + 100 - 100 * start_factor > 100 ? (rel_range_distance = range_pct * start_factor, 
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter], 
                start_factor = 1) : (rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor, 
                rest_factor = 0), direction ? (abs_distance_counter -= rel_range_distance, this.xPct.length + range_counter >= 1 && range_counter--) : (abs_distance_counter += rel_range_distance, 
                this.xPct.length - range_counter >= 1 && range_counter++), rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
                return value + abs_distance_counter;
            }, Spectrum.prototype.toStepping = function(value) {
                return function(xVal, xPct, value) {
                    if (value >= xVal.slice(-1)[0]) return 100;
                    var j = getJ(value, xVal), pa = xPct[j - 1], pb = xPct[j];
                    return pa + function(range, value) {
                        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
                    }([ xVal[j - 1], xVal[j] ], value) / subRangeRatio(pa, pb);
                }(this.xVal, this.xPct, value);
            }, Spectrum.prototype.fromStepping = function(value) {
                return function(xVal, xPct, value) {
                    if (value >= 100) return xVal.slice(-1)[0];
                    var j = getJ(value, xPct), pa = xPct[j - 1];
                    return function(range, value) {
                        return value * (range[1] - range[0]) / 100 + range[0];
                    }([ xVal[j - 1], xVal[j] ], (value - pa) * subRangeRatio(pa, xPct[j]));
                }(this.xVal, this.xPct, value);
            }, Spectrum.prototype.getStep = function(value) {
                return function(xPct, xSteps, snap, value) {
                    if (100 === value) return value;
                    var j = getJ(value, xPct), a = xPct[j - 1], b = xPct[j];
                    return snap ? value - a > (b - a) / 2 ? b : a : xSteps[j - 1] ? xPct[j - 1] + function(value, to) {
                        return Math.round(value / to) * to;
                    }(value - xPct[j - 1], xSteps[j - 1]) : value;
                }(this.xPct, this.xSteps, this.snap, value);
            }, Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
                var j = getJ(value, this.xPct);
                return (100 === value || isDown && value === this.xPct[j - 1]) && (j = Math.max(j - 1, 1)), 
                (this.xVal[j] - this.xVal[j - 1]) / size;
            }, Spectrum.prototype.getNearbySteps = function(value) {
                var j = getJ(value, this.xPct);
                return {
                    stepBefore: {
                        startValue: this.xVal[j - 2],
                        step: this.xNumSteps[j - 2],
                        highestStep: this.xHighestCompleteStep[j - 2]
                    },
                    thisStep: {
                        startValue: this.xVal[j - 1],
                        step: this.xNumSteps[j - 1],
                        highestStep: this.xHighestCompleteStep[j - 1]
                    },
                    stepAfter: {
                        startValue: this.xVal[j],
                        step: this.xNumSteps[j],
                        highestStep: this.xHighestCompleteStep[j]
                    }
                };
            }, Spectrum.prototype.countStepDecimals = function() {
                var stepDecimals = this.xNumSteps.map(countDecimals);
                return Math.max.apply(null, stepDecimals);
            }, Spectrum.prototype.convert = function(value) {
                return this.getStep(this.toStepping(value));
            };
            var defaultFormatter = {
                to: function(value) {
                    return void 0 !== value && value.toFixed(2);
                },
                from: Number
            }, cssClasses = {
                target: "target",
                base: "base",
                origin: "origin",
                handle: "handle",
                handleLower: "handle-lower",
                handleUpper: "handle-upper",
                touchArea: "touch-area",
                horizontal: "horizontal",
                vertical: "vertical",
                background: "background",
                connect: "connect",
                connects: "connects",
                ltr: "ltr",
                rtl: "rtl",
                textDirectionLtr: "txt-dir-ltr",
                textDirectionRtl: "txt-dir-rtl",
                draggable: "draggable",
                drag: "state-drag",
                tap: "state-tap",
                active: "active",
                tooltip: "tooltip",
                pips: "pips",
                pipsHorizontal: "pips-horizontal",
                pipsVertical: "pips-vertical",
                marker: "marker",
                markerHorizontal: "marker-horizontal",
                markerVertical: "marker-vertical",
                markerNormal: "marker-normal",
                markerLarge: "marker-large",
                markerSub: "marker-sub",
                value: "value",
                valueHorizontal: "value-horizontal",
                valueVertical: "value-vertical",
                valueNormal: "value-normal",
                valueLarge: "value-large",
                valueSub: "value-sub"
            };
            function validateFormat(entry) {
                if (function(entry) {
                    return "object" == typeof entry && "function" == typeof entry.to && "function" == typeof entry.from;
                }(entry)) return !0;
                throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
            }
            function testStep(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
                parsed.singleStep = entry;
            }
            function testKeyboardPageMultiplier(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'keyboardPageMultiplier' is not numeric.");
                parsed.keyboardPageMultiplier = entry;
            }
            function testKeyboardDefaultStep(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'keyboardDefaultStep' is not numeric.");
                parsed.keyboardDefaultStep = entry;
            }
            function testRange(parsed, entry) {
                if ("object" != typeof entry || Array.isArray(entry)) throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
                if (void 0 === entry.min || void 0 === entry.max) throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
                if (entry.min === entry.max) throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
                parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
            }
            function testStart(parsed, entry) {
                if (entry = asArray(entry), !Array.isArray(entry) || !entry.length) throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
                parsed.handles = entry.length, parsed.start = entry;
            }
            function testSnap(parsed, entry) {
                if (parsed.snap = entry, "boolean" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
            }
            function testAnimate(parsed, entry) {
                if (parsed.animate = entry, "boolean" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
            }
            function testAnimationDuration(parsed, entry) {
                if (parsed.animationDuration = entry, "number" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
            }
            function testConnect(parsed, entry) {
                var i, connect = [ !1 ];
                if ("lower" === entry ? entry = [ !0, !1 ] : "upper" === entry && (entry = [ !1, !0 ]), 
                !0 === entry || !1 === entry) {
                    for (i = 1; i < parsed.handles; i++) connect.push(entry);
                    connect.push(!1);
                } else {
                    if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
                    connect = entry;
                }
                parsed.connect = connect;
            }
            function testOrientation(parsed, entry) {
                switch (entry) {
                  case "horizontal":
                    parsed.ort = 0;
                    break;

                  case "vertical":
                    parsed.ort = 1;
                    break;

                  default:
                    throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
                }
            }
            function testMargin(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
                0 !== entry && (parsed.margin = parsed.spectrum.getDistance(entry));
            }
            function testLimit(parsed, entry) {
                if (!isNumeric(entry)) throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
                if (parsed.limit = parsed.spectrum.getDistance(entry), !parsed.limit || parsed.handles < 2) throw new Error("noUiSlider (" + VERSION + "): 'limit' option is only supported on linear sliders with 2 or more handles.");
            }
            function testPadding(parsed, entry) {
                var index;
                if (!isNumeric(entry) && !Array.isArray(entry)) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers.");
                if (Array.isArray(entry) && 2 !== entry.length && !isNumeric(entry[0]) && !isNumeric(entry[1])) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers.");
                if (0 !== entry) {
                    for (Array.isArray(entry) || (entry = [ entry, entry ]), parsed.padding = [ parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1]) ], 
                    index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number(s).");
                    if ((entry[0] + entry[1]) / (parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1] - parsed.spectrum.xVal[0]) > 1) throw new Error("noUiSlider (" + VERSION + "): 'padding' option must not exceed 100% of the range.");
                }
            }
            function testDirection(parsed, entry) {
                switch (entry) {
                  case "ltr":
                    parsed.dir = 0;
                    break;

                  case "rtl":
                    parsed.dir = 1;
                    break;

                  default:
                    throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
                }
            }
            function testBehaviour(parsed, entry) {
                if ("string" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
                var tap = entry.indexOf("tap") >= 0, drag = entry.indexOf("drag") >= 0, fixed = entry.indexOf("fixed") >= 0, snap = entry.indexOf("snap") >= 0, hover = entry.indexOf("hover") >= 0, unconstrained = entry.indexOf("unconstrained") >= 0;
                if (fixed) {
                    if (2 !== parsed.handles) throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
                    testMargin(parsed, parsed.start[1] - parsed.start[0]);
                }
                if (unconstrained && (parsed.margin || parsed.limit)) throw new Error("noUiSlider (" + VERSION + "): 'unconstrained' behaviour cannot be used with margin or limit");
                parsed.events = {
                    tap: tap || snap,
                    drag,
                    fixed,
                    snap,
                    hover,
                    unconstrained
                };
            }
            function testTooltips(parsed, entry) {
                if (!1 !== entry) if (!0 === entry) {
                    parsed.tooltips = [];
                    for (var i = 0; i < parsed.handles; i++) parsed.tooltips.push(!0);
                } else {
                    if (parsed.tooltips = asArray(entry), parsed.tooltips.length !== parsed.handles) throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
                    parsed.tooltips.forEach(function(formatter) {
                        if ("boolean" != typeof formatter && ("object" != typeof formatter || "function" != typeof formatter.to)) throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
                    });
                }
            }
            function testAriaFormat(parsed, entry) {
                parsed.ariaFormat = entry, validateFormat(entry);
            }
            function testFormat(parsed, entry) {
                parsed.format = entry, validateFormat(entry);
            }
            function testKeyboardSupport(parsed, entry) {
                if (parsed.keyboardSupport = entry, "boolean" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'keyboardSupport' option must be a boolean.");
            }
            function testDocumentElement(parsed, entry) {
                parsed.documentElement = entry;
            }
            function testCssPrefix(parsed, entry) {
                if ("string" != typeof entry && !1 !== entry) throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
                parsed.cssPrefix = entry;
            }
            function testCssClasses(parsed, entry) {
                if ("object" != typeof entry) throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
                if ("string" == typeof parsed.cssPrefix) for (var key in parsed.cssClasses = {}, 
                entry) entry.hasOwnProperty(key) && (parsed.cssClasses[key] = parsed.cssPrefix + entry[key]); else parsed.cssClasses = entry;
            }
            function testOptions(options) {
                var parsed = {
                    margin: 0,
                    limit: 0,
                    padding: 0,
                    animate: !0,
                    animationDuration: 300,
                    ariaFormat: defaultFormatter,
                    format: defaultFormatter
                }, tests = {
                    step: {
                        r: !1,
                        t: testStep
                    },
                    keyboardPageMultiplier: {
                        r: !1,
                        t: testKeyboardPageMultiplier
                    },
                    keyboardDefaultStep: {
                        r: !1,
                        t: testKeyboardDefaultStep
                    },
                    start: {
                        r: !0,
                        t: testStart
                    },
                    connect: {
                        r: !0,
                        t: testConnect
                    },
                    direction: {
                        r: !0,
                        t: testDirection
                    },
                    snap: {
                        r: !1,
                        t: testSnap
                    },
                    animate: {
                        r: !1,
                        t: testAnimate
                    },
                    animationDuration: {
                        r: !1,
                        t: testAnimationDuration
                    },
                    range: {
                        r: !0,
                        t: testRange
                    },
                    orientation: {
                        r: !1,
                        t: testOrientation
                    },
                    margin: {
                        r: !1,
                        t: testMargin
                    },
                    limit: {
                        r: !1,
                        t: testLimit
                    },
                    padding: {
                        r: !1,
                        t: testPadding
                    },
                    behaviour: {
                        r: !0,
                        t: testBehaviour
                    },
                    ariaFormat: {
                        r: !1,
                        t: testAriaFormat
                    },
                    format: {
                        r: !1,
                        t: testFormat
                    },
                    tooltips: {
                        r: !1,
                        t: testTooltips
                    },
                    keyboardSupport: {
                        r: !0,
                        t: testKeyboardSupport
                    },
                    documentElement: {
                        r: !1,
                        t: testDocumentElement
                    },
                    cssPrefix: {
                        r: !0,
                        t: testCssPrefix
                    },
                    cssClasses: {
                        r: !0,
                        t: testCssClasses
                    }
                }, defaults = {
                    connect: !1,
                    direction: "ltr",
                    behaviour: "tap",
                    orientation: "horizontal",
                    keyboardSupport: !0,
                    cssPrefix: "noUi-",
                    cssClasses,
                    keyboardPageMultiplier: 5,
                    keyboardDefaultStep: 10
                };
                options.format && !options.ariaFormat && (options.ariaFormat = options.format), 
                Object.keys(tests).forEach(function(name) {
                    if (!isSet(options[name]) && void 0 === defaults[name]) {
                        if (tests[name].r) throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
                        return !0;
                    }
                    tests[name].t(parsed, isSet(options[name]) ? options[name] : defaults[name]);
                }), parsed.pips = options.pips;
                var d = document.createElement("div");
                return parsed.transformRule = void 0 !== d.style.transform ? "transform" : void 0 !== d.style.msTransform ? "msTransform" : "webkitTransform", 
                parsed.style = [ [ "left", "top" ], [ "right", "bottom" ] ][parsed.dir][parsed.ort], 
                parsed;
            }
            function scope(target, options, originalOptions) {
                var scope_Base, scope_Handles, scope_Connects, scope_Pips, scope_Tooltips, scope_Self, behaviour, addTarget, actions = window.navigator.pointerEnabled ? {
                    start: "pointerdown",
                    move: "pointermove",
                    end: "pointerup"
                } : window.navigator.msPointerEnabled ? {
                    start: "MSPointerDown",
                    move: "MSPointerMove",
                    end: "MSPointerUp"
                } : {
                    start: "mousedown touchstart",
                    move: "mousemove touchmove",
                    end: "mouseup touchend"
                }, supportsPassive = window.CSS && CSS.supports && CSS.supports("touch-action", "none") && function() {
                    var supportsPassive = !1;
                    try {
                        var opts = Object.defineProperty({}, "passive", {
                            get: function() {
                                supportsPassive = !0;
                            }
                        });
                        window.addEventListener("test", null, opts);
                    } catch (e) {}
                    return supportsPassive;
                }(), scope_Target = target, scope_Spectrum = options.spectrum, scope_Values = [], scope_Locations = [], scope_HandleNumbers = [], scope_ActiveHandlesCount = 0, scope_Events = {}, scope_Document = target.ownerDocument, scope_DocumentElement = options.documentElement || scope_Document.documentElement, scope_Body = scope_Document.body, PIPS_NONE = -1, PIPS_NO_VALUE = 0, PIPS_LARGE_VALUE = 1, PIPS_SMALL_VALUE = 2, scope_DirOffset = "rtl" === scope_Document.dir || 1 === options.ort ? 0 : 100;
                function addNodeTo(addTarget, className) {
                    var div = scope_Document.createElement("div");
                    return className && addClass(div, className), addTarget.appendChild(div), div;
                }
                function addOrigin(base, handleNumber) {
                    var origin = addNodeTo(base, options.cssClasses.origin), handle = addNodeTo(origin, options.cssClasses.handle);
                    return addNodeTo(handle, options.cssClasses.touchArea), handle.setAttribute("data-handle", handleNumber), 
                    options.keyboardSupport && (handle.setAttribute("tabindex", "0"), handle.addEventListener("keydown", function(event) {
                        return function(event, handleNumber) {
                            if (isSliderDisabled() || isHandleDisabled(handleNumber)) return !1;
                            var horizontalKeys = [ "Left", "Right" ], verticalKeys = [ "Down", "Up" ], largeStepKeys = [ "PageDown", "PageUp" ], edgeKeys = [ "Home", "End" ];
                            options.dir && !options.ort ? horizontalKeys.reverse() : options.ort && !options.dir && (verticalKeys.reverse(), 
                            largeStepKeys.reverse());
                            var to, key = event.key.replace("Arrow", ""), isLargeDown = key === largeStepKeys[0], isLargeUp = key === largeStepKeys[1], isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown, isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp, isMax = key === edgeKeys[1];
                            if (!(isDown || isUp || key === edgeKeys[0] || isMax)) return !0;
                            if (event.preventDefault(), isUp || isDown) {
                                var multiplier = options.keyboardPageMultiplier, direction = isDown ? 0 : 1, step = getNextStepsForHandle(handleNumber)[direction];
                                if (null === step) return !1;
                                !1 === step && (step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep)), 
                                (isLargeUp || isLargeDown) && (step *= multiplier), step = Math.max(step, 1e-7), 
                                to = scope_Values[handleNumber] + (step *= isDown ? -1 : 1);
                            } else to = isMax ? options.spectrum.xVal[options.spectrum.xVal.length - 1] : options.spectrum.xVal[0];
                            return setHandle(handleNumber, scope_Spectrum.toStepping(to), !0, !0), fireEvent("slide", handleNumber), 
                            fireEvent("update", handleNumber), fireEvent("change", handleNumber), fireEvent("set", handleNumber), 
                            !1;
                        }(event, handleNumber);
                    })), handle.setAttribute("role", "slider"), handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal"), 
                    0 === handleNumber ? addClass(handle, options.cssClasses.handleLower) : handleNumber === options.handles - 1 && addClass(handle, options.cssClasses.handleUpper), 
                    origin;
                }
                function addConnect(base, add) {
                    return !!add && addNodeTo(base, options.cssClasses.connect);
                }
                function addTooltip(handle, handleNumber) {
                    return !!options.tooltips[handleNumber] && addNodeTo(handle.firstChild, options.cssClasses.tooltip);
                }
                function isSliderDisabled() {
                    return scope_Target.hasAttribute("disabled");
                }
                function isHandleDisabled(handleNumber) {
                    return scope_Handles[handleNumber].hasAttribute("disabled");
                }
                function removeTooltips() {
                    scope_Tooltips && (removeEvent("update.tooltips"), scope_Tooltips.forEach(function(tooltip) {
                        tooltip && removeElement(tooltip);
                    }), scope_Tooltips = null);
                }
                function tooltips() {
                    removeTooltips(), scope_Tooltips = scope_Handles.map(addTooltip), bindEvent("update.tooltips", function(values, handleNumber, unencoded) {
                        if (scope_Tooltips[handleNumber]) {
                            var formattedValue = values[handleNumber];
                            !0 !== options.tooltips[handleNumber] && (formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber])), 
                            scope_Tooltips[handleNumber].innerHTML = formattedValue;
                        }
                    });
                }
                function removePips() {
                    scope_Pips && (removeElement(scope_Pips), scope_Pips = null);
                }
                function pips(grid) {
                    removePips();
                    var mode = grid.mode, filter = grid.filter || !1, spread = function(density, mode, group) {
                        var array, indexes = {}, firstInRange = scope_Spectrum.xVal[0], lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1], ignoreFirst = !1, ignoreLast = !1, prevPct = 0;
                        return (array = group.slice().sort(function(a, b) {
                            return a - b;
                        }), group = array.filter(function(a) {
                            return !this[a] && (this[a] = !0);
                        }, {}))[0] !== firstInRange && (group.unshift(firstInRange), ignoreFirst = !0), 
                        group[group.length - 1] !== lastInRange && (group.push(lastInRange), ignoreLast = !0), 
                        group.forEach(function(current, index) {
                            var step, i, q, newPct, pctDifference, pctPos, type, realSteps, stepSize, low = current, high = group[index + 1], isSteps = "steps" === mode;
                            if (isSteps && (step = scope_Spectrum.xNumSteps[index]), step || (step = high - low), 
                            !1 !== low) for (void 0 === high && (high = low), step = Math.max(step, 1e-7), i = low; i <= high; i = (i + step).toFixed(7) / 1) {
                                for (stepSize = (pctDifference = (newPct = scope_Spectrum.toStepping(i)) - prevPct) / (realSteps = Math.round(pctDifference / density)), 
                                q = 1; q <= realSteps; q += 1) indexes[(pctPos = prevPct + q * stepSize).toFixed(5)] = [ scope_Spectrum.fromStepping(pctPos), 0 ];
                                type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE, 
                                !index && ignoreFirst && i !== high && (type = 0), i === high && ignoreLast || (indexes[newPct.toFixed(5)] = [ i, type ]), 
                                prevPct = newPct;
                            }
                        }), indexes;
                    }(grid.density || 1, mode, function(mode, values, stepped) {
                        if ("range" === mode || "steps" === mode) return scope_Spectrum.xVal;
                        if ("count" === mode) {
                            if (values < 2) throw new Error("noUiSlider (" + VERSION + "): 'values' (>= 2) required for mode 'count'.");
                            var interval = values - 1, spread = 100 / interval;
                            for (values = []; interval--; ) values[interval] = interval * spread;
                            values.push(100), mode = "positions";
                        }
                        return "positions" === mode ? values.map(function(value) {
                            return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                        }) : "values" === mode ? stepped ? values.map(function(value) {
                            return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                        }) : values : void 0;
                    }(mode, grid.values || !1, grid.stepped || !1)), format = grid.format || {
                        to: Math.round
                    };
                    return scope_Pips = scope_Target.appendChild(function(spread, filterFunc, formatter) {
                        var element = scope_Document.createElement("div"), valueSizeClasses = [];
                        valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal, valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge, 
                        valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;
                        var markerSizeClasses = [];
                        markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal, markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge, 
                        markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;
                        var valueOrientationClasses = [ options.cssClasses.valueHorizontal, options.cssClasses.valueVertical ], markerOrientationClasses = [ options.cssClasses.markerHorizontal, options.cssClasses.markerVertical ];
                        function getClasses(type, source) {
                            var a = source === options.cssClasses.value;
                            return source + " " + (a ? valueOrientationClasses : markerOrientationClasses)[options.ort] + " " + (a ? valueSizeClasses : markerSizeClasses)[type];
                        }
                        return addClass(element, options.cssClasses.pips), addClass(element, 0 === options.ort ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical), 
                        Object.keys(spread).forEach(function(offset) {
                            !function(offset, value, type) {
                                if ((type = filterFunc ? filterFunc(value, type) : type) !== PIPS_NONE) {
                                    var node = addNodeTo(element, !1);
                                    node.className = getClasses(type, options.cssClasses.marker), node.style[options.style] = offset + "%", 
                                    type > PIPS_NO_VALUE && ((node = addNodeTo(element, !1)).className = getClasses(type, options.cssClasses.value), 
                                    node.setAttribute("data-value", value), node.style[options.style] = offset + "%", 
                                    node.innerHTML = formatter.to(value));
                                }
                            }(offset, spread[offset][0], spread[offset][1]);
                        }), element;
                    }(spread, filter, format));
                }
                function baseSize() {
                    var rect = scope_Base.getBoundingClientRect(), alt = "offset" + [ "Width", "Height" ][options.ort];
                    return 0 === options.ort ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
                }
                function attachEvent(events, element, callback, data) {
                    var method = function(e) {
                        return !!(e = function(e, pageOffset, eventTarget) {
                            var x, y, touch = 0 === e.type.indexOf("touch"), mouse = 0 === e.type.indexOf("mouse"), pointer = 0 === e.type.indexOf("pointer");
                            if (0 === e.type.indexOf("MSPointer") && (pointer = !0), "mousedown" === e.type && !e.buttons && !e.touches) return !1;
                            if (touch) {
                                var isTouchOnTarget = function(checkTouch) {
                                    return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target) || checkTouch.target.shadowRoot && checkTouch.target.shadowRoot.contains(eventTarget);
                                };
                                if ("touchstart" === e.type) {
                                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                                    if (targetTouches.length > 1) return !1;
                                    x = targetTouches[0].pageX, y = targetTouches[0].pageY;
                                } else {
                                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                                    if (!targetTouch) return !1;
                                    x = targetTouch.pageX, y = targetTouch.pageY;
                                }
                            }
                            return pageOffset = pageOffset || getPageOffset(scope_Document), (mouse || pointer) && (x = e.clientX + pageOffset.x, 
                            y = e.clientY + pageOffset.y), e.pageOffset = pageOffset, e.points = [ x, y ], e.cursor = mouse || pointer, 
                            e;
                        }(e, data.pageOffset, data.target || element)) && !(isSliderDisabled() && !data.doNotReject) && (className = options.cssClasses.tap, 
                        !(((el = scope_Target).classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className)) && !data.doNotReject)) && !(events === actions.start && void 0 !== e.buttons && e.buttons > 1) && (!data.hover || !e.buttons) && (supportsPassive || e.preventDefault(), 
                        e.calcPoint = e.points[options.ort], void callback(e, data));
                        var el, className;
                    }, methods = [];
                    return events.split(" ").forEach(function(eventName) {
                        var options = !!supportsPassive && {
                            passive: !0
                        };
                        element.addEventListener(eventName, method, options), methods.push([ eventName, method, options ]);
                    }), methods;
                }
                function calcPointToPercentage(calcPoint) {
                    var elem, orientation, rect, doc, docElem, pageOffset, proposal = 100 * (calcPoint - (orientation = options.ort, 
                    rect = (elem = scope_Base).getBoundingClientRect(), docElem = (doc = elem.ownerDocument).documentElement, 
                    pageOffset = getPageOffset(doc), /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (pageOffset.x = 0), 
                    orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft)) / baseSize();
                    return proposal = limit(proposal), options.dir ? 100 - proposal : proposal;
                }
                function documentLeave(event, data) {
                    "mouseout" === event.type && "HTML" === event.target.nodeName && null === event.relatedTarget && eventEnd(event, data);
                }
                function eventMove(event, data) {
                    if (-1 === navigator.appVersion.indexOf("MSIE 9") && 0 === event.buttons && 0 !== data.buttonsProperty) return eventEnd(event, data);
                    var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
                    moveHandles(movement > 0, 100 * movement / data.baseSize, data.locations, data.handleNumbers);
                }
                function eventEnd(event, data) {
                    data.handle && (removeClass(data.handle, options.cssClasses.active), scope_ActiveHandlesCount -= 1), 
                    data.listeners.forEach(function(c) {
                        scope_DocumentElement.removeEventListener(c[0], c[1], c[2]);
                    }), 0 === scope_ActiveHandlesCount && (removeClass(scope_Target, options.cssClasses.drag), 
                    setZindex(), event.cursor && (scope_Body.style.cursor = "", scope_Body.removeEventListener("selectstart", preventDefault))), 
                    data.handleNumbers.forEach(function(handleNumber) {
                        fireEvent("change", handleNumber), fireEvent("set", handleNumber), fireEvent("end", handleNumber);
                    });
                }
                function eventStart(event, data) {
                    if (data.handleNumbers.some(isHandleDisabled)) return !1;
                    var handle;
                    1 === data.handleNumbers.length && (scope_ActiveHandlesCount += 1, addClass(handle = scope_Handles[data.handleNumbers[0]].children[0], options.cssClasses.active)), 
                    event.stopPropagation();
                    var listeners = [], moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                        target: event.target,
                        handle,
                        listeners,
                        startCalcPoint: event.calcPoint,
                        baseSize: baseSize(),
                        pageOffset: event.pageOffset,
                        handleNumbers: data.handleNumbers,
                        buttonsProperty: event.buttons,
                        locations: scope_Locations.slice()
                    }), endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                        target: event.target,
                        handle,
                        listeners,
                        doNotReject: !0,
                        handleNumbers: data.handleNumbers
                    }), outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                        target: event.target,
                        handle,
                        listeners,
                        doNotReject: !0,
                        handleNumbers: data.handleNumbers
                    });
                    listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)), event.cursor && (scope_Body.style.cursor = getComputedStyle(event.target).cursor, 
                    scope_Handles.length > 1 && addClass(scope_Target, options.cssClasses.drag), scope_Body.addEventListener("selectstart", preventDefault, !1)), 
                    data.handleNumbers.forEach(function(handleNumber) {
                        fireEvent("start", handleNumber);
                    });
                }
                function bindEvent(namespacedEvent, callback) {
                    scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [], scope_Events[namespacedEvent].push(callback), 
                    "update" === namespacedEvent.split(".")[0] && scope_Handles.forEach(function(a, index) {
                        fireEvent("update", index);
                    });
                }
                function removeEvent(namespacedEvent) {
                    var event = namespacedEvent && namespacedEvent.split(".")[0], namespace = event && namespacedEvent.substring(event.length);
                    Object.keys(scope_Events).forEach(function(bind) {
                        var tEvent = bind.split(".")[0], tNamespace = bind.substring(tEvent.length);
                        event && event !== tEvent || namespace && namespace !== tNamespace || delete scope_Events[bind];
                    });
                }
                function fireEvent(eventName, handleNumber, tap) {
                    Object.keys(scope_Events).forEach(function(targetEvent) {
                        var eventType = targetEvent.split(".")[0];
                        eventName === eventType && scope_Events[targetEvent].forEach(function(callback) {
                            callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || !1, scope_Locations.slice(), scope_Self);
                        });
                    });
                }
                function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
                    var distance;
                    return scope_Handles.length > 1 && !options.events.unconstrained && (lookBackward && handleNumber > 0 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, 0), 
                    to = Math.max(to, distance)), lookForward && handleNumber < scope_Handles.length - 1 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, 1), 
                    to = Math.min(to, distance))), scope_Handles.length > 1 && options.limit && (lookBackward && handleNumber > 0 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, 0), 
                    to = Math.min(to, distance)), lookForward && handleNumber < scope_Handles.length - 1 && (distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, 1), 
                    to = Math.max(to, distance))), options.padding && (0 === handleNumber && (distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], 0), 
                    to = Math.max(to, distance)), handleNumber === scope_Handles.length - 1 && (distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], 1), 
                    to = Math.min(to, distance))), !((to = limit(to = scope_Spectrum.getStep(to))) === reference[handleNumber] && !getValue) && to;
                }
                function inRuleOrder(v, a) {
                    var o = options.ort;
                    return (o ? a : v) + ", " + (o ? v : a);
                }
                function moveHandles(upward, proposal, locations, handleNumbers) {
                    var proposals = locations.slice(), b = [ !upward, upward ], f = [ upward, !upward ];
                    handleNumbers = handleNumbers.slice(), upward && handleNumbers.reverse(), handleNumbers.length > 1 ? handleNumbers.forEach(function(handleNumber, o) {
                        var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], !1);
                        !1 === to ? proposal = 0 : (proposal = to - proposals[handleNumber], proposals[handleNumber] = to);
                    }) : b = f = [ !0 ];
                    var state = !1;
                    handleNumbers.forEach(function(handleNumber, o) {
                        state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
                    }), state && handleNumbers.forEach(function(handleNumber) {
                        fireEvent("update", handleNumber), fireEvent("slide", handleNumber);
                    });
                }
                function transformDirection(a, b) {
                    return options.dir ? 100 - a - b : a;
                }
                function setZindex() {
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        scope_Handles[handleNumber].style.zIndex = 3 + (scope_Handles.length + (scope_Locations[handleNumber] > 50 ? -1 : 1) * handleNumber);
                    });
                }
                function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
                    return exactInput || (to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, !1)), 
                    !1 !== to && (function(handleNumber, to) {
                        scope_Locations[handleNumber] = to, scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
                        var translateRule = "translate(" + inRuleOrder(10 * (transformDirection(to, 0) - scope_DirOffset) + "%", "0") + ")";
                        scope_Handles[handleNumber].style[options.transformRule] = translateRule, updateConnect(handleNumber), 
                        updateConnect(handleNumber + 1);
                    }(handleNumber, to), !0);
                }
                function updateConnect(index) {
                    if (scope_Connects[index]) {
                        var l = 0, h = 100;
                        0 !== index && (l = scope_Locations[index - 1]), index !== scope_Connects.length - 1 && (h = scope_Locations[index]);
                        var connectWidth = h - l, translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")", scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
                        scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
                    }
                }
                function resolveToValue(to, handleNumber) {
                    return null === to || !1 === to || void 0 === to ? scope_Locations[handleNumber] : ("number" == typeof to && (to = String(to)), 
                    to = options.format.from(to), !1 === (to = scope_Spectrum.toStepping(to)) || isNaN(to) ? scope_Locations[handleNumber] : to);
                }
                function valueSet(input, fireSetEvent, exactInput) {
                    var values = asArray(input);
                    fireSetEvent = void 0 === fireSetEvent || !!fireSetEvent, options.animate && !(void 0 === scope_Locations[0]) && addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration), 
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), !0, !1, exactInput);
                    });
                    for (var i = 1 === scope_HandleNumbers.length ? 0 : 1; i < scope_HandleNumbers.length; ++i) scope_HandleNumbers.forEach(function(handleNumber) {
                        setHandle(handleNumber, scope_Locations[handleNumber], !0, !0, exactInput);
                    });
                    setZindex(), scope_HandleNumbers.forEach(function(handleNumber) {
                        fireEvent("update", handleNumber), null !== values[handleNumber] && fireSetEvent && fireEvent("set", handleNumber);
                    });
                }
                function valueGet() {
                    var values = scope_Values.map(options.format.to);
                    return 1 === values.length ? values[0] : values;
                }
                function getNextStepsForHandle(handleNumber) {
                    var location = scope_Locations[handleNumber], nearbySteps = scope_Spectrum.getNearbySteps(location), value = scope_Values[handleNumber], increment = nearbySteps.thisStep.step, decrement = null;
                    if (options.snap) return [ value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null ];
                    !1 !== increment && value + increment > nearbySteps.stepAfter.startValue && (increment = nearbySteps.stepAfter.startValue - value), 
                    decrement = value > nearbySteps.thisStep.startValue ? nearbySteps.thisStep.step : !1 !== nearbySteps.stepBefore.step && value - nearbySteps.stepBefore.highestStep, 
                    100 === location ? increment = null : 0 === location && (decrement = null);
                    var stepDecimals = scope_Spectrum.countStepDecimals();
                    return null !== increment && !1 !== increment && (increment = Number(increment.toFixed(stepDecimals))), 
                    null !== decrement && !1 !== decrement && (decrement = Number(decrement.toFixed(stepDecimals))), 
                    [ decrement, increment ];
                }
                return addClass(addTarget = scope_Target, options.cssClasses.target), addClass(addTarget, 0 === options.dir ? options.cssClasses.ltr : options.cssClasses.rtl), 
                addClass(addTarget, 0 === options.ort ? options.cssClasses.horizontal : options.cssClasses.vertical), 
                addClass(addTarget, "rtl" === getComputedStyle(addTarget).direction ? options.cssClasses.textDirectionRtl : options.cssClasses.textDirectionLtr), 
                scope_Base = addNodeTo(addTarget, options.cssClasses.base), function(connectOptions, base) {
                    var connectBase = addNodeTo(base, options.cssClasses.connects);
                    scope_Handles = [], (scope_Connects = []).push(addConnect(connectBase, connectOptions[0]));
                    for (var i = 0; i < options.handles; i++) scope_Handles.push(addOrigin(base, i)), 
                    scope_HandleNumbers[i] = i, scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
                }(options.connect, scope_Base), (behaviour = options.events).fixed || scope_Handles.forEach(function(handle, index) {
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [ index ]
                    });
                }), behaviour.tap && attachEvent(actions.start, scope_Base, function(event) {
                    event.stopPropagation();
                    var proposal = calcPointToPercentage(event.calcPoint), handleNumber = function(clickedPosition) {
                        var smallestDifference = 100, handleNumber = !1;
                        return scope_Handles.forEach(function(handle, index) {
                            if (!isHandleDisabled(index)) {
                                var handlePosition = scope_Locations[index], differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
                                (differenceWithThisHandle < smallestDifference || differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition || 100 === differenceWithThisHandle && 100 === smallestDifference) && (handleNumber = index, 
                                smallestDifference = differenceWithThisHandle);
                            }
                        }), handleNumber;
                    }(proposal);
                    if (!1 === handleNumber) return !1;
                    options.events.snap || addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration), 
                    setHandle(handleNumber, proposal, !0, !0), setZindex(), fireEvent("slide", handleNumber, !0), 
                    fireEvent("update", handleNumber, !0), fireEvent("change", handleNumber, !0), fireEvent("set", handleNumber, !0), 
                    options.events.snap && eventStart(event, {
                        handleNumbers: [ handleNumber ]
                    });
                }, {}), behaviour.hover && attachEvent(actions.move, scope_Base, function(event) {
                    var proposal = calcPointToPercentage(event.calcPoint), to = scope_Spectrum.getStep(proposal), value = scope_Spectrum.fromStepping(to);
                    Object.keys(scope_Events).forEach(function(targetEvent) {
                        "hover" === targetEvent.split(".")[0] && scope_Events[targetEvent].forEach(function(callback) {
                            callback.call(scope_Self, value);
                        });
                    });
                }, {
                    hover: !0
                }), behaviour.drag && scope_Connects.forEach(function(connect, index) {
                    if (!1 !== connect && 0 !== index && index !== scope_Connects.length - 1) {
                        var handleBefore = scope_Handles[index - 1], handleAfter = scope_Handles[index], eventHolders = [ connect ];
                        addClass(connect, options.cssClasses.draggable), behaviour.fixed && (eventHolders.push(handleBefore.children[0]), 
                        eventHolders.push(handleAfter.children[0])), eventHolders.forEach(function(eventHolder) {
                            attachEvent(actions.start, eventHolder, eventStart, {
                                handles: [ handleBefore, handleAfter ],
                                handleNumbers: [ index - 1, index ]
                            });
                        });
                    }
                }), valueSet(options.start), options.pips && pips(options.pips), options.tooltips && tooltips(), 
                bindEvent("update", function(values, handleNumber, unencoded, tap, positions) {
                    scope_HandleNumbers.forEach(function(index) {
                        var handle = scope_Handles[index], min = checkHandlePosition(scope_Locations, index, 0, !0, !0, !0), max = checkHandlePosition(scope_Locations, index, 100, !0, !0, !0), now = positions[index];
                        options.ariaFormat.to(unencoded[index]), min = scope_Spectrum.fromStepping(min).toFixed(0), 
                        max = scope_Spectrum.fromStepping(max).toFixed(0), now = scope_Spectrum.fromStepping(now).toFixed(0), 
                        handle.children[0].setAttribute("aria-valuemin", min), handle.children[0].setAttribute("aria-valuemax", max), 
                        handle.children[0].setAttribute("aria-valuenow", now);
                    });
                }), scope_Self = {
                    destroy: function() {
                        for (var key in options.cssClasses) options.cssClasses.hasOwnProperty(key) && removeClass(scope_Target, options.cssClasses[key]);
                        for (;scope_Target.firstChild; ) scope_Target.removeChild(scope_Target.firstChild);
                        delete scope_Target.noUiSlider;
                    },
                    steps: function() {
                        return scope_HandleNumbers.map(getNextStepsForHandle);
                    },
                    on: bindEvent,
                    off: removeEvent,
                    get: valueGet,
                    set: valueSet,
                    setHandle: function(handleNumber, value, fireSetEvent, exactInput) {
                        if (!((handleNumber = Number(handleNumber)) >= 0 && handleNumber < scope_HandleNumbers.length)) throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);
                        setHandle(handleNumber, resolveToValue(value, handleNumber), !0, !0, exactInput), 
                        fireEvent("update", handleNumber), fireSetEvent && fireEvent("set", handleNumber);
                    },
                    reset: function(fireSetEvent) {
                        valueSet(options.start, fireSetEvent);
                    },
                    __moveHandles: function(a, b, c) {
                        moveHandles(a, b, scope_Locations, c);
                    },
                    options: originalOptions,
                    updateOptions: function(optionsToUpdate, fireSetEvent) {
                        var v = valueGet(), updateAble = [ "margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips" ];
                        updateAble.forEach(function(name) {
                            void 0 !== optionsToUpdate[name] && (originalOptions[name] = optionsToUpdate[name]);
                        });
                        var newOptions = testOptions(originalOptions);
                        updateAble.forEach(function(name) {
                            void 0 !== optionsToUpdate[name] && (options[name] = newOptions[name]);
                        }), scope_Spectrum = newOptions.spectrum, options.margin = newOptions.margin, options.limit = newOptions.limit, 
                        options.padding = newOptions.padding, options.pips ? pips(options.pips) : removePips(), 
                        options.tooltips ? tooltips() : removeTooltips(), scope_Locations = [], valueSet(optionsToUpdate.start || v, fireSetEvent);
                    },
                    target: scope_Target,
                    removePips,
                    removeTooltips,
                    getTooltips: function() {
                        return scope_Tooltips;
                    },
                    getOrigins: function() {
                        return scope_Handles;
                    },
                    pips
                };
            }
            return {
                __spectrum: Spectrum,
                version: VERSION,
                cssClasses,
                create: function(target, originalOptions) {
                    if (!target || !target.nodeName) throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
                    if (target.noUiSlider) throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
                    var api = scope(target, testOptions(originalOptions), originalOptions);
                    return target.noUiSlider = api, api;
                }
            };
        }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, []) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
    },
    87592: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            VT: function() {
                return DefaultSlicerProperties;
            },
            OQ: function() {
                return convert;
            }
        });
        var tslib_es6 = __webpack_require__(81337), slicer_capabilities = __webpack_require__(9434), common_colorHelper = __webpack_require__(90120), fontProperties = __webpack_require__(18664), units = __webpack_require__(32105), outline = __webpack_require__(40550), slicerExpandCollapseToggle = __webpack_require__(36265), visualWarnings = __webpack_require__(45296), debug = __webpack_require__(62458), fontUtils = __webpack_require__(38265), urlUtils = __webpack_require__(48066), formatUtil = __webpack_require__(59694), dataViewObject2 = __webpack_require__(82755), dataViewScopeIdentity = __webpack_require__(78843), valueFormatter = __webpack_require__(72489), selectionId = __webpack_require__(26543), filterScopeIdsCollector = __webpack_require__(1629), semanticQuery = __webpack_require__(95462), sqExpr = __webpack_require__(94419), sqExprVisitor = __webpack_require__(75074), sqExprEqualityVisitor = __webpack_require__(45413), slicerUtil1 = __webpack_require__(68447), converterHelper = __webpack_require__(54522), SlicerCategoricalDataReader = function() {
            function SlicerCategoricalDataReader(categorical, columns, selectedDataPoints) {
                this.columns = columns, this.selectedDataPoints = selectedDataPoints, this.column = categorical && !_.isEmpty(categorical.categories) ? categorical.categories[0] : null, 
                this.column && (this.objects = this.column.objects), this.count = this.column && this.column.values ? this.column.values.length : 0, 
                this.isImage = (0, converterHelper.pt)(this.columns[0]);
            }
            return SlicerCategoricalDataReader.prototype.getDataPointsCount = function() {
                return this.count;
            }, SlicerCategoricalDataReader.prototype.getMetadataColumn = function() {
                return this.column && this.column.source || this.columns[0];
            }, SlicerCategoricalDataReader.prototype.getDataViewDataPoint = function(index) {
                var count, _this = this;
                return debug.fF.assert(function() {
                    return index <= _this.count;
                }, ".getDataViewDataPoint index is out of bounds"), this.objects && (count = (0, 
                dataViewObject2.NA)(this.objects[index], slicer_capabilities.gO.general.count, count)), 
                {
                    scopeId: this.column.identity[index],
                    count,
                    value: this.column.values[index],
                    levelCount: this.count
                };
            }, SlicerCategoricalDataReader.prototype.isImageData = function() {
                return this.isImage;
            }, SlicerCategoricalDataReader.prototype.getLevel = function() {
                return 0;
            }, SlicerCategoricalDataReader.prototype.hasCount = function() {
                return !_.isEmpty(this.objects);
            }, SlicerCategoricalDataReader.prototype.getSelectedNodes = function() {
                return this.selectedDataPoints;
            }, SlicerCategoricalDataReader.prototype.getMetadataColumns = function() {
                return this.column && [ this.column.source ];
            }, SlicerCategoricalDataReader.prototype.getIdentityExprs = function() {
                return this.column && this.column.identityFields && [ this.column.identityFields ];
            }, SlicerCategoricalDataReader;
        }(), advancedSlicer_capabilities = __webpack_require__(62283), tileLibrary_capabilities = __webpack_require__(93187), SlicerMatrixDataReader = function() {
            function SlicerMatrixDataReader(matrix, metadataColumns, root, selectedDataPoints) {
                this.matrix = matrix, this.metadataColumns = metadataColumns, this.root = root, 
                this.selectedDataPoints = selectedDataPoints, this.root = root, this.level = root && root.level + 1 || 0, 
                this.root || (this.root = matrix && matrix.rows && matrix.rows.root, this.root && !_.isEmpty(matrix.rows.levels) && (this.metadata = matrix.rows.levels[this.level].sources[0], 
                this.metadata && (this.isImageUrlColumn = (0, converterHelper.pt)(this.metadata)))), 
                this.valueSources = null == matrix ? void 0 : matrix.valueSources, this.count = this.root && this.root.children && this.root.children.length || 0;
            }
            return SlicerMatrixDataReader.prototype.getDataPointsCount = function() {
                return this.count;
            }, SlicerMatrixDataReader.prototype.getMetadataColumn = function() {
                return this.metadata || this.metadataColumns[this.level];
            }, SlicerMatrixDataReader.prototype.getDataViewDataPoint = function(index) {
                var value, _this = this;
                debug.fF.assert(function() {
                    return index < _this.count && index >= 0;
                }, ".getDataViewDataPoint index is out of bounds");
                var node = this.root.children[index];
                if (!node.isSubtotal) {
                    var reader;
                    if (debug.fF.assert(function() {
                        return 1 === node.levelValues.length;
                    }, ".getDataViewDataPoint does not expect levelValues to have more than one value."), 
                    _.some(node.children, function(child) {
                        return !child.isSubtotal;
                    })) {
                        var filterNode = _.find(this.selectedDataPoints, function(selected) {
                            return (0, dataViewScopeIdentity.fS)(selected.identity, node.identity);
                        });
                        reader = new SlicerMatrixDataReader(this.matrix, this.metadataColumns, node, filterNode && filterNode.children);
                    }
                    value = node.levelValues[0].value;
                    var imageUrl, hasDefaultInstanceImage = !_.isEmpty((0, dataViewObject2.NA)(node.objects, advancedSlicer_capabilities.yD.image.image, void 0, "default"));
                    this.isImage = !hasDefaultInstanceImage && 1 === this.metadataColumns.length && this.isImageUrlColumn, 
                    this.isImage && (imageUrl = (0, valueFormatter.WU)(value));
                    var tooltipInfo = this.readTooltipInfo(node), levelCount = this.count;
                    return this.root && this.root.children && (levelCount = _.filter(this.root.children, function(child) {
                        return !child.isSubtotal && child.level === node.level;
                    }).length), {
                        scopeId: node.identity,
                        isCollapsed: node.isCollapsed,
                        value,
                        childrenReader: reader,
                        tooltipInfo,
                        imageUrl,
                        label: this.readLabelValue(node.objects),
                        objects: node.objects,
                        levelCount
                    };
                }
            }, SlicerMatrixDataReader.prototype.isImageData = function() {
                return this.isImage;
            }, SlicerMatrixDataReader.prototype.getLevel = function() {
                return this.level;
            }, SlicerMatrixDataReader.prototype.hasCount = function() {
                return !1;
            }, SlicerMatrixDataReader.prototype.getSelectedNodes = function() {
                return this.selectedDataPoints;
            }, SlicerMatrixDataReader.prototype.getMetadataColumns = function() {}, SlicerMatrixDataReader.prototype.getIdentityExprs = function() {
                return this.metadataColumns && _.map(this.metadataColumns, function(column) {
                    return column.identityExprs;
                });
            }, SlicerMatrixDataReader.prototype.readLabelValue = function(objects) {
                if (objects) return (0, dataViewObject2.NA)(objects, tileLibrary_capabilities.OV.label.field);
            }, SlicerMatrixDataReader.prototype.readTooltipInfo = function(node) {
                var _a, tooltipInfo;
                if (!_.isEmpty(node.values)) for (var valueIndex in node.values) {
                    var instanceValue = node.values[valueIndex], instanceIndex = null !== (_a = instanceValue.valueSourceIndex) && void 0 !== _a ? _a : 0, dynamicFormatString = (0, 
                    dataViewObject2.NA)(instanceValue.objects, advancedSlicer_capabilities.yD.general.formatString), valueSource = this.valueSources[instanceIndex];
                    (tooltipInfo = tooltipInfo || []).push({
                        displayName: valueSource.displayName,
                        value: (0, converterHelper.xq)(instanceValue.value, valueSource, advancedSlicer_capabilities.yD.general.formatString, !1, dynamicFormatString)
                    });
                }
                return tooltipInfo;
            }, SlicerMatrixDataReader;
        }(), SlicerDataViewReader = function() {
            function SlicerDataViewReader(dataView, listJoinSeparator, selectedDataPoints) {
                this.dataView = dataView, this.listJoinSeparator = listJoinSeparator, this.initMetadataColumns(), 
                this.reader = dataView.categorical ? new SlicerCategoricalDataReader(dataView.categorical, this.columns, selectedDataPoints) : new SlicerMatrixDataReader(dataView.matrix, this.columns, void 0, selectedDataPoints);
            }
            return SlicerDataViewReader.prototype.getIdentityFields = function() {
                var columns = this.getMetadataColumns();
                return this.reader.getIdentityExprs() || _.map(columns, function(column) {
                    return column.identityExprs;
                });
            }, SlicerDataViewReader.prototype.getDataPointsReader = function() {
                return this.reader;
            }, SlicerDataViewReader.prototype.hasGroupOnKeys = function() {
                var columns = this.getMetadataColumns();
                if (_.isEmpty(columns)) return !1;
                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    if (!_.isEmpty(column.identityExprs) && !_.isEmpty(column.expr) && (column.identityExprs.length > 1 || !(0, 
                    sqExprEqualityVisitor.fS)(column.identityExprs[0], column.expr))) return !0;
                }
                return !1;
            }, SlicerDataViewReader.prototype.getQueryNamePerLevel = function() {
                var columns = this.getMetadataColumns();
                return _.map(columns, function(column) {
                    return column.queryName;
                });
            }, SlicerDataViewReader.prototype.getDisplayNamePerLevel = function() {
                var columns = this.getMetadataColumns();
                return _.map(columns, function(column) {
                    return column.displayName;
                });
            }, SlicerDataViewReader.prototype.getDisplayName = function() {
                var displayNames = this.getDisplayNamePerLevel();
                return _.join(displayNames, this.listJoinSeparator);
            }, SlicerDataViewReader.prototype.getColumns = function() {
                return this.columns;
            }, SlicerDataViewReader.prototype.getMetadataColumnByLevel = function(index) {
                return this.columns[index];
            }, SlicerDataViewReader.prototype.getMetadataColumns = function() {
                return this.reader.getMetadataColumns() || this.columns;
            }, SlicerDataViewReader.prototype.initMetadataColumns = function() {
                this.columns = (0, slicerUtil1.zJ)(this.dataView.metadata.columns);
            }, SlicerDataViewReader;
        }(), sqExprStaticMembers = __webpack_require__(74082), getDataViewScopeIdentityComparisonExpr = __webpack_require__(3222), isDefaultValue = __webpack_require__(18885), slicerSelectionHandler = __webpack_require__(83611), SlicerFilterAnalyzer = function() {
            function SlicerFilterAnalyzer(options, avoidDefaultValue) {
                this.hasMappedColumn = !1, this.filter = options.filter, this.isNotFilter = !1, 
                this.analyze(options, avoidDefaultValue);
            }
            return SlicerFilterAnalyzer.prototype.analyze = function(options, avoidDefaultValue) {
                var _this = this;
                if (this.hasMappedColumn = (0, slicerUtil1.R6)({
                    columns: options.columns
                }), this.isAnyFilter = semanticQuery.yl.isAnyFilter(this.filter), !this.isAnyFilter) {
                    var fieldSQExprsPerLevel = options.fieldSQExprs;
                    if (this.filter) {
                        var filterNodes = (0, filterScopeIdsCollector.Gl)(this.filter, fieldSQExprsPerLevel);
                        if (filterNodes) {
                            if (this.isNotFilter = _.some(filterNodes, function(filterNode) {
                                return !filterNode.selected;
                            }), this.hasMappedColumn) {
                                var hasBlankFilter = _.some(filterNodes, function(filterNode) {
                                    return _this.isSQExprBlank(filterNode);
                                });
                                (this.isNotFilter || hasBlankFilter) && (this.isNotFilter = !1, this.filter = void 0);
                            }
                            this.selectedIdentities = filterNodes, this.isDefaultFilter = 1 === this.selectedIdentities.length && (0, 
                            isDefaultValue.F)(this.selectedIdentities[0].identity.expr);
                        }
                    }
                    if (this.defaultValueByLevel = this.getDataViewDefaultValuePerLevel(options.columns, options.defaultValuePropertyId), 
                    !_.isEmpty(_.compact(this.defaultValueByLevel)) && !avoidDefaultValue && (this.filter || (this.filter = slicerSelectionHandler.N.buildDefaultValueFilter(options.columns), 
                    this.selectedIdentities = (0, filterScopeIdsCollector.Gl)(this.filter, fieldSQExprsPerLevel), 
                    this.isDefaultFilter = !0), this.isDefaultFilter && !_.isEmpty(this.selectedIdentities))) for (var node_1 = this.selectedIdentities[0], level = 0; node_1; ) {
                        var defaultValueScopeIdentity = (0, dataViewScopeIdentity.TZ)((0, getDataViewScopeIdentityComparisonExpr.R)(fieldSQExprsPerLevel[level], this.defaultValueByLevel[level].identityFieldsValues));
                        this.isNotFilter = !1, node_1.identity = defaultValueScopeIdentity, debug.fF.assert(function() {
                            return _.isEmpty(node_1.children) || 1 === node_1.children.length;
                        }, "Default value filter can not have more than single node per level"), node_1 = _.isEmpty(node_1.children) ? void 0 : node_1.children[0], 
                        level++;
                    }
                }
            }, SlicerFilterAnalyzer.prototype.isSQExprBlank = function(filterNode) {
                var expr = filterNode.identity.expr;
                return !!(0, sqExprStaticMembers.$Q)(expr) && (0, sqExprStaticMembers.WC)(expr);
            }, SlicerFilterAnalyzer.prototype.getDataViewDefaultValuePerLevel = function(columns, defaultValueProperty) {
                if (!_.isEmpty(columns)) return _.map(columns, function(column) {
                    return (0, dataViewObject2.NA)(column.objects, defaultValueProperty);
                });
            }, SlicerFilterAnalyzer;
        }(), DefaultSlicerOutlineColorName = "foregroundNeutralSecondaryAlt2", DefaultSlicerTextColorName = "foregroundNeutralSecondary", DefaultSlicerBorderColorSearch = "#C8C8C8", DefaultBackgroundColorSearch = "#ffffff";
        function DefaultSlicerProperties(style) {
            return {
                general: {
                    outlineWeight: 1,
                    outlineColor: common_colorHelper.v.getThemeColor(style, DefaultSlicerOutlineColorName)
                },
                slicerText: {
                    color: common_colorHelper.v.getThemeColor(style, DefaultSlicerTextColorName),
                    outlineStyle: outline.$m.Nil,
                    textSize: 10,
                    fontFamily: fontUtils.Wn.regular.css,
                    labelBold: !1,
                    labelItalic: !1,
                    labelUnderline: !1
                },
                selection: (0, slicerUtil1.Cq)(),
                search: {
                    enabled: !1,
                    outlineStyle: outline.$m.Bottom,
                    borderColor: DefaultSlicerBorderColorSearch,
                    background: DefaultBackgroundColorSearch
                },
                expandCollapse: {
                    indentation: 15,
                    visible: !0,
                    toggleType: slicerExpandCollapseToggle.H.Chevron
                },
                items: {
                    padding: void 0,
                    accessibilityContrastProperties: !1
                }
            };
        }
        function convert(options) {
            var dataView = options.dataView, hostServices = options.hostServices, selectionHandler = options.selectionHandler;
            if (debug.fF.assertValue(hostServices, "hostServices"), dataView && dataView.metadata && !_.isEmpty(dataView.metadata.columns)) {
                var listSeparator = hostServices.getLocalizedString("ListJoin_Separator"), dataViewReader = new SlicerDataViewReader(dataView, hostServices.getLocalizedString("ListJoin_Separator")), identityFields = dataViewReader.getIdentityFields();
                if (!_.isEmpty(identityFields)) {
                    var filter = dataView.metadata && dataView.metadata.objects && (0, dataViewObject2.NA)(dataView.metadata.objects, slicer_capabilities.gO.general.filter), columns = dataViewReader.getColumns(), analyzer = new SlicerFilterAnalyzer({
                        columns,
                        defaultValuePropertyId: slicer_capabilities.gO.general.defaultValue,
                        filter,
                        fieldSQExprs: identityFields
                    }, hostServices.ignoreDefaultFilter());
                    _.isEmpty(analyzer.selectedIdentities) || (dataViewReader = new SlicerDataViewReader(dataView, listSeparator, analyzer.selectedIdentities));
                    var shouldDisableSelectAll = analyzer.hasMappedColumn && !(0, slicerUtil1.Wm)({
                        columns
                    });
                    !function(originalFilter, analyzer, selectionHandler, hostServices, shouldDisableSelectAll) {
                        var analyzedSemanticFilter = analyzer.filter, isInvertedSelectionMode = selectionHandler.isSelectionModeInverted();
                        if (analyzedSemanticFilter && !semanticQuery.yl.isSameFilter(analyzedSemanticFilter, originalFilter)) {
                            selectionHandler.handleClearSelection();
                            var filterPropertyIdentifier = slicer_capabilities.gO.general.filter, properties = {};
                            properties[filterPropertyIdentifier.propertyName] = analyzer.filter, hostServices.persistProperties({
                                merge: [ {
                                    objectName: filterPropertyIdentifier.objectName,
                                    selector: void 0,
                                    properties
                                } ]
                            });
                        }
                        !shouldDisableSelectAll || !isInvertedSelectionMode && semanticQuery.yl.isSameFilter(analyzedSemanticFilter, originalFilter) || (0, 
                        slicerUtil1.K5)(selectionHandler, !1);
                    }(filter, analyzer, selectionHandler, hostServices, shouldDisableSelectAll), selectionHandler.setColumns(dataViewReader.getColumns()), 
                    selectionHandler.setQueryNameByLevel(dataViewReader.getQueryNamePerLevel());
                    var slicerData = function(analyzer, dataViewMetadata, dataReader, options, shouldDisableSelectAll) {
                        var hostServices = options.hostServices, selectionHandler = options.selectionHandler, style = options.style, localizedSelectAllText = options.localizedSelectAllText, localizedDeselectAllText = options.localizedDeselectAllText, isSlicer = options.isSlicer ?? !1, isInvertedSelectionMode = null != selectionHandler && selectionHandler.isSelectionModeInverted();
                        isInvertedSelectionMode = analyzer.filter ? analyzer.isAnyFilter ? (0, dataViewObject2.NA)(dataViewMetadata.objects, slicer_capabilities.gO.data.isInvertedSelectionMode, isInvertedSelectionMode) : analyzer.isNotFilter : !analyzer.hasMappedColumn && (0, 
                        dataViewObject2.NA)(dataViewMetadata.objects, slicer_capabilities.gO.data.isInvertedSelectionMode, isInvertedSelectionMode);
                        var defaultSettings = function(dataViewMetadata, style, slicerType) {
                            var defaultSettings = DefaultSlicerProperties(style), objects = dataViewMetadata.objects, colorHelper = common_colorHelper.v.create(style);
                            if (objects) {
                                defaultSettings.items.accessibilityContrastProperties = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.accessibilityContrastProperties, !1);
                                var defaultTextClass = "lightLabel", defaultTextColor = "foregroundNeutralSecondary";
                                defaultSettings.items.accessibilityContrastProperties && 0 === slicerType && (defaultTextColor = "foreground", 
                                defaultTextClass = "largeLightLabel");
                                var slicerItemTextFontProperties = (0, fontProperties.Zi)((0, dataViewObject2.RK)(objects, "items"), {
                                    color: "fontColor",
                                    family: "fontFamily",
                                    size: "textSize"
                                }, colorHelper, style, defaultTextColor, defaultTextClass, {
                                    color: defaultSettings.slicerText.color,
                                    family: defaultSettings.slicerText.fontFamily,
                                    size: units.B.createFromPt(defaultSettings.slicerText.textSize)
                                }, !0);
                                defaultSettings.slicerText.color = slicerItemTextFontProperties.color, defaultSettings.slicerText.fontFamily = slicerItemTextFontProperties.family, 
                                defaultSettings.slicerText.textSize = slicerItemTextFontProperties.size.pt, defaultSettings.items.accessibilityContrastProperties && 1 === slicerType && (defaultSettings.slicerText.outlineStyle = outline.$m.Top | outline.$m.Bottom | outline.$m.Left | outline.$m.Right), 
                                defaultSettings.slicerText.outlineStyle = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.outlineStyle, defaultSettings.slicerText.outlineStyle);
                                var textBackground = colorHelper.getColorForProperty(objects, slicer_capabilities.gO.items.background, void 0);
                                textBackground && (defaultSettings.slicerText.background = textBackground), defaultSettings.search.enabled = (0, 
                                dataViewObject2.NA)(objects, slicer_capabilities.gO.general.selfFilterEnabled, defaultSettings.search.enabled), 
                                defaultSettings.search.outlineStyle = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.searchBox.outlineStyle, defaultSettings.search.outlineStyle), 
                                defaultSettings.search.borderColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.searchBox.borderColor, defaultSettings.search.borderColor);
                                var searchBackground = colorHelper.getColorForProperty(objects, slicer_capabilities.gO.searchBox.background, void 0);
                                defaultSettings.search.background = searchBackground || defaultSettings.slicerText.background || defaultSettings.search.background, 
                                defaultSettings.expandCollapse.toggleType = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.expandCollapseToggleType, defaultSettings.expandCollapse.toggleType), 
                                defaultSettings.expandCollapse.indentation = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.steppedLayoutIndentation, defaultSettings.expandCollapse.indentation), 
                                defaultSettings.general.outlineWeight = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.general.outlineWeight, defaultSettings.general.outlineWeight), 
                                defaultSettings.general.outlineColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.general.outlineColor, defaultSettings.general.outlineColor), 
                                defaultSettings.selection.selectAllCheckboxEnabled = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.selection.selectAllCheckboxEnabled, defaultSettings.selection.selectAllCheckboxEnabled), 
                                defaultSettings.selection.singleSelect = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.selection.singleSelect, defaultSettings.selection.singleSelect), 
                                defaultSettings.selection.strictSingleSelect = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.selection.strictSingleSelect, defaultSettings.selection.strictSingleSelect), 
                                defaultSettings.slicerText.labelBold = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.bold, !1), 
                                defaultSettings.slicerText.labelItalic = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.italic, !1), 
                                defaultSettings.slicerText.labelUnderline = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.underline, !1), 
                                defaultSettings.items.padding = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.items.padding, void 0);
                            }
                            return defaultSettings;
                        }(dataViewMetadata, style, options.slicerType);
                        selectionHandler && (selectionHandler.setSelectionModeInverted(isInvertedSelectionMode), 
                        selectionHandler.setDefaultValueMode(semanticQuery.yl.isDefaultFilter(analyzer.filter)));
                        var queryNamePerLevel = dataReader.getQueryNamePerLevel(), cache = hostServices.getFilterExpressionMetadata(), retainedDataPoints = [], sortableRetainedDataPoints = [], slicerDataPoints = readSlicerDataPoints(dataReader, dataReader.getDataPointsReader(), retainedDataPoints, sortableRetainedDataPoints, hostServices, queryNamePerLevel, cache, {
                            calculatedIndex: 0
                        }, void 0, analyzer, options.featureSwitches, options.valueSettings, options.hideRetainedDataPoints);
                        if (sortableRetainedDataPoints.length > 0) {
                            var sortedRetainedDataPoints = _.chain(sortableRetainedDataPoints).sort(compareSelectedDataPoints).map(function(d) {
                                return d.dataPoint;
                            }).value();
                            retainedDataPoints = retainedDataPoints.concat(sortedRetainedDataPoints);
                        }
                        var metadata = selectionHandler.toFilterExpressionMetadata(retainedDataPoints);
                        hostServices.setFilterExpressionMetadata(metadata);
                        var searchKey = function(dataViewMetadata) {
                            var selfFilter = (0, dataViewObject2.NA)(dataViewMetadata.objects, slicer_capabilities.gO.general.selfFilter, void 0);
                            if (!selfFilter) return "";
                            var filterItems = selfFilter.conditions();
                            debug.fF.assert(function() {
                                return 1 === filterItems.length;
                            }, "There should be exactly 1 filter expression.");
                            var containsFilter = filterItems[0];
                            if (containsFilter) {
                                var containsValueVisitor = new ConditionsFilterValueVisitor;
                                return containsFilter.accept(containsValueVisitor), containsValueVisitor.getValueForField();
                            }
                        }(dataViewMetadata), selection = defaultSettings.selection, strictSingleSelect = selection.strictSingleSelect;
                        if (!strictSingleSelect && isSlicer && selectionHandler.isDisableMultipleSelectForMappedColumn() && (strictSingleSelect = !0, 
                        defaultSettings.selection.strictSingleSelect = !0), selection.selectAllCheckboxEnabled && !strictSingleSelect && _.isEmpty(searchKey)) {
                            var tooltipValue = shouldDisableSelectAll ? hostServices.getLocalizedString("DQP_Disabled_SelectAll") : localizedSelectAllText;
                            slicerDataPoints.unshift({
                                value: isInvertedSelectionMode && localizedDeselectAllText ? localizedDeselectAllText : localizedSelectAllText,
                                tooltip: tooltipValue,
                                identity: selectionId.l0.createWithMeasure(localizedSelectAllText),
                                selected: !1,
                                isSelectAllDataPoint: !0,
                                partially: retainedDataPoints.length > 0,
                                count: void 0,
                                disabled: shouldDisableSelectAll,
                                levelIndex: 0,
                                levelCount: void 0,
                                index: 0,
                                id: "0:0"
                            });
                        }
                        return selectionHandler && selectionHandler.setStrictSingleSelect(strictSingleSelect, _.isEmpty(retainedDataPoints) ? slicerDataPoints : retainedDataPoints), 
                        {
                            categorySourceName: dataReader.getDisplayName(),
                            slicerSettings: defaultSettings,
                            slicerDataPoints,
                            defaultValueByLevel: analyzer.defaultValueByLevel,
                            searchKey,
                            restatement: getRestatement(hostServices, retainedDataPoints, isInvertedSelectionMode, dataReader.getColumns()),
                            warnings: new visualWarnings.tb,
                            retainedDataPoints,
                            queryNameByLevel: queryNamePerLevel,
                            hasGroupOnKeys: dataReader.hasGroupOnKeys()
                        };
                    }(analyzer, dataView.metadata, dataViewReader, options, shouldDisableSelectAll);
                    return slicerData.hasImages = _.some(slicerData.slicerDataPoints, function(slicerDatePoint) {
                        return slicerDatePoint.isImage;
                    }), slicerData;
                }
            }
        }
        function readSlicerDataPoints(dataReader, dataLevelReader, selectedDataPoints, sortableSelectedDataPoints, hostServices, queryNamePerLevel, cache, slicerIndex, parent, analyzer, featureSwitches, valueSettings, hideRetainedDataPoints) {
            for (var selectedFilterNodes = dataLevelReader.getSelectedNodes(), categoryValuesLen = dataLevelReader.getDataPointsCount(), slicerDataPoints = [], source = dataLevelReader.getMetadataColumn(), isFieldParameterAsData = Boolean(featureSwitches && featureSwitches.fieldParameters && source.parameter && 2 === source.parameter.kind), formatString = (0, 
            valueFormatter.EO)(source, slicer_capabilities.gO.general.formatString), level = dataLevelReader.getLevel(), levelIndex = 0, i = 0; i < categoryValuesLen; i++) {
                var dataPoint = dataLevelReader.getDataViewDataPoint(i);
                if (dataPoint) {
                    levelIndex++, slicerIndex.calculatedIndex++;
                    var label, selectedFilterNode = (0, slicerUtil1.X$)(dataPoint.scopeId, selectedFilterNodes);
                    label = valueSettings ? formatValue(dataPoint.value, valueSettings, source) : (0, 
                    valueFormatter.WU)(dataPoint.value, formatString);
                    var isImage = dataLevelReader.isImageData() && (0, urlUtils.gU)(label), tooltip = label, shouldDisable = !1, id = level + ":" + levelIndex;
                    (null == analyzer ? void 0 : analyzer.hasMappedColumn) && null == dataPoint.value && (shouldDisable = !0, 
                    tooltip = hostServices.getLocalizedString("DQP_Disabled_Blank"));
                    var slicerData = {
                        value: label,
                        tooltip,
                        identity: null,
                        selected: null != selectedFilterNode && selectedFilterNode.checked,
                        partially: selectedFilterNode && !_.isEmpty(selectedFilterNode.children),
                        count: dataPoint.count,
                        isImage,
                        level,
                        parent,
                        isCollapsed: dataPoint.isCollapsed,
                        scopeIdentity: dataPoint.scopeId,
                        levelIndex,
                        levelCount: dataPoint.levelCount,
                        disabled: shouldDisable,
                        index: slicerIndex.calculatedIndex,
                        id: parent ? parent.id + "," + id : id,
                        tooltipInfo: dataPoint.tooltipInfo,
                        imageUrl: dataPoint.imageUrl,
                        label: dataPoint.label,
                        objects: dataPoint.objects
                    };
                    if (selectedFilterNode && selectedFilterNode.checked && (isFieldParameterAsData ? sortableSelectedDataPoints.push({
                        dataPoint: slicerData,
                        selectionIndex: selectedFilterNode.index
                    }) : selectedDataPoints.push(slicerData)), slicerDataPoints.push(slicerData), parent && parent.children.push(slicerData), 
                    setIdentity(slicerData, queryNamePerLevel), !dataPoint.isCollapsed && dataPoint.childrenReader) slicerData.children = [], 
                    slicerDataPoints.push.apply(slicerDataPoints, readSlicerDataPoints(dataReader, dataPoint.childrenReader, selectedDataPoints, sortableSelectedDataPoints, hostServices, queryNamePerLevel, cache, slicerIndex, slicerData, void 0, featureSwitches, void 0, hideRetainedDataPoints) || []); else if (selectedFilterNode && !_.isEmpty(selectedFilterNode.children)) {
                        var nextLevel = level + 1, metadataColumn = dataReader.getMetadataColumnByLevel(nextLevel);
                        restoreFromSelection(nextLevel, analyzer, selectedFilterNode.children, queryNamePerLevel, cache && cache.cachedValueItems, metadataColumn, dataReader, dataLevelReader, slicerData, slicerDataPoints, selectedDataPoints, sortableSelectedDataPoints, !1, slicerIndex, featureSwitches);
                    }
                }
            }
            return _.isEmpty(selectedFilterNodes) || restoreFromSelection(level, analyzer, selectedFilterNodes, queryNamePerLevel, cache && cache.cachedValueItems, source, dataReader, dataLevelReader, parent, slicerDataPoints, selectedDataPoints, sortableSelectedDataPoints, !(hideRetainedDataPoints || parent && !1 !== parent.isCollapsed), slicerIndex, featureSwitches), 
            slicerDataPoints;
        }
        function restoreFromSelection(level, filter, nodes, queryNamePerLevel, valueMap, source, reader, levelReader, parent, dataPoints, selectedDataPoints, sortableSelectedDataPoints, shouldRender, slicerIndex, featureSwitches) {
            var isFieldParameterAsData = featureSwitches && featureSwitches.fieldParameters && source.parameter && 2 === source.parameter.kind, formatString = (0, 
            valueFormatter.EO)(source, slicer_capabilities.gO.general.formatString);
            parent && (parent.children = []);
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i], isFilterIdentity = !1, value = void 0, cache = void 0;
                filter && filter.isDefaultFilter && !_.isEmpty(filter.defaultValueByLevel) && filter.defaultValueByLevel[level] ? value = sqExpr.jz.getTextValue(filter.defaultValueByLevel[level].value) : (cache = findValuesForFilterNode(level, node, valueMap), 
                _.isEmpty(cache) ? (value = (0, filterScopeIdsCollector.Xz)(node.identity), isFilterIdentity = !0) : value = cache[0].valueMap[level]), 
                slicerIndex.calculatedIndex++;
                var label = (0, valueFormatter.WU)(value, formatString), dataPoint = createRetainedSlicerDataPoint(node.checked, label, levelReader.hasCount(), levelReader.isImageData(), level, node.identity, parent, !_.isEmpty(node.children), queryNamePerLevel, slicerIndex.calculatedIndex);
                if (dataPoint.isFilterIdentity = isFilterIdentity, shouldRender && dataPoints.push(dataPoint), 
                dataPoint.selected && (isFieldParameterAsData ? sortableSelectedDataPoints.push({
                    dataPoint,
                    selectionIndex: node.index
                }) : selectedDataPoints.push(dataPoint)), !_.isEmpty(node.children)) {
                    var nextLevel = level + 1, source_1 = reader.getMetadataColumnByLevel(nextLevel);
                    restoreFromSelection(nextLevel, filter, node.children, queryNamePerLevel, cache, source_1, reader, levelReader, dataPoint, dataPoints, selectedDataPoints, sortableSelectedDataPoints, shouldRender, slicerIndex, featureSwitches);
                }
            }
        }
        function createRetainedSlicerDataPoint(selected, label, hasCount, isImage, level, identity, parent, partially, queryNamePerLevel, index) {
            var dataPoint = {
                value: label,
                tooltip: label,
                identity: null,
                selected,
                count: hasCount ? 0 : void 0,
                isImage,
                level,
                parent,
                scopeIdentity: identity,
                partially,
                disabled: !1,
                index
            };
            return setIdentity(dataPoint, queryNamePerLevel), parent && parent.children.push(dataPoint), 
            dataPoint;
        }
        function findValuesForFilterNode(level, node, values) {
            if (!_.isEmpty(values)) {
                for (var result = [], _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var map = values_1[_i];
                    (0, dataViewScopeIdentity.fS)(map.identities[level], node.identity) && result.push(map);
                }
                return result;
            }
        }
        function setIdentity(slicerData, queryNamesByLevel) {
            for (var builder = selectionId.dw.builder(), data = slicerData; data; ) builder.withColumnIdentity(data.scopeIdentity, queryNamesByLevel[slicerData.level]), 
            data = data.parent;
            slicerData.identity = builder.createSelectionId();
        }
        function getRestatement(hostServices, selected, isInverted, columnsByLevel) {
            if (_.isEmpty(selected)) return hostServices.getLocalizedString("All");
            if (1 === selected.length && !isInverted) {
                var dataPoint = selected[0];
                if (null == dataPoint.parent) return dataPoint.value;
                for (var values = [], MultiColumn_Join_Separator = hostServices.getLocalizedString("MultiColumn_Join_Separator"), NamePattern_Bracket = hostServices.getLocalizedString("NamePattern_Bracket"); dataPoint; ) values.unshift((0, 
                formatUtil.W)(NamePattern_Bracket, dataPoint.value, columnsByLevel[dataPoint.level].displayName)), 
                dataPoint = dataPoint.parent;
                return values.join(MultiColumn_Join_Separator);
            }
            return hostServices.getLocalizedString("Slicer_Restatement_Multiple");
        }
        function compareSelectedDataPoints(a, b) {
            debug.fF.assert(function() {
                return null != a.dataPoint.level && null != b.dataPoint.level;
            }, "level should not be nullish"), debug.fF.assert(function() {
                return null != a.selectionIndex && null != b.selectionIndex;
            }, "selectionIndex should not be nullish");
            var levelDiff = a.dataPoint.level - b.dataPoint.level;
            return 0 !== levelDiff ? levelDiff : (debug.fF.assert(function() {
                return a.selectionIndex !== b.selectionIndex;
            }), a.selectionIndex - b.selectionIndex);
        }
        var ConditionsFilterValueVisitor = function(_super) {
            function ConditionsFilterValueVisitor() {
                return null !== _super && _super.apply(this, arguments) || this;
            }
            return (0, tslib_es6.__extends)(ConditionsFilterValueVisitor, _super), ConditionsFilterValueVisitor.prototype.visitConstant = function(expr) {
                expr.type && expr.type.text && (this.value = expr.value);
            }, ConditionsFilterValueVisitor.prototype.visitContains = function(expr) {
                expr.left.accept(this), expr.right.accept(this);
            }, ConditionsFilterValueVisitor.prototype.visitOr = function(expr) {
                expr.left.accept(this), expr.right.accept(this);
            }, ConditionsFilterValueVisitor.prototype.visitColumnRef = function(expr) {
                this.fieldExpr = expr;
            }, ConditionsFilterValueVisitor.prototype.visitHierarchyLevel = function(expr) {
                this.fieldExpr = expr;
            }, ConditionsFilterValueVisitor.prototype.visitDefault = function(expr) {
                this.value = void 0, this.fieldExpr = void 0;
            }, ConditionsFilterValueVisitor.prototype.getValueForField = function() {
                return this.fieldExpr && this.value;
            }, ConditionsFilterValueVisitor;
        }(sqExprVisitor.vq);
        function formatValue(value, valueSettings, column) {
            if (null != value || _.isEmpty(valueSettings.showBlankAs)) {
                var labelDisplayUnits = valueSettings.labelDisplayUnits, isCustom = -1 === labelDisplayUnits, specificFormatString = void 0;
                isCustom && !_.isEmpty(valueSettings.customFormatString) && (specificFormatString = valueSettings.customFormatString);
                var objects = {};
                return null != specificFormatString && (objects = {
                    general: {
                        formatString: specificFormatString
                    }
                }), new valueFormatter.g({
                    column,
                    formatStringPropId: slicer_capabilities.gO.general.formatString,
                    nullsAreBlank: !0,
                    precision: isCustom ? void 0 : valueSettings.labelPrecision,
                    formatSingleValues: 0 === labelDisplayUnits,
                    defaultPrecisionForScaledValues: !0,
                    trailingZeroes: !0
                }).format(value, objects);
            }
            return valueSettings.showBlankAs;
        }
    },
    36408: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            ContainerClass: function() {
                return slicer_ContainerClass;
            },
            ContentWrapperClass: function() {
                return ContentWrapperClass;
            },
            Slicer: function() {
                return Slicer;
            }
        });
        var tslib_es6 = __webpack_require__(81337), focusManager_helpers = __webpack_require__(11034), slicer_capabilities = __webpack_require__(9434), slicer_pluginMethods = __webpack_require__(4308), responsiveVisualUtil2 = __webpack_require__(10034), dataViewCategoricalReader = __webpack_require__(51129), slicerMode = __webpack_require__(20598), slicerOrientation = __webpack_require__(3212), visualWarnings = __webpack_require__(45296), DomFactory = __webpack_require__(38308), debug = __webpack_require__(62458), build_control_util = __webpack_require__(56578), loadMoreDataHandler = __webpack_require__(60810), enums = __webpack_require__(46135), dataViewObject2 = __webpack_require__(82755), relativeDateRange = __webpack_require__(90031), dateUtil = __webpack_require__(17591), scaleRange = __webpack_require__(5342), slicerHelper = __webpack_require__(45875), formatUtil = __webpack_require__(59694), rangeFilterPattern = __webpack_require__(78107), sqExpr = __webpack_require__(94419), formattingService = __webpack_require__(28326), CssConstants = __webpack_require__(79154), InputClass = ((0, 
        CssConstants.CH)("date-slicer-datepicker"), (0, CssConstants.CH)("date-slicer-datepicker-wrapper"), 
        (0, CssConstants.CH)("date-slicer-input")), RangeSlicerSupportedModes = [ slicerMode.e4, slicerMode.bb, slicerMode.vX ], slicerUtil1 = __webpack_require__(68447), DateSlicer = function() {
            function DateSlicer(options) {
                options && (this.preventVirtualKeyboardOnTheFirstTap = options.preventVirtualKeyboardOnTheFirstTap, 
                this.featureSwitches = options.featureSwitches), this.culture = formattingService.dx.getCurrentCulture(), 
                this.inputElements = [], this.eventsHelper = new slicerUtil1.PB;
                var hostServices = this.hostServices = options.hostServices;
                this.startInputLabel = hostServices.getLocalizedString("Slicer_StartLabel"), this.endInputLabel = hostServices.getLocalizedString("Slicer_EndLabel");
            }
            return DateSlicer.prototype.createRange = function(data) {
                return new scaleRange.C0(data.bounds.min, data.bounds.max, data.value.min, data.value.max);
            }, DateSlicer.prototype.getSliderOptions = function(data, singleValue) {
                return {
                    min: 0,
                    max: (0, dateUtil.I)(data.bounds.max, data.bounds.min),
                    step: 1
                };
            }, DateSlicer.prototype.areEqual = function(val1, val2) {
                return (0, dateUtil.X)(val1, val2);
            }, DateSlicer.prototype.defaultValue = function() {
                return new Date(0);
            }, DateSlicer.prototype.startProperty = function() {
                return slicer_capabilities.gO.data.startDate;
            }, DateSlicer.prototype.endProperty = function() {
                return slicer_capabilities.gO.data.endDate;
            }, DateSlicer.prototype.formatValue = function(value, formatter) {
                return formattingService.dx.formatValue(value, "d");
            }, DateSlicer.prototype.parseSingleSliderValue = function(value, dataPoints) {
                return null;
            }, DateSlicer.prototype.inputStyleProperties = function() {
                return {
                    background: slicer_capabilities.gO.date.background,
                    fontColor: slicer_capabilities.gO.date.fontColor,
                    textSize: slicer_capabilities.gO.date.textSize,
                    fontFamily: slicer_capabilities.gO.date.fontFamily,
                    bold: slicer_capabilities.gO.date.bold,
                    italic: slicer_capabilities.gO.date.italic,
                    underline: slicer_capabilities.gO.date.underline
                };
            }, DateSlicer.prototype.parseInput = function(inputString, dataPoints, singleValue) {
                return formattingService.dx.parseDate(inputString);
            }, DateSlicer.prototype.isInputValid = function(inputValue, range, type, singleValue) {
                return !(null == inputValue || 0 === type && inputValue > range.max || 1 === type && inputValue < range.min);
            }, DateSlicer.prototype.setRange = function(value, formatter, start, end, type, bounds) {
                null == type ? (this.featureSwitches.useModernDatePickerSlicer || (start.val(formattingService.dx.formatValue(value.min, "d")), 
                end.val(formattingService.dx.formatValue(value.max, "d"))), start.attr("aria-label", (0, 
                formatUtil.W)(this.startInputLabel, formattingService.dx.formatValue(bounds.min, "d"), formattingService.dx.formatValue(value.max, "d"))), 
                end.attr("aria-label", (0, formatUtil.W)(this.endInputLabel, formattingService.dx.formatValue(value.min, "d"), formattingService.dx.formatValue(bounds.max, "d")))) : 0 === type ? (this.featureSwitches.useModernDatePickerSlicer || start.val(formattingService.dx.formatValue(value.min, "d")), 
                start.attr("aria-label", (0, formatUtil.W)(this.startInputLabel, formattingService.dx.formatValue(bounds.min, "d"), formattingService.dx.formatValue(bounds.max, "d")))) : 1 === type && (this.featureSwitches.useModernDatePickerSlicer || end.val(formattingService.dx.formatValue(value.max, "d")), 
                end.attr("aria-label", (0, formatUtil.W)(this.endInputLabel, formattingService.dx.formatValue(bounds.min, "d"), formattingService.dx.formatValue(bounds.max, "d"))));
            }, DateSlicer.prototype.enumerateObjectInstances = function(options, data, featureSwitches) {
                var _a;
                if ("date" === options.objectName && data && data.inputStyle) {
                    var dateProps = slicer_capabilities.gO.date;
                    return [ {
                        selector: null,
                        objectName: "date",
                        properties: (_a = {
                            fontColor: data.inputStyle.fontColor,
                            background: data.inputStyle.background,
                            textSize: data.inputStyle.textSize,
                            fontFamily: data.inputStyle.fontFamily
                        }, _a[dateProps.bold.propertyName] = data.inputStyle.labelBold, _a[dateProps.italic.propertyName] = data.inputStyle.labelItalic, 
                        _a[dateProps.underline.propertyName] = data.inputStyle.labelUnderline, _a)
                    } ];
                }
            }, DateSlicer.prototype.getValuesCard = function(data, featureSwitches) {
                var _this = this, dateProps = slicer_capabilities.gO.date, valuesCardBuilder = new build_control_util.CQ(new build_control_util.lg("values"), "Role_DisplayName_Values", [ dateProps.fontFamily, dateProps.textSize, dateProps.fontColor, dateProps.background, dateProps.bold, dateProps.italic, dateProps.underline ], function(key) {
                    return _this.hostServices.getLocalizedString(key);
                }), fontControl = (new build_control_util.UN).withFontFamily({
                    descriptor: dateProps.fontFamily,
                    value: data.inputStyle.fontFamily
                }).withFontSizeProperties({
                    descriptor: dateProps.textSize,
                    value: data.inputStyle.textSize
                }).withBold({
                    descriptor: dateProps.bold,
                    value: data.inputStyle.labelBold
                }).withItalic({
                    descriptor: dateProps.italic,
                    value: data.inputStyle.labelItalic
                }).withUnderline({
                    descriptor: dateProps.underline,
                    value: data.inputStyle.labelUnderline
                }).build();
                return valuesCardBuilder.addGroup("values", function(groupBuilder) {
                    groupBuilder.withDisplayName("Role_DisplayName_Values"), groupBuilder.addCompositeSlice("fontselector", "Font", fontControl), 
                    groupBuilder.addSimpleSlice("color", new build_control_util.BT({
                        descriptor: dateProps.fontColor,
                        value: {
                            value: data.inputStyle.fontColor
                        }
                    }).build());
                }).addGroup("background", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_Background").addSimpleSlice("color", new build_control_util.BT({
                        descriptor: dateProps.background,
                        value: {
                            value: data.inputStyle.background
                        }
                    }).build());
                }), valuesCardBuilder.build();
            }, DateSlicer.prototype.getDataPointsForSingleValueRange = function(dataView) {
                return [];
            }, DateSlicer.prototype.createInputElement = function(control, type) {
                var _this = this, pattern = this.culture.calendar.patterns.d, $element = (0, DomFactory.ze)().attr("type", "text").attr("drag-resize-disabled", "true").prop("readonly", !!this.preventVirtualKeyboardOnTheFirstTap).attr("placeholder", pattern).addClass(InputClass.class).appendTo(control);
                control.attr("tabindex", "0"), control.keydown(function(event) {
                    13 !== event.keyCode && 32 !== event.keyCode || $element.focus();
                }), $element.datepicker({
                    showOtherMonths: !0,
                    selectOtherMonths: !0,
                    changeMonth: !0,
                    changeYear: !0,
                    nextText: "",
                    prevText: "",
                    firstDay: this.culture.calendar.firstDay,
                    dayNamesMin: this.culture.calendar.days.namesAbbr,
                    dateFormat: this.culture.calendar.patterns.d.replace("yyyy", "yy").toLowerCase(),
                    monthNamesShort: this.culture.calendar.months.names,
                    onClose: function() {
                        $element.prop("readonly", !!_this.preventVirtualKeyboardOnTheFirstTap);
                    }
                }), $element.on("click", function(event) {
                    _this.preventVirtualKeyboardOnTheFirstTap && $element.is("[readonly]") && ($element.prop("readonly", !1), 
                    $element.blur()), $element.datepicker("show");
                }), this.preventVirtualKeyboardOnTheFirstTap && $element.on("touchstart", function(event) {
                    $element.is("[readonly]") || $element.is(":focus") || $element.focus();
                });
                var widget = $element.datepicker("widget");
                return widget.attr("prevent-focus-loss", "false"), $element.attr("prevent-focus-loss", "false"), 
                $element.datepicker("option", "beforeShow", function() {
                    widget.addClass("themeableElement"), _this.unregisterPopupHideEvents = _this.eventsHelper.onPopupHideEvent(function(eventType, target) {
                        _this.onPopupHideEvent(eventType, target);
                    }, control.get(0)), _this.fixLayout(widget, $element, 1e3);
                }), this.inputElements.push($element), $element;
            }, DateSlicer.prototype.onPopupHideEvent = function(eventType, targetElement) {
                if ("resize" !== eventType) {
                    var target = $(targetElement);
                    target.hasClass("hasDatepicker") || target.hasClass("ui-datepicker") || target.hasClass("ui-icon") || $(target).closest(".ui-datepicker").length || this.hideDatepicker();
                } else this.hideDatepicker();
            }, DateSlicer.prototype.hideDatepicker = function() {
                this.unbindPopupHideEventHandlers();
                for (var _i = 0, _a = this.inputElements; _i < _a.length; _i++) {
                    var inputElement = _a[_i];
                    inputElement.datepicker("widget").is(":visible") && inputElement.datepicker("hide").blur();
                }
            }, DateSlicer.prototype.onDestroy = function() {
                this.hideDatepicker();
            }, DateSlicer.prototype.unbindPopupHideEventHandlers = function() {
                this.unregisterPopupHideEvents && this.unregisterPopupHideEvents();
            }, DateSlicer.prototype.fixLayout = function(widget, element, maxWait) {
                var _this = this;
                setTimeout(function() {
                    widget.is(":visible") ? (slicerHelper.Ck.fixWidgetPosition(widget, element, null, !0), 
                    widget.find(".ui-datepicker-current-day").addClass("backgroundToForegroundColor")) : maxWait > 0 && _this.fixLayout(widget, element, maxWait - 20);
                }, 20);
            }, DateSlicer.prototype.filterExpr = function(filter) {
                var roundedRange = (0, rangeFilterPattern.VM)(filter);
                return {
                    lower: (0, sqExpr.CQ)(roundedRange.min),
                    upper: (0, sqExpr.CQ)(roundedRange.max)
                };
            }, DateSlicer.prototype.comparisonKind = function() {
                return {
                    lower: 2,
                    upper: 3
                };
            }, DateSlicer.prototype.addAriaDescription = function(inputControl) {
                var dateFormat = this.culture.calendar.patterns.d, inputTextHint = formattingService.dx.format(this.hostServices.getLocalizedString("DateSlicer_InputTextHint"), [ dateFormat ]);
                inputControl.attr("aria-description", inputTextHint);
            }, DateSlicer;
        }(), FocusGroupNavigation = __webpack_require__(6450), focusManager = __webpack_require__(65302), common_colorHelper = __webpack_require__(90120), fontProperties = __webpack_require__(18664), units = __webpack_require__(32105), colorHelper = __webpack_require__(44783), fontUtils = __webpack_require__(38265), browserUtils = __webpack_require__(59107), StandaloneUtility1 = __webpack_require__(64329), Utility = __webpack_require__(38078), DropdownSlicerRenderer = function() {
            function DropdownSlicerRenderer(verticalSlicer, initOptions) {
                var _this = this;
                this.DefaultRestatementColorName = "foregroundDark", this.verticalSlicerRenderer = verticalSlicer, 
                this.isDeferred = !0, this.popup = $("<div ></div>").addClass("slicer-dropdown-popup"), 
                browserUtils.M.isIOSWebView() && this.popup.addClass(slicerUtil1.M7.class), this.popup.on("slicer.dataPointSelected", function(e) {
                    _this.strictSingleSelect && (_this.hidePopup(), e.stopPropagation());
                }), this.content = $("<div ></div>").addClass("slicer-dropdown-content"), this.loader = $("<div ></div>").addClass("slicer-dropdown-loader"), 
                this.hostServices = initOptions.hostServices, this.controlId = "slicer-dropdown-popup-".concat(Utility.b$.generateGuid()), 
                this.popup.addClass("visual").addClass("themeableElement").attr("focus-nav-mode", "Group").attr("id", this.controlId).keydown(function(event) {
                    27 !== event.keyCode || _this.popup.is(":hidden") ? 9 !== event.keyCode || _this.popup.is(":hidden") || (_this.hidePopup(), 
                    focusManager.IK.focus(FocusGroupNavigation.m.getFocusNextElement(!0, _this.menu.get(0))), 
                    event.preventDefault(), event.stopPropagation()) : (_this.hidePopup(), _this.menu.focus(), 
                    event.preventDefault(), event.stopPropagation());
                }), $("body").append(this.popup), this.popup.append(this.content), this.popup.append(this.loader), 
                this.featureSwitches = initOptions.featureSwitches, this.eventsHelper = new slicerUtil1.PB;
            }
            return DropdownSlicerRenderer.prototype.onClear = function(isUserAction) {
                this.verticalSlicerRenderer.onClear(isUserAction);
            }, DropdownSlicerRenderer.prototype.onModeChange = function(mode) {
                this.popup.remove(), this.verticalSlicerRenderer.onModeChange(mode);
            }, DropdownSlicerRenderer.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                var newPropertySaveObjects = (0, slicerUtil1.tm)(propertySaveObjects, sourceType);
                return debug.fF.assertNonEmpty(newPropertySaveObjects, "There should be at least one save object"), 
                newPropertySaveObjects;
            }, DropdownSlicerRenderer.prototype.hasSlider = function() {
                return !1;
            }, DropdownSlicerRenderer.prototype.supportsOrientation = function() {
                return !1;
            }, DropdownSlicerRenderer.prototype.enumerateObjectInstances = function(options) {
                return this.verticalSlicerRenderer.enumerateObjectInstances(options, this.featureSwitches);
            }, DropdownSlicerRenderer.prototype.getValuesCard = function() {
                return this.verticalSlicerRenderer.getValuesCard(this.featureSwitches);
            }, DropdownSlicerRenderer.prototype.getSlicerSettingsCardOptions = function(cardUidBuilder, orientation, activeMode, slicerModes) {
                return this.verticalSlicerRenderer.getSlicerSettingsCardOptions(cardUidBuilder, orientation, activeMode, slicerModes);
            }, DropdownSlicerRenderer.prototype.getAdditionalCards = function() {
                return this.verticalSlicerRenderer.getAdditionalCards();
            }, DropdownSlicerRenderer.prototype.init = function(slicerInitOptions, element) {
                return this.container = element, this.style = slicerInitOptions.visualInitOptions.style, 
                this.slicerSelectionHandler = this.verticalSlicerRenderer.init(slicerInitOptions, this.content), 
                this.slicerSelectionHandler;
            }, DropdownSlicerRenderer.prototype.onDestroy = function() {
                this.verticalSlicerRenderer && this.verticalSlicerRenderer.onDestroy(), this.unbindPopupHideEventHandlers(), 
                this.popup.remove();
            }, DropdownSlicerRenderer.prototype.render = function(options) {
                this.options = options, this.data = this.verticalSlicerRenderer.converter(this.options.dataView, this.options.isSlicer), 
                this.slicerSelectionHandler.setSelected(this.data.retainedDataPoints);
                var shouldUpdateRestatement = !this.loadDataForGroupOnKeysIfNeeded();
                this.renderMenu(this.data.restatement, shouldUpdateRestatement), this.isExpanded ? this.showPopup(this.setFocus, !0) : this.hidePopup();
            }, DropdownSlicerRenderer.prototype.loadDataForGroupOnKeysIfNeeded = function() {
                if (!this.isExpanded && this.data.hasGroupOnKeys) {
                    if (this.isDeferred && !_.isEmpty(this.data.retainedDataPoints) && _.some(this.data.retainedDataPoints, function(dataPoint) {
                        return dataPoint.isFilterIdentity;
                    })) return this.setShouldDeferData(!1), !0;
                    this.setShouldDeferData(!0);
                }
                return !1;
            }, DropdownSlicerRenderer.prototype.setShouldDeferData = function(value) {
                this.isDeferred = value, this.hostServices.setShouldDeferData(value);
            }, DropdownSlicerRenderer.prototype.renderMenu = function(restatement, shouldUpdateRestatement) {
                var _a, _this = this;
                if (this.menu || (this.menu = (0, DomFactory.hi)(), this.menu.addClass("slicer-dropdown-menu"), 
                this.menu.attr(((_a = {
                    role: "combobox",
                    "aria-haspopup": "listbox",
                    tabindex: "0",
                    "aria-controls": this.controlId
                })["aria-expanded"] = "false", _a["drag-resize-disabled"] = "true", _a)), this.container.append(this.menu), 
                this.menu.on("click touchstart keydown", function(event) {
                    _this.focusEventType = event.type, event.preventDefault(), ("click" === event.type || "touchstart" === event.type || 40 === event.keyCode && !event.ctrlKey || 38 === event.keyCode && !event.ctrlKey || 32 === event.keyCode || 13 === event.keyCode) && _this.onRenderMenuClick(event, !0);
                }), this.restatement = (0, DomFactory.hi)(), this.restatement.addClass("slicer-restatement"), 
                this.menu.append(this.restatement), this.icon = $("<i ></i>").addClass("dropdown-chevron"), 
                this.icon.appendTo(this.menu)), this.menu.attr({
                    "aria-label": this.options.restatement
                }), this.icon.addClass("powervisuals-glyph"), this.icon.addClass("chevron-down"), 
                this.settings = this.defaultRestatementSetting(), this.options.dataView.metadata && this.options.dataView.metadata.objects) {
                    var objects = this.options.dataView.metadata.objects, colorHelper = common_colorHelper.v.create(this.style), slicerItemTextFontProperties = (0, 
                    fontProperties.Zi)((0, dataViewObject2.RK)(objects, "items"), {
                        color: "fontColor",
                        family: "fontFamily",
                        size: "textSize"
                    }, colorHelper, this.style, "foregroundNeutralSecondary", "lightLabel", {
                        color: this.settings.fontColor,
                        family: this.settings.fontFamily,
                        size: units.B.createFromPt(this.settings.textSize)
                    });
                    this.settings.fontColor = slicerItemTextFontProperties.color, this.settings.fontFamily = slicerItemTextFontProperties.family, 
                    this.settings.textSize = slicerItemTextFontProperties.size.pt, this.settings.background = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.items.background, this.settings.background), 
                    this.strictSingleSelect = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.selection.strictSingleSelect, this.strictSingleSelect);
                }
                shouldUpdateRestatement && this.restatement.text(restatement), this.menu.css({
                    "background-color": this.settings.background || "",
                    color: this.settings.fontColor,
                    "font-size": StandaloneUtility1.FP.fromPointToPixel(this.settings.textSize),
                    "font-family": this.settings.fontFamily
                }), this.popup.css({
                    "background-color": this.settings.background || ""
                });
            }, DropdownSlicerRenderer.prototype.onRenderMenuClick = function(event, setFocus) {
                if (event.stopPropagation(), this.popup.is(":hidden")) return this.isExpanded = !0, 
                this.setFocus = setFocus, this.setShouldDeferData(!1), this.loader.css({
                    "background-color": this.settings.background || ""
                }), this.loader.show(), this.popup.addClass("focused"), void this.showPopup(!1, !1);
                this.popup.removeClass("focused"), this.hidePopup();
            }, DropdownSlicerRenderer.prototype.showPopup = function(setFocus, requireUpdate) {
                var _this = this;
                window.requestAnimationFrame(function() {
                    if (_this.popup) {
                        _this.unbindPopupHideEventHandlers();
                        var width = _this.menu.width() + 10;
                        _this.popup.css({
                            width
                        }), _this.menu.attr("aria-expanded", "true"), _this.icon.removeClass("chevron-down"), 
                        _this.icon.addClass("chevron-up"), slicerHelper.Ck.fixWidgetPosition(_this.popup, _this.menu, null, !0), 
                        requireUpdate && _this.verticalSlicerRenderer.renderVerticalSlicer(_this.data, _this.options, function() {
                            _this.loader.hide(), _this.focusCallbackTimeout && window.clearTimeout(_this.focusCallbackTimeout), 
                            _this.focusCallbackTimeout = window.setTimeout(function() {
                                setFocus && focusManager.IK.focusChildInGroup(_this.popup.get(0), "keydown" === _this.focusEventType), 
                                _this.focusCallbackTimeout = void 0, _this.setFocus = !1, _this.focusEventType = void 0;
                            }, 0);
                        }), _this.unregisterPopupHideEvents = _this.eventsHelper.onPopupHideEvent(function(eventType, target) {
                            _this.onPopupHideEvent(eventType, target);
                        }, _this.menu.get(0), _this.popup.get(0), !0), _this.popup.show();
                    }
                });
            }, DropdownSlicerRenderer.prototype.hidePopup = function() {
                this.popup && (this.isResize = !1, this.isExpanded = !1, this.popup.hide(), this.setShouldDeferData(!0), 
                this.menu.attr("aria-expanded", "false"), this.icon.removeClass("chevron-up"), this.icon.addClass("chevron-down"), 
                this.unbindPopupHideEventHandlers());
            }, DropdownSlicerRenderer.prototype.onPopupHideEvent = function(eventType, targetElement) {
                if ("resize" !== eventType) {
                    "focusin" === eventType && (this.isResize = !1);
                    var target = $(targetElement);
                    if (!(target.parents(".slicer-dropdown-popup").length || target.is(this.menu) || this.menu.find(target).length)) {
                        if ("scroll" === eventType) return void slicerHelper.Ck.fixWidgetPosition(this.popup, this.menu, null, !0);
                        this.isResize || this.hidePopup();
                    }
                } else this.isResize = !0;
            }, DropdownSlicerRenderer.prototype.unbindPopupHideEventHandlers = function() {
                this.unregisterPopupHideEvents && (this.unregisterPopupHideEvents(), this.unregisterPopupHideEvents = void 0);
            }, DropdownSlicerRenderer.prototype.defaultRestatementSetting = function() {
                return {
                    textSize: 10,
                    fontFamily: fontUtils.Wn.regular.css,
                    fontColor: common_colorHelper.v.getThemeColor(this.style, this.DefaultRestatementColorName),
                    background: this.style.isHighContrast ? common_colorHelper.v.getThemeColor(this.style, colorHelper.U) : void 0
                };
            }, DropdownSlicerRenderer;
        }(), textMeasurementService = __webpack_require__(32041), wordBreaker = __webpack_require__(66001), horizontalSlicer1_container = (0, 
        CssConstants.CH)("horizontalSlicerContainer"), ItemsContainer = (0, CssConstants.CH)("slicerItemsContainer"), NavigationArrow = (0, 
        CssConstants.CH)("navigationArrow"), LeftNavigationArrow = (0, CssConstants.CH)("left"), RightNavigationArrow = (0, 
        CssConstants.CH)("right"), MultiSelectEnabled = (0, CssConstants.CH)("isMultiSelectEnabled"), FlexDisplay = (0, 
        CssConstants.CH)("flexDisplay"), CanScrollRight = (0, CssConstants.CH)("canScrollRight"), CanScrollLeft = (0, 
        CssConstants.CH)("canScrollLeft"), IndividualItemContainer = (0, CssConstants.CH)("individualItemContainer"), ImageContainer = (0, 
        CssConstants.CH)("horizontalImageContainer"), HorizontalSlicerImage = (0, CssConstants.CH)("horizontalSlicerImage"), Input = (0, 
        CssConstants.CH)("slicerCheckbox"), slicer_converter = __webpack_require__(87592), slicerBehaviors = __webpack_require__(62224), slicerSelectionHandler = __webpack_require__(83611), slicerSearchInput = __webpack_require__(82085), HorizontalSlicerRenderer = function() {
            function HorizontalSlicerRenderer(options, viewModelAdapter) {
                this.viewModelAdapter = viewModelAdapter, this.textProperties = {
                    fontFamily: fontUtils.Wn.regular.css,
                    fontSize: "14px"
                }, options && (this.horizontalSlicerLayout = options.horizontalSlicerLayout, this.featureSwitches = options.featureSwitches), 
                this.behavior = new slicerBehaviors.wV, this.horizontalSlicerLayout || (this.horizontalSlicerLayout = new HorizontalSlicerLayout), 
                this.domHelper = new slicerUtil1.gy, this.dataStartIndex = 0, this.searchComponent = new slicerSearchInput.v(null == options ? void 0 : options.hostServices);
            }
            return HorizontalSlicerRenderer.prototype.hasSlider = function() {
                return !1;
            }, HorizontalSlicerRenderer.prototype.getDefaultValue = function() {
                if (this.data && !_.isEmpty(this.data.defaultValueByLevel)) return this.data.defaultValueByLevel[0].value;
            }, HorizontalSlicerRenderer.prototype.getIdentityFields = function() {
                return (0, slicerUtil1.nQ)(this.dataView);
            }, HorizontalSlicerRenderer.prototype.supportsOrientation = function() {
                return !0;
            }, HorizontalSlicerRenderer.prototype.getSlicerSettings = function(data) {
                var slicerSettings = data && data.slicerSettings;
                return slicerSettings || (slicerSettings = (0, slicer_converter.VT)(this.style)), 
                slicerSettings;
            }, HorizontalSlicerRenderer.prototype.enumerateObjectInstances = function(options) {
                var data = this.originalData, settings = this.getSlicerSettings(data);
                return (0, slicerUtil1.qo)(options, data, settings, this.dataView, this.featureSwitches);
            }, HorizontalSlicerRenderer.prototype.getValuesCard = function() {
                var data = this.originalData, settings = this.getSlicerSettings(data);
                return (0, slicerUtil1.s9)(this.hostServices, data, settings, this.featureSwitches);
            }, HorizontalSlicerRenderer.prototype.getSlicerSettingsCardOptions = function(cardUidBuilder, orientation, activeMode, slicerModes) {
                var data = this.originalData, settings = data ? data.slicerSettings : void 0;
                return settings || (settings = (0, slicer_converter.VT)(this.style)), (0, slicerUtil1.nD)({
                    cardUidBuilder,
                    currentSlicerSettings: settings,
                    data,
                    dataView: this.dataView,
                    hostServices: this.hostServices,
                    orientation,
                    activeMode,
                    slicerModes,
                    featureSwitches: this.featureSwitches
                });
            }, HorizontalSlicerRenderer.prototype.getAdditionalCards = function() {
                var data = this.originalData, settings = data ? data.slicerSettings : void 0;
                return settings || (settings = (0, slicer_converter.VT)(this.style)), (0, slicerUtil1.oE)(this.hostServices, data, settings, this.dataView);
            }, HorizontalSlicerRenderer.prototype.onModeChange = function(mode) {
                (0, slicerUtil1.VD)(this.hostServices, mode);
            }, HorizontalSlicerRenderer.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                var newPropertySaveObjects = (0, slicerUtil1.tm)(propertySaveObjects, sourceType);
                return debug.fF.assertNonEmpty(newPropertySaveObjects, "There should be at least one save object"), 
                newPropertySaveObjects;
            }, HorizontalSlicerRenderer.prototype.getRestatement = function() {
                return this.data && this.data.restatement;
            }, HorizontalSlicerRenderer.prototype.onClear = function(isUserAction) {
                (0, slicerUtil1.K5)(this.selectionHandler, isUserAction);
            }, HorizontalSlicerRenderer.prototype.init = function(slicerInitOptions, element) {
                var _this = this;
                this.element = element, this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                this.style = slicerInitOptions.visualInitOptions.style, this.behavior && (this.selectionHandler = new slicerSelectionHandler.N(hostServices, this.behavior)), 
                this.loadMoreData = function() {
                    return slicerInitOptions.loadMoreData();
                };
                var containerDiv = document.createElement("div");
                containerDiv.className = horizontalSlicer1_container.class;
                var container = this.container = d3.select(containerDiv);
                this.searchComponent.create(container);
                var body = this.body = container.append("div").classed(slicerUtil1.uT.class + " " + FlexDisplay.class, !0), navigationArrowColor = {
                    color: common_colorHelper.v.getThemeColor(this.style, "foregroundNeutralSecondary")
                }, navigationArrowHoverColor = {
                    color: common_colorHelper.v.getThemeColor(this.style, "foreground")
                };
                this.leftNavigationArrow = body.append("button").call(this.horizontalSlicerLayout.getNavigationArrowsClass, !0).attr("aria-label", this.hostServices.getLocalizedString("Previous_ButtonText")).attr("tabindex", -1).styles(navigationArrowColor).on("pointerover", function() {
                    return _this.leftNavigationArrow.styles(navigationArrowHoverColor);
                }).on("pointerleave", function() {
                    return _this.leftNavigationArrow.styles(navigationArrowColor);
                });
                var isStrictSingleSelect = this.data && this.data.slicerSettings.selection.strictSingleSelect;
                this.itemsContainer = body.append("div").classed(ItemsContainer.class + " " + FlexDisplay.class, !0).attr("tabindex", "0").attr("role", "listbox").attr("aria-multiselectable", !isStrictSingleSelect);
                var itemsContainerElement = this.itemsContainer.node();
                return $(itemsContainerElement).on("keydown", function(event) {
                    var keyCode = event.keyCode, isForward = 39 === keyCode || 40 === keyCode;
                    (isForward || 37 === keyCode || 38 === keyCode) && (_this.focusNextElement(isForward), 
                    event.stopPropagation());
                }), this.rightNavigationArrow = body.append("button").call(this.horizontalSlicerLayout.getNavigationArrowsClass, !1).attr("aria-label", this.hostServices.getLocalizedString("Next_ButtonText")).attr("tabindex", -1).styles(navigationArrowColor).on("pointerover", function() {
                    return _this.rightNavigationArrow.styles(navigationArrowHoverColor);
                }).on("pointerleave", function() {
                    return _this.rightNavigationArrow.styles(navigationArrowColor);
                }), this.element.get(0).appendChild(containerDiv), this.bindNavigationEvents(), 
                this.selectionHandler;
            }, HorizontalSlicerRenderer.prototype.render = function(options) {
                this.hasSearchableData = options.hasSearchableData;
                var localizedSelectAllText = this.hostServices.getLocalizedString(slicerUtil1.vx), dataView = options.dataView;
                if (this.originalData = this.data = (0, slicer_converter.OQ)({
                    dataView,
                    localizedSelectAllText,
                    selectionHandler: this.selectionHandler,
                    hostServices: this.hostServices,
                    style: this.style,
                    isSlicer: options.isSlicer,
                    featureSwitches: this.featureSwitches,
                    slicerType: 1
                }), this.viewModelAdapter && (this.data = this.viewModelAdapter.applyChanges(options.viewport, this.originalData, dataView)), 
                this.updateItemsContainerLabel(), this.updateStyle(this.hasSearchableData), !dataView || !this.data || _.isEmpty(this.data.slicerDataPoints)) return this.itemsContainer.selectAll("*").remove(), 
                void (this.itemsToDisplay = 0);
                this.dataView = dataView, this.currentViewport && options.viewport && (this.currentViewport.height !== options.viewport.height || this.currentViewport.width !== options.viewport.width) && !this.isMaxDimensionsNeedsReCalculate() || this.calculateAndSetMaxItemDimensions(), 
                this.currentViewport = options.viewport, this.itemsToDisplay = this.horizontalSlicerLayout.calculateNumberOfItemsToDisplay(this.element, this.totalItemWidth, this.totalItemHeight, this.getDataPointsCount()), 
                0 !== this.itemsToDisplay && this.renderCore();
            }, HorizontalSlicerRenderer.prototype.renderCore = function() {
                this.horizontalSlicerLayout.renderCore && this.horizontalSlicerLayout.renderCore(this.container);
                var data = this.data;
                if (data && data.slicerDataPoints) {
                    this.normalizePosition();
                    var dataPointsLength = this.getDataPointsCount(), itemsToDisplay = this.itemsToDisplay, dataStartIndex = this.dataStartIndex, canScrollRight = dataStartIndex + this.itemsToDisplay <= dataPointsLength - 1, canScrollLeft = dataStartIndex > 0, focusOnExitingRightArrow = this.container.classed(CanScrollRight.class) && !canScrollRight && document.activeElement === this.rightNavigationArrow.node(), focusOnExitingLeftArrow = this.container.classed(CanScrollLeft.class) && !canScrollLeft && document.activeElement === this.leftNavigationArrow.node();
                    (focusOnExitingRightArrow || focusOnExitingLeftArrow) && this.itemsContainer.node().focus(), 
                    this.container.classed(CanScrollRight.class, canScrollRight), this.container.classed(CanScrollLeft.class, canScrollLeft), 
                    this.renderItems(data.slicerSettings), this.bindInteractivityService(), dataStartIndex + itemsToDisplay >= .8 * dataPointsLength && this.loadMoreData();
                }
            }, HorizontalSlicerRenderer.prototype.updateStyle = function(hasSearchableData) {
                var data = this.data, settings = data && data.slicerSettings, searchSettings = slicerSearchInput.v.fromSlicerSettings(settings, null == data ? void 0 : data.searchKey, hasSearchableData && settings.search.enabled, !1, this.featureSwitches);
                this.searchComponent.update(searchSettings), settings && this.container.classed(MultiSelectEnabled.class, !settings.selection.singleSelect);
            }, HorizontalSlicerRenderer.prototype.renderItems = function(slicerSettings) {
                var _this = this, itemsToDisplay = this.itemsToDisplay;
                debug.fF.assert(function() {
                    return itemsToDisplay > 0;
                }, "items to display should be greater than zero");
                var dataStartIndex = this.dataStartIndex, materializedDataPoints = this.data.slicerDataPoints.slice(dataStartIndex, dataStartIndex + itemsToDisplay), items = this.horizontalSlicerLayout.bindData(materializedDataPoints, this.data, this.itemsContainer), itemsEnterUpdate = items.enter().append("div").classed(IndividualItemContainer.class, !0).classed("containerBackground", !slicerSettings.items.accessibilityContrastProperties).classed("containerBackgroundContrast", slicerSettings.items.accessibilityContrastProperties).attr("role", "option").attr("tabindex", 0).each(function(d) {
                    var item = d3.select(this);
                    if (d.isImage) {
                        var imageContainer = item.append("div").classed(ImageContainer.class, !0);
                        imageContainer.append("div").classed(Input.class, !0).append("input").attr("type", "checkbox"), 
                        imageContainer.append("img").classed(HorizontalSlicerImage.class, !0);
                    } else item.append("div").classed(slicerUtil1.NV.class, !0).classed(FlexDisplay.class, !0);
                }).merge(items), self = this;
                itemsEnterUpdate.each(function(d) {
                    var item = d3.select(this);
                    (0, slicerUtil1.hx)(item, d), item.attr("aria-label", (0, slicerUtil1.rX)(self.hostServices, d.tooltip)).attr("aria-setsize", -1).attr("aria-posinset", d.levelIndex ? d.levelIndex : 1);
                }), itemsEnterUpdate.attr("aria-selected", function(d) {
                    return !0 === d.selected;
                }), itemsEnterUpdate.order(), itemsEnterUpdate.select(slicerUtil1.NV.selector).styles({
                    "padding-left": StandaloneUtility1.FP.toString(8),
                    "padding-right": StandaloneUtility1.FP.toString(8)
                }), itemsEnterUpdate.styles({
                    "margin-right": function(d, i) {
                        return _this.horizontalSlicerLayout.getDataPointRightMargin(i, _this.itemsToDisplay);
                    }
                }), this.domHelper.setSlicerTextStyle(itemsEnterUpdate, slicerSettings, this.featureSwitches), 
                items.exit().remove(), this.animationFrameId && window.cancelAnimationFrame(this.animationFrameId), 
                this.animationFrameId = window.requestAnimationFrame(function() {
                    itemsEnterUpdate.select("img").attr("title", function(d) {
                        return (0, slicerUtil1.rX)(_this.hostServices, d.tooltip);
                    }).attr("src", function(d) {
                        return d.value;
                    }), itemsEnterUpdate.select(slicerUtil1.NV.selector).attr("title", function(d) {
                        return (0, slicerUtil1.rX)(_this.hostServices, d.tooltip);
                    }).text(function(d) {
                        return d.value;
                    });
                    var labels = _this.element.find(slicerUtil1.NV.selector), item = labels.first(), itemHeight = item.height(), itemWidth = item.width();
                    labels.each(function(i, element) {
                        textMeasurementService.b.wordBreakOverflowingText(element, itemWidth, itemHeight);
                    });
                });
            }, HorizontalSlicerRenderer.prototype.bindInteractivityService = function() {
                if (this.selectionHandler && this.body) {
                    var itemsContainer = this.body.selectAll(IndividualItemContainer.selector), data = this.data, searchInput = this.searchComponent.input;
                    if (!searchInput.empty()) {
                        var element = searchInput.node();
                        (_.isEmpty(element.value) || _.isEmpty(data.searchKey)) && searchInput.property("value", data.searchKey);
                    }
                    this.selectionHandler.bind(data.retainedDataPoints, {
                        behaviorOptions: {
                            slicerContainer: this.container,
                            itemsContainer,
                            settings: data.slicerSettings,
                            searchInput,
                            style: this.style
                        },
                        orientation: slicerOrientation.i.Horizontal
                    });
                }
                this.behavior.renderSelection();
            }, HorizontalSlicerRenderer.prototype.normalizePosition = function() {
                var dataPointsLength = this.getDataPointsCount(), lastStartIndex = this.horizontalSlicerLayout.getLastStartIndex(this.itemsToDisplay, dataPointsLength);
                this.dataStartIndex = Utility.b$.clampValue(this.dataStartIndex, 0, lastStartIndex);
            }, HorizontalSlicerRenderer.prototype.bindNavigationEvents = function() {
                this.registerMouseWheelScrollEvents(), this.registerMouseClickEvents();
            }, HorizontalSlicerRenderer.prototype.registerMouseClickEvents = function() {
                var _this = this, rightNavigationArrow = this.container.selectAll(RightNavigationArrow.selector), leftNavigationArrow = this.container.selectAll(LeftNavigationArrow.selector);
                rightNavigationArrow.on("click", function() {
                    _this.scrollRight();
                }), leftNavigationArrow.on("click", function() {
                    _this.scrollLeft();
                });
            }, HorizontalSlicerRenderer.prototype.registerMouseWheelScrollEvents = function() {
                var _this = this, scrollableElement = this.body.node();
                scrollableElement.addEventListener("mousewheel", function(e) {
                    _this.onMouseWheel(e.wheelDelta);
                }), scrollableElement.addEventListener("DOMMouseScroll", function(e) {
                    _this.onMouseWheel(e.detail);
                });
            }, HorizontalSlicerRenderer.prototype.onMouseWheel = function(wheelDelta) {
                wheelDelta < 0 ? this.scrollRight() : wheelDelta > 0 && this.scrollLeft();
            }, HorizontalSlicerRenderer.prototype.scrollRight = function() {
                var lastItemStartIndex = this.horizontalSlicerLayout.getLastStartIndex(this.itemsToDisplay, this.getDataPointsCount());
                this.dataStartIndex !== lastItemStartIndex && (this.dataStartIndex += this.horizontalSlicerLayout.getScrollSize(this.itemsToDisplay), 
                this.dataStartIndex = Math.min(this.dataStartIndex, lastItemStartIndex), this.renderCore());
            }, HorizontalSlicerRenderer.prototype.scrollLeft = function() {
                0 !== this.dataStartIndex && (this.dataStartIndex -= this.horizontalSlicerLayout.getScrollSize(this.itemsToDisplay), 
                this.dataStartIndex = Math.max(this.dataStartIndex, 0), this.renderCore());
            }, HorizontalSlicerRenderer.prototype.getScaledTextWidth = function(textSize) {
                return textSize / StandaloneUtility1.Gj * 80;
            }, HorizontalSlicerRenderer.prototype.isMaxDimensionsNeedsReCalculate = function() {
                if (!this.lastCalculatedProperties) return !0;
                var slicerSettings = this.data.slicerSettings, slicerText = slicerSettings.slicerText, lastProps = this.lastCalculatedProperties;
                return lastProps.textSize !== slicerText.textSize || lastProps.fontFamily !== slicerText.fontFamily || lastProps.outlineStyle !== slicerText.outlineStyle || lastProps.outlineWeight !== slicerSettings.general.outlineWeight || lastProps.hasImage !== this.data.hasImages;
            }, HorizontalSlicerRenderer.prototype.calculateAndSetMaxItemDimensions = function() {
                var textSize, fontFamily, data = this.data, slicerSettings = this.data.slicerSettings, dataPointsLength = this.getDataPointsCount(), maxItemWidth = 0, maxItemHeight = 0, outlineStyle = slicerSettings.slicerText.outlineStyle, outlineWeight = slicerSettings.general.outlineWeight;
                if (0 === dataPointsLength) maxItemWidth = 0, maxItemHeight = 0; else if (data.hasImages) maxItemWidth = 100, 
                maxItemHeight = 100; else {
                    var dataPoints = data.slicerDataPoints, sampleSize = Math.min(dataPointsLength, 50), properties = jQuery.extend(!0, {}, this.textProperties);
                    fontFamily = slicerSettings.slicerText.fontFamily, properties.fontSize = StandaloneUtility1.FP.fromPoint(textSize = slicerSettings.slicerText.textSize), 
                    properties.fontFamily = fontFamily, properties.text = "Sample";
                    for (var getMaxWordWidth = wordBreaker.bY, textHeight = textMeasurementService.b.measureSvgTextHeight(properties), i = 0; i < sampleSize; i++) {
                        var itemText = dataPoints[i].value;
                        properties.text = itemText, maxItemWidth = Math.max(maxItemWidth, getMaxWordWidth(itemText, textMeasurementService.b.measureSvgTextWidth, properties));
                        var lines = Math.min(2, (0, wordBreaker.iD)(itemText));
                        maxItemHeight = Math.max(maxItemHeight, textHeight * lines);
                    }
                    maxItemWidth = Math.min(maxItemWidth, this.getScaledTextWidth(textSize));
                }
                var borderWidth = this.domHelper.getRowsOutlineWidth(outlineStyle, outlineWeight);
                this.totalItemWidth = maxItemWidth + 18 + borderWidth, this.totalItemHeight = maxItemHeight + 18 + borderWidth;
                var result = this.horizontalSlicerLayout.calculateTotalItemDimensions(this.totalItemWidth, this.totalItemHeight);
                this.totalItemWidth = result.width, this.totalItemHeight = result.height, this.lastCalculatedProperties = {
                    outlineStyle,
                    outlineWeight,
                    textSize,
                    fontFamily,
                    hasImage: data.hasImages
                };
            }, HorizontalSlicerRenderer.prototype.focusNextElement = function(forward) {
                var option = this.horizontalSlicerLayout.findNextElement(document.activeElement, forward);
                if (!option) {
                    forward ? this.scrollRight() : this.scrollLeft();
                    var itemContainer = this.itemsContainer.node(), element = document.activeElement;
                    itemContainer.contains(element) || (element = itemContainer), option = this.horizontalSlicerLayout.findNextElement(element, forward);
                }
                option && option.focus();
            }, HorizontalSlicerRenderer.prototype.updateItemsContainerLabel = function() {
                var _a;
                (null === (_a = this.data) || void 0 === _a ? void 0 : _a.categorySourceName) && this.itemsContainer.attr("aria-label", this.data.categorySourceName), 
                this.itemsContainer.attr("aria-multiselectable", !(this.data && this.data.slicerSettings.selection.strictSingleSelect));
            }, HorizontalSlicerRenderer.prototype.getDataPointsCount = function() {
                return _.size(this.data.slicerDataPoints);
            }, HorizontalSlicerRenderer.prototype.addWarnings = function(warningBuilder) {
                (0, slicerUtil1.td)(this.data.warnings, warningBuilder);
            }, HorizontalSlicerRenderer;
        }(), HorizontalSlicerLayout = function() {
            function HorizontalSlicerLayout() {}
            return HorizontalSlicerLayout.prototype.bindData = function(materializedDataPoints, data, itemsContainer) {
                return itemsContainer.selectAll(IndividualItemContainer.selector).data(materializedDataPoints, function(d) {
                    return (0, slicerUtil1.fz)(d);
                });
            }, HorizontalSlicerLayout.prototype.calculateTotalItemDimensions = function(totalItemWidth, totalItemHeight) {
                return {
                    width: totalItemWidth,
                    height: totalItemHeight
                };
            }, HorizontalSlicerLayout.prototype.calculateNumberOfItemsToDisplay = function(element, totalItemsWidth, totalItemsHeight, dataPointsLength) {
                var availableWidth = element.find(slicerUtil1.uT.selector).width() - 2 * HorizontalSlicerLayout.NavigationArrowWidth;
                if (0 === totalItemsWidth) return 0;
                var numberOfItems = Math.round(availableWidth / totalItemsWidth);
                return Utility.b$.clampValue(numberOfItems, 1, dataPointsLength);
            }, HorizontalSlicerLayout.prototype.findNextElement = function(element, forward) {
                return $(element).hasClass(ItemsContainer.class) ? forward ? element.firstElementChild : void 0 : forward ? element.nextElementSibling : element.previousElementSibling;
            }, HorizontalSlicerLayout.prototype.getNavigationArrowsClass = function(selection, isLeft) {
                isLeft ? selection.classed(NavigationArrow.class, !0).classed(LeftNavigationArrow.class, !0) : selection.classed(NavigationArrow.class, !0).classed(RightNavigationArrow.class, !0);
            }, HorizontalSlicerLayout.prototype.getScrollSize = function(itemsToDisplay) {
                return 1 === itemsToDisplay ? itemsToDisplay : itemsToDisplay - 1;
            }, HorizontalSlicerLayout.prototype.getLastStartIndex = function(itemsToDisplay, dataPointsLength) {
                return dataPointsLength - itemsToDisplay;
            }, HorizontalSlicerLayout.prototype.getDataPointRightMargin = function(index, itemsToDisplay) {
                return this.isLastRowItem(index, itemsToDisplay) ? "0px" : StandaloneUtility1.FP.toString(2);
            }, HorizontalSlicerLayout.prototype.isLastRowItem = function(fieldIndex, columnsToDisplay) {
                return fieldIndex === columnsToDisplay - 1;
            }, HorizontalSlicerLayout.NavigationArrowWidth = 19, HorizontalSlicerLayout;
        }(), selectmenu = __webpack_require__(68983), relativeSlicerPeriod = __webpack_require__(73508), relativeSlicerRelativeQualifier = __webpack_require__(66486), relativeDateFilterPattern = __webpack_require__(38703), semanticQuery = __webpack_require__(95462), RelativeDateComponent = function() {
            function RelativeDateComponent() {}
            return RelativeDateComponent.prototype.getVisualObjectInstance = function(data) {
                return {
                    selector: null,
                    objectName: "dateRange",
                    properties: {
                        includeToday: data.includeToday,
                        anchorDate: data.anchorDate
                    }
                };
            }, RelativeDateComponent.prototype.appendVisualSlices = function(groupBuilder, data) {
                null != data.includeToday && groupBuilder.addSimpleSlice("includeToday", new build_control_util.bd({
                    descriptor: slicer_capabilities.gO.dateRange.includeToday,
                    value: data.includeToday
                }).build()), groupBuilder.addSimpleSlice("anchorDate", new build_control_util.hz({
                    descriptor: slicer_capabilities.gO.dateRange.anchorDate,
                    value: data.anchorDate,
                    placeholder: ""
                }).build());
            }, RelativeDateComponent.prototype.getMode = function() {
                return slicerMode.K8;
            }, RelativeDateComponent.prototype.getRelativePropertyId = function() {
                return slicer_capabilities.gO.data.relativePeriod;
            }, RelativeDateComponent.prototype.getListOfOptions = function() {
                return relativeSlicerPeriod.GA.members();
            }, RelativeDateComponent.prototype.getSelectedPeriodOption = function(data) {
                return debug.fF.assert(function() {
                    return !(0, formatUtil.g)(data.period);
                }, "The period should be defined"), relativeSlicerPeriod.GA.members([ data.period ])[0];
            }, RelativeDateComponent.prototype.getPeriods = function(data) {
                var periods = data.range !== relativeSlicerRelativeQualifier.Vk ? relativeSlicerPeriod.GA.members() : relativeSlicerPeriod.J6.members();
                if (data.range === relativeSlicerRelativeQualifier.Vk) switch (data.period) {
                  case relativeSlicerPeriod.qQ:
                    data.period = relativeSlicerPeriod.P4;
                    break;

                  case relativeSlicerPeriod.ks:
                    data.period = relativeSlicerPeriod.e7;
                    break;

                  case relativeSlicerPeriod.$G:
                    data.period = relativeSlicerPeriod.gQ;
                }
                return periods;
            }, RelativeDateComponent;
        }(), RelativeTimeComponent = function() {
            function RelativeTimeComponent() {}
            return RelativeTimeComponent.prototype.getVisualObjectInstance = function(data) {}, 
            RelativeTimeComponent.prototype.appendVisualSlices = function(groupBuilder, data) {}, 
            RelativeTimeComponent.prototype.getMode = function() {
                return slicerMode.GV;
            }, RelativeTimeComponent.prototype.getRelativePropertyId = function() {
                return slicer_capabilities.gO.data.relativeTimePeriod;
            }, RelativeTimeComponent.prototype.getListOfOptions = function() {
                return relativeSlicerPeriod._k.members();
            }, RelativeTimeComponent.prototype.getSelectedPeriodOption = function(data) {
                return debug.fF.assert(function() {
                    return !(0, formatUtil.g)(data.period);
                }, "The period should be defined"), relativeSlicerPeriod._k.members([ data.period ])[0];
            }, RelativeTimeComponent.prototype.getPeriods = function(data) {
                return data.range !== relativeSlicerRelativeQualifier.Vk ? relativeSlicerPeriod._k.members() : relativeSlicerPeriod.PN.members();
            }, RelativeTimeComponent;
        }();
        function toRelativeDateRangeOptions(data) {
            return debug.fF.assertValue(data, "data"), {
                duration: data.duration,
                includeToday: data.includeToday,
                relativeUnit: toRelativeDateUnit(data.period),
                relativeQualifier: toRelativeDateQualifier(data.range),
                anchorDate: data.anchorDate
            };
        }
        function toRelativeDateUnit(timePeriod) {
            switch (timePeriod) {
              case relativeSlicerPeriod.LK:
                return relativeDateRange.hU.Minute;

              case relativeSlicerPeriod.i4:
                return relativeDateRange.hU.Hour;

              case relativeSlicerPeriod.an:
                return relativeDateRange.hU.Day;

              case relativeSlicerPeriod.P4:
                return relativeDateRange.hU.Week;

              case relativeSlicerPeriod.qQ:
                return relativeDateRange.hU.CalendarWeek;

              case relativeSlicerPeriod.e7:
                return relativeDateRange.hU.Month;

              case relativeSlicerPeriod.ks:
                return relativeDateRange.hU.CalendarMonth;

              case relativeSlicerPeriod.gQ:
                return relativeDateRange.hU.Year;

              case relativeSlicerPeriod.$G:
                return relativeDateRange.hU.CalendarYear;

              default:
                return void debug.fF.assertFail("Unsupported timePeriod: " + timePeriod);
            }
        }
        function toRelativeDateQualifier(qualifier) {
            switch (qualifier) {
              case relativeSlicerRelativeQualifier.Z$:
                return relativeDateRange.KO.Last;

              case relativeSlicerRelativeQualifier.Vk:
                return relativeDateRange.KO.Current;

              case relativeSlicerRelativeQualifier.lp:
                return relativeDateRange.KO.Next;

              default:
                return void debug.fF.assertFail("Unsupported qualifier: " + qualifier);
            }
        }
        function DefaultInputSettings(style) {
            return {
                textSize: 9,
                fontFamily: fontUtils.Wn.regular.css,
                fontColor: common_colorHelper.v.getThemeColor(style, "foregroundDark"),
                background: null,
                labelBold: !1,
                labelItalic: !1,
                labelUnderline: !1
            };
        }
        var RelativeSlicer = function() {
            function RelativeSlicer(options, type) {
                this.isRendered = !1, this.hostServices = options.hostServices, this.relativeSlicerComponent = function(type) {
                    switch (type) {
                      case relativeDateRange.wj.Time:
                        return new RelativeTimeComponent;

                      case relativeDateRange.wj.Date:
                        return new RelativeDateComponent;

                      default:
                        return void debug.fF.assertFail("Unsupported RelativeFilterType");
                    }
                }(type);
            }
            return RelativeSlicer.prototype.init = function(options, element) {
                this.host = element, this.isRendered = !1, this.style = options.visualInitOptions.style, 
                this.eventsHelper = new slicerUtil1.PB;
            }, RelativeSlicer.prototype.onDestroy = function() {
                this.unregisterSelectMenuCloseEvents && this.unregisterSelectMenuCloseEvents(), 
                this.rangeSelectMenu && this.rangeSelectMenu.destroy(), this.periodSelectMenu && this.periodSelectMenu.destroy();
            }, RelativeSlicer.prototype.hasSlider = function() {
                return !1;
            }, RelativeSlicer.prototype.supportsOrientation = function() {
                return !1;
            }, RelativeSlicer.prototype.onClear = function() {
                this.data.range = relativeSlicerRelativeQualifier.Z$, this.data.period = relativeSlicerPeriod.YP, 
                this.data.duration = 1, this.data.filter = null, this.renderInternal(), (0, slicerUtil1.VD)(this.hostServices, this.data.mode);
            }, RelativeSlicer.prototype.enumerateObjectInstances = function(options, featureSwitches) {
                var _a, visualObject = this.relativeSlicerComponent.getVisualObjectInstance(this.data);
                if ("dateRange" === options.objectName && visualObject) return [ visualObject ];
                if ("numericInputStyle" === options.objectName) {
                    var numericProps = slicer_capabilities.gO.numericInputStyle;
                    return [ {
                        selector: null,
                        objectName: "numericInputStyle",
                        properties: (_a = {
                            fontColor: this.data.inputStyle.fontColor,
                            background: this.data.inputStyle.background,
                            textSize: this.data.inputStyle.textSize,
                            fontFamily: this.data.inputStyle.fontFamily
                        }, _a[numericProps.bold.propertyName] = this.data.inputStyle.labelBold, _a[numericProps.italic.propertyName] = this.data.inputStyle.labelItalic, 
                        _a[numericProps.underline.propertyName] = this.data.inputStyle.labelUnderline, _a)
                    } ];
                }
            }, RelativeSlicer.prototype.getValuesCard = function(featureSwitches) {
                var _this = this, numericProps = slicer_capabilities.gO.numericInputStyle, valuesCardBuilder = new build_control_util.CQ(new build_control_util.lg("values"), "Role_DisplayName_Values", [ numericProps.fontFamily, numericProps.textSize, numericProps.fontColor, numericProps.background, numericProps.bold, numericProps.italic, numericProps.underline, slicer_capabilities.gO.dateRange.includeToday, slicer_capabilities.gO.dateRange.anchorDate ], function(key) {
                    return _this.hostServices.getLocalizedString(key);
                }), fontControl = (new build_control_util.UN).withFontFamily({
                    descriptor: numericProps.fontFamily,
                    value: this.data.inputStyle.fontFamily
                }).withFontSizeProperties({
                    descriptor: numericProps.textSize,
                    value: this.data.inputStyle.textSize
                }).withBold({
                    descriptor: numericProps.bold,
                    value: this.data.inputStyle.labelBold
                }).withItalic({
                    descriptor: numericProps.italic,
                    value: this.data.inputStyle.labelItalic
                }).withUnderline({
                    descriptor: numericProps.underline,
                    value: this.data.inputStyle.labelUnderline
                }).build();
                return valuesCardBuilder.addGroup("values", function(groupBuilder) {
                    groupBuilder.withDisplayName("Role_DisplayName_Values"), groupBuilder.addCompositeSlice("fontselector", "Font", fontControl), 
                    groupBuilder.addSimpleSlice("color", new build_control_util.BT({
                        descriptor: numericProps.fontColor,
                        value: {
                            value: _this.data.inputStyle.fontColor
                        }
                    }).build()), _this.relativeSlicerComponent.appendVisualSlices(groupBuilder, _this.data);
                }).addGroup("background", function(groupBuilder) {
                    groupBuilder.withDisplayName("Visual_Background").addSimpleSlice("color", new build_control_util.BT({
                        descriptor: numericProps.background,
                        value: {
                            value: _this.data.inputStyle.background
                        }
                    }).build());
                }), valuesCardBuilder.build();
            }, RelativeSlicer.prototype.getSlicerSettingsCardOptions = function(cardUidBuilder, orientation, activeMode, slicerModes, featureSwitches) {
                return (0, slicerUtil1.nD)({
                    cardUidBuilder,
                    currentSlicerSettings: void 0,
                    data: void 0,
                    dataView: void 0,
                    hostServices: this.hostServices,
                    orientation,
                    activeMode,
                    slicerModes,
                    featureSwitches
                });
            }, RelativeSlicer.prototype.getAdditionalCards = function() {}, RelativeSlicer.prototype.onModeChange = function(mode) {
                (0, slicerUtil1.VD)(this.hostServices, mode);
            }, RelativeSlicer.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                var newPropertySaveObjects = (0, slicerUtil1.tm)(propertySaveObjects, sourceType);
                return debug.fF.assertNonEmpty(newPropertySaveObjects, "There should be at least one save object"), 
                newPropertySaveObjects;
            }, RelativeSlicer.converter = function(reader, style, mode, relativePropertyId) {
                var result = {
                    mode,
                    range: relativeSlicerRelativeQualifier.Z$,
                    period: relativeSlicerPeriod.YP,
                    duration: 1,
                    includeToday: !0,
                    identity: null,
                    anchorDate: void 0,
                    filter: null,
                    inputStyle: DefaultInputSettings(style)
                }, metadataColumns = reader.columns.getMetadataColumns(slicer_capabilities.CT.value);
                debug.fF.assert(function() {
                    return 1 === metadataColumns.length;
                }, "expect to have a metadataColumn"), result.identity = metadataColumns[0].expr;
                var objects = reader.objects.getStaticObjects();
                if (objects) {
                    var colorHelper = common_colorHelper.v.create(style);
                    result.filter = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.general.filter, result.filter), 
                    result.range = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.data.relativeRange, result.range), 
                    result.period = (0, dataViewObject2.NA)(objects, relativePropertyId, result.period), 
                    result.duration = Math.abs((0, dataViewObject2.NA)(objects, slicer_capabilities.gO.data.relativeDuration, result.duration)), 
                    result.includeToday = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.dateRange.includeToday, result.includeToday), 
                    result.anchorDate = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.dateRange.anchorDate, result.anchorDate);
                    var slicerNumericInputFontProperties = (0, fontProperties.Zi)((0, dataViewObject2.RK)(objects, "numericInputStyle"), {
                        color: "fontColor",
                        family: "fontFamily",
                        size: "textSize"
                    }, colorHelper, style, "foregroundDark", "smallLabel", {
                        color: result.inputStyle.fontColor,
                        family: result.inputStyle.fontFamily,
                        size: units.B.createFromPt(result.inputStyle.textSize)
                    });
                    result.inputStyle.fontColor = slicerNumericInputFontProperties.color, result.inputStyle.fontFamily = slicerNumericInputFontProperties.family, 
                    result.inputStyle.textSize = slicerNumericInputFontProperties.size.pt, result.inputStyle.background = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.numericInputStyle.background, result.inputStyle.background), 
                    result.inputStyle.labelBold = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.numericInputStyle.bold, result.inputStyle.labelBold), 
                    result.inputStyle.labelItalic = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.numericInputStyle.italic, result.inputStyle.labelItalic), 
                    result.inputStyle.labelUnderline = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.numericInputStyle.underline, result.inputStyle.labelUnderline);
                }
                return result;
            }, RelativeSlicer.prototype.render = function(options) {
                var _this = this, reader = (0, dataViewCategoricalReader.G)(options.dataView);
                this.data = RelativeSlicer.converter(reader, this.style, this.relativeSlicerComponent.getMode(), this.relativeSlicerComponent.getRelativePropertyId()), 
                this.isRendered || (this.initControls(), this.unregisterSelectMenuCloseEvents = this.eventsHelper.onPopupHideEvent(function(eventType, target) {
                    _this.onSelectMenuClose(eventType, target);
                }, this.selectionContainer.get(0))), this.updateProperties(this.data.range, this.data.period, this.data.duration), 
                this.renderInternal();
            }, RelativeSlicer.prototype.onSelectMenuClose = function(eventType, target) {
                $(target).hasClass("slicer-select-menu") || $(target).closest(".".concat("slicer-select-menu")).length || (this.rangeSelectMenu.close(), 
                this.periodSelectMenu.close());
            }, RelativeSlicer.prototype.initControls = function() {
                var _this = this;
                this.isRendered = !0, this.container = (0, DomFactory.hi)().addClass("relative-slicer").appendTo(this.host), 
                this.selectionContainer = (0, DomFactory.hi)().addClass("selection-container").appendTo(this.container), 
                this.selectionContainer.on("keyup keydown", function(event) {
                    9 !== event.keyCode && 27 !== event.keyCode && event.stopPropagation();
                }), this.rangeSelectMenuContainer = (0, DomFactory.hi)().addClass("range-menu").appendTo(this.selectionContainer);
                var rangeSettings = {
                    onChange: function(val) {
                        _this.rangeChanged(val);
                    },
                    container: this.rangeSelectMenuContainer,
                    options: this.getSelectMenuOptions(relativeSlicerRelativeQualifier.dt.members()),
                    className: "slicer-select-menu",
                    selectedValue: "Select",
                    title: this.hostServices.getLocalizedString("Visual_Axis_Range")
                };
                this.rangeSelectMenu = new selectmenu.S(rangeSettings), this.rangeSelectMenu.update({
                    selectedValue: relativeSlicerRelativeQualifier.Z$
                }), this.durationInput = (0, DomFactory.ze)().attr("type", "number").attr("min", "1").attr("max", this.getDurationMax()).attr("drag-resize-disabled", "true").addClass("duration-input").attr("aria-label", this.hostServices.getLocalizedString("Duration")).appendTo(this.selectionContainer), 
                this.durationInput.val(this.data.duration.toString()), this.durationInput.on("change", _.debounce(function(event) {
                    _this.durationChanged();
                }, 100)), this.periodSelectMenuContainer = (0, DomFactory.hi)().addClass("period-menu").appendTo(this.selectionContainer);
                var listOfOptions = this.relativeSlicerComponent.getListOfOptions(), periodSettings = {
                    onChange: function(val) {
                        _this.periodChanged(val);
                    },
                    container: this.periodSelectMenuContainer,
                    options: this.getSelectMenuOptions(listOfOptions),
                    className: "slicer-select-menu",
                    title: this.hostServices.getLocalizedString("DaxTemplates_PeriodField")
                };
                this.periodSelectMenu = new selectmenu.S(periodSettings), this.periodSelectMenu.disableOption(relativeSlicerPeriod.YP), 
                this.updatePeriod(), this.restatementContainer = (0, DomFactory.hi)().addClass("restatement-container").appendTo(this.container), 
                this.restatementIcon = $("<i ></i>").addClass("restatement-icon").addClass("pbi-glyph-datetime").appendTo(this.restatementContainer), 
                this.restatement = (0, DomFactory.hi)().addClass("restatement").appendTo(this.restatementContainer), 
                this.restatement.text(this.hostServices.getLocalizedString("ExportData_NoAppliedFiltersText"));
            }, RelativeSlicer.prototype.updatePeriod = function() {
                var periods = this.relativeSlicerComponent.getPeriods(this.data);
                this.periodSelectMenu.update({
                    options: this.getSelectMenuOptions(periods),
                    selectedValue: this.data.period
                });
            }, RelativeSlicer.prototype.rangeChanged = function(val) {
                this.data.range = val, this.data.range === relativeSlicerRelativeQualifier.Vk ? (this.durationInput.attr("type", "text"), 
                this.durationInput.val("-"), this.durationInput.prop("disabled", !0), this.data.duration = 0) : ("-" === this.durationInput.val() ? (this.durationInput.attr("type", "number"), 
                this.durationInput.val("1"), this.data.duration = 1) : this.updateDuration(), this.durationInput.prop("disabled", !1)), 
                this.updatePeriod();
                var visualObjectInstancesToPersist = this.updateProperties(this.data.range, this.data.period, this.data.duration);
                this.hostServices.persistProperties(visualObjectInstancesToPersist), this.renderInternal();
            }, RelativeSlicer.prototype.periodChanged = function(val) {
                this.updateDuration();
                var visualObjectInstancesToPersist = this.updateProperties(this.data.range, val, this.data.duration);
                this.hostServices.persistProperties(visualObjectInstancesToPersist), this.renderInternal();
            }, RelativeSlicer.prototype.durationChanged = function() {
                this.updateDuration();
                var visualObjectInstancesToPersist = this.updateProperties(this.data.range, this.data.period, this.data.duration);
                this.hostServices.persistProperties(visualObjectInstancesToPersist), this.renderInternal();
            }, RelativeSlicer.prototype.renderInternal = function() {
                var periodOption = this.relativeSlicerComponent.getSelectedPeriodOption(this.data), fontSize = StandaloneUtility1.FP.fromPointToPixel(this.data.inputStyle.textSize), css = {
                    "font-size": fontSize,
                    "font-family": this.data.inputStyle.fontFamily,
                    color: this.data.inputStyle.fontColor,
                    "background-color": this.data.inputStyle.background ? this.data.inputStyle.background : "",
                    "font-weight": this.data.inputStyle.labelBold ? CssConstants.en : CssConstants.AI,
                    "font-style": this.data.inputStyle.labelItalic ? CssConstants.BF : CssConstants.AI,
                    "text-decoration": this.data.inputStyle.labelUnderline ? CssConstants.f0 : CssConstants.zu
                };
                this.durationInput.css(css), css["font-size"] = fontSize - 1, this.restatement.css(css);
                var rangeMenuButton = this.rangeSelectMenuContainer.find(".ui-selectmenu-button");
                rangeMenuButton.css(css);
                var rangeTooltip = relativeSlicerRelativeQualifier.dt.members([ this.data.range ])[0].displayName({
                    get: this.hostServices.getLocalizedString.bind(this.hostServices)
                });
                rangeMenuButton.attr("title", rangeTooltip);
                var periodMenuButton = this.periodSelectMenuContainer.find(".ui-selectmenu-button");
                periodMenuButton.css(css);
                var periodTooltip = periodOption.displayName({
                    get: this.hostServices.getLocalizedString.bind(this.hostServices)
                });
                periodMenuButton.attr("title", periodTooltip), this.rangeSelectMenu.update({
                    selectedValue: this.data.range
                }), this.updatePeriod(), this.periodSelectMenu.disableOption(relativeSlicerPeriod.YP), 
                0 === this.data.duration ? (this.durationInput.attr("type", "text"), this.durationInput.val("-"), 
                this.durationInput.prop("disabled", !0)) : (this.durationInput.attr("type", "number"), 
                this.durationInput.prop("disabled", !1), this.durationInput.attr("max", this.getDurationMax()), 
                this.durationInput.val(Math.abs(this.data.duration).toString())), this.setRestatement();
            }, RelativeSlicer.prototype.updateProperties = function(range, period, duration) {
                this.data.range = range;
                var visualObjectInstancesToPersist, periodChanged = this.data.period !== period;
                this.data.period = period, this.data.duration = duration;
                var filterExpr = null;
                if (this.data.period !== relativeSlicerPeriod.YP && (filterExpr = this.createFilter()), 
                null !== filterExpr || !this.data.filter) {
                    var semanticFilter = filterExpr ? semanticQuery.yl.fromSQExpr(filterExpr) : null;
                    return semanticQuery.yl.isSameFilter(semanticFilter, this.data.filter) && !periodChanged || (visualObjectInstancesToPersist = this.createProperties(semanticFilter), 
                    this.setRestatement()), visualObjectInstancesToPersist;
                }
                this.onClear();
            }, RelativeSlicer.prototype.updateDuration = function() {
                this.data.range === relativeSlicerRelativeQualifier.Vk ? this.data.duration = 0 : this.isDurationValid() && (this.data.duration = Math.min(parseInt(this.durationInput.val(), 10), this.getDurationMax()));
            }, RelativeSlicer.prototype.isDurationValid = function() {
                var inputValue = parseInt(this.durationInput.val(), 10);
                return $.isNumeric(inputValue) && inputValue > 0;
            }, RelativeSlicer.prototype.getDurationMax = function() {
                var period = this.data.period !== relativeSlicerPeriod.YP ? this.data.period : relativeSlicerPeriod.an;
                return relativeDateRange.t0.getDurationMax(toRelativeDateQualifier(this.data.range), toRelativeDateUnit(period));
            }, RelativeSlicer.prototype.createFilter = function() {
                var filter;
                if (this.data.identity) {
                    var options = toRelativeDateRangeOptions(this.data);
                    filter = (0, relativeDateFilterPattern.kW)({
                        field: this.data.identity,
                        options
                    });
                }
                return filter;
            }, RelativeSlicer.prototype.getRelativePropertyName = function() {
                return this.relativeSlicerComponent.getRelativePropertyId().propertyName;
            }, RelativeSlicer.prototype.createProperties = function(filter) {
                var objects = {
                    merge: [],
                    replace: [],
                    remove: []
                }, objectGeneral = {
                    objectName: "general",
                    selector: null,
                    properties: {}
                };
                null !== filter ? (objectGeneral.properties[slicer_capabilities.gO.general.filter.propertyName] = filter, 
                objects.merge.push(objectGeneral)) : (objectGeneral.properties[slicer_capabilities.gO.general.filter.propertyName] = !0, 
                objects.remove.push(objectGeneral));
                var objectData = {
                    objectName: "data",
                    selector: null,
                    properties: {}
                };
                if (null != this.data.mode && (objectData.properties[slicer_capabilities.gO.data.mode.propertyName] = this.data.mode), 
                null != this.data.range && (objectData.properties[slicer_capabilities.gO.data.relativeRange.propertyName] = this.data.range), 
                null != this.data.duration && (objectData.properties[slicer_capabilities.gO.data.relativeDuration.propertyName] = this.data.duration), 
                null != this.data.period) {
                    var relativePropertyName = this.getRelativePropertyName();
                    objectData.properties[relativePropertyName] = this.data.period;
                }
                objects.replace.push(objectData);
                var objectDateRange = {
                    objectName: "dateRange",
                    selector: null,
                    properties: {}
                };
                return null != this.data.includeToday && (objectDateRange.properties[slicer_capabilities.gO.dateRange.includeToday.propertyName] = this.data.includeToday), 
                this.data.anchorDate && (objectDateRange.properties[slicer_capabilities.gO.dateRange.anchorDate.propertyName] = this.data.anchorDate), 
                objects.replace.push(objectDateRange), this.hostServices.onSelect({
                    type: 0,
                    visualObjects: []
                }), objects;
            }, RelativeSlicer.prototype.setRestatement = function() {
                var _a, _b, _c, _this = this;
                if (this.data.period === relativeSlicerPeriod.YP) this.restatement.text(this.hostServices.getLocalizedString("ExportData_NoAppliedFiltersText")); else {
                    var options = toRelativeDateRangeOptions(this.data), shouldGetDetailedRestatement = null === (_b = null === (_a = this.hostServices) || void 0 === _a ? void 0 : _a.networkAvailability()) || void 0 === _b ? void 0 : _b.isNetworkAvailable();
                    this.restatement.text(relativeDateRange.t0.getRestatement(options, shouldGetDetailedRestatement, function(key, args) {
                        return _this.hostServices.getLocalizedString(key, args);
                    }, null === (_c = this.hostServices.visualTimeSynchronization()) || void 0 === _c ? void 0 : _c.getAnchorTime()));
                }
            }, RelativeSlicer.prototype.getSelectMenuOptions = function(options) {
                for (var selectMenuOptions = [], _i = 0, options_1 = options; _i < options_1.length; _i++) {
                    var option = options_1[_i], displayName = option.displayName({
                        get: this.hostServices.getLocalizedString.bind(this.hostServices)
                    });
                    selectMenuOptions.push({
                        text: displayName,
                        value: option.value
                    });
                }
                return selectMenuOptions;
            }, RelativeSlicer;
        }(), NumericSlicerOptions = (0, __webpack_require__(28488).i)([ {
            value: slicerMode.vX,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_Between");
            }
        }, {
            value: slicerMode.bb,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_LessThanEqualLabel");
            }
        }, {
            value: slicerMode.e4,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_GreaterThanEqualLabel");
            }
        }, {
            value: slicerMode.RB,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_Basic");
            }
        }, {
            value: slicerMode.j6,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_Dropdown");
            }
        }, {
            value: slicerMode.Zr,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_SingleVal");
            }
        }, {
            value: slicerMode.Ih,
            displayName: function(resources) {
                return resources.get("Visual_SliderMode_VerticalList");
            }
        }, {
            value: slicerMode.of,
            displayName: function(resources) {
                return resources.get("Tile_Generic");
            }
        } ]), NumericSlicer = function() {
            function NumericSlicer(options) {
                this.hostServices = options.hostServices, this.startInputLabel = this.hostServices.getLocalizedString("Slicer_StartTimeLabel"), 
                this.endInputLabel = this.hostServices.getLocalizedString("Slicer_EndTimeLabel");
            }
            return NumericSlicer.prototype.createRange = function(data) {
                return data.isSourceInteger ? new scaleRange.BN(data.bounds.min, data.bounds.max, data.value.min, data.value.max) : new scaleRange.mD(data.bounds.min, data.bounds.max, data.value.min, data.value.max);
            }, NumericSlicer.prototype.areEqual = function(val1, val2) {
                return val1 === val2;
            }, NumericSlicer.prototype.defaultValue = function() {
                return 0;
            }, NumericSlicer.prototype.startProperty = function() {
                return slicer_capabilities.gO.data.numericStart;
            }, NumericSlicer.prototype.endProperty = function() {
                return slicer_capabilities.gO.data.numericEnd;
            }, NumericSlicer.prototype.parseSingleSliderValue = function(position, dataPoints) {
                var value = dataPoints[position];
                return {
                    min: value,
                    max: value
                };
            }, NumericSlicer.prototype.formatValue = function(value, formatter) {
                return debug.fF.assertValue(value, "value"), formatter ? formatter.format(value) : value.toString();
            }, NumericSlicer.prototype.getSliderOptions = function(data, singleValue) {
                return singleValue ? {
                    min: 0,
                    max: data.dataPoints.length - 1,
                    step: 1
                } : data.isSourceInteger ? {
                    min: data.bounds.min,
                    max: data.bounds.max,
                    step: 1
                } : {
                    min: data.bounds.min,
                    max: data.bounds.max,
                    step: null
                };
            }, NumericSlicer.prototype.inputStyleProperties = function() {
                return {
                    background: slicer_capabilities.gO.numericInputStyle.background,
                    fontColor: slicer_capabilities.gO.numericInputStyle.fontColor,
                    textSize: slicer_capabilities.gO.numericInputStyle.textSize,
                    fontFamily: slicer_capabilities.gO.numericInputStyle.fontFamily,
                    bold: slicer_capabilities.gO.numericInputStyle.bold,
                    italic: slicer_capabilities.gO.numericInputStyle.italic,
                    underline: slicer_capabilities.gO.numericInputStyle.underline
                };
            }, NumericSlicer.prototype.parseInput = function(inputString, dataPoints, singleValue) {
                var value = parseFloat(inputString);
                return singleValue && $.isNumeric(value) ? _.indexOf(dataPoints, value) > -1 ? value : this.findClosestPoint(value, dataPoints) : value;
            }, NumericSlicer.prototype.findClosestPoint = function(value, dataPoints) {
                for (var result = _.head(dataPoints), difference = Math.abs(result - value), i = 1; i < dataPoints.length; i++) {
                    var currentDifference = Math.abs(dataPoints[i] - value);
                    currentDifference < difference && (difference = currentDifference, result = dataPoints[i]);
                }
                return result;
            }, NumericSlicer.prototype.isInputValid = function(inputValue, range, type, singleValue) {
                return !(!$.isNumeric(inputValue) || 0 === type && inputValue > range.max || 1 === type && inputValue < range.min || singleValue && inputValue === range.min);
            }, NumericSlicer.prototype.setRange = function(value, formatter, start, end, type, bounds) {
                debug.fF.assertValue(value.min, "value.min"), debug.fF.assertValue(value.max, "value.max"), 
                null == type ? (start.val(formatter.format(value.min)), start.attr("aria-label", (0, 
                formatUtil.W)(this.startInputLabel, formatter.format(bounds.min), formatter.format(value.max))), 
                end.val(formatter.format(value.max)), end.attr("aria-label", (0, formatUtil.W)(this.endInputLabel, formatter.format(value.min), formatter.format(bounds.max)))) : 0 === type ? (start.val(formatter.format(value.min)), 
                start.attr("aria-label", (0, formatUtil.W)(this.startInputLabel, formatter.format(bounds.min), formatter.format(bounds.max)))) : 1 === type && (end.val(formatter.format(value.max)), 
                end.attr("aria-label", (0, formatUtil.W)(this.endInputLabel, formatter.format(bounds.min), formatter.format(bounds.max))));
            }, NumericSlicer.prototype.createInputElement = function(control, type) {
                return (0, DomFactory.ze)().attr("type", "text").attr("drag-resize-disabled", "true").addClass(InputClass.class).appendTo(control);
            }, NumericSlicer.prototype.enumerateObjectInstances = function(options, data, featureSwitches) {
                var _a;
                if ("numericInputStyle" === options.objectName && data && data.inputStyle) {
                    var numericProps = slicer_capabilities.gO.numericInputStyle;
                    return [ {
                        selector: null,
                        objectName: "numericInputStyle",
                        properties: (_a = {
                            fontColor: data.inputStyle.fontColor,
                            background: data.inputStyle.background,
                            textSize: data.inputStyle.textSize,
                            fontFamily: data.inputStyle.fontFamily
                        }, _a[numericProps.bold.propertyName] = data.inputStyle.labelBold, _a[numericProps.italic.propertyName] = data.inputStyle.labelItalic, 
                        _a[numericProps.underline.propertyName] = data.inputStyle.labelUnderline, _a)
                    } ];
                }
            }, NumericSlicer.prototype.getValuesCard = function(data, featureSwitches) {
                var _this = this, numericProps = slicer_capabilities.gO.numericInputStyle, valuesCardBuilder = new build_control_util.CQ(new build_control_util.lg("values"), "Role_DisplayName_Values", [ numericProps.fontFamily, numericProps.textSize, numericProps.fontColor, numericProps.background, numericProps.bold, numericProps.italic, numericProps.underline ], function(key) {
                    return _this.hostServices.getLocalizedString(key);
                }), fontControlBuilder = (new build_control_util.UN).withFontFamily({
                    descriptor: numericProps.fontFamily,
                    value: data.inputStyle.fontFamily
                }).withFontSizeProperties({
                    descriptor: numericProps.textSize,
                    value: data.inputStyle.textSize
                }).withBold({
                    descriptor: numericProps.bold,
                    value: data.inputStyle.labelBold
                }).withItalic({
                    descriptor: numericProps.italic,
                    value: data.inputStyle.labelItalic
                }).withUnderline({
                    descriptor: numericProps.underline,
                    value: data.inputStyle.labelUnderline
                });
                return valuesCardBuilder.addGroup("values", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Role_DisplayName_Values").addCompositeSlice("fontselector", "Font", fontControlBuilder.build()).addSimpleSlice("color", new build_control_util.BT({
                        descriptor: numericProps.fontColor,
                        value: {
                            value: data.inputStyle.fontColor
                        }
                    }).build());
                }).addGroup("background", function(groupBuilder) {
                    return groupBuilder.withDisplayName("Visual_Background").addSimpleSlice("color", new build_control_util.BT({
                        descriptor: numericProps.background,
                        value: {
                            value: data.inputStyle.background
                        }
                    }).build());
                }), valuesCardBuilder.build();
            }, NumericSlicer.prototype.getDataPointsForSingleValueRange = function(dataView) {
                var category = dataView.categorical.categories[0], result = _.filter(category && category.values || [], function(n) {
                    return $.isNumeric(n);
                });
                return result = _.sortBy(result, function(n) {
                    return n;
                }), _.uniq(result);
            }, NumericSlicer.prototype.filterExpr = function(filter) {
                return {
                    lower: (0, sqExpr.tx)(filter.min),
                    upper: (0, sqExpr.tx)(filter.max)
                };
            }, NumericSlicer.prototype.comparisonKind = function() {
                return {
                    lower: 2,
                    upper: 4
                };
            }, NumericSlicer;
        }(), noUiSlider = __webpack_require__(45863), dataLabelViewModel1Consts = __webpack_require__(56707), VisualsCommon_color = __webpack_require__(64067), valueFormatter = __webpack_require__(72489), DefaultFontFamily = "Segoe UI,wf_segoe-ui_normal,helvetica,arial,sans-serif", RangeClass = (0, 
        CssConstants.CH)("date-slicer-range"), rangeSlicer_ContainerClass = (0, CssConstants.CH)("date-slicer"), HeadClass = (0, 
        CssConstants.CH)("date-slicer-head"), SliderClass = (0, CssConstants.CH)("date-slicer-slider"), ControlClass = (0, 
        CssConstants.CH)("date-slicer-control"), RoundHandlesClass = (0, CssConstants.CH)("roundHandles"), WrapRangeBoxesClass = (0, 
        CssConstants.CH)("wrap"), rangeSlicer_DateSlicerClass = (0, CssConstants.CH)("date-slicer-datepicker"), rangeSlicer_DateSlicerWrapperClass = (0, 
        CssConstants.CH)("date-slicer-datepicker-wrapper"), noUiConnectClass = (0, CssConstants.CH)("noUi-connect"), noUiConnectsClass = (0, 
        CssConstants.CH)("noUi-connects"), noUiBackgroundClass = (0, CssConstants.CH)("noUi-background"), noUiHandleClass = (0, 
        CssConstants.CH)("noUi-handle");
        function rangeSlicer_DefaultInputSettings(style) {
            return {
                textSize: 9,
                fontFamily: fontUtils.Wn.regular.css,
                fontColor: common_colorHelper.v.getThemeColor(style, "foregroundDark"),
                background: null,
                labelBold: !1,
                labelItalic: !1,
                labelUnderline: !1
            };
        }
        var RangeSlicer = function() {
            function RangeSlicer(options, renderer, singleValue, isCategorySourceNumeric, viewModelAdapter) {
                this.viewModelAdapter = viewModelAdapter, this.isRendered = !1, options && (this.hostServices = options.hostServices, 
                this.preventTextSelection = options.preventTextSelection, this.featureSwitches = options.featureSwitches), 
                this.rangeSlicerRenderer = renderer, this.singleValue = singleValue, this.isCategorySourceNumeric = isCategorySourceNumeric, 
                this.useModernDatePicker = !this.isCategorySourceNumeric && this.featureSwitches.useModernDatePickerSlicer;
            }
            return Object.defineProperty(RangeSlicer.prototype, "defaultSliderMode", {
                get: function() {
                    return this.singleValue ? slicerMode.Zr : slicerMode.vX;
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(RangeSlicer.prototype, "activeMode", {
                get: function() {
                    return this.data.mode || this.defaultSliderMode;
                },
                enumerable: !1,
                configurable: !0
            }), RangeSlicer.prototype.init = function(options, element) {
                this.host = element, this.style = options.visualInitOptions.style, this.featureSwitches = options.visualInitOptions.featureSwitches;
            }, RangeSlicer.prototype.onModeChange = function(mode) {
                if (_.indexOf(RangeSlicerSupportedModes, mode) > -1) {
                    if (!this.data) return;
                    this.updateMode(mode);
                } else (0, slicerUtil1.VD)(this.hostServices, mode);
            }, RangeSlicer.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                if (0 === sourceType && 1 === propertySaveObjects.length && propertySaveObjects[0].objectName === slicer_capabilities.gO.data.mode.objectName && propertySaveObjects[0].propertyName === slicer_capabilities.gO.data.mode.propertyName) {
                    var newSlicerMode = propertySaveObjects[0].propertyValue;
                    return _.indexOf(RangeSlicerSupportedModes, newSlicerMode) > -1 ? this.buildUpdatedPropertySaveObjects(newSlicerMode) : (0, 
                    slicerUtil1.tm)(propertySaveObjects, sourceType);
                }
                return propertySaveObjects;
            }, RangeSlicer.prototype.buildUpdatedPropertySaveObjects = function(mode) {
                var updatePropertySaveObjects = [];
                this.updateRangeSlicerState(mode);
                var properties = this.buildRangeSlicerProperties();
                this.data.properties.filter = properties.filter, this.data.properties.bounds = properties.bounds;
                var semanticFilterForNewMode = this.createFilter(properties, mode, this.data.state, this.data.identity);
                updatePropertySaveObjects.push({
                    objectName: slicer_capabilities.gO.general.filter.objectName,
                    propertyName: slicer_capabilities.gO.general.filter.propertyName,
                    propertyValue: semanticFilterForNewMode,
                    propertyType: {
                        filter: {}
                    }
                });
                var startEndValuePropertyType = this.isCategorySourceNumeric ? {
                    numeric: !0
                } : {
                    dateTime: !0
                }, startValueProperty = null;
                1 & this.data.state && null !== properties.start && (startValueProperty = properties.start);
                var startSaveObject = {
                    objectName: this.rangeSlicerRenderer.startProperty().objectName,
                    propertyName: this.rangeSlicerRenderer.startProperty().propertyName,
                    propertyValue: startValueProperty,
                    propertyType: startEndValuePropertyType
                };
                updatePropertySaveObjects.push(startSaveObject);
                var endValueProperty = null;
                2 & this.data.state && null !== properties.end && (endValueProperty = properties.end);
                var endSaveObject = {
                    objectName: this.rangeSlicerRenderer.endProperty().objectName,
                    propertyName: this.rangeSlicerRenderer.endProperty().propertyName,
                    propertyValue: endValueProperty,
                    propertyType: startEndValuePropertyType
                };
                return updatePropertySaveObjects.push(endSaveObject), updatePropertySaveObjects.push({
                    objectName: slicer_capabilities.gO.data.mode.objectName,
                    propertyName: slicer_capabilities.gO.data.mode.propertyName,
                    propertyValue: mode,
                    propertyType: {
                        enumeration: slicerMode.dt
                    }
                }), updatePropertySaveObjects;
            }, RangeSlicer.prototype.buildRangeSlicerProperties = function() {
                return {
                    start: 1 & this.data.state ? this.data.value.min : null,
                    end: 2 & this.data.state ? this.data.value.max : null,
                    mode: this.data.mode,
                    filter: {
                        min: this.data.value.min,
                        max: this.data.value.max
                    },
                    bounds: {
                        min: this.data.bounds.min,
                        max: this.data.bounds.max
                    }
                };
            }, RangeSlicer.prototype.onClear = function() {
                if (this.data && this.data.initialValue) {
                    this.data.value = this.data.initialValue, this.data.state = 0, this.updateProperties(), 
                    this.hostServices.triggerUpdate();
                    var message = this.hostServices.getLocalizedString("Slicer_ClearSelectionsCleared");
                    this.hostServices.alertWithDebounce("announce-clear-selection", message);
                }
            }, RangeSlicer.prototype.render = function(options) {
                if (_.isEmpty(options.dataView)) this.hostServices.setWarnings([ new visualWarnings.L$ ]); else {
                    if (this.dataView = options.dataView, this.reader = (0, dataViewCategoricalReader.G)(this.dataView), 
                    this.originalData = this.data = this.converter(this.reader, options), !this.isMetaColumnsValid(this.reader)) return this.hostServices.setWarnings([ new visualWarnings.L$ ]), 
                    void (this.isRendered && this.disableSlicer());
                    this.isRendered && this.enableSlicer(), this.viewModelAdapter && (this.data = this.viewModelAdapter.applyChanges(options.viewport, this.originalData, this.dataView)), 
                    this.isRendered || this.initControls(), this.rangeSlicerRenderer.setRange(this.data.value, this.data.formatter, this.start, this.end, null, this.data.bounds), 
                    this.range = this.rangeSlicerRenderer.createRange(this.data), this.updateInputControls(), 
                    this.updateSlider(this.activeMode), this.updateProperties(), this.isDataColumnsValid(this.reader) || (this.hostServices.setWarnings([ new visualWarnings.L$ ]), 
                    this.isRendered && this.disableSlicer());
                }
            }, RangeSlicer.prototype.hasSlider = function() {
                return !!this.data && this.data.sliderSettings.show;
            }, RangeSlicer.prototype.supportsOrientation = function() {
                return !1;
            }, RangeSlicer.prototype.enumerateObjectInstances = function(options) {
                var data = this.originalData;
                return "date" === options.objectName || "numericInputStyle" === options.objectName ? this.rangeSlicerRenderer.enumerateObjectInstances(options, data, this.featureSwitches) : "slider" === options.objectName && data ? [ {
                    selector: null,
                    objectName: "slider",
                    properties: {
                        show: data.sliderSettings.show,
                        color: data.sliderSettings.color
                    },
                    propertyInstanceKind: {
                        color: 3
                    }
                } ] : void 0;
            }, RangeSlicer.prototype.getSlicerSettingsCardOptions = function(cardUidBuilder, orientation, activeMode, slicerModes) {
                return (0, slicerUtil1.nD)({
                    cardUidBuilder,
                    currentSlicerSettings: void 0,
                    data: void 0,
                    dataView: this.dataView,
                    hostServices: this.hostServices,
                    orientation,
                    activeMode,
                    slicerModes,
                    featureSwitches: this.featureSwitches
                });
            }, RangeSlicer.prototype.getValuesCard = function() {
                var data = this.originalData;
                if (data) return this.rangeSlicerRenderer.getValuesCard(data, this.featureSwitches);
            }, RangeSlicer.prototype.getAdditionalCards = function() {
                var _a, _this = this, data = this.originalData;
                if (data) {
                    var sliderProps = slicer_capabilities.gO.slider, revertToDefaultDescriptors = [ sliderProps.show, sliderProps.color, sliderProps.handleFillColor, sliderProps.handleBorderColor, sliderProps.secondaryLineColor ], sliderCardBuilder = new build_control_util.CQ(new build_control_util.lg("slider"), "Slicer_Slider", revertToDefaultDescriptors, function(key) {
                        return _this.hostServices.getLocalizedString(key);
                    });
                    return sliderCardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: sliderProps.show,
                            value: data.sliderSettings.show
                        }).build();
                    }), (null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.slicerSliderColors) ? sliderCardBuilder.addGroup("handles", function(groupBuilder) {
                        groupBuilder.withDisplayName("Slicer_Handles"), _this.data.sliderSettings.drawRoundSliderHandles ? groupBuilder.addSimpleSlice("fill", new build_control_util.BT({
                            descriptor: sliderProps.handleFillColor,
                            value: {
                                value: data.sliderSettings.handleFillColor
                            }
                        }).build()).addSimpleSlice("border", new build_control_util.BT({
                            descriptor: sliderProps.handleBorderColor,
                            value: {
                                value: data.sliderSettings.handleBorderColor
                            }
                        }).build()) : groupBuilder.addSimpleSlice("color", new build_control_util.BT({
                            descriptor: sliderProps.handleBorderColor,
                            value: {
                                value: data.sliderSettings.handleBorderColor
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Generic_Color");
                        });
                    }).addGroup("primaryLine", function(groupBuilder) {
                        groupBuilder.withDisplayName("Primary_Line").addSimpleSlice("primaryLineColor", new build_control_util.BT({
                            descriptor: sliderProps.color,
                            value: {
                                value: data.sliderSettings.primaryLineColor
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Generic_Color");
                        });
                    }).addGroup("secondaryLine", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Secondary_Line").addSimpleSlice("secondaryLineColor", new build_control_util.BT({
                            descriptor: sliderProps.secondaryLineColor,
                            value: {
                                value: data.sliderSettings.secondaryLineColor
                            }
                        }).build());
                    }) : sliderCardBuilder.addGroup("colors", function(groupBuilder) {
                        groupBuilder.withDisplayName("Generic_Color").addSimpleSlice("color", new build_control_util.BT({
                            descriptor: sliderProps.color,
                            value: {
                                value: data.sliderSettings.color
                            }
                        }).build());
                    }), [ sliderCardBuilder.build() ];
                }
            }, RangeSlicer.prototype.isDataColumnsValid = function(reader) {
                if (this.singleValue) return reader.columns.getCategoryCount() > 0;
                var metadataColumns = reader.columns.getMetadataColumns(slicer_capabilities.CT.value);
                if (!_.isEmpty(metadataColumns)) {
                    var metadata = metadataColumns[0];
                    if (metadata.aggregates && null != metadata.aggregates.min && null != metadata.aggregates.max) return !0;
                }
                return !1;
            }, RangeSlicer.prototype.isMetaColumnsValid = function(reader) {
                var metadataColumns = reader.columns.getMetadataColumns(slicer_capabilities.CT.value);
                return !_.isEmpty(metadataColumns);
            }, RangeSlicer.prototype.converter = function(reader, options) {
                var _a, _b, style, result = {
                    state: 0,
                    mode: null,
                    formatter: null,
                    identity: null,
                    value: null,
                    initialValue: null,
                    bounds: null,
                    filter: null,
                    properties: {
                        filter: null
                    },
                    sliderSettings: (style = this.style, {
                        color: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary"),
                        show: !0,
                        drawRoundSliderHandles: !1,
                        minSliderVisibilityHeight: 0,
                        minSliderVisibilityWidth: 150,
                        handleFillColor: common_colorHelper.v.getThemeColor(style, "background"),
                        handleBorderColor: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary"),
                        primaryLineColor: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary"),
                        secondaryLineColor: common_colorHelper.v.getThemeColor(style, "foregroundNeutralLight")
                    }),
                    inputStyle: rangeSlicer_DefaultInputSettings(this.style),
                    dataPoints: null,
                    wrapRangeBoxes: !1,
                    isSourceInteger: !1,
                    hideDatePickerButton: !0
                }, metadata = reader.columns.getMetadataColumns(slicer_capabilities.CT.value)[0], formatString = (0, 
                valueFormatter.EO)(metadata, slicer_capabilities.gO.general.formatString);
                result.isSourceInteger = !0 === metadata.type.integer, result.formatter = (0, valueFormatter.E3)(formatString), 
                result.identity = metadata.expr;
                var min = this.rangeSlicerRenderer.defaultValue(), max = this.rangeSlicerRenderer.defaultValue();
                if (this.singleValue) result.dataPoints = this.rangeSlicerRenderer.getDataPointsForSingleValueRange(this.dataView), 
                result.dataPoints.length > 0 && (min = result.dataPoints[0], max = result.dataPoints[result.dataPoints.length - 1]); else {
                    var values = metadata.aggregates;
                    null != values.min && (min = values.min), null != values.max && (max = values.max);
                }
                result.value = {
                    min,
                    max
                }, result.initialValue = {
                    min,
                    max
                }, result.bounds = {
                    min: result.value.min,
                    max: result.value.max
                };
                var objects = reader.objects.getStaticObjects();
                if (objects) {
                    result.filter = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.general.filter), 
                    result.properties.start = result.filter ? (0, dataViewObject2.NA)(objects, this.rangeSlicerRenderer.startProperty(), null) : null, 
                    result.properties.end = result.filter ? (0, dataViewObject2.NA)(objects, this.rangeSlicerRenderer.endProperty(), null) : null, 
                    result.properties.mode = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.data.mode, null), 
                    result.hideDatePickerButton = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.date.hideDatePickerButton, !0);
                    var inputProps = this.rangeSlicerRenderer.inputStyleProperties(), colorHelper = common_colorHelper.v.create(this.style), object = (0, 
                    dataViewObject2.RK)(objects, this.rangeSlicerRenderer instanceof NumericSlicer ? "numericInputStyle" : "date"), slicerNumericInputFontProperties = (0, 
                    fontProperties.Zi)(object, {
                        color: "fontColor",
                        family: "fontFamily",
                        size: "textSize"
                    }, colorHelper, this.style, "foregroundDark", "smallLabel", {
                        color: result.inputStyle.fontColor,
                        family: result.inputStyle.fontFamily,
                        size: units.B.createFromPt(result.inputStyle.textSize)
                    });
                    result.inputStyle.fontColor = slicerNumericInputFontProperties.color, result.inputStyle.fontFamily = slicerNumericInputFontProperties.family, 
                    result.inputStyle.textSize = slicerNumericInputFontProperties.size.pt, result.inputStyle.background = colorHelper.getColorForPropertyWithDefaultColor(objects, inputProps.background, result.inputStyle.background), 
                    result.inputStyle.labelBold = (0, dataViewObject2.NA)(objects, inputProps.bold, result.inputStyle.labelBold), 
                    result.inputStyle.labelItalic = (0, dataViewObject2.NA)(objects, inputProps.italic, result.inputStyle.labelItalic), 
                    result.inputStyle.labelUnderline = (0, dataViewObject2.NA)(objects, inputProps.underline, result.inputStyle.labelUnderline), 
                    result.sliderSettings.color = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.slider.color, result.sliderSettings.color), 
                    result.sliderSettings.show = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.slider.show, result.sliderSettings.show), 
                    (null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.slicerSliderColors) && (result.sliderSettings.handleFillColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.slider.handleFillColor, result.sliderSettings.handleFillColor), 
                    result.sliderSettings.primaryLineColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.slider.color, result.sliderSettings.color), 
                    result.sliderSettings.handleBorderColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.slider.handleBorderColor, result.sliderSettings.primaryLineColor), 
                    result.sliderSettings.secondaryLineColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.slider.secondaryLineColor, result.sliderSettings.secondaryLineColor)), 
                    null !== result.properties.start && (result.state |= 1, result.value.min = result.properties.start, 
                    result.properties.start < result.bounds.min && (result.bounds.min = result.properties.start)), 
                    null !== result.properties.end && (result.state = result.state |= 2, result.value.max = result.properties.end, 
                    result.properties.end > result.bounds.max && (result.bounds.max = result.properties.end)), 
                    result.value.min > result.bounds.max && (result.value.max = result.bounds.max = result.value.min), 
                    result.value.max < result.bounds.min && (result.value.min = result.bounds.min = result.value.max), 
                    null != result.properties.mode && (result.mode = result.properties.mode), result.filter && (result.properties.filter = {
                        min: result.value.min,
                        max: result.value.max
                    });
                } else result.state = 0, result.properties.start = null, result.properties.end = null, 
                result.properties.mode = null;
                var color = (0, VisualsCommon_color.WV)((null === (_b = this.featureSwitches) || void 0 === _b ? void 0 : _b.slicerSliderColors) ? result.sliderSettings.handleBorderColor : result.sliderSettings.color);
                return result.sliderSettings.activeColor = (0, VisualsCommon_color.jd)(color, .5, .2), 
                result.sliderSettings.hoverColor = (0, VisualsCommon_color.Bx)((0, VisualsCommon_color._j)(color, 100)), 
                result.sliderSettings.label = options.restatement, result.properties.bounds = {
                    min: result.bounds.min,
                    max: result.bounds.max
                }, result;
            }, RangeSlicer.prototype.initControls = function() {
                this.isRendered = !0, this.createHtmlControls(), this.updateMode(this.data.mode);
            }, RangeSlicer.prototype.createHtmlControls = function() {
                var _this = this;
                this.container = (0, DomFactory.hi)().addClass(rangeSlicer_ContainerClass.class).appendTo(this.host), 
                this.container.on("keyup keydown", function(event) {
                    9 !== event.keyCode && 27 !== event.keyCode && event.stopPropagation();
                });
                var $head = (0, DomFactory.hi)().addClass(HeadClass.class).css(this.getFontStyles()).appendTo(this.container), $range = (0, 
                DomFactory.hi)().addClass(RangeClass.class).appendTo($head);
                if (this.startContainer = (0, DomFactory.hi)().addClass(ControlClass.class).appendTo($range), 
                this.endContainer = (0, DomFactory.hi)().addClass(ControlClass.class).appendTo($range), 
                this.useModernDatePicker ? (debug.fF.assert(function() {
                    return _this.data.value.min instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.value.max instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.bounds.min instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.bounds.max instanceof Date;
                }, "Date required"), this.startComponentRef = this.hostServices.getUIComponentFactory().createDatePicker(this.startContainer.get(0), this.data.value.min, function(inputValue) {
                    null !== inputValue && _this.onRangeChange(0);
                }, Utility.b$.generateGuid(), this.data.bounds.min, this.data.bounds.max, this.data.hideDatePickerButton), 
                this.endComponentRef = this.hostServices.getUIComponentFactory().createDatePicker(this.endContainer.get(0), this.data.value.max, function(inputValue) {
                    null !== inputValue && _this.onRangeChange(1);
                }, Utility.b$.generateGuid(), this.data.bounds.min, this.data.bounds.max, this.data.hideDatePickerButton), 
                this.start = this.startComponentRef.datePickerElement.find(":input").first(), this.end = this.endComponentRef.datePickerElement.find(":input").first(), 
                this.startButton = this.startComponentRef.datePickerElement.find(":button"), this.endButton = this.endComponentRef.datePickerElement.find(":button"), 
                this.data.hideDatePickerButton ? (this.start.addClass(InputClass.class), this.end.addClass(InputClass.class)) : (this.start.addClass(rangeSlicer_DateSlicerClass.class), 
                this.startComponentRef.datePickerElement.addClass(rangeSlicer_DateSlicerWrapperClass.class), 
                this.end.addClass(rangeSlicer_DateSlicerClass.class), this.endComponentRef.datePickerElement.addClass(rangeSlicer_DateSlicerWrapperClass.class))) : (this.start = this.rangeSlicerRenderer.createInputElement(this.startContainer, 0), 
                this.end = this.rangeSlicerRenderer.createInputElement(this.endContainer, 1)), this.rangeSlicerRenderer.addAriaDescription && (this.rangeSlicerRenderer.addAriaDescription(this.start), 
                this.rangeSlicerRenderer.addAriaDescription(this.end)), (0, slicerUtil1.Id)()) {
                    var enableHoverClass = slicerUtil1.hY.class;
                    this.start.addClass(enableHoverClass), this.end.addClass(enableHoverClass);
                }
                this.bindEventHandlersToInputElements(), this.sliderContainer = (0, DomFactory.hi)().addClass(SliderClass.class).appendTo(this.container);
            }, RangeSlicer.prototype.bindEventHandlersToInputElements = function() {
                var _this = this;
                this.start.on("click touchend contextmenu", function(event) {
                    event.stopPropagation();
                }), this.end.on("click touchend contextmenu", function(event) {
                    event.stopPropagation();
                }), this.start.on("change", function(event) {
                    _this.onRangeChange(0);
                }), this.start.on("keyup", function(event) {
                    13 === event.which && (_this.start.blur(), _this.start.focus());
                }), this.start.on("focus", function(event) {
                    _this.singleValue && !_this.data.filter || (_this.useModernDatePicker ? (debug.fF.assert(function() {
                        return _this.data.value.min instanceof Date;
                    }, "Date required"), _this.startComponentRef.writeValue(_this.data.value.min)) : _this.start.val(_this.rangeSlicerRenderer.formatValue(_this.data.value.min, null))), 
                    _this.preventTextSelection || _this.start.select();
                }), this.start.on("blur", function(event) {
                    _this.singleValue && !_this.data.filter || (_this.useModernDatePicker ? (debug.fF.assert(function() {
                        return _this.data.value.min instanceof Date;
                    }, "Date required"), _this.startComponentRef.writeValue(_this.data.value.min)) : _this.start.val(_this.rangeSlicerRenderer.formatValue(_this.data.value.min, _this.data.formatter)));
                }), this.end.on("change", function(event) {
                    _this.onRangeChange(1);
                }), this.end.on("keyup", function(event) {
                    13 === event.which && (_this.end.blur(), _this.end.focus());
                }), this.end.on("focus", function(event) {
                    _this.useModernDatePicker ? (debug.fF.assert(function() {
                        return _this.data.value.max instanceof Date;
                    }, "Date required"), _this.endComponentRef.writeValue(_this.data.value.max)) : _this.end.val(_this.rangeSlicerRenderer.formatValue(_this.data.value.max, null)), 
                    _this.preventTextSelection || _this.end.select();
                }), this.end.on("blur", function(event) {
                    _this.useModernDatePicker ? (debug.fF.assert(function() {
                        return _this.data.value.max instanceof Date;
                    }, "Date required"), _this.endComponentRef.writeValue(_this.data.value.max)) : _this.end.val(_this.rangeSlicerRenderer.formatValue(_this.data.value.max, _this.data.formatter));
                });
            }, RangeSlicer.prototype.onRangeChange = function(rangeType) {
                var _this = this, inputString = 0 === rangeType ? this.start.val() : this.end.val(), inputValue = this.rangeSlicerRenderer.parseInput(inputString, this.data.dataPoints, this.singleValue);
                this.rangeSlicerRenderer.isInputValid(inputValue, this.data.value, rangeType, this.singleValue) ? this.updateRange({
                    min: inputValue,
                    max: inputValue
                }, rangeType) : (this.rangeSlicerRenderer.setRange(this.data.value, this.data.formatter, this.start, this.end, rangeType, this.data.bounds), 
                this.useModernDatePicker && (debug.fF.assert(function() {
                    return _this.data.value.min instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.value.max instanceof Date;
                }, "Date required"), this.startComponentRef.writeValue(this.data.value.min), this.endComponentRef.writeValue(this.data.value.max)));
            }, RangeSlicer.prototype.onDestroy = function() {
                this.rangeSlicerRenderer.onDestroy && this.rangeSlicerRenderer.onDestroy();
            }, RangeSlicer.prototype.getFontStyles = function() {
                var _a;
                return (_a = {})["font-size"] = StandaloneUtility1.FP.fromPointToPixel(9), _a["font-family"] = DefaultFontFamily, 
                _a["font-weight"] = dataLabelViewModel1Consts.bL.weight, _a;
            }, RangeSlicer.prototype.updateSliderControl = function() {
                var _a, _b, _this = this, options = this.createSliderOptions();
                if (this.slider) {
                    this.slider.updateOptions(options);
                    var sliderValue = [];
                    if (this.singleValue) {
                        var position = _.indexOf(this.data.dataPoints, this.data.value.min);
                        sliderValue.push(position);
                    } else {
                        var value = this.range.getScaledValue();
                        this.activeMode !== slicerMode.bb && sliderValue.push(value.min), this.activeMode !== slicerMode.e4 && sliderValue.push(value.max);
                    }
                    this.slider.set(sliderValue);
                } else this.sliderOptions = options, this.slider && (this.slider.destroy(), this.sliderContainer.empty()), 
                this.sliderElement = (0, DomFactory.hi)().attr("drag-resize-disabled", "true").attr("rtl", ("rtl" === document.dir).toString()).appendTo(this.sliderContainer), 
                (0, noUiSlider.create)(this.sliderElement.get(0), this.sliderOptions), this.slider = this.sliderElement.get(0).noUiSlider, 
                this.slider.on("slide", function(data, index, values) {
                    window.requestAnimationFrame(function() {
                        var rangeValue = _this.parseSliderValue(values);
                        _this.rangeSlicerRenderer.setRange(rangeValue, _this.data.formatter, _this.start, _this.end, null, _this.data.bounds), 
                        _this.useModernDatePicker && (debug.fF.assert(function() {
                            return rangeValue.min instanceof Date;
                        }, "Date required"), debug.fF.assert(function() {
                            return rangeValue.max instanceof Date;
                        }, "Date required"), _this.startComponentRef.writeValue(rangeValue.min), _this.endComponentRef.writeValue(rangeValue.max));
                    });
                }), this.slider.on("change", _.debounce(function(data, index, values) {
                    var value = _this.parseSliderValue(values), type = _this.getChangeType(_this.activeMode, index);
                    _this.updateRange(value, type);
                }, 100)), this.applyHandlesHoverState(this.sliderContainer.find(noUiHandleClass.selector));
                this.updateAccessibilityAttributes(this.data, this.sliderContainer.find(noUiHandleClass.selector), this.activeMode);
                var sliderHandleBorderColor = (null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.slicerSliderColors) ? this.data.sliderSettings.handleBorderColor : this.data.sliderSettings.color, sliderPrimaryLineColor = (null === (_b = this.featureSwitches) || void 0 === _b ? void 0 : _b.slicerSliderColors) ? this.data.sliderSettings.primaryLineColor : this.data.sliderSettings.color;
                this.sliderContainer.find(noUiConnectClass.selector).css({
                    "background-color": sliderPrimaryLineColor
                }), this.sliderContainer.find(noUiConnectsClass.selector).css({
                    "background-color": this.data.sliderSettings.secondaryLineColor
                }), this.sliderContainer.find(noUiHandleClass.selector).each(function(i, element) {
                    var jqueryElement = $(element), color = jqueryElement.is(":hover") ? _this.data.sliderSettings.activeColor : sliderHandleBorderColor;
                    _this.setSliderHandleColor(jqueryElement, color);
                }), this.sliderContainer.find(noUiConnectClass.selector).addClass("backgroundToSelectedBackgroundColor"), 
                this.sliderContainer.find(noUiBackgroundClass.selector).addClass("backgroundToForegroundColor");
                var sliderHandles = this.sliderContainer.find(noUiHandleClass.selector);
                this.data.sliderSettings.drawRoundSliderHandles ? (sliderHandles.addClass("backgroundToSolidBackgroundColor"), 
                sliderHandles.addClass("highContrastSelectedBorderColor")) : sliderHandles.addClass("backgroundToSelectedBackgroundColor");
            }, RangeSlicer.prototype.setSliderHandleColor = function(element, color) {
                var cssProps = {
                    "border-color": "",
                    "background-color": ""
                };
                this.data.sliderSettings.drawRoundSliderHandles && (cssProps["background-color"] = this.data.sliderSettings.handleFillColor), 
                cssProps[this.data.sliderSettings.drawRoundSliderHandles ? "border-color" : "background-color"] = color, 
                element.css(cssProps);
            }, RangeSlicer.prototype.disableSlicer = function() {
                this.disableSlider(), 1 & this.data.state || (this.useModernDatePicker ? this.startComponentRef.writeValue() : this.start.val(""), 
                this.disableInput(this.start, this.data.inputStyle.fontColor, this.startButton)), 
                2 & this.data.state || (this.useModernDatePicker ? this.endComponentRef.writeValue() : this.end.val(""), 
                this.disableInput(this.end, this.data.inputStyle.fontColor, this.endButton)), this.data.bounds.min = this.data.bounds.max = null, 
                this.updateProperties();
            }, RangeSlicer.prototype.disableSlider = function() {
                this.sliderElement && this.sliderElement.get(0).setAttribute("disabled", "true"), 
                this.sliderContainer.css("opacity", "0.1"), this.slider && this.slider.set([ 0, 100 ]);
            }, RangeSlicer.prototype.applyTooltip = function(element, tooltip) {
                var tooltipRef, _this = this;
                element.on("focus mouseenter", function() {
                    tooltipRef = _this.renderTooltip(element.get(0), tooltip);
                }), element.on("blur mouseleave", function() {
                    null == tooltipRef || tooltipRef.close(), tooltipRef = null;
                }), element.on("keydown", function(event) {
                    null !== tooltipRef && 27 === event.keyCode && (event.stopPropagation(), event.preventDefault(), 
                    tooltipRef.close(), tooltipRef = null);
                });
            }, RangeSlicer.prototype.renderTooltip = function(element, tooltip) {
                var _a;
                return this.tooltip && this.tooltip.close(), this.tooltip = null === (_a = this.hostServices.getUIComponentFactory()) || void 0 === _a ? void 0 : _a.createTooltip(element, tooltip), 
                this.tooltip;
            }, RangeSlicer.prototype.enableSlicer = function() {
                this.sliderElement && !this.rangeSlicerRenderer.areEqual(this.data.bounds.min, this.data.bounds.max) && this.sliderElement.get(0).removeAttribute("disabled"), 
                this.sliderContainer.css("opacity", "1.0"), this.enableInput(this.start, this.startButton), 
                this.enableInput(this.end, this.endButton);
            }, RangeSlicer.prototype.applyHandlesHoverState = function(handles) {
                var _a, isMouseDown = !1, isMouseOver = !1, rangeSlicer = this, slicerSliderColors = null === (_a = this.featureSwitches) || void 0 === _a ? void 0 : _a.slicerSliderColors;
                handles.on("mouseenter", function() {
                    isMouseOver = !0, isMouseDown || rangeSlicer.setSliderHandleColor($(this), rangeSlicer.data.sliderSettings.hoverColor);
                }).on("mouseleave", function() {
                    isMouseOver = !1, isMouseDown || rangeSlicer.setSliderHandleColor($(this), slicerSliderColors ? rangeSlicer.data.sliderSettings.handleBorderColor : rangeSlicer.data.sliderSettings.color);
                }).on("mousedown touchstart", function() {
                    var _this = this;
                    isMouseDown = !0, rangeSlicer.setSliderHandleColor($(this), rangeSlicer.data.sliderSettings.activeColor), 
                    $(document).on("mouseup touchEnd", function mouseup() {
                        $(document).off("mouseup touchEnd", mouseup), isMouseDown && (isMouseDown = !1, 
                        rangeSlicer.setSliderHandleColor($(_this), slicerSliderColors ? rangeSlicer.data.sliderSettings.handleBorderColor : rangeSlicer.data.sliderSettings.color));
                    });
                }).on("mouseup touchend", function() {
                    isMouseDown = !1, rangeSlicer.setSliderHandleColor($(this), isMouseOver ? rangeSlicer.data.sliderSettings.hoverColor : slicerSliderColors ? rangeSlicer.data.sliderSettings.handleBorderColor : rangeSlicer.data.sliderSettings.color);
                });
            }, RangeSlicer.prototype.updateInputControls = function() {
                var _a, _b, _this = this;
                this.singleValue && !this.data.filter && (this.useModernDatePicker ? this.startComponentRef.writeValue() : this.start.val(""));
                var properties = {
                    fontSize: StandaloneUtility1.FP.fromPoint(this.data.inputStyle.textSize),
                    fontFamily: this.data.inputStyle.fontFamily || DefaultFontFamily,
                    fontWeight: this.data.inputStyle.labelBold ? CssConstants.en : CssConstants.AI,
                    fontStyle: this.data.inputStyle.labelItalic ? CssConstants.BF : CssConstants.AI
                }, fontCss = {
                    "font-size": properties.fontSize,
                    "font-family": properties.fontFamily,
                    "font-weight": properties.fontWeight,
                    "font-style": properties.fontStyle,
                    "text-decoration": this.data.inputStyle.labelUnderline ? CssConstants.f0 : CssConstants.zu
                };
                this.start.parent().css(fontCss), this.end.parent().css(fontCss);
                var css = {
                    color: this.data.inputStyle.fontColor,
                    "background-color": this.data.inputStyle.background ? this.data.inputStyle.background : "",
                    "text-decoration": this.data.inputStyle.labelUnderline ? CssConstants.f0 : CssConstants.zu
                };
                this.start.css(css), this.end.css(css), this.startButton && this.startButton.css(css), 
                this.endButton && this.endButton.css(css), this.useModernDatePicker && this.startComponentRef && this.endComponentRef && (debug.fF.assert(function() {
                    return _this.data.value.min instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.value.max instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.bounds.min instanceof Date;
                }, "Date required"), debug.fF.assert(function() {
                    return _this.data.bounds.max instanceof Date;
                }, "Date required"), this.startComponentRef.updateDateRange(this.data.bounds.min, this.data.bounds.max), 
                this.endComponentRef.updateDateRange(this.data.bounds.min, this.data.bounds.max), 
                this.startComponentRef.writeValue(this.data.value.min), this.endComponentRef.writeValue(this.data.value.max), 
                null === (_a = this.startComponentRef.datePickerElement) || void 0 === _a || _a.attr("drag-resize-disabled", "true"), 
                null === (_b = this.endComponentRef.datePickerElement) || void 0 === _b || _b.attr("drag-resize-disabled", "true")), 
                !this.isCategorySourceNumeric && this.useModernDatePicker ? (this.setInputWidth(this.start, properties, this.data.value.min), 
                this.setInputWidth(this.end, properties, this.data.value.max)) : (this.setInputWidth(this.start, properties), 
                this.setInputWidth(this.end, properties));
            }, RangeSlicer.prototype.setInputWidth = function(input, properties, inputValue) {
                input.css("width", "");
                var value = input.val();
                if (inputValue && inputValue instanceof Date && (value = formattingService.dx.formatValue(inputValue, "d")), 
                value) {
                    var text = value.toString(), width = textMeasurementService.b.measureSvgTextWidth(properties, text), padding = parseFloat(input.css("padding-left")) + parseFloat(input.css("padding-right")), border = 2 * parseFloat(input.css("border-width"));
                    width = Math.ceil(width + padding + border), input.outerWidth(!1) < width && input.css({
                        width
                    });
                }
            }, RangeSlicer.prototype.disableInput = function(inputControl, color, buttonControl) {
                var RGBA = (0, VisualsCommon_color.WV)(color);
                RGBA.A = .3, inputControl.css({
                    color: (0, VisualsCommon_color.U8)(RGBA)
                }), inputControl.prop("disabled", !0), buttonControl && (buttonControl.css({
                    color: (0, VisualsCommon_color.U8)(RGBA)
                }), buttonControl.prop("disabled", !0));
            }, RangeSlicer.prototype.enableInput = function(inputControl, buttonControl) {
                inputControl.prop("disabled", !1), null == buttonControl || buttonControl.prop("disabled", !1);
            }, RangeSlicer.prototype.createSliderOptions = function() {
                var start, connect, sliderOptions = this.rangeSlicerRenderer.getSliderOptions(this.data, this.singleValue), range = this.range.getScaledValue();
                switch (this.activeMode) {
                  case slicerMode.bb:
                    start = range.max, connect = [ !0, !1 ];
                    break;

                  case slicerMode.e4:
                    start = range.min, connect = [ !1, !0 ];
                    break;

                  case slicerMode.vX:
                    start = [ range.min, range.max ], connect = !0;
                    break;

                  case slicerMode.Zr:
                    start = _.indexOf(this.data.dataPoints, this.data.value.min), connect = !1;
                }
                return {
                    connect,
                    behaviour: "tap",
                    range: {
                        min: sliderOptions.min === sliderOptions.max ? 0 : sliderOptions.min,
                        max: sliderOptions.min === sliderOptions.max ? 1 : sliderOptions.max
                    },
                    start,
                    step: sliderOptions.step
                };
            }, RangeSlicer.prototype.parseSliderValue = function(values) {
                if ((this.data.isSourceInteger || this.singleValue) && (values = _.map(values, function(value) {
                    return Math.round(value);
                })), this.singleValue) return this.rangeSlicerRenderer.parseSingleSliderValue(values[0], this.data.dataPoints);
                var rangeValue = this.range.getScaledValue();
                switch (this.activeMode) {
                  case slicerMode.bb:
                    rangeValue.max = values[0];
                    break;

                  case slicerMode.e4:
                    rangeValue.min = values[0];
                    break;

                  case slicerMode.vX:
                    rangeValue.min = values[0], rangeValue.max = values[1];
                }
                return this.range.setScaledValue(rangeValue), this.range.getValue();
            }, RangeSlicer.prototype.updateSlider = function(mode) {
                mode === slicerMode.e4 ? (this.enableInput(this.start, this.startButton), this.disableInput(this.end, this.data.inputStyle.fontColor, this.endButton)) : mode === slicerMode.bb ? (this.enableInput(this.end, this.endButton), 
                this.disableInput(this.start, this.data.inputStyle.fontColor, this.startButton)) : (this.enableInput(this.start, this.startButton), 
                this.enableInput(this.end, this.endButton)), mode === slicerMode.Zr ? this.endContainer.hide() : this.endContainer.show(), 
                !this.data.sliderSettings.show || this.shouldHideSmallSlider() ? this.sliderContainer.hide() : (this.sliderContainer.show(), 
                this.updateSliderControl()), this.sliderContainer.toggleClass(RoundHandlesClass.class, !!this.data.sliderSettings.drawRoundSliderHandles), 
                this.container.find(HeadClass.selector).toggleClass(WrapRangeBoxesClass.class, !!this.data.wrapRangeBoxes), 
                this.rangeSlicerRenderer.areEqual(this.data.bounds.min, this.data.bounds.max) && this.disableSlider();
            }, RangeSlicer.prototype.updateMode = function(mode) {
                this.updateRangeSlicerState(mode), this.updateProperties();
            }, RangeSlicer.prototype.updateProperties = function() {
                var properties = this.buildRangeSlicerProperties();
                if (this.requireToUpdate(properties)) {
                    this.data.properties.filter = properties.filter, this.data.properties.bounds = properties.bounds;
                    var objects = this.createPersistProperties(properties, this.data.identity, this.data.state);
                    this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                        type: 0,
                        visualObjects: []
                    });
                }
            }, RangeSlicer.prototype.updateRangeSlicerState = function(mode) {
                var lastMode = this.data.mode;
                null == mode ? mode = this.defaultSliderMode : this.data.mode = mode, mode === slicerMode.bb ? (lastMode === slicerMode.e4 && 1 & this.data.state && (this.data.value.max = this.data.value.min, 
                this.data.value.min = this.data.bounds.min, this.data.state = 2), this.data.state &= -2) : mode === slicerMode.e4 && (lastMode === slicerMode.bb && 2 & this.data.state && (this.data.value.min = this.data.value.max, 
                this.data.state = 1), this.data.state &= -3);
            }, RangeSlicer.prototype.getChangeType = function(mode, handle) {
                var type = null;
                switch (mode) {
                  case slicerMode.e4:
                  case slicerMode.Zr:
                    type = 0;
                    break;

                  case slicerMode.bb:
                    type = 1;
                    break;

                  default:
                    type = 0 === handle ? 0 : 1;
                }
                return type;
            }, RangeSlicer.prototype.createPersistProperties = function(properties, identity, state) {
                var filter = this.createFilter(properties, properties.mode ?? this.defaultSliderMode, state, identity), objects = {
                    merge: [ {
                        objectName: "general",
                        selector: void 0,
                        properties: {}
                    } ],
                    replace: [ {
                        objectName: "data",
                        selector: void 0,
                        properties: {}
                    } ],
                    remove: [ {
                        objectName: "data",
                        selector: void 0,
                        properties: {}
                    }, {
                        objectName: "general",
                        selector: void 0,
                        properties: {}
                    } ]
                };
                return null !== filter ? objects.merge[0].properties[slicer_capabilities.gO.general.filter.propertyName] = filter : objects.remove[1].properties[slicer_capabilities.gO.general.filter.propertyName] = !0, 
                1 & state && null !== properties.start ? objects.replace[0].properties[this.rangeSlicerRenderer.startProperty().propertyName] = properties.start : null == properties.start && (objects.remove[0].properties[this.rangeSlicerRenderer.startProperty().propertyName] = !0), 
                2 & state && null !== properties.end ? objects.replace[0].properties[this.rangeSlicerRenderer.endProperty().propertyName] = properties.end : null == properties.end && (objects.remove[0].properties[this.rangeSlicerRenderer.endProperty().propertyName] = !0), 
                null != properties.mode && (objects.replace[0].properties[slicer_capabilities.gO.data.mode.propertyName] = properties.mode), 
                objects;
            }, RangeSlicer.prototype.updateRange = function(value, type) {
                null == type ? (this.data.value.min = value.min, this.data.value.max = value.max) : 0 === type ? (this.data.value.min = value.min, 
                null === this.data.bounds.min || this.singleValue || !this.rangeSlicerRenderer.areEqual(this.data.value.min, this.data.bounds.min) || this.useModernDatePicker ? this.data.state |= 1 : this.data.state &= -2) : 1 === type && (this.data.value.max = value.max, 
                null !== this.data.bounds.max && this.rangeSlicerRenderer.areEqual(this.data.value.max, this.data.bounds.max) && !this.useModernDatePicker ? this.data.state &= -3 : this.data.state |= 2), 
                this.updateProperties();
            }, RangeSlicer.prototype.createFilter = function(properties, mode, state, identity) {
                var filterExpr = null, result = null, slicerFilters = this.rangeSlicerRenderer.filterExpr(properties.filter);
                if (mode === slicerMode.Zr) filterExpr = 1 & state ? (0, sqExpr.qu)(0, identity, slicerFilters.lower) : null; else {
                    var comparisonKind = this.rangeSlicerRenderer.comparisonKind();
                    if (1 & state && 2 & state) {
                        var lowerFilter = (0, sqExpr.qu)(comparisonKind.lower, identity, slicerFilters.lower), upperFilter = (0, 
                        sqExpr.qu)(comparisonKind.upper, identity, slicerFilters.upper);
                        filterExpr = (0, sqExpr.xD)(lowerFilter, upperFilter);
                    } else 1 & state ? filterExpr = (0, sqExpr.qu)(comparisonKind.lower, identity, slicerFilters.lower) : 2 & state && (filterExpr = (0, 
                    sqExpr.qu)(comparisonKind.upper, identity, slicerFilters.upper));
                }
                return null !== filterExpr && (result = semanticQuery.yl.fromSQExpr(filterExpr)), 
                result;
            }, RangeSlicer.prototype.requireToUpdate = function(properties) {
                return !(null === this.data.properties.filter && 0 === this.data.state && (properties.mode === this.data.properties.mode || properties.mode === this.defaultSliderMode && null === this.data.properties.mode) || null != this.data.properties.filter && properties.mode === this.data.properties.mode && this.rangeSlicerRenderer.areEqual(properties.start, this.data.properties.start) && this.rangeSlicerRenderer.areEqual(properties.end, this.data.properties.end) && this.rangeSlicerRenderer.areEqual(properties.filter.min, this.data.properties.filter.min) && this.rangeSlicerRenderer.areEqual(properties.filter.max, this.data.properties.filter.max) && this.rangeSlicerRenderer.areEqual(properties.bounds.min, this.data.properties.bounds.min) && this.rangeSlicerRenderer.areEqual(properties.bounds.max, this.data.properties.bounds.max));
            }, RangeSlicer.prototype.shouldHideSmallSlider = function() {
                var sliderSettings = this.data.sliderSettings;
                if ((this.container.width() || 0) <= sliderSettings.minSliderVisibilityWidth) return !0;
                if (sliderSettings.minSliderVisibilityHeight > 0) {
                    var textboxesHeight = this.endContainer.position().top + this.endContainer.outerHeight();
                    if (this.container.parent().outerHeight() - textboxesHeight < sliderSettings.minSliderVisibilityHeight) return !0;
                }
                return !1;
            }, RangeSlicer.prototype.updateAccessibilityAttributes = function(data, handles, activeMode) {
                var hintText, tooltipText, sliderMinValue = data.value.min, sliderMaxValue = data.value.max, isNumeric = this.rangeSlicerRenderer instanceof NumericSlicer;
                switch (activeMode) {
                  case slicerMode.bb:
                    hintText = (tooltipText = this.hostServices.getLocalizedString(isNumeric ? "End_Time" : "End_Date")) + " " + this.getRangeText(data.bounds.min, data.bounds.max), 
                    this.addAccessibilityAttributesToSliderHandle(handles, hintText, sliderMaxValue), 
                    this.applyTooltip(handles, tooltipText);
                    break;

                  case slicerMode.e4:
                    hintText = (tooltipText = this.hostServices.getLocalizedString(isNumeric ? "Start_Time" : "Start_Date")) + " " + this.getRangeText(data.bounds.min, data.bounds.max), 
                    this.addAccessibilityAttributesToSliderHandle(handles, hintText, sliderMinValue), 
                    this.applyTooltip(handles, tooltipText);
                    break;

                  case slicerMode.vX:
                    hintText = (tooltipText = this.hostServices.getLocalizedString(isNumeric ? "Start_Time" : "Start_Date")) + " " + this.getRangeText(data.bounds.min, data.value.max), 
                    this.addAccessibilityAttributesToSliderHandle(handles.first(), hintText, sliderMinValue), 
                    this.applyTooltip(handles.first(), tooltipText), hintText = (tooltipText = this.hostServices.getLocalizedString(isNumeric ? "End_Time" : "End_Date")) + " " + this.getRangeText(data.value.min, data.bounds.max), 
                    this.addAccessibilityAttributesToSliderHandle(handles.last(), hintText, sliderMaxValue), 
                    this.applyTooltip(handles.last(), tooltipText);
                }
                handles.attr("aria-label", data.sliderSettings.label);
            }, RangeSlicer.prototype.addAccessibilityAttributesToSliderHandle = function(handle, hintText, currentHandleValue) {
                handle.attr("aria-valuetext", this.rangeSlicerRenderer.formatValue(currentHandleValue, this.data.formatter)).attr("aria-description", hintText);
            }, RangeSlicer.prototype.getRangeText = function(lowerBoundValue, upperBoundValue) {
                return formattingService.dx.format(this.hostServices.getLocalizedString("Slicer_Range_Hint"), this.isCategorySourceNumeric ? [ lowerBoundValue, upperBoundValue ] : [ formattingService.dx.formatValue(lowerBoundValue, "d"), formattingService.dx.formatValue(upperBoundValue, "d") ]);
            }, RangeSlicer;
        }(), visualBorderUtil = __webpack_require__(34021), visualLocKeys = __webpack_require__(33024), iconPlacementType = __webpack_require__(67922), outline = __webpack_require__(40550), PendingChangesIconSvg = '<svg width="17" height="16" viewBox="0 0 17 16" class='.concat("slicer-header-pending-icon", ' xmlns="https://www.w3.org/2000/svg">\n        <path class=\'').concat("slicer-header-pending-icon-path", ' OfficeIconColors_HighContrast\' d="M8.00781 0C12.4261 0 16.0078 3.58172 16.0078 8C16.0078 12.4183 12.4261\n        16 8.00781 16C3.58953 16 0.0078125 12.4183 0.0078125 8C0.0078125 3.58172 3.58953 0 8.00781 0ZM7.50781 3C7.23167 3 7.00781 3.22386\n        7.00781 3.5V8.5L7.01587 8.58988C7.0582 8.82312 7.26235 9 7.50781 9H10.5078L10.5977 8.99194C10.8309 8.94961 11.0078 8.74546 11.0078\n        8.5C11.0078 8.22386 10.784 8 10.5078 8H8.00781V3.5L7.99976 3.41012C7.95742 3.17688 7.75327 3 7.50781 3Z" /></svg>'), SlicerHeader = function() {
            function SlicerHeader(settings, services, style, featureSwitches) {
                this.services = services, this.settings = settings, this.style = style, this.originalData = this.data = SlicerHeader.DefaultData(this.style, settings.text, this.services), 
                this.featureSwitches = featureSwitches, this.render();
            }
            return SlicerHeader.DefaultData = function(style, text, hostServices) {
                return {
                    borderStyle: "solid",
                    borderBottomWidth: 1,
                    show: !0,
                    outlineStyle: outline.$m.Nil,
                    fontColor: common_colorHelper.v.getThemeColor(style, "foregroundDark"),
                    textSize: 9,
                    fontFamily: fontUtils.Wn.regular.css,
                    iconColor: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary"),
                    iconHoverColor: common_colorHelper.v.getThemeColor(style, "foreground"),
                    outlineColor: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondaryAlt2"),
                    outlineWeight: 1,
                    searchEnabled: !1,
                    background: null,
                    showRestatement: !1,
                    menu: {
                        fontColor: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary")
                    },
                    warnings: new visualWarnings.tb,
                    text,
                    labelBold: !1,
                    labelItalic: !1,
                    labelUnderline: !1,
                    pendingChangesIcon: {
                        show: !0,
                        color: common_colorHelper.v.getThemeColor(style, "foregroundNeutralSecondary"),
                        transparency: 0,
                        position: "right",
                        size: 12,
                        showTooltip: !0,
                        tooltipText: "",
                        tooltipLabel: hostServices.localize("Not_Yet_Applied_With_Parentheses")
                    }
                };
            }, SlicerHeader.InFocusModeData = function(style, text, hostServices) {
                var data = SlicerHeader.DefaultData(style, text, hostServices);
                return data.borderStyle = "none", data.background = common_colorHelper.v.getThemeColor(style, "foregroundNeutralLight"), 
                data.textSize = StandaloneUtility1.FP.toPoint(13), data.fontColor = common_colorHelper.v.getThemeColor(style, "foregroundNeutralDark"), 
                data.fontFamily = fontUtils.Wn.regular.css, data;
            }, SlicerHeader.prototype.destroy = function() {
                this.selectMenu && this.selectMenu.destroy();
            }, SlicerHeader.prototype.enumerateObjectInstances = function(options) {
                var data = this.originalData;
                if (data) {
                    if ("header" === options.objectName) {
                        var result = {
                            selector: null,
                            objectName: "header",
                            properties: {
                                text: data.text,
                                show: data.show,
                                fontColor: data.fontColor,
                                background: data.background,
                                textSize: data.textSize,
                                fontFamily: data.fontFamily,
                                bold: data.labelBold,
                                italic: data.labelItalic,
                                underline: data.labelUnderline,
                                outlineColor: data.outlineColor,
                                outlineWeight: data.outlineWeight
                            },
                            propertyInstanceKind: {
                                text: 3,
                                fontColor: 3,
                                background: 3
                            }
                        };
                        return result.properties.outlineStyle = data.outlineStyle, this.settings.supportsRestatement && (result.properties.showRestatement = data.showRestatement), 
                        [ result ];
                    }
                    return "general" === options.objectName ? [ {
                        selector: null,
                        objectName: "general",
                        properties: {
                            outlineColor: data.outlineColor,
                            outlineWeight: data.outlineWeight
                        }
                    } ] : void 0;
                }
            }, SlicerHeader.prototype.getSlicerHeaderCard = function(hostServices) {
                var _this = this, data = this.originalData;
                if (data) {
                    var headerProps = slicer_capabilities.gO.header, headerPendingChangesIconProps = slicer_capabilities.gO.pendingChangesIcon, cardBuilder = new build_control_util.CQ(new build_control_util.lg("slicerHeader"), "Slicer_Header", [ headerProps.text, headerProps.fontFamily, headerProps.textSize, headerProps.bold, headerProps.italic, headerProps.underline, headerProps.fontColor, headerProps.showRestatement, headerProps.outlineStyle, slicer_capabilities.gO.general.outlineColor, slicer_capabilities.gO.general.outlineWeight, headerProps.background, headerProps.show, headerPendingChangesIconProps.show, headerPendingChangesIconProps.color, headerPendingChangesIconProps.position, headerPendingChangesIconProps.transparency, headerPendingChangesIconProps.size, headerPendingChangesIconProps.showTooltip, headerPendingChangesIconProps.tooltipText, headerPendingChangesIconProps.tooltipLabel ], function(key) {
                        return hostServices.getLocalizedString(key);
                    }), fontControl = (new build_control_util.UN).withFontFamily({
                        descriptor: headerProps.fontFamily,
                        value: data.fontFamily
                    }).withFontSizeProperties({
                        descriptor: headerProps.textSize,
                        value: data.textSize
                    }).withBold({
                        descriptor: headerProps.bold,
                        value: data.labelBold
                    }).withItalic({
                        descriptor: headerProps.italic,
                        value: data.labelItalic
                    }).withUnderline({
                        descriptor: headerProps.underline,
                        value: data.labelUnderline
                    }).build();
                    return cardBuilder.addTopLevelToggle("show", function() {
                        return new build_control_util.bd({
                            descriptor: headerProps.show,
                            value: data.show
                        }).build();
                    }).addGroup("text", function(groupBuilder) {
                        groupBuilder.withDisplayName("Text").addSimpleSlice("title", new build_control_util.fq({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, headerProps.text), {
                                instanceKind: 3
                            }),
                            value: data.text,
                            placeholder: ""
                        }).build()).addCompositeSlice("fontselector", "Font", fontControl).addSimpleSlice("color", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, headerProps.fontColor), {
                                instanceKind: 3
                            }),
                            value: {
                                value: data.fontColor
                            }
                        }).build()), _this.settings.supportsRestatement && groupBuilder.addSimpleSlice("labelContents", new build_control_util.bd({
                            descriptor: headerProps.showRestatement,
                            value: data.showRestatement
                        }).build());
                    }).addGroup("border", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Border").addSimpleSlice("border position", new build_control_util.oM({
                            descriptor: headerProps.outlineStyle,
                            value: data.outlineStyle
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Border_Position");
                        }).addSimpleSlice("color", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, slicer_capabilities.gO.general.outlineColor), {
                                instanceKind: 3
                            }),
                            value: {
                                value: data.outlineColor
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Generic_Color");
                        }).addSimpleSlice("lineWidth", new build_control_util.JN({
                            descriptor: slicer_capabilities.gO.general.outlineWeight,
                            value: data.outlineWeight,
                            options: {
                                minValue: {
                                    type: 0,
                                    value: 1
                                },
                                maxValue: {
                                    type: 1,
                                    value: 10
                                }
                            },
                            localize: function(key) {
                                return hostServices.getLocalizedString(key);
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Visual_Line_Width");
                        });
                    }).addGroup("background", function(groupBuilder) {
                        groupBuilder.withDisplayName("Visual_Background").addSimpleSlice("color", new build_control_util.BT({
                            descriptor: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, headerProps.background), {
                                instanceKind: 3
                            }),
                            value: {
                                value: data.background
                            }
                        }).build(), function(sliceBuilder) {
                            return sliceBuilder.withCustomDisplayName("Generic_Color");
                        });
                    }), this.featureSwitches.applyAllSlicersButton && cardBuilder.addGroup("pendingChangesIcon", function(groupBuilder) {
                        groupBuilder.withDisplayName("PendingIcon").addTopLevelToggle("show", function() {
                            return new build_control_util.bd({
                                descriptor: headerPendingChangesIconProps.show,
                                value: data.pendingChangesIcon.show
                            }).build();
                        }).addSimpleSlice("pendingIconColor", new build_control_util.BT({
                            descriptor: headerPendingChangesIconProps.color,
                            value: {
                                value: data.pendingChangesIcon.color
                            }
                        }).build()).addSimpleSlice("pendingIconTransparency", build_control_util.JN.getTransparencySliderBuilder({
                            descriptor: headerPendingChangesIconProps.transparency,
                            value: data.pendingChangesIcon.transparency,
                            localize: function(key) {
                                return hostServices.getLocalizedString(key);
                            }
                        }).build()).addSimpleSlice("pendingIconPosition", new build_control_util.uY({
                            descriptor: headerPendingChangesIconProps.position,
                            value: data.pendingChangesIcon.position,
                            filterValues: [ iconPlacementType.t$, iconPlacementType.F2 ]
                        }).build()).addSimpleSlice("pendingIconSize", function() {
                            return new build_control_util.mu({
                                descriptor: headerPendingChangesIconProps.size,
                                value: data.pendingChangesIcon.size,
                                options: {
                                    minValue: {
                                        type: 0,
                                        value: 1
                                    },
                                    maxValue: {
                                        type: 1,
                                        value: 999
                                    },
                                    unitSymbol: visualLocKeys.e_
                                }
                            }).build();
                        }).addSimpleSlice("pendingIconTooltip", function() {
                            return new build_control_util.bd({
                                descriptor: headerPendingChangesIconProps.showTooltip,
                                value: data.pendingChangesIcon.showTooltip
                            }).build();
                        }).addSimpleSlice("pendingIconTooltipText", function() {
                            return new build_control_util.Jr({
                                descriptor: headerPendingChangesIconProps.tooltipText,
                                placeholder: "Slicer_PendingChanges",
                                value: data.pendingChangesIcon.tooltipText,
                                localize: function(key) {
                                    return hostServices.getLocalizedString(key);
                                }
                            }).build();
                        }).addSimpleSlice("pendingIconLabelText", function() {
                            return new build_control_util.Jr({
                                descriptor: headerPendingChangesIconProps.tooltipLabel,
                                placeholder: "  ",
                                value: data.pendingChangesIcon.tooltipLabel,
                                localize: function(key) {
                                    return "  " === key ? key : hostServices.getLocalizedString(key);
                                }
                            }).build();
                        });
                    }), cardBuilder.build();
                }
            }, SlicerHeader.prototype.update = function(reader, settings) {
                debug.fF.assertValue(reader, "Reader"), $.extend(this.settings, settings), this.settings.enableInFocusRenderers && this.settings.isInFocus ? this.data = SlicerHeader.InFocusModeData(this.style, settings.text, this.services) : (this.originalData = SlicerHeader.converter(reader, this.style, settings.text, this.services), 
                this.data = this.services.applySlicerHeaderChanges(this.originalData)), this.addSlicerHelperTooltip(), 
                this.maintainSelectMenu(), this.updateTitle();
            }, SlicerHeader.prototype.setFilterRestatement = function(restatement, supportsRestatement) {
                this.settings.restatement = restatement, this.settings.supportsRestatement = supportsRestatement, 
                this.updateTitleText();
            }, SlicerHeader.converter = function(reader, style, title, hostServices) {
                debug.fF.assertValue(reader, "Reader");
                var data = SlicerHeader.DefaultData(style, title, hostServices), objects = reader.objects.getStaticObjects(), colorHelper = common_colorHelper.v.create(style);
                if (objects) {
                    var slicerHeaderFontProperties = (0, fontProperties.Zi)((0, dataViewObject2.RK)(objects, "header"), {
                        color: "fontColor",
                        family: "fontFamily",
                        size: "textSize"
                    }, colorHelper, style, "foregroundDark", "title", {
                        color: data.fontColor,
                        family: data.fontFamily,
                        size: units.B.createFromPt(data.textSize)
                    });
                    data.fontColor = slicerHeaderFontProperties.color, data.fontFamily = slicerHeaderFontProperties.family, 
                    data.textSize = slicerHeaderFontProperties.size.pt, data.show = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.show, data.show), 
                    data.text = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.text, data.text), 
                    data.menu.fontColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.header.fontColor, data.menu.fontColor), 
                    data.background = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.header.background, data.background), 
                    data.outlineColor = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.general.outlineColor, data.outlineColor), 
                    data.outlineWeight = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.general.outlineWeight, data.outlineWeight), 
                    data.outlineStyle = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.outlineStyle, data.outlineStyle), 
                    data.searchEnabled = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.general.selfFilterEnabled, data.searchEnabled), 
                    data.showRestatement = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.showRestatement, data.showRestatement), 
                    data.labelBold = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.bold, data.labelBold), 
                    data.labelItalic = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.italic, data.labelItalic), 
                    data.labelUnderline = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.header.underline, data.labelUnderline), 
                    data.pendingChangesIcon.show = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.show, data.pendingChangesIcon.show), 
                    data.pendingChangesIcon.color = colorHelper.getColorForPropertyWithDefaultColor(objects, slicer_capabilities.gO.pendingChangesIcon.color, data.pendingChangesIcon.color), 
                    data.pendingChangesIcon.transparency = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.transparency, data.pendingChangesIcon.transparency), 
                    data.pendingChangesIcon.position = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.position, data.pendingChangesIcon.position), 
                    data.pendingChangesIcon.size = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.size, data.pendingChangesIcon.size), 
                    data.pendingChangesIcon.showTooltip = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.showTooltip, data.pendingChangesIcon.showTooltip), 
                    data.pendingChangesIcon.tooltipText = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.tooltipText, (0, 
                    Utility.HZ)(data.pendingChangesIcon.tooltipText)), data.pendingChangesIcon.tooltipLabel = (0, 
                    dataViewObject2.NA)(objects, slicer_capabilities.gO.pendingChangesIcon.tooltipLabel, data.pendingChangesIcon.tooltipLabel);
                }
                return data;
            }, SlicerHeader.prototype.render = function() {
                this.header = (0, DomFactory.hi)().addClass("slicer-header").appendTo(this.settings.host), 
                this.addTitle(), this.addSlicerHelperTooltip(), this.maintainSelectMenu();
            }, SlicerHeader.prototype.maintainSelectMenu = function() {
                if ((!this.featureSwitches.updateFormattingPaneObjects || !this.featureSwitches.moveSlicerTypeSelection) && (this.selectMenu || 0 === this.services.getViewMode() ? this.updateSelectMenu() : this.addSelectMenu(), 
                this.selectMenuContainer)) {
                    var viewModel_1 = this.data;
                    this.selectMenuContainer.find("span.ui-icon").css("color", this.data.iconColor).hover(function() {
                        $(this).css("color", viewModel_1.iconHoverColor);
                    }, function() {
                        $(this).css("color", viewModel_1.iconColor);
                    });
                }
            }, SlicerHeader.prototype.addSelectMenu = function() {
                var _this = this, selectMenuText = this.services.localize("Slicer_SelectMenu_Tooltip");
                this.selectMenuContainer = (0, DomFactory.hi)().addClass("slicer-header-selectmenu").toggleClass(slicerUtil1.hY.class, (0, 
                slicerUtil1.Id)()).appendTo(this.title), this.applyTooltip(this.selectMenuContainer, selectMenuText, this.services.onRenderTooltip);
                var settings = {
                    onChange: function(val) {
                        _this.settings.onChange && _this.settings.onChange(val);
                    },
                    container: this.selectMenuContainer,
                    options: this.getSelectMenuOptions(),
                    selectedValue: this.settings.selectedValue,
                    className: "slicer-select-menu",
                    disabled: 2 === this.settings.visibilityState,
                    title: selectMenuText
                };
                this.selectMenu = new selectmenu.S(settings), SlicerHeader.addHoverInOut(this.settings.hoverContainer, function() {
                    0 !== _this.services.getViewMode() && (_this.selectMenuContainer.css("visibility", "visible"), 
                    _this.selectMenuContainer.css("display", "flex"));
                }, function() {
                    _this.settings.areControlButtonsAlwaysVisible || (_.isEmpty(_this.data.text) ? _this.selectMenuContainer.css("visibility", "hidden") : _this.selectMenuContainer.css("display", "none"));
                });
            }, SlicerHeader.prototype.addSlicerHelperTooltip = function() {
                var _this = this;
                if (this.featureSwitches.updateFormattingPaneObjects && this.featureSwitches.moveSlicerTypeSelection) if (0 !== this.services.getViewMode()) if (this.selectMenuContainer) this.selectMenuContainer.show(); else {
                    var selectMenuText = this.services.localize("Slicer_Helper_Tooltip");
                    this.selectMenuContainer = (0, DomFactory.hi)().addClass("slicer-header-selectmenu").toggleClass(slicerUtil1.hY.class, (0, 
                    slicerUtil1.Id)()).appendTo(this.title), this.helperTooltipButton = (0, DomFactory.yP)().addClass("slicer-helper-tooltip-button").attr("aria-label", selectMenuText).attr("role", "button").attr("tabindex", "0"), 
                    this.applyTooltip(this.helperTooltipButton, selectMenuText, this.services.onRenderTooltip), 
                    this.helperTooltipButton.appendTo(this.selectMenuContainer);
                    var viewModel = this.data;
                    this.helperButtonIcon = (0, DomFactory.yP)().addClass("ui-icon").css("color", this.data.iconColor).hover(function() {
                        $(this).css("color", viewModel.iconHoverColor);
                    }, function() {
                        $(this).css("color", viewModel.iconColor);
                    }), this.helperButtonIcon.appendTo(this.helperTooltipButton), SlicerHeader.addHoverInOut(this.settings.hoverContainer, function() {
                        0 !== _this.services.getViewMode() && (_this.selectMenuContainer.css("visibility", "visible"), 
                        _this.selectMenuContainer.css("display", "flex"));
                    }, function() {
                        _this.settings.areControlButtonsAlwaysVisible || (_.isEmpty(_this.data.text) ? _this.selectMenuContainer.css("visibility", "hidden") : _this.selectMenuContainer.css("display", "none"));
                    });
                } else this.selectMenuContainer && this.selectMenuContainer.hide();
            }, SlicerHeader.prototype.addPendingChangesIcon = function() {
                this.pendingChangesIcon = $(PendingChangesIconSvg).addClass("slicer-header-pending-icon").appendTo(this.title);
            }, SlicerHeader.prototype.addPendingChangesText = function() {
                this.pendingChangesText = (0, DomFactory.hi)().append(this.data.pendingChangesIcon.tooltipLabel).addClass("slicer-header-pending-text").appendTo(this.title);
            }, SlicerHeader.prototype.updatePendingChangesIcon = function() {
                var pendingChangesIconData = this.data.pendingChangesIcon;
                pendingChangesIconData.show && this.settings.hasUnappliedFilters && this.featureSwitches.applyAllSlicersButton ? (this.pendingChangesIcon.css("display", "block"), 
                this.pendingChangesText.css("display", "block")) : (this.pendingChangesIcon.css("display", "none"), 
                this.pendingChangesText.css("display", "none")), this.pendingChangesIcon.css("opacity", "".concat((0, 
                VisualsCommon_color.TD)(this.data.pendingChangesIcon.transparency)));
                var size = pendingChangesIconData.size.toString();
                this.pendingChangesIcon.attr("height", "".concat(size)), this.pendingChangesIcon.attr("width", "".concat(size)), 
                this.pendingChangesIcon.attr("viewbox", "0 0 ".concat(size, " ").concat(size)), 
                this.pendingChangesIcon.children(".".concat("slicer-header-pending-icon-path")).attr("fill", pendingChangesIconData.color), 
                pendingChangesIconData.tooltipText && this.applyTooltip(this.pendingChangesIcon, pendingChangesIconData.tooltipText, this.services.onRenderTooltip, pendingChangesIconData.showTooltip), 
                this.pendingChangesText.text(pendingChangesIconData.tooltipLabel), pendingChangesIconData.tooltipLabel || this.pendingChangesText.css("display", "none"), 
                "left" === pendingChangesIconData.position ? (this.pendingChangesIcon.css("order", "1"), 
                this.pendingChangesText.css("order", "2"), this.textElement.css("order", "3")) : (this.pendingChangesText.css("order", "1"), 
                this.pendingChangesIcon.css("order", "3"), this.textElement.css("order", "2"));
            }, SlicerHeader.prototype.addSpacer = function() {
                this.spacer = (0, DomFactory.hi)(), this.spacer.addClass("slicer-header-spacer").appendTo(this.title);
            }, SlicerHeader.prototype.addTitle = function() {
                var _this = this;
                this.title = (0, DomFactory.hi)(), this.title.addClass("slicer-header-title").appendTo(this.header);
                var clearText = this.services.localize("Slicer_Clear");
                this.clearButton = (0, DomFactory.yP)().addClass("slicer-header-clear").toggleClass(slicerUtil1.hY.class, (0, 
                slicerUtil1.Id)()).attr("aria-label", clearText).attr("role", "button").attr("tabindex", "0").on("keydown", function(event) {
                    "Space" !== event.key && "Enter" !== event.key || _this.settings.onClear && (_this.settings.onClear(), 
                    event.stopPropagation());
                }).appendTo(this.title), this.applyTooltip(this.clearButton, clearText, this.services.onRenderTooltip), 
                this.clearButton.click(function() {
                    _this.settings.onClear && _this.settings.onClear();
                }), SlicerHeader.addHoverInOut(this.settings.hoverContainer, function() {
                    _this.settings.strictSingleSelect || (_this.clearButton.css("visibility", "visible"), 
                    _this.clearButton.css("display", "block"));
                }, function() {
                    _this.settings.areControlButtonsAlwaysVisible || (_.isEmpty(_this.data.text) ? _this.clearButton.css("visibility", "hidden") : _this.clearButton.css("display", "none"));
                }), this.textElement = $("<h3></h3>").addClass("slicer-header-text").appendTo(this.title), 
                this.addPendingChangesText(), this.addPendingChangesIcon(), this.addSpacer();
            }, SlicerHeader.prototype.applyTooltip = function(element, tooltip, onRenderTooltip, tooltipEnabled) {
                void 0 === tooltipEnabled && (tooltipEnabled = !0);
                var tooltipRef = null;
                if (!tooltipEnabled) return null == tooltipRef || tooltipRef.close(), void element.off("focus mouseenter blur mouseleave keydown");
                element.on("focus mouseenter", function() {
                    tooltipRef = onRenderTooltip(element.get(0), tooltip);
                }), element.on("blur mouseleave", function() {
                    null == tooltipRef || tooltipRef.close(), tooltipRef = null;
                }), element.on("keydown", function(event) {
                    null !== tooltipRef && "Escape" === event.key && (event.stopPropagation(), event.preventDefault(), 
                    tooltipRef.close(), tooltipRef = null);
                });
            }, SlicerHeader.prototype.updateTitle = function() {
                if (this.data.show) {
                    var fontSizeInPixels = StandaloneUtility1.FP.fromPoint(this.data.textSize), hideOutline = !1;
                    if (this.settings.areControlButtonsAlwaysVisible && (this.settings.strictSingleSelect || (this.clearButton.css("visibility", "visible"), 
                    this.clearButton.css("display", "block")), 0 !== this.services.getViewMode() && this.selectMenuContainer && (this.selectMenuContainer.css("visibility", "visible"), 
                    this.selectMenuContainer.css("display", "flex"))), this.data.searchEnabled) {
                        var defaultData = SlicerHeader.DefaultData(this.style, this.settings.text, this.services);
                        hideOutline = this.data.outlineStyle === defaultData.outlineStyle && this.data.outlineWeight === defaultData.outlineWeight && this.data.outlineColor === defaultData.outlineColor;
                    }
                    this.title.show(), this.title.css({
                        "border-style": hideOutline ? "none" : this.data.borderStyle,
                        "border-color": this.data.outlineColor,
                        "border-width": (0, visualBorderUtil.$b)(this.data.outlineStyle, this.data.outlineWeight),
                        "background-color": _.isEmpty(this.data.background) ? "" : this.data.background,
                        "font-size": fontSizeInPixels
                    }), this.clearButton.css({
                        "font-size": fontSizeInPixels
                    }), this.updateTextElementStyle(this.textElement), this.updateTextElementStyle(this.pendingChangesText), 
                    this.updateTitleText();
                    var viewModel_2 = this.data;
                    this.clearButton.css("color", this.data.iconColor).hover(function() {
                        $(this).css("color", viewModel_2.iconHoverColor);
                    }, function() {
                        $(this).css("color", viewModel_2.iconColor);
                    }), this.updatePendingChangesIcon();
                } else this.title.hide();
            }, SlicerHeader.prototype.updateTextElementStyle = function(element) {
                null == element || element.css({
                    "font-size": StandaloneUtility1.FP.fromPoint(this.data.textSize),
                    "font-family": this.data.fontFamily,
                    color: this.data.fontColor,
                    "font-weight": this.data.labelBold ? CssConstants.en : CssConstants.AI,
                    "font-style": this.data.labelItalic ? CssConstants.BF : CssConstants.AI,
                    "text-decoration": this.data.labelUnderline ? CssConstants.f0 : CssConstants.zu
                });
            }, SlicerHeader.prototype.updateTitleText = function() {
                var text = this.data.text;
                if (this.data.showRestatement && this.settings.restatement) {
                    var formatString = this.services.localize("NamePattern_Colon");
                    text = (0, formatUtil.W)(formatString, text, this.settings.restatement);
                }
                this.textElement.text(text).attr("title", text).attr("aria-label", text);
            }, SlicerHeader.prototype.updateSelectMenu = function() {
                this.selectMenu && 0 === this.services.getViewMode() ? this.selectMenuContainer.hide() : this.selectMenu && (this.selectMenuContainer.show(), 
                this.selectMenu.update({
                    options: this.getSelectMenuOptions(),
                    selectedValue: this.settings.selectedValue,
                    disabled: 2 === this.settings.visibilityState
                }));
            }, SlicerHeader.prototype.getSelectMenuOptions = function() {
                for (var selectMenuOptions = [], _i = 0, options_1 = this.settings.slicerModeOptions; _i < options_1.length; _i++) {
                    var option = options_1[_i], displayName = option.displayName({
                        get: this.services.localize
                    });
                    selectMenuOptions.push({
                        text: displayName,
                        value: option.value
                    });
                }
                return selectMenuOptions;
            }, SlicerHeader.prototype.addWarnings = function(warningBuilder) {
                (0, slicerUtil1.td)(this.data.warnings, warningBuilder);
            }, SlicerHeader.addHoverInOut = function(element, handlerIn, handlerOut) {
                (0, slicerUtil1.Id)() && element.hover(handlerIn, handlerOut);
            }, SlicerHeader;
        }(), Double = __webpack_require__(41640), TabularSlicerLayout = function() {
            function TabularSlicerLayout() {}
            return TabularSlicerLayout.prototype.renderCore = function(container) {
                container.classed(Tabular.class, !0);
            }, TabularSlicerLayout.prototype.bindData = function(materializedDataPoints, data, itemsContainer) {
                return this.renderColumns(materializedDataPoints, itemsContainer).selectAll(IndividualItemContainer.selector).data(function(chunk) {
                    return chunk;
                }, function(d) {
                    return (0, slicerUtil1.fz)(d);
                });
            }, TabularSlicerLayout.prototype.renderColumns = function(materializedDataPoints, itemsContainer) {
                var itemsPerColumn = this.numberOfRows, groupedDataPoints = _.chunk(materializedDataPoints, itemsPerColumn), columnsEnterUpdate = itemsContainer.selectAll(ColumnItemContainer.selector).style("height", null).data(groupedDataPoints).join(function(enter) {
                    return enter.append("div").classed(ColumnItemContainer.class, !0);
                });
                return this.scaleLastColumnIfNeeded(itemsPerColumn, groupedDataPoints, itemsContainer), 
                columnsEnterUpdate;
            }, TabularSlicerLayout.prototype.scaleLastColumnIfNeeded = function(itemsPerColumn, groupedDataPoints, itemsContainer) {
                if (groupedDataPoints && _.last(groupedDataPoints)) {
                    var numOfItemsInLastColumn = _.last(groupedDataPoints).length;
                    if (numOfItemsInLastColumn < itemsPerColumn) {
                        var lastColumn = itemsContainer.select(ColumnItemContainer.selector + ":last-child"), sizePecent = (0, 
                        Double.W0)(100 * numOfItemsInLastColumn / itemsPerColumn, .01);
                        lastColumn.style("height", sizePecent + "%");
                    }
                }
            }, TabularSlicerLayout.prototype.findNextElement = function(element, forward) {
                return $(element).hasClass(ItemsContainer.class) ? forward ? element.firstElementChild.firstElementChild : element.lastElementChild.lastElementChild : forward ? !(option = element.nextElementSibling) && (container = element.parentElement).nextElementSibling ? container.nextElementSibling.firstElementChild : option : !(option = element.previousElementSibling) && (container = element.parentElement).previousElementSibling ? container.previousElementSibling.lastElementChild : option;
                var option, container;
            }, TabularSlicerLayout.prototype.getScrollSize = function(itemsToDisplay) {
                return this.numberOfRows;
            }, TabularSlicerLayout.prototype.getLastStartIndex = function(itemsToDisplay, dataPointsLength) {
                if (dataPointsLength <= itemsToDisplay) return 0;
                var emptyLeftovers = 0, itemsChunk = this.numberOfRows, moduloResult = dataPointsLength % itemsChunk;
                return moduloResult > 0 && (emptyLeftovers = itemsChunk - moduloResult), Math.max(dataPointsLength - itemsToDisplay + emptyLeftovers, 0);
            }, TabularSlicerLayout.prototype.calculateTotalItemDimensions = function(totalItemWidth, totalItemHeight) {
                return totalItemWidth = Math.max(totalItemWidth, TabularSlicerLayout.MinItemWidth), 
                totalItemHeight = Math.max(totalItemHeight, TabularSlicerLayout.MinItemHeight), 
                {
                    width: totalItemWidth += 2 * TabularSlicerLayout.TabularMargin,
                    height: totalItemHeight += 2 * TabularSlicerLayout.TabularMargin
                };
            }, TabularSlicerLayout.prototype.calculateNumberOfItemsToDisplay = function(element, totalItemsWidth, totalItemsHeight, dataPointsLength) {
                var body = element.find(slicerUtil1.uT.selector), availableWidth = body.width() - 2 * TabularSlicerLayout.NavigationArrowWidth, availableHeight = body.height();
                return this.calculateTableDimensions({
                    height: availableHeight,
                    width: availableWidth
                }, {
                    height: totalItemsHeight,
                    width: totalItemsWidth
                }, dataPointsLength);
            }, TabularSlicerLayout.prototype.calculateTableDimensions = function(availableViewport, totalItemsArea, dataPointsLength) {
                var totalItemsWidth = totalItemsArea.width, totalItemsHeight = totalItemsArea.height, availableHeight = availableViewport.height;
                if (0 === totalItemsWidth) return 0;
                var numberOfColumns = Math.floor(availableViewport.width / totalItemsWidth);
                this.numberOfRows = 0 === totalItemsHeight ? 1 : Math.floor(availableHeight / totalItemsHeight), 
                this.numberOfRows = Utility.b$.clampValue(this.numberOfRows, 1, dataPointsLength);
                var root = Math.ceil(Math.sqrt(dataPointsLength));
                return numberOfColumns >= root && this.numberOfRows >= root ? this.numberOfRows = numberOfColumns = root : this.numberOfRows >= dataPointsLength && numberOfColumns > 1 && (this.numberOfRows = Math.ceil(this.numberOfRows / numberOfColumns)), 
                Utility.b$.clampValue(this.numberOfRows * numberOfColumns, this.numberOfRows, dataPointsLength);
            }, TabularSlicerLayout.prototype.getNavigationArrowsClass = function(selection, isLeft) {
                isLeft ? selection.classed(TabularNavigationArrow.class, !0).classed(LeftNavigationArrow.class, !0).classed(PbiVisualsGlyph.class, !0).classed(TabularLeftNavigationArrow.class, !0) : selection.classed(TabularNavigationArrow.class, !0).classed(RightNavigationArrow.class, !0).classed(PbiVisualsGlyph.class, !0).classed(TabularRightNavigationArrow.class, !0);
            }, TabularSlicerLayout.prototype.getDataPointRightMargin = function(index, itemsToDisplay) {
                return "0px";
            }, TabularSlicerLayout.MinItemWidth = 40, TabularSlicerLayout.MinItemHeight = 40, 
            TabularSlicerLayout.TabularMargin = 2, TabularSlicerLayout.NavigationArrowWidth = 19, 
            TabularSlicerLayout;
        }(), Tabular = (0, CssConstants.CH)("tabular"), ColumnItemContainer = (0, CssConstants.CH)("columnItemContainer"), PbiVisualsGlyph = (0, 
        CssConstants.CH)("powervisuals-glyph"), TabularNavigationArrow = (0, CssConstants.CH)("tabularNavigationArrow"), TabularLeftNavigationArrow = (0, 
        CssConstants.CH)("left-nav-arrow"), TabularRightNavigationArrow = (0, CssConstants.CH)("right-nav-arrow"), FocusNavigationUtility = __webpack_require__(57470), renderUtil = __webpack_require__(60066), listView = __webpack_require__(97121), slicerExpandCollapseToggle = __webpack_require__(36265), arrayExtensions = __webpack_require__(50550), jqueryPromiseFactory = __webpack_require__(88987), svgUtil = __webpack_require__(10389), dataViewAnalysis = __webpack_require__(92129), sqExprEqualityVisitor = __webpack_require__(45413), VerticalSlicerRenderer = function() {
            function VerticalSlicerRenderer(verticalSlicerStrategy, options, lockKeyboardNavigation) {
                void 0 === lockKeyboardNavigation && (lockKeyboardNavigation = !0), this.lockKeyboardNavigation = lockKeyboardNavigation, 
                this.hasSearchableData = !1, this.scrollPositionStack = [], this.defaultMinWidth = 50, 
                this.shouldResetScrollPosition = !1, this.isCollapse = !1, this.expandable = !1, 
                this.pendingFocusCall = !1, this.focusCallback = null, this.verticalSlicerStrategy = verticalSlicerStrategy, 
                this.behavior = new slicerBehaviors.wV, this.domHelper = new slicerUtil1.gy, this.hostServices = options.hostServices, 
                options && (this.featureSwitches = options.featureSwitches), this.factory = (0, 
                jqueryPromiseFactory.p)(), this.searchComponent = new slicerSearchInput.v(this.hostServices);
            }
            return VerticalSlicerRenderer.prototype.hasSlider = function() {
                return !1;
            }, VerticalSlicerRenderer.prototype.supportsOrientation = function() {
                return !this.dataView || !this.data || _.isEmpty(this.data.queryNameByLevel) || 1 === this.data.queryNameByLevel.length;
            }, VerticalSlicerRenderer.prototype.enumerateObjectInstances = function(options) {
                return (0, slicerUtil1.qo)(options, this.data, this.settings, this.dataView, this.featureSwitches);
            }, VerticalSlicerRenderer.prototype.getValuesCard = function() {
                return (0, slicerUtil1.s9)(this.hostServices, this.data, this.settings, this.featureSwitches);
            }, VerticalSlicerRenderer.prototype.getSlicerSettingsCardOptions = function(cardUidBuilder, orientation, activeMode, slicerModes) {
                return (0, slicerUtil1.nD)({
                    cardUidBuilder,
                    currentSlicerSettings: this.settings,
                    data: this.data,
                    dataView: this.dataView,
                    hostServices: this.hostServices,
                    orientation,
                    activeMode,
                    slicerModes,
                    featureSwitches: this.featureSwitches
                });
            }, VerticalSlicerRenderer.prototype.getAdditionalCards = function() {
                return (0, slicerUtil1.oE)(this.hostServices, this.data, this.settings, this.dataView);
            }, VerticalSlicerRenderer.prototype.onModeChange = function(mode) {
                (0, slicerUtil1.VD)(this.hostServices, mode);
            }, VerticalSlicerRenderer.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                var newPropertySaveObjects = (0, slicerUtil1.tm)(propertySaveObjects, sourceType);
                return debug.fF.assertNonEmpty(newPropertySaveObjects, "There should be at least one save object"), 
                newPropertySaveObjects;
            }, VerticalSlicerRenderer.prototype.getRestatement = function() {
                return this.data && this.data.restatement;
            }, VerticalSlicerRenderer.prototype.onClear = function(isUserAction) {
                (0, slicerUtil1.dq)(this.selectionHandler), (0, slicerUtil1.K5)(this.selectionHandler, isUserAction), 
                this.searchComponent && (this.searchComponent.input.node().value = "");
            }, VerticalSlicerRenderer.prototype.init = function(slicerInitOptions, element) {
                var _this = this;
                this.element = element, this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var selectionHandler, hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                this.style = slicerInitOptions.visualInitOptions.style, this.settings = (0, slicer_converter.VT)(this.style), 
                this.behavior && (selectionHandler = new slicerSelectionHandler.N(hostServices, this.behavior));
                var containerDiv = document.createElement("div");
                containerDiv.className = Container.class;
                var container = this.container = d3.select(containerDiv);
                return this.searchComponent.create(container), this.verticalSlicerStrategy.hasClearSearchButton() && this.searchComponent.addClearButton(), 
                this.createBodyElement(), this.listView = (0, listView.P)({
                    rowHeight: void 0,
                    enter: function(rowSelection) {
                        _this.createDataPoints(rowSelection);
                    },
                    update: function(rowSelection) {
                        _this.updateDataPoints(rowSelection, selectionHandler);
                    },
                    loadMoreData: function() {
                        return slicerInitOptions.loadMoreData();
                    },
                    scrollEnabled: !0,
                    viewport: this.currentViewport,
                    baseContainer: this.body,
                    isReadMode: function() {
                        return 1 !== _this.hostServices.getViewMode();
                    },
                    scrollToFrame: slicerInitOptions.enableMultiElementRows ? function(options) {
                        return _this.scrollToFrameForMultiElementRow(options);
                    } : void 0
                }), this.element.get(0).appendChild(containerDiv), this.selectionHandler = selectionHandler, 
                selectionHandler;
            }, VerticalSlicerRenderer.prototype.onDestroy = function() {
                this.listView && this.listView.destroy();
            }, VerticalSlicerRenderer.prototype.render = function(options) {
                this.renderVerticalSlicer(this.converter(options.dataView, options.isSlicer), options);
            }, VerticalSlicerRenderer.prototype.renderVerticalSlicer = function(data, options, callback) {
                this.focusCallback && (FocusNavigationUtility.M.contains(this.container.node(), document.activeElement) || (this.focusCallback = void 0, 
                this.listView && this.listView.resetCallBacks())), this.currentViewport = options.viewport, 
                this.hasSearchableData = options.hasSearchableData;
                var dataView = options.dataView, searchSettings = slicerSearchInput.v.fromSlicerSettings(this.settings, null == data ? void 0 : data.searchKey, this.verticalSlicerStrategy.shouldShowSearchHeader(this.settings, this.hasSearchableData), this.verticalSlicerStrategy.hasClearSearchButton(), this.featureSwitches);
                if (this.searchComponent.update(searchSettings), this.container.node().querySelector("input.searchInput") === document.activeElement && options.isSearchMode && this.announceSearchResults(data.slicerDataPoints.length), 
                this.body.select(EmptyResult.selector).remove(), dataView && this.data && !_.isEmpty(this.data.slicerDataPoints)) this.expandable = this.data.queryNameByLevel.length > 1, 
                this.setBodyRole(), this.setBodyAriaLabel(), this.updateSelectionStyle(), this.listView.viewport(this.currentViewport).data(this.data.slicerDataPoints, function(d) {
                    return (0, slicerUtil1.fz)(d);
                }, options.resetScrollbarPosition && this.shouldResetScrollPosition, callback); else {
                    if (this.listView && (this.listView.empty(), this.verticalSlicerStrategy.shouldShowSearchHeader(this.settings, this.hasSearchableData))) {
                        var emptySearchResultsText = this.body.insert("p", ".scroll-wrapper").classed(EmptyResult.class, !0).text(this.hostServices.getLocalizedString("ContentList_EmptySearchResults"));
                        this.domHelper.setSlicerTextStyle(emptySearchResultsText, this.settings, this.featureSwitches);
                    }
                    callback && callback();
                }
            }, VerticalSlicerRenderer.prototype.converter = function(dataView, isSlicer) {
                void 0 === isSlicer && (isSlicer = !1);
                var localizedSelectAllText = this.hostServices.getLocalizedString(slicerUtil1.vx), data = (0, 
                slicer_converter.OQ)({
                    dataView,
                    localizedSelectAllText,
                    selectionHandler: this.selectionHandler,
                    hostServices: this.hostServices,
                    style: this.style,
                    isSlicer,
                    featureSwitches: this.featureSwitches,
                    slicerType: 0
                });
                return this.shouldResetScrollPosition = this.getShouldResetScrollPosition(dataView, data), 
                this.data = data, this.isCollapse = !1, dataView && this.data && (this.settings = data.slicerSettings, 
                this.dataView = dataView), data;
            }, VerticalSlicerRenderer.prototype.hasSearchEnabled = function() {
                return this.verticalSlicerStrategy.shouldShowSearchHeader(this.settings, this.hasSearchableData);
            }, VerticalSlicerRenderer.prototype.updateSelectionStyle = function() {
                var settings = this.settings;
                this.container.classed("isMultiSelectEnabled", settings && settings.selection && !settings.selection.singleSelect);
            }, VerticalSlicerRenderer.prototype.createDataPoints = function(rowSelection) {
                var _this = this, self = this, settings = this.settings, listItemElement = rowSelection.append("div").classed(ItemContainer.class, !0), inputElement = listItemElement.append("div").classed(verticalSlicer_Input.class, !0).attr("aria-hidden", !0);
                this.verticalSlicerStrategy.customizeInputElement(inputElement, settings);
                var isInverted = this.selectionHandler.isSelectionModeInverted();
                listItemElement.on("contextmenu", function(data, index) {
                    d3.event.stopPropagation(), d3.event.preventDefault(), _this.onContextMenu(data, {
                        x: d3.event.clientX,
                        y: d3.event.clientY
                    });
                }), listItemElement.call(VerticalSlicerRenderer.updateTabIndex);
                var role = this.getOptionRole();
                listItemElement.each(function(d, i) {
                    var _this = this, item = d3.select(this);
                    this.addEventListener("keydown", function(event) {
                        var bindData = item.data();
                        if (!_.isEmpty(bindData)) {
                            var data = bindData[0], handleEvent = function(action) {
                                event.preventDefault(), event.stopPropagation(), action();
                            };
                            if (39 === event.keyCode && !0 === data.isCollapsed || 37 === event.keyCode && !1 === data.isCollapsed) {
                                var currentActiveElement_1 = document.activeElement;
                                event.stopPropagation(), self.expandCollapseNode(data), handleEvent(function() {
                                    return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                        return (0, tslib_es6.__generator)(this, function(_a) {
                                            return [ 2, self.focusRowAtIndex(currentActiveElement_1, self.getCurrentRowDataIndex(currentActiveElement_1), !1, !1, !1, !1, !1, !0) ];
                                        });
                                    });
                                });
                            } else 39 === event.keyCode && data.children ? handleEvent(function() {
                                return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                    return (0, tslib_es6.__generator)(this, function(_a) {
                                        return [ 2, self.focusRowAtIndex(document.activeElement, data.children[0].index, !1, !0, !1, !1, !0, !1) ];
                                    });
                                });
                            }) : 37 === event.keyCode && data.parent ? handleEvent(function() {
                                return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                    return (0, tslib_es6.__generator)(this, function(_a) {
                                        return [ 2, self.focusRowAtIndex(document.activeElement, data.parent.index, !1, !1, !0, !1, !0, !1) ];
                                    });
                                });
                            }) : 39 === event.keyCode || 37 === event.keyCode ? event.stopPropagation() : 56 === event.keyCode && (event.stopPropagation(), 
                            self.expandCollapseAllNodesOnSameLevel(data));
                        }
                    }), self.updateItemState(item, d), self.setAccessibilityAttributes(d, item, role, isInverted), 
                    item.attr("data-row-index", d.index).attr("data-row-id", d.id), null != d.count && item.append("span").classed(slicerUtil1.HR.class, !0).styles({
                        "font-size": StandaloneUtility1.FP.fromPoint(settings.slicerText.textSize),
                        "font-family": settings.slicerText.fontFamily
                    });
                });
            }, VerticalSlicerRenderer.prototype.getUnusedAriaStatus = function() {
                return "aria-selected";
            }, VerticalSlicerRenderer.prototype.setAccessibilityAttributes = function(d, item, role, isInverted) {
                item.attr("role", role.role).attr(role.selected, (0, slicerUtil1.OO)(d, isInverted)).attr("aria-setsize", d.levelCount || -1).attr("title", (0, 
                slicerUtil1.rX)(this.hostServices, d.tooltip)).attr("aria-posinset", d.levelIndex ? d.levelIndex : 1);
            }, VerticalSlicerRenderer.updateTabIndex = function(rowSelection) {
                var firstItem, tabFound = !1;
                rowSelection.each(function(d, i) {
                    var item = d3.select(this);
                    0 === i && (firstItem = item), tabFound || "0" !== item.attr("tabindex") ? tabFound && "0" === item.attr("tabindex") && item.attr("tabindex", null) : tabFound = !0;
                }), firstItem && !tabFound && firstItem.attr("tabindex", "0");
            }, VerticalSlicerRenderer.prototype.updateItemType = function(item, d) {
                var image = item.select(slicerUtil1.Iy.selector), text = item.select(slicerUtil1.NV.selector);
                if (d.isImage) return text.remove(), image.empty() && (image = item.append("img").classed(slicerUtil1.Iy.class, !0)), 
                image.attr("src", d.value), void image.attr("role", "none");
                text.empty() && (image.remove(), text.empty() && (text = item.append("span").classed(slicerUtil1.NV.class, !0))), 
                text.text(d.value);
            }, VerticalSlicerRenderer.prototype.getOptionRole = function() {
                return {
                    role: this.expandable ? "treeitem" : "option",
                    selected: "aria-selected"
                };
            }, VerticalSlicerRenderer.prototype.updateDataPoints = function(rowSelection, selectionHandler) {
                var settings = this.settings, data = this.data;
                if (data && settings) {
                    var domHelper = this.domHelper, isInverted_1 = this.selectionHandler.isSelectionModeInverted();
                    rowSelection.select(ItemContainer.selector), rowSelection.select(verticalSlicer_Input.selector), 
                    rowSelection.select(ExpandButton.selector), this.verticalSlicerStrategy.updateInputElement(rowSelection.selectAll(verticalSlicer_Input.selector), settings);
                    var countText = rowSelection.selectAll(slicerUtil1.HR.selector);
                    if (!countText.empty() && this.verticalSlicerStrategy.shouldShowCount() && (rowSelection.select(CountText.selector), 
                    countText.text(function(d) {
                        return d.count;
                    }), domHelper.setSlicerTextStyle(countText, settings, this.featureSwitches)), selectionHandler && this.body) {
                        var self_1 = this, body = this.body.attr("width", this.currentViewport.width), role_1 = this.getOptionRole(), slicerItemContainers = this.body.selectAll(ItemContainer.selector);
                        slicerItemContainers.each(function(d, index) {
                            var item = d3.select(this);
                            self_1.updateItemState(item, d), item.node().hasAttribute("role") && item.attr(self_1.getUnusedAriaStatus(), null), 
                            self_1.setAccessibilityAttributes(d, item, role_1, isInverted_1), null != settings.items.padding && (item.style("padding-top", "".concat(settings.items.padding, "px")), 
                            item.style("padding-bottom", "".concat(settings.items.padding, "px")));
                        });
                        var labelText = rowSelection.selectAll(slicerUtil1.NV.selector);
                        this.verticalSlicerStrategy.setLabelTextStyle(domHelper, labelText, settings, this.style, this.featureSwitches), 
                        VerticalSlicerRenderer.updateTabIndex(slicerItemContainers);
                        var slicerItemInputs = body.selectAll(verticalSlicer_Input.selector);
                        selectionHandler.bind(data.retainedDataPoints, {
                            behaviorOptions: {
                                slicerContainer: this.container,
                                itemContainers: slicerItemContainers,
                                itemInputs: slicerItemInputs,
                                settings: data.slicerSettings,
                                searchInput: this.searchComponent.input,
                                clearSearchTextButton: this.searchComponent.clear,
                                style: this.style
                            },
                            orientation: slicerOrientation.i.Vertical
                        });
                    }
                    this.behavior.renderSelection();
                }
            }, VerticalSlicerRenderer.prototype.announceSearchResults = function(lengthOfDataPoint) {
                var message;
                message = 0 === lengthOfDataPoint ? this.hostServices.getLocalizedString("ContentList_EmptySearchResults") : 1 === lengthOfDataPoint ? this.hostServices.getLocalizedString("Count_SearchBox_Result_One") : this.hostServices.getLocalizedString("Count_SearchBox_Results").replace("{0}", lengthOfDataPoint.toString()), 
                this.hostServices.alertWithDebounce("announce-search", message);
            }, VerticalSlicerRenderer.prototype.getExpandParameters = function(d) {
                debug.fF.assert(function() {
                    return void 0 !== d.isCollapsed;
                }, ".expandCollapseNode should not be called with un-expandable node"), this.isCollapse = !1 === d.isCollapsed;
                var dataPointInfo = (0, slicerUtil1.No)(d, this.data.queryNameByLevel);
                return {
                    dataRoles: [ slicer_capabilities.CT.value ],
                    data: dataPointInfo.selector,
                    isCollapse: !d.isCollapsed,
                    nodeIndex: dataPointInfo.path
                };
            }, VerticalSlicerRenderer.prototype.expandCollapseNode = function(d) {
                var expandParams = this.getExpandParameters(d);
                this.hostServices.setNodeExpansionState({
                    dataRoles: expandParams.dataRoles,
                    data: expandParams.data,
                    isCollapse: expandParams.isCollapse,
                    nodeIndex: expandParams.nodeIndex
                });
            }, VerticalSlicerRenderer.prototype.expandCollapseAllNodesOnSameLevel = function(d) {
                var expandParams = this.getExpandParameters(d);
                this.hostServices.setLevelExpansionState({
                    dataRoles: expandParams.dataRoles,
                    data: expandParams.data,
                    isCollapse: expandParams.isCollapse,
                    nodeIndex: expandParams.nodeIndex
                });
            }, VerticalSlicerRenderer.prototype.onContextMenu = function(d, point) {
                var dataPointInfo = (0, slicerUtil1.No)(d, this.data.queryNameByLevel), args = {
                    nodeIndex: dataPointInfo.path,
                    dataRoles: [ slicer_capabilities.CT.value ],
                    position: {
                        x: d3.event.clientX,
                        y: d3.event.clientY
                    },
                    data: [ dataPointInfo.selector ]
                };
                this.hostServices.onContextMenu(args);
            }, VerticalSlicerRenderer.prototype.getShouldResetScrollPosition = function(newDataView, newData) {
                if (!this.dataView || !this.data || !newDataView || !newData || this.isCollapse) return !1;
                if (1 === this.data.queryNameByLevel.length) return !(0, dataViewAnalysis.ih)(newDataView, this.dataView);
                if ((0, arrayExtensions.s_)(this.data.queryNameByLevel, newData.queryNameByLevel, function(q1, q2) {
                    return q1 === q2;
                })) {
                    if (!_.isEmpty(this.data.slicerDataPoints) && !_.isEmpty(newData.slicerDataPoints) && this.data.slicerDataPoints.length > newData.slicerDataPoints.length && !this.isCollapse) {
                        var firstVisibleRow_1 = this.listView.getFirstVisibleRow();
                        return !firstVisibleRow_1 || void 0 !== firstVisibleRow_1.levelIndex && !_.some(newData.slicerDataPoints, function(d) {
                            return d.identity.equals(firstVisibleRow_1.identity);
                        });
                    }
                    return !1;
                }
                if (this.dataView.matrix && this.dataView.matrix.rows && newDataView.matrix && newDataView.matrix.rows) {
                    var oldSources = _.map(this.dataView.matrix.rows.levels, function(level) {
                        return level.sources[0].expr;
                    }), newSources = _.map(newDataView.matrix.rows.levels, function(level) {
                        return level.sources[0].expr;
                    });
                    return !(0, arrayExtensions.s_)(oldSources, newSources, sqExprEqualityVisitor.fS);
                }
                return !0;
            }, VerticalSlicerRenderer.prototype.updateExpansionState = function(item, d) {
                var margin = 0;
                d.level > 0 && (margin = d.level * StandaloneUtility1.FP.fromPointToPixel(this.data.slicerSettings.expandCollapse.indentation)), 
                item.styles({
                    "margin-left": "".concat(margin, "px")
                }), this.updateExpandButton(item, d);
            }, VerticalSlicerRenderer.prototype.updateExpandButton = function(item, d) {
                var expandButton = item.select(ExpandButton.selector);
                this.expandable && (expandButton.empty() && (expandButton = this.createExpandButton(item)), 
                item.attr("aria-expanded", void 0 === d.isCollapsed ? null : !d.isCollapsed), void 0 !== d.level && item.attr("aria-level", d.level + 1));
                var fontSize = StandaloneUtility1.FP.fromPoint(this.data.slicerSettings.slicerText.textSize);
                if (expandButton.styles({
                    "font-size": fontSize,
                    width: fontSize
                }), expandButton.attr("aria-hidden", "true"), void 0 !== d.isCollapsed) {
                    var buttonType = this.data.slicerSettings.expandCollapse.toggleType;
                    expandButton.classed(Hidden.class, !1), expandButton.selectAll(".glyphicon").classed("pbi-glyph-chevrondownsmall", d.isCollapsed && buttonType === slicerExpandCollapseToggle.H.Chevron).classed("pbi-glyph-chevronupsmall", !d.isCollapsed && buttonType === slicerExpandCollapseToggle.H.Chevron).classed("pbi-glyph-explore-content-single", d.isCollapsed && buttonType === slicerExpandCollapseToggle.H.PlusMinus).classed("pbi-glyph-collapse-content-single", !d.isCollapsed && buttonType === slicerExpandCollapseToggle.H.PlusMinus).classed("pbi-glyph-caretright", d.isCollapsed && buttonType === slicerExpandCollapseToggle.H.Caret).classed("pbi-glyph-caretdownright", !d.isCollapsed && buttonType === slicerExpandCollapseToggle.H.Caret);
                } else this.expandable || expandButton.empty() ? expandButton.classed(Hidden.class, !0) : expandButton.remove();
            }, VerticalSlicerRenderer.prototype.createExpandButton = function(item) {
                var _this = this, glyphContainer = item.insert("div", ":first-child").classed(ExpandButton.class, !0).on("click", function(data) {
                    d3.event.stopPropagation(), _this.expandCollapseNode(data);
                });
                return glyphContainer.append("i").classed("glyphicon", !0), glyphContainer;
            }, VerticalSlicerRenderer.prototype.scrollToFrameForMultiElementRow = function(options) {
                var listView = options.listView, loadMoreData = options.loadMoreData, rowHeight = options.rowHeight, scrollTop = options.scrollTop, totalElements = options.totalRows, visibleGroupContainer = options.visibleGroupContainer, baseContainer = options.baseContainer, rowScrollPosition = 0 === scrollTop ? 0 : Math.floor(scrollTop / rowHeight);
                if (!(this.currentRowPosition && rowScrollPosition === this.currentRowPosition || rowScrollPosition < 0)) {
                    var transformAttr = (0, svgUtil.O7)(0, rowScrollPosition * rowHeight);
                    visibleGroupContainer.styles({
                        transform: function(d) {
                            return transformAttr;
                        },
                        "-webkit-transform": transformAttr
                    });
                    var elements = visibleGroupContainer.selectAll(".row").filter(function() {
                        return "" !== this.textContent;
                    });
                    return void 0 === this.currentRowPosition ? (this.currentPosition = this.getInitialPosition(totalElements, baseContainer), 
                    elements && elements.node() && (this.currentRowPosition = rowScrollPosition)) : (this.updateCurrentPosition(rowScrollPosition, totalElements, baseContainer, visibleGroupContainer, elements), 
                    this.currentRowPosition = rowScrollPosition), listView.performScrollToFrame(this.currentPosition.startIndex, this.currentPosition.endIndex, totalElements, this.currentPosition.endIndex - this.currentPosition.startIndex, loadMoreData);
                }
            }, VerticalSlicerRenderer.prototype.getInitialPosition = function(totalElements, baseContainer) {
                var endIndex = totalElements, visibleContainerSize = Math.ceil($(baseContainer.node()).outerHeight() / this.listView.getRowHeight()) * Math.floor($(baseContainer.node()).outerWidth() / this.defaultMinWidth);
                return visibleContainerSize > 0 && (endIndex = Math.min(totalElements, visibleContainerSize)), 
                {
                    startIndex: 0,
                    endIndex
                };
            }, VerticalSlicerRenderer.prototype.updateCurrentPosition = function(rowScrollPosition, totalElements, baseContainer, visibleGroupContainer, elements) {
                var rowDif = Math.abs(rowScrollPosition - this.currentRowPosition);
                if (rowScrollPosition === this.currentRowPosition) this.currentPosition = this.scrollPositionStack.pop() || this.getInitialPosition(totalElements, baseContainer); else if (rowScrollPosition < this.currentRowPosition) for (;rowDif > 0; ) this.currentPosition = this.scrollPositionStack.pop() || this.currentPosition, 
                rowDif--; else for (;rowDif > 0; ) {
                    var visibleRows = Math.ceil($(baseContainer.node()).outerHeight() / $(elements.node()).outerHeight());
                    if (this.currentPosition.startIndex >= totalElements - 1) return;
                    this.scrollPositionStack.push(this.currentPosition);
                    var elementsInRowArray = this.getElementsPerRow(visibleGroupContainer, visibleRows, elements), newStartIndex = this.currentPosition.startIndex + elementsInRowArray[0];
                    this.currentPosition = {
                        startIndex: newStartIndex,
                        endIndex: Math.min(totalElements, newStartIndex + _.sum(elementsInRowArray) + this.getMaxElementsInRow(visibleGroupContainer, elements))
                    }, rowDif--;
                }
            }, VerticalSlicerRenderer.prototype.getElementsPerRow = function(visibleGroupContainer, rowCount, elements) {
                for (var elementsPerRow = [], node = elements.node(), i = 0; i < rowCount && null !== node; i++) {
                    elementsPerRow.push(0);
                    for (var top_1 = $(node).position().top; null !== node && $(node).position().top <= top_1 + 5; ) elementsPerRow[i]++, 
                    node = node.nextElementSibling;
                }
                return elementsPerRow;
            }, VerticalSlicerRenderer.prototype.getMaxElementsInRow = function(visibleGroupContainer, elements) {
                var minWidthAttribute = elements.node().getAttribute("min-width");
                return minWidthAttribute ? $(visibleGroupContainer.node()).outerWidth() / +minWidthAttribute : Math.floor($(visibleGroupContainer.node()).outerWidth() / this.defaultMinWidth);
            }, VerticalSlicerRenderer.prototype.createBodyElement = function() {
                var _this = this;
                this.body = this.container.append("div").classed(slicerUtil1.uT.class, !0);
                var searchBar = this.searchComponent.input.node();
                this.body.on("wheel", function() {
                    _this.focusCallback = void 0, _this.listView.resetCallBacks(), _this.listView.onScroll();
                }), searchBar.addEventListener("keydown", function(event) {
                    40 === event.keyCode ? (_this.searchBarFocusNextElement(), event.preventDefault(), 
                    event.stopPropagation()) : 70 === event.keyCode && event.ctrlKey && (_this.searchBarFocusNextElement(), 
                    _this.enableSearch(), event.preventDefault(), event.stopPropagation());
                }), this.body.on("keydown", function() {
                    var d3Event = d3.event, handleEvent = function(action) {
                        d3Event.preventDefault(), d3Event.stopPropagation(), _this.pendingFocusCall || action();
                    };
                    if (40 === d3Event.keyCode) {
                        var activeElement_1 = document.activeElement, shiftKey_1 = d3Event.shiftKey;
                        handleEvent(function() {
                            return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                return (0, tslib_es6.__generator)(this, function(_a) {
                                    return [ 2, this.focusRowAtIndex(activeElement_1, this.getCurrentRowDataIndex(document.activeElement) + 2, !1, !0, !0, shiftKey_1, !1, !1) ];
                                });
                            });
                        });
                    } else if (38 === d3Event.keyCode) {
                        var activeElement_2 = document.activeElement, shiftKey_2 = d3Event.shiftKey;
                        _this.settings.search.enabled && 0 === _this.getCurrentRowDataIndex(activeElement_2) || _this.settings.search.enabled && 1 === _this.getCurrentRowDataIndex(activeElement_2) && !_this.settings.selection.selectAllCheckboxEnabled ? (_this.focusForJumpRow(searchBar), 
                        handleEvent(function() {
                            return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                return (0, tslib_es6.__generator)(this, function(_a) {
                                    return [ 2 ];
                                });
                            });
                        })) : handleEvent(function() {
                            return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                return (0, tslib_es6.__generator)(this, function(_a) {
                                    return [ 2, this.focusRowAtIndex(activeElement_2, this.getCurrentRowDataIndex(document.activeElement) - 3, !1, !1, !0, shiftKey_2, !1, !1) ];
                                });
                            });
                        });
                    } else if (9 === d3Event.keyCode) _this.lockKeyboardNavigation && _this.body.node().focus(); else if (35 === d3Event.keyCode) handleEvent(function() {
                        return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                            return (0, tslib_es6.__generator)(this, function(_a) {
                                return [ 2, this.focusRowAtIndex(document.activeElement, this.data.slicerDataPoints.length, !1, !0, !1, !1, !1, !1) ];
                            });
                        });
                    }); else if (36 === d3Event.keyCode) handleEvent(function() {
                        return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                            return (0, tslib_es6.__generator)(this, function(_a) {
                                return [ 2, this.focusRowAtIndex(document.activeElement, 1, !1, !1, !1, !1, !1, !1) ];
                            });
                        });
                    }); else if (34 === d3Event.keyCode) {
                        var element_1 = document.activeElement;
                        handleEvent(function() {
                            return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                return (0, tslib_es6.__generator)(this, function(_a) {
                                    return [ 2, this.focusRowAtIndex(element_1, this.getCurrentRowDataIndex(document.activeElement) + this.getRowsPerPage(), !0, !0, !1, !1, !1, !1) ];
                                });
                            });
                        });
                    } else if (33 === d3Event.keyCode) {
                        var element_2 = document.activeElement;
                        handleEvent(function() {
                            return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                                return (0, tslib_es6.__generator)(this, function(_a) {
                                    return [ 2, this.focusRowAtIndex(element_2, Math.max(this.getCurrentRowDataIndex(document.activeElement) - this.getRowsPerPage(), 1), !1, !1, !1, !1, !1, !1) ];
                                });
                            });
                        });
                    } else 70 === d3Event.keyCode && d3Event.ctrlKey && handleEvent(function() {
                        return (0, tslib_es6.__awaiter)(_this, void 0, void 0, function() {
                            return (0, tslib_es6.__generator)(this, function(_a) {
                                return [ 2, this.enableSearch() ];
                            });
                        });
                    });
                });
            }, VerticalSlicerRenderer.prototype.setBodyRole = function() {
                this.body.attr("role", this.expandable ? "tree" : "listbox"), this.body.attr("aria-multiselectable", !(this.data && this.data.slicerSettings.selection.strictSingleSelect));
            }, VerticalSlicerRenderer.prototype.setBodyAriaLabel = function() {
                this.body.attr("aria-label", this.data.categorySourceName);
            }, VerticalSlicerRenderer.prototype.enableSearch = function() {
                var _a;
                if (this.settings.search) {
                    this.settings.search.enabled = !this.settings.search.enabled;
                    var searchSettings = slicerSearchInput.v.fromSlicerSettings(this.settings, null === (_a = this.data) || void 0 === _a ? void 0 : _a.searchKey, this.verticalSlicerStrategy.shouldShowSearchHeader(this.settings, this.hasSearchableData), this.verticalSlicerStrategy.hasClearSearchButton(), this.featureSwitches);
                    this.searchComponent.update(searchSettings);
                }
            }, VerticalSlicerRenderer.prototype.focusRowAtIndex = function(currentRow, rowIndex, manualLoadMore, forward, arrowKeys, shiftKey, selectIndex, keepCurrentFocus) {
                var _this = this, deferred = this.factory.defer(), currentRowDataId = currentRow.getAttribute("data-row-id"), d3Event = d3.event;
                return this.focusCallback = void 0, this.listView.resetCallBacks(), this.pendingFocusCall ? deferred.resolve(1) : (this.pendingFocusCall = !0, 
                this.focusCallback = function() {
                    var nextRow, parent, parentContainer = $(_this.container.node()).find(".visibleGroup").get(0), newCurrentRow = $(parentContainer).find("[data-row-id='" + currentRowDataId + "']").get(0);
                    if (newCurrentRow ? parent = (currentRow = newCurrentRow).parentElement : nextRow = void 0, 
                    currentRow && _this.removeFocusForJumpRow(currentRow), keepCurrentFocus) currentRow ? _this.focusForJumpRow(currentRow) : forward || parent.previousElementSibling || currentRow.addEventListener("blur", function handler_1() {
                        _this.focusForJumpRow(currentRow), currentRow.removeEventListener("blur", handler_1);
                    }); else if (arrowKeys || selectIndex || !parentContainer ? arrowKeys && !selectIndex && parent ? !nextRow && forward && parent.nextElementSibling ? nextRow = parent.nextElementSibling.firstElementChild : nextRow || forward || !parent.previousElementSibling || (nextRow = parent.previousElementSibling.firstElementChild) : selectIndex && parentContainer && (forward ? (nextRow = _this.selectItemFromRowId(d3.select(currentRow).data()[0].children[0].id, parentContainer), 
                    nextRow = _this.adjustBottomRowToInViewRow(nextRow, parentContainer)) : (nextRow = _this.selectItemFromRowId(d3.select(currentRow).data()[0].parent.id, parentContainer), 
                    nextRow = _this.adjustTopRowToInViewRow(nextRow, parentContainer))) : !nextRow && forward ? nextRow = _this.adjustBottomRowToInViewRow(nextRow = parentContainer.lastElementChild.firstElementChild, parentContainer) : nextRow || forward || (nextRow = _this.adjustTopRowToInViewRow(nextRow = parentContainer.firstElementChild.firstElementChild, parentContainer)), 
                    nextRow) {
                        if (_this.focusForJumpRow(nextRow), shiftKey && _this.pendingFocusCall) {
                            var updateSettings = _this.settings;
                            updateSettings.selection.singleSelect = updateSettings.selection.strictSingleSelect, 
                            slicerBehaviors.wV.toggleItemSelectionFromExternal(d3Event, d3.select(nextRow).data()[0], _this.selectionHandler, updateSettings), 
                            _this.setAccessibilityAttributes(d3.select(nextRow).data()[0], d3.select(nextRow), _this.getOptionRole(), _this.selectionHandler.isSelectionModeInverted());
                        }
                    } else currentRow && _this.focusForJumpRow(currentRow);
                    _this.pendingFocusCall = !1, deferred.resolve(0);
                }, this.listView.scrollRowIntoView(rowIndex - 1, this.focusCallback)), deferred.promise;
            }, VerticalSlicerRenderer.prototype.getCurrentRowDataIndex = function(row) {
                if (row) {
                    var slicerDataPoint = d3.select(row).data()[0];
                    if (slicerDataPoint) return slicerDataPoint.index;
                }
                return 1;
            }, VerticalSlicerRenderer.prototype.adjustBottomRowToInViewRow = function(nextRow, parentContainer) {
                return nextRow.getBoundingClientRect().y + nextRow.getBoundingClientRect().height > this.container.node().getBoundingClientRect().y + this.container.node().getBoundingClientRect().height && (nextRow = parentContainer.lastElementChild.previousElementSibling.firstElementChild), 
                nextRow;
            }, VerticalSlicerRenderer.prototype.adjustTopRowToInViewRow = function(nextRow, parentContainer) {
                return nextRow.getBoundingClientRect().y <= parentContainer.getBoundingClientRect().y && this.listView.canScrollTop() && (nextRow = parentContainer.firstElementChild.nextElementSibling.firstElementChild), 
                nextRow;
            }, VerticalSlicerRenderer.prototype.getRowsPerPage = function() {
                return this.listView.getVisibleRowsWithoutPadding();
            }, VerticalSlicerRenderer.prototype.selectItemFromRowId = function(id, element) {
                return d3.select(element).select("[data-row-id='" + id + "']").node();
            }, VerticalSlicerRenderer.prototype.searchBarFocusNextElement = function() {
                var parentContainer = $(this.container.node()).find(".visibleGroup").get(0);
                this.focusForJumpRow(parentContainer.firstElementChild.firstElementChild);
            }, VerticalSlicerRenderer.prototype.focusForJumpRow = function(row) {
                row.setAttribute("tabindex", "0"), row.setAttribute("focusable", "true"), row.classList.add(renderUtil.Pg), 
                browserUtils.M.focus(row, {
                    preventScroll: !0
                });
            }, VerticalSlicerRenderer.prototype.removeFocusForJumpRow = function(row) {
                row.setAttribute("tabindex", "-1"), row.removeAttribute("focusable"), row.classList.remove(renderUtil.Pg);
            }, VerticalSlicerRenderer.prototype.updateItemState = function(item, d) {
                this.updateExpansionState(item, d), this.updateItemType(item, d), (0, slicerUtil1.hx)(item, d);
            }, VerticalSlicerRenderer;
        }(), CheckBoxSlicerStrategy = function() {
            function CheckBoxSlicerStrategy() {}
            return CheckBoxSlicerStrategy.prototype.canShowSearchHeader = function(_settings, hasSearchableData) {
                return !!hasSearchableData;
            }, CheckBoxSlicerStrategy.prototype.hasClearSearchButton = function() {
                return !1;
            }, CheckBoxSlicerStrategy.prototype.setLabelTextStyle = function(domHelper, slicerText, settings, _style, featureSwitches) {
                domHelper.setSlicerTextStyle(slicerText, settings, featureSwitches);
            }, CheckBoxSlicerStrategy.prototype.shouldShowSearchHeader = function(settings, hasSearchableData) {
                return this.strictSingleSelect = settings.selection.strictSingleSelect, settings.search.enabled && this.canShowSearchHeader(settings, hasSearchableData);
            }, CheckBoxSlicerStrategy.prototype.shouldShowCount = function() {
                return !0;
            }, CheckBoxSlicerStrategy.prototype.updateInputElement = function(inputElement, settings) {
                inputElement.selectAll("span").style("font-size", StandaloneUtility1.FP.fromPoint(settings.slicerText.textSize)).classed(this.strictSingleSelect ? "radiobutton" : "checkbox", !0).classed(this.strictSingleSelect ? "checkbox" : "radiobutton", !1);
            }, CheckBoxSlicerStrategy.prototype.customizeInputElement = function(inputElement, settings) {
                inputElement.append("span").style("font-size", StandaloneUtility1.FP.fromPoint(settings.slicerText.textSize)).classed("glyphicon", !0).classed(this.strictSingleSelect ? "radiobutton" : "checkbox", !0).classed(settings.items.accessibilityContrastProperties ? "checkboxOutlineContrast" : "checkboxOutline", !0);
            }, CheckBoxSlicerStrategy;
        }(), listElementFontFamily = fontUtils.Wn.regular.css, CheckListSlicerStrategy = function() {
            function CheckListSlicerStrategy() {}
            return CheckListSlicerStrategy.prototype.hasClearSearchButton = function() {
                return !0;
            }, CheckListSlicerStrategy.prototype.setLabelTextStyle = function(domHelper, slicerText, settings, style, featureSwitches) {
                var overridingSettings = (0, slicer_converter.VT)(style);
                overridingSettings.slicerText.textSize = StandaloneUtility1.FP.toPoint(13), overridingSettings.slicerText.fontFamily = listElementFontFamily, 
                overridingSettings.slicerText.color = common_colorHelper.v.getThemeColor(style, colorHelper.fA), 
                domHelper.setSlicerTextStyle(slicerText, overridingSettings, featureSwitches);
            }, CheckListSlicerStrategy.prototype.canShowSearchHeader = function(settings, hasSearchableData) {
                return settings.search.enabled || hasSearchableData;
            }, CheckListSlicerStrategy.prototype.shouldShowSearchHeader = function(settings, hasSearchableData) {
                return this.canShowSearchHeader(settings, hasSearchableData);
            }, CheckListSlicerStrategy.prototype.updateInputElement = function(inputElement) {}, 
            CheckListSlicerStrategy.prototype.shouldShowCount = function() {
                return !1;
            }, CheckListSlicerStrategy.prototype.customizeInputElement = function(inputElement) {
                inputElement.append("span").classed("powervisuals-glyph checkmark", !0);
            }, CheckListSlicerStrategy;
        }(), Container = (0, CssConstants.CH)("slicerContainer"), ItemContainer = (0, CssConstants.CH)("slicerItemContainer"), verticalSlicer_Input = (0, 
        CssConstants.CH)("slicerCheckbox"), ExpandButton = (0, CssConstants.CH)("expandButton"), Hidden = (0, 
        CssConstants.CH)("hidden"), CountText = (0, CssConstants.CH)("slicerCountText"), EmptyResult = (0, 
        CssConstants.CH)("slicerEmptyResult"), viewModelAdapterUtils = __webpack_require__(30053), Prototype = __webpack_require__(39681), HorizontalSlicerViewModelAdapter = function() {
            function HorizontalSlicerViewModelAdapter() {}
            return HorizontalSlicerViewModelAdapter.prototype.applyChanges = function(viewport, originalData, dataView) {
                var data = originalData;
                return viewModelAdapterUtils.a.shouldApplyResponsiveChanges(dataView, slicer_capabilities.gO) && (data = this.applyResponsiveSlicerChanges(viewport, data), 
                this.updateWarnings(data, originalData)), data;
            }, HorizontalSlicerViewModelAdapter.prototype.applyResponsiveSlicerChanges = function(viewport, originalData) {
                var slicerData = (0, Prototype.ED)(originalData);
                return this.applyFontSizeChanges(viewport, slicerData), slicerData;
            }, HorizontalSlicerViewModelAdapter.prototype.applyFontSizeChanges = function(viewport, data) {
                var maxFontSizePt = (0, slicerHelper.Cd)(viewport, slicerHelper.$O.horizontalSlicer.fontSize);
                data.slicerSettings.slicerText.textSize > maxFontSizePt && (data.slicerSettings = (0, 
                Prototype.ED)(data.slicerSettings), data.slicerSettings.slicerText = (0, Prototype.ED)(data.slicerSettings.slicerText), 
                data.slicerSettings.slicerText.textSize = maxFontSizePt);
            }, HorizontalSlicerViewModelAdapter.prototype.updateWarnings = function(data, originalData) {
                if (data.slicerSettings.slicerText.textSize !== originalData.slicerSettings.slicerText.textSize) {
                    var warning = new visualWarnings.Yx;
                    data.warnings.addForVisualObject("items", {
                        selector: null,
                        warnings: [ warning ]
                    });
                }
            }, HorizontalSlicerViewModelAdapter;
        }(), RangeSlicerViewModelAdapter = function() {
            function RangeSlicerViewModelAdapter() {}
            return RangeSlicerViewModelAdapter.prototype.applyChanges = function(viewport, data, dataView) {
                return viewModelAdapterUtils.a.shouldApplyResponsiveChanges(dataView, slicer_capabilities.gO) && (data = this.applyResponsiveRangeSlicerChanges(viewport, data)), 
                data;
            }, RangeSlicerViewModelAdapter.prototype.applyResponsiveRangeSlicerChanges = function(viewport, originalData) {
                var rangeSlicerData = (0, Prototype.ED)(originalData);
                return this.applyRangeSlicerDataChanges(rangeSlicerData), this.applySliderChanges(rangeSlicerData), 
                rangeSlicerData;
            }, RangeSlicerViewModelAdapter.prototype.applySliderChanges = function(rangeSlicerData) {
                rangeSlicerData.sliderSettings = (0, Prototype.ED)(rangeSlicerData.sliderSettings), 
                rangeSlicerData.sliderSettings.drawRoundSliderHandles = !0, rangeSlicerData.sliderSettings.minSliderVisibilityHeight = RangeSlicerViewModelAdapter.MinSliderVisibilityHeight, 
                rangeSlicerData.sliderSettings.minSliderVisibilityWidth = RangeSlicerViewModelAdapter.MinSliderVisibilityWidth;
            }, RangeSlicerViewModelAdapter.prototype.applyRangeSlicerDataChanges = function(rangeSlicerData) {
                rangeSlicerData.wrapRangeBoxes = !0;
            }, RangeSlicerViewModelAdapter.MinSliderVisibilityHeight = 35, RangeSlicerViewModelAdapter.MinSliderVisibilityWidth = 0, 
            RangeSlicerViewModelAdapter;
        }(), SlicerViewModelAdapter = function() {
            function SlicerViewModelAdapter() {}
            return SlicerViewModelAdapter.prototype.applySlicerChanges = function(viewport, slicerData, dataView) {
                return this.shouldApplyResponsiveChanges(dataView, slicerData.mode, slicerData.orientation) && (slicerData = this.applyResponsiveSlicerChanges(viewport, slicerData)), 
                slicerData;
            }, SlicerViewModelAdapter.prototype.applySlicerHeaderChanges = function(viewport, slicerHeaderData, dataView, slicerData, hasSlider) {
                return slicerHeaderData.show && this.shouldApplyResponsiveChanges(dataView, slicerData.mode, slicerData.orientation) && (slicerHeaderData = this.applyResponsiveSlicerHeaderChanges(viewport, slicerHeaderData, slicerData, hasSlider)), 
                slicerHeaderData;
            }, SlicerViewModelAdapter.prototype.enumerateObjectInstances = function(options, objects, dataView, activeMode, slicerOrientation) {
                this.doesSlicerModeSupportsResponsive(activeMode, slicerOrientation) && "general" === options.objectName && this.enumerateGeneral(dataView, objects);
            }, SlicerViewModelAdapter.prototype.enumerateGeneral = function(dataView, objects) {
                debug.fF.assert(function() {
                    return null === objects[0].selector;
                }, "objects[0].selector === null");
                var ResponsiveSlicerProperties = viewModelAdapterUtils.a.getResponsiveVisualProperties(dataView, slicer_capabilities.gO);
                _.merge(objects[0], {
                    selector: null,
                    properties: {
                        responsive: ResponsiveSlicerProperties.responsive
                    },
                    objectName: "general"
                });
            }, SlicerViewModelAdapter.prototype.getResponsiveSlice = function(dataView, activeMode, slicerOrientation, localize) {
                if (this.doesSlicerModeSupportsResponsive(activeMode, slicerOrientation)) {
                    var generalProps = slicer_capabilities.gO.general, responsiveSlicerProperties = viewModelAdapterUtils.a.getResponsiveVisualProperties(dataView, slicer_capabilities.gO);
                    return {
                        item: new build_control_util.vi({
                            uidBuilder: new build_control_util.IN(new build_control_util.SS(new build_control_util.lg("visualPlaceholderCard"), "visualPlaceholderGroup"), "responsive"),
                            control: new build_control_util.bd({
                                descriptor: generalProps.responsive,
                                value: responsiveSlicerProperties.responsive
                            }).build(),
                            localize
                        }).build(),
                        revertToDefaultDescriptors: [ generalProps.responsive ]
                    };
                }
            }, SlicerViewModelAdapter.prototype.shouldApplyResponsiveChanges = function(dataView, activeMode, orientation) {
                return this.doesSlicerModeSupportsResponsive(activeMode, orientation) && viewModelAdapterUtils.a.shouldApplyResponsiveChanges(dataView, slicer_capabilities.gO);
            }, SlicerViewModelAdapter.prototype.doesSlicerModeSupportsResponsive = function(activeMode, orientation) {
                return SlicerViewModelAdapter.isRangeSlicerMode(activeMode) || SlicerViewModelAdapter.isHorizontalSlicer(activeMode, orientation);
            }, SlicerViewModelAdapter.prototype.applyResponsiveSlicerChanges = function(viewport, originalSlicerData) {
                var slicerData = viewModelAdapterUtils.a.cloneData(originalSlicerData);
                return this.applyIconResponsiveChanges(viewport, slicerData), this.applyResponsiveSlicerHorizontalChanges(slicerData), 
                slicerData;
            }, SlicerViewModelAdapter.prototype.applyResponsiveSlicerHeaderChanges = function(viewport, originalSlicerHeaderData, slicerData, hasSlider) {
                var slicerHeaderData = viewModelAdapterUtils.a.cloneData(originalSlicerHeaderData);
                return this.applyHeaderChanges(viewport, slicerData, slicerHeaderData, hasSlider), 
                this.updateResponsiveHeaderWarnings(slicerHeaderData, originalSlicerHeaderData), 
                slicerHeaderData;
            }, SlicerViewModelAdapter.prototype.applyIconResponsiveChanges = function(viewport, slicerData) {
                var iconBreakpoints;
                SlicerViewModelAdapter.isRangeSlicerMode(slicerData.mode) ? iconBreakpoints = slicerHelper.$O.rangeSlicer.iconBreakpoints : SlicerViewModelAdapter.isHorizontalSlicer(slicerData.mode, slicerData.orientation) ? iconBreakpoints = slicerHelper.$O.horizontalSlicer.iconBreakpoints : debug.fF.assertFail("not supported slicer (mode: ".concat(slicerData.mode, ", orientation: ").concat(slicerData.orientation, ") should never arrive this function.")), 
                _.some(iconBreakpoints, function(breakpoint) {
                    return viewport.height <= breakpoint.height && viewport.width <= breakpoint.width;
                }) && (slicerData.showIcon = !0);
            }, SlicerViewModelAdapter.prototype.applyResponsiveSlicerHorizontalChanges = function(slicerData) {
                SlicerViewModelAdapter.isHorizontalSlicer(slicerData.mode, slicerData.orientation) && (slicerData.showTabularSlicer = !0);
            }, SlicerViewModelAdapter.prototype.applyHeaderChanges = function(viewport, slicerData, slicerHeaderData, hasSlider) {
                if (SlicerViewModelAdapter.isRangeSlicerMode(slicerData.mode)) {
                    var breakpoints = slicerHelper.$O.rangeSlicer;
                    slicerHeaderData.show = hasSlider ? viewport.height >= breakpoints.hideHeaderHeightSlider : viewport.height >= breakpoints.hideHeaderHeightNoSlider;
                } else SlicerViewModelAdapter.isHorizontalSlicer(slicerData.mode, slicerData.orientation) ? slicerHeaderData.show = viewport.height >= (breakpoints = slicerHelper.$O.horizontalSlicer).hideHeaderHeight : debug.fF.assertFail("not supported slicer (mode: ".concat(slicerData.mode, ", orientation: ").concat(slicerData.orientation, ") should never arrive this function."));
                var maxFontSizePt = (0, slicerHelper.Cd)(viewport, slicerHelper.$O.slicerHeader.fontSize);
                slicerHeaderData.textSize = Math.min(slicerHeaderData.textSize, maxFontSizePt);
            }, SlicerViewModelAdapter.prototype.updateResponsiveHeaderWarnings = function(headerData, originalHeaderData) {
                var warning;
                headerData.show !== originalHeaderData.show ? warning = new visualWarnings.C_ : headerData.textSize !== originalHeaderData.textSize && (warning = new visualWarnings.Fy), 
                warning && headerData.warnings.addForVisualObject("header", {
                    selector: null,
                    warnings: [ warning ]
                });
            }, SlicerViewModelAdapter.isRangeSlicerMode = function(mode) {
                return (0, slicerMode.l6)(mode);
            }, SlicerViewModelAdapter.isHorizontalSlicer = function(mode, orientation) {
                return mode === slicerMode.RB && orientation === slicerOrientation.i.Horizontal;
            }, SlicerViewModelAdapter;
        }(), slicer_ContainerClass = "slicer-container", ContentWrapperClass = "slicer-content-wrapper";
        function DefaultModes(moveSlicerTypeSelection) {
            return slicerMode.dt.members(moveSlicerTypeSelection ? [ slicerMode.Ih, slicerMode.of, slicerMode.j6 ] : [ slicerMode.RB, slicerMode.j6 ]);
        }
        var Slicer = function() {
            function Slicer(options) {
                this.areControlButtonsAlwaysVisible = !1, this.tooltip = null, this.enableInFocusRenderers = !1, 
                this.enableMultiElementRows = !1, this.preventVirtualKeyboardOnTheFirstTap = !1, 
                this.isInFocus = !1, this.hasSearchableData = !1, this.lockKeyboardNavigation = !0, 
                this.isSlicer = !1, this.hasUnappliedFilters = !1, options && (this.enableInFocusRenderers = options.enableInFocusRenderers, 
                this.enableMultiElementRows = options.enableMultiElementRows, this.preventVirtualKeyboardOnTheFirstTap = options.preventVirtualKeyboardOnTheFirstTap, 
                this.lockKeyboardNavigation = !1 !== options.lockKeyboardNavigation, this.featureSwitches = options.featureSwitches, 
                this.isSlicer = options.isSlicer), this.activeMode = slicerMode.RB, this.slicerOrientation = slicerOrientation.i.Vertical, 
                this.viewModelAdapter = new SlicerViewModelAdapter;
            }
            return Slicer.prototype.init = function(options) {
                var _this = this;
                this.initOptions = options, this.element = options.element, this.style = options.style, 
                this.visibilityHelper = (0, responsiveVisualUtil2.q)().visibilityHelper(this.element, "slicerResponsiveIcon"), 
                this.currentViewport = options.viewport, this.hostServices = options.host, this.loadMoreHandler = new loadMoreDataHandler.J(this.hostServices), 
                this.container = (0, DomFactory.hi)().addClass(slicer_ContainerClass).appendTo(this.element), 
                this.alert = (0, DomFactory.yP)().appendTo(this.container).attr("aria-live", "polite").attr("role", "status").hide(), 
                this.headerContainer = (0, DomFactory.hi)().appendTo(this.container).addClass("slicer-header-wrapper"), 
                this.slicerContainer = (0, DomFactory.hi)().appendTo(this.container).addClass(ContentWrapperClass), 
                this.initializeSlicerRenderer(), this.container.on(focusManager_helpers.BZ, function() {
                    _this.areControlButtonsAlwaysVisible = !0, _this.container.addClass("focused"), 
                    _this.alert.text(_this.activeMode);
                    var hasSlider = !!_this.slicerRenderer && _this.slicerRenderer.hasSlider();
                    _this.updateSlicerHeader(hasSlider);
                }), this.container.on("focusin", function() {
                    _this.container.addClass("focused");
                });
            }, Slicer.prototype.destroy = function() {
                this.slicerRenderer.onDestroy && this.slicerRenderer.onDestroy(), this.slicerHeader && this.slicerHeader.destroy();
            }, Slicer.prototype.update = function(options) {
                debug.fF.assertValue(options, "options"), this.isInFocus = !!options.isInFocus, 
                options.type & enums.EP.Resize && this.resizing(options.viewport), options.type & enums.EP.FilterOptionsChange && (this.hasUnappliedFilters = options.pendingChanges[0], 
                this.updateSlicerHeader(this.slicerRenderer.hasSlider())), (!options.type || options.type & enums.EP.Data) && (debug.fF.assertValue(options, "options"), 
                this.dataChanged(options.dataViews, options.operationKind));
            }, Slicer.prototype.dataChanged = function(dataViews, operationKind) {
                debug.fF.assertValue(dataViews, "dataViews"), _.isEmpty(dataViews) || (this.dataView = dataViews[0], 
                this.render(operationKind !== enums.su.Append, !0));
            }, Slicer.prototype.resizing = function(finalViewport) {
                this.currentViewport = finalViewport, this.render(!1);
            }, Slicer.prototype.enumerateObjectInstances = function(options) {
                if (this.dataView) switch (options.objectName) {
                  case "header":
                  case "modeSelection":
                    return this.slicerHeader.enumerateObjectInstances(options);

                  case "general":
                    var objects = this.slicerHeader.enumerateObjectInstances(options);
                    return this.slicerRenderer && this.slicerRenderer.supportsOrientation() && (objects[0].properties.orientation = this.data ? this.data.orientation : slicerOrientation.i.Vertical), 
                    this.viewModelAdapter && this.viewModelAdapter.enumerateObjectInstances(options, objects, this.dataView, this.activeMode, this.slicerOrientation), 
                    objects;

                  default:
                    return this.slicerRenderer.enumerateObjectInstances(options, this.featureSwitches);
                }
            }, Slicer.prototype.onDataViewObjectChanged = function(propertySaveObjects, sourceType) {
                if (this.featureSwitches.updateFormattingPaneObjects && this.featureSwitches.moveSlicerTypeSelection) {
                    var newPropertySaveObjects = this.slicerRenderer.onDataViewObjectChanged(propertySaveObjects, sourceType);
                    return debug.fF.assertNonEmpty(newPropertySaveObjects, "There should be at least one object property to save"), 
                    newPropertySaveObjects;
                }
                return propertySaveObjects;
            }, Slicer.prototype.getFormattingModel = function() {
                var _this = this;
                if (this.dataView) return new build_control_util.Nq(function() {
                    return _this.getSlicerSettingsCard();
                }, function() {
                    return _this.slicerHeader.getSlicerHeaderCard(_this.hostServices);
                }, function() {
                    return _this.slicerRenderer.getValuesCard(_this.featureSwitches);
                }, function() {
                    return _this.slicerRenderer.getAdditionalCards();
                }).build();
            }, Slicer.prototype.getSlicerSettingsCard = function() {
                var _this = this;
                if ((0, slicerMode.Ek)(this.activeMode) || this.featureSwitches.updateFormattingPaneObjects || this.featureSwitches.moveSlicerTypeSelection) {
                    var orientation, cardUidBuilder = new build_control_util.lg("slicerSettings");
                    this.slicerRenderer && this.slicerRenderer.supportsOrientation() && (orientation = this.data ? this.data.orientation : slicerOrientation.i.Vertical);
                    var slicerModes = this.data ? this.data.activeOptions : DefaultModes(this.featureSwitches.updateFormattingPaneObjects && this.featureSwitches.moveSlicerTypeSelection);
                    if (this.data.isCategorySourceNumeric) {
                        for (var numericSlicerTypes = [], _i = 0, _a = this.data.activeOptions; _i < _a.length; _i++) numericSlicerTypes.push(NumericSlicerOptions.members([ _a[_i].value ])[0]);
                        slicerModes = (0, tslib_es6.__spreadArray)([], numericSlicerTypes, !0);
                    }
                    var selectionGroups = this.slicerRenderer.getSlicerSettingsCardOptions(cardUidBuilder, orientation, this.activeMode, slicerModes, this.featureSwitches);
                    if (selectionGroups) {
                        var groups = selectionGroups.groups;
                        return new build_control_util.CQ(cardUidBuilder, "Slicer_Settings", selectionGroups.revertToDefaultDescriptors, function(key) {
                            return _this.hostServices.getLocalizedString(key);
                        }).withGroups(groups).build();
                    }
                }
            }, Slicer.prototype.resolveFormattingPlaceholder = function(placeholder) {
                if ((0, build_control_util.n$)(placeholder) && "responsive" === placeholder.name) return this.getResponsiveSlice();
            }, Slicer.prototype.getResponsiveSlice = function() {
                var _this = this;
                if (this.dataView && this.viewModelAdapter) return this.viewModelAdapter.getResponsiveSlice(this.dataView, this.activeMode, this.slicerOrientation, function(key) {
                    return _this.hostServices.getLocalizedString(key);
                });
            }, Slicer.prototype.loadMoreData = function() {
                return this.loadMoreHandler.updateDataView(this.dataView), this.loadMoreHandler.loadMoreData();
            }, Slicer.prototype.onClearSelection = function() {
                this.slicerRenderer && this.slicerRenderer.onClear && this.slicerRenderer.onClear();
            }, Slicer.converter = function(dataView, featureSwitches, listJoinSeparator) {
                if (dataView) {
                    var categorySourceName, moveSlicerTypeSelection = featureSwitches.updateFormattingPaneObjects && featureSwitches.moveSlicerTypeSelection, mode = null, orientation = slicerOrientation.i.Vertical, strictSingleSelect = !1, isCategorySourceNumeric = !1, activeOptions = DefaultModes(moveSlicerTypeSelection), switchMode = 1, hasSearchableData = !1;
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        orientation = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.general.orientation, orientation), 
                        strictSingleSelect = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.selection.strictSingleSelect, strictSingleSelect), 
                        mode = (0, dataViewObject2.NA)(objects, slicer_capabilities.gO.data.mode, mode);
                    }
                    if (dataView.metadata && dataView.metadata.columns) {
                        var columns = (0, slicerUtil1.zJ)(dataView.metadata.columns);
                        if (!_.isEmpty(columns)) {
                            var column = columns[0];
                            mode = (0, slicer_pluginMethods.D_)(columns, mode), categorySourceName = _.join(_.map(columns, function(cl) {
                                return cl.displayName;
                            }), listJoinSeparator), hasSearchableData = !_.some(columns, function(column) {
                                return !0 !== column.type.text;
                            }), 1 === columns.length ? (hasSearchableData = !0 === column.type.text, isCategorySourceNumeric = !0 === column.type.numeric, 
                            column.parameter && 1 === column.parameter.kind ? (activeOptions = _.union(DefaultModes(moveSlicerTypeSelection), slicerMode.dt.members([ mode ])), 
                            strictSingleSelect = strictSingleSelect || !column.parameter.supportsMultipleValues) : !0 === column.type.dateTime ? activeOptions = function(moveSlicerTypeSelection) {
                                return slicerMode.dt.members(moveSlicerTypeSelection ? [ slicerMode.Ih, slicerMode.of, slicerMode.j6, slicerMode.bb, slicerMode.e4, slicerMode.vX, slicerMode.K8, slicerMode.GV ] : [ slicerMode.RB, slicerMode.j6, slicerMode.bb, slicerMode.e4, slicerMode.vX, slicerMode.K8, slicerMode.GV ]);
                            }(moveSlicerTypeSelection) : isCategorySourceNumeric && (activeOptions = _.union(activeOptions, function(moveSlicerTypeSelection) {
                                return slicerMode.dt.members(moveSlicerTypeSelection ? [ slicerMode.Ih, slicerMode.of, slicerMode.j6, slicerMode.bb, slicerMode.e4, slicerMode.vX ] : [ slicerMode.RB, slicerMode.j6, slicerMode.bb, slicerMode.e4, slicerMode.vX ]);
                            }(moveSlicerTypeSelection)), column.parameter && (activeOptions = _.union(activeOptions, slicerMode.dt.members([ slicerMode.Zr ]))))) : (orientation = slicerOrientation.i.Vertical, 
                            moveSlicerTypeSelection && (activeOptions = slicerMode.dt.members([ slicerMode.Ih, slicerMode.j6 ]))), 
                            (0, slicerMode.Lw)(mode) && 1 === columns.length && (switchMode = column.aggregates && null != column.aggregates.min && null != column.aggregates.max ? switchMode : 2);
                        }
                    }
                    return {
                        orientation,
                        categorySourceName,
                        isCategorySourceNumeric,
                        mode: mode || slicerMode.RB,
                        switchMode,
                        hasSearchableData,
                        activeOptions,
                        showIcon: !1,
                        showTabularSlicer: !1,
                        warningObjectCollection: new visualWarnings.tb,
                        strictSingleSelect
                    };
                }
            }, Slicer.prototype.render = function(resetScrollbarPosition, stopWaitingForData) {
                this.updateViewport(), this.previousData = this.data, this.data = this.originalData = Slicer.converter(this.dataView, this.featureSwitches, this.hostServices.getLocalizedString("ListJoin_Separator")), 
                this.featureSwitches.updateFormattingPaneObjects && this.featureSwitches.moveSlicerTypeSelection && this.clearSelectionIfNeeded(), 
                this.viewModelAdapter && this.dataView && (this.data = this.viewModelAdapter.applySlicerChanges(this.currentViewport, this.originalData, this.dataView)), 
                this.data && (this.hasSearchableData = this.data.hasSearchableData), this.renderSlicer(resetScrollbarPosition, stopWaitingForData), 
                this.visibilityHelper.updateVisibility(this.data && this.data.showIcon ? {
                    showIcon: !0,
                    viewport: this.currentViewport
                } : {
                    showIcon: !1
                });
            }, Slicer.prototype.renderSlicer = function(resetScrollbarPosition, stopWaitingForData) {
                this.updateSlicerRendererIfNeeded(), this.updateSlicerHeader(this.slicerRenderer.hasSlider()), 
                this.slicerRenderer.render({
                    dataView: this.dataView,
                    viewport: this.currentViewport,
                    resetScrollbarPosition,
                    hasSearchableData: this.hasSearchableData,
                    restatement: this.data && this.data.categorySourceName,
                    isSlicer: this.isSlicer,
                    isSearchMode: !!this.selectionHandler && this.selectionHandler.isSearchMode()
                });
                var supportsRestatement = null != this.slicerRenderer.getRestatement;
                this.slicerHeader && this.slicerHeader.setFilterRestatement(supportsRestatement ? this.slicerRenderer.getRestatement() : void 0, supportsRestatement), 
                stopWaitingForData && this.loadMoreHandler.onLoadMoreDataCompleted(), this.updateWarnings();
            }, Slicer.prototype.updateSlicerRendererIfNeeded = function() {
                if (this.enableInFocusRenderers && this.container.hasClass("full-screen") !== this.isInFocus) return this.isInFocus ? this.container.addClass("full-screen") : this.container.removeClass("full-screen"), 
                void this.initializeSlicerRenderer();
                if (this.data) {
                    var newMode = this.data.mode || slicerMode.RB;
                    this.activeMode !== newMode || (0, slicerMode.l6)(this.activeMode) && this.previousData && this.previousData.isCategorySourceNumeric !== this.data.isCategorySourceNumeric ? (this.activeMode = newMode, 
                    this.initializeSlicerRenderer()) : (this.slicerOrientation !== (this.data.orientation || slicerOrientation.i.Vertical) || this.previousData && this.previousData.showTabularSlicer !== this.data.showTabularSlicer) && this.initializeSlicerRenderer();
                }
            }, Slicer.prototype.clearSelectionIfNeeded = function() {
                if (this.previousData && this.data) {
                    var newMode = this.data.mode || slicerMode.RB;
                    if (this.previousData.mode !== newMode || (0, slicerMode.l6)(newMode) && this.previousData && this.previousData.isCategorySourceNumeric !== this.data.isCategorySourceNumeric) {
                        this.hostServices.onSelect({
                            type: 0,
                            visualObjects: []
                        });
                        var message = this.hostServices.getLocalizedString("Slicer_ClearSelectionsCleared");
                        this.hostServices.alertWithDebounce("announce-clear-selection", message);
                    }
                }
            }, Slicer.prototype.updateViewport = function() {
                this.container.css({
                    height: this.currentViewport.height
                });
            }, Slicer.prototype.updateSlicerHeader = function(hasSlider) {
                var _this = this;
                if (this.dataView) {
                    var reader = (0, dataViewCategoricalReader.y)(this.dataView);
                    if (!this.slicerHeader) {
                        var settings = {
                            onClear: function() {
                                _this.slicerRenderer && _this.slicerRenderer.onClear(!0);
                            },
                            onChange: function(mode) {
                                !_this.slicerRenderer || _this.featureSwitches.updateFormattingPaneObjects || _this.featureSwitches.moveSlicerTypeSelection || _this.slicerRenderer.onModeChange(mode);
                            },
                            host: this.headerContainer,
                            visibilityState: this.data.switchMode,
                            selectedValue: this.activeMode,
                            hoverContainer: this.element,
                            enableInFocusRenderers: this.enableInFocusRenderers,
                            slicerModeOptions: this.slicerActiveOptions()
                        }, services = {
                            localize: this.hostServices.getLocalizedString.bind(this.hostServices),
                            getViewMode: this.hostServices.getViewMode.bind(this.hostServices),
                            applySlicerHeaderChanges: function(visualSlicerHeaderData) {
                                var result = visualSlicerHeaderData;
                                return _this.viewModelAdapter && _this.dataView && _this.data && (result = _this.viewModelAdapter.applySlicerHeaderChanges(_this.currentViewport, visualSlicerHeaderData, _this.dataView, _this.data, hasSlider)), 
                                result;
                            },
                            onRenderTooltip: function(element, text) {
                                return _this.getTooltipComponent(element, text);
                            }
                        };
                        this.slicerHeader = new SlicerHeader(settings, services, this.style, this.featureSwitches);
                    }
                    this.slicerHeader.update(reader, {
                        text: this.data.categorySourceName,
                        restatement: this.slicerRenderer.getRestatement ? this.slicerRenderer.getRestatement() : void 0,
                        selectedValue: this.activeMode,
                        visibilityState: this.data.switchMode,
                        isInFocus: this.isInFocus,
                        slicerModeOptions: this.slicerActiveOptions(),
                        areControlButtonsAlwaysVisible: this.areControlButtonsAlwaysVisible,
                        strictSingleSelect: this.data.strictSingleSelect,
                        hasUnappliedFilters: this.hasUnappliedFilters
                    });
                }
            }, Slicer.prototype.getTooltipComponent = function(elemet, text) {
                var _a;
                return null !== this.tooltip && this.tooltip.close(), this.tooltip = null === (_a = this.hostServices.getUIComponentFactory()) || void 0 === _a ? void 0 : _a.createTooltip(elemet, text), 
                this.tooltip;
            }, Slicer.prototype.slicerActiveOptions = function() {
                if (this.data.isCategorySourceNumeric) {
                    for (var activeOptions = [], _i = 0, _a = this.data.activeOptions; _i < _a.length; _i++) activeOptions.push(NumericSlicerOptions.members([ _a[_i].value ])[0]);
                    return activeOptions;
                }
                return this.data.activeOptions;
            }, Slicer.prototype.initializeSlicerRenderer = function() {
                switch (this.slicerRenderer && this.slicerRenderer.onDestroy && this.slicerRenderer.onDestroy(), 
                this.slicerOrientation = this.data && this.data.orientation || slicerOrientation.i.Vertical, 
                this.slicerContainer.empty(), this.activeMode) {
                  case slicerMode.RB:
                    return void this.initializeBasicSlicer();

                  case slicerMode.j6:
                    return void this.initializeDropdownSlicer();

                  case slicerMode.K8:
                    return void this.initializeRelativeSlicer(relativeDateRange.wj.Date);

                  case slicerMode.GV:
                    return void this.initializeRelativeSlicer(relativeDateRange.wj.Time);

                  case slicerMode.vX:
                  case slicerMode.bb:
                  case slicerMode.e4:
                    return void this.initializeRangeSlicer(!1);

                  case slicerMode.Zr:
                    return void this.initializeRangeSlicer(!0);

                  default:
                    return debug.fF.assertFail("initializeSlicerRenderer - Unexpected activeMode: " + this.activeMode), 
                    void this.initializeVerticalSlicer();
                }
            }, Slicer.prototype.initializeBasicSlicer = function() {
                if (this.enableInFocusRenderers && this.isInFocus) this.initializeInFocusVerticalSlicer(); else switch (this.slicerOrientation) {
                  case slicerOrientation.i.Horizontal:
                    this.initializeHorizontalOrTabularSlicer();
                    break;

                  case slicerOrientation.i.Vertical:
                    this.initializeVerticalSlicer();
                }
            }, Slicer.prototype.initializeInFocusVerticalSlicer = function() {
                this.hostServices.setShouldDeferData(!1);
                var verticalSlicerRenderer = this.slicerRenderer = new VerticalSlicerRenderer(new CheckListSlicerStrategy, {
                    hostServices: this.hostServices,
                    featureSwitches: this.featureSwitches
                }, this.lockKeyboardNavigation), options = this.createInitOptions();
                this.selectionHandler = verticalSlicerRenderer.init(options, this.slicerContainer);
            }, Slicer.prototype.initializeVerticalSlicer = function() {
                var verticalSlicerRenderer = this.slicerRenderer = new VerticalSlicerRenderer(new CheckBoxSlicerStrategy, {
                    hostServices: this.hostServices,
                    featureSwitches: this.featureSwitches
                }, this.lockKeyboardNavigation), options = this.createInitOptions();
                this.selectionHandler = verticalSlicerRenderer.init(options, this.slicerContainer);
            }, Slicer.prototype.initializeRangeSlicer = function(singleValue) {
                if (this.data.isCategorySourceNumeric) {
                    var rendererViewModelAdapter = new RangeSlicerViewModelAdapter, rangeSlicerRenderer = new NumericSlicer({
                        hostServices: this.hostServices
                    });
                    this.slicerRenderer = new RangeSlicer({
                        hostServices: this.hostServices,
                        featureSwitches: this.featureSwitches
                    }, rangeSlicerRenderer, singleValue, this.data.isCategorySourceNumeric, rendererViewModelAdapter);
                } else rendererViewModelAdapter = new RangeSlicerViewModelAdapter, rangeSlicerRenderer = new DateSlicer({
                    preventVirtualKeyboardOnTheFirstTap: this.preventVirtualKeyboardOnTheFirstTap,
                    hostServices: this.hostServices,
                    featureSwitches: this.featureSwitches
                }), this.slicerRenderer = new RangeSlicer({
                    preventTextSelection: this.preventVirtualKeyboardOnTheFirstTap,
                    hostServices: this.hostServices,
                    featureSwitches: this.featureSwitches
                }, rangeSlicerRenderer, singleValue, this.data.isCategorySourceNumeric, rendererViewModelAdapter);
                var options = this.createInitOptions();
                this.selectionHandler = this.slicerRenderer.init(options, this.slicerContainer);
            }, Slicer.prototype.initializeHorizontalOrTabularSlicer = function() {
                var slicerLayout;
                slicerLayout = this.data && this.data.showTabularSlicer ? new TabularSlicerLayout : new HorizontalSlicerLayout;
                var rendererViewModelAdapter = new HorizontalSlicerViewModelAdapter, slicerRenderer = this.slicerRenderer = new HorizontalSlicerRenderer({
                    hostServices: this.hostServices,
                    horizontalSlicerLayout: slicerLayout,
                    featureSwitches: this.featureSwitches
                }, rendererViewModelAdapter), options = this.createInitOptions();
                this.selectionHandler = slicerRenderer.init(options, this.slicerContainer);
            }, Slicer.prototype.initializeRelativeSlicer = function(relativeFilterType) {
                var relativeSlicerRenderer = this.slicerRenderer = function(relativeFilterType, slicerOptions) {
                    switch (relativeFilterType) {
                      case relativeDateRange.wj.Time:
                        return new RelativeSlicer(slicerOptions, relativeDateRange.wj.Time);

                      case relativeDateRange.wj.Date:
                        return new RelativeSlicer(slicerOptions, relativeDateRange.wj.Date);

                      default:
                        return void debug.fF.assertFail("Unsupported RelativeFilterType");
                    }
                }(relativeFilterType, {
                    hostServices: this.hostServices
                }), options = this.createInitOptions();
                this.selectionHandler = relativeSlicerRenderer.init(options, this.slicerContainer);
            }, Slicer.prototype.initializeDropdownSlicer = function() {
                if (this.enableInFocusRenderers && this.isInFocus) this.initializeInFocusVerticalSlicer(); else {
                    var slicerOptions = {
                        hostServices: this.hostServices,
                        featureSwitches: this.featureSwitches
                    }, verticalSlicerRenderer = new VerticalSlicerRenderer(new CheckBoxSlicerStrategy, slicerOptions);
                    this.slicerRenderer = new DropdownSlicerRenderer(verticalSlicerRenderer, slicerOptions);
                    var options = this.createInitOptions();
                    this.selectionHandler = this.slicerRenderer.init(options, this.slicerContainer);
                }
            }, Slicer.prototype.createInitOptions = function() {
                var _this = this;
                return {
                    visualInitOptions: this.initOptions,
                    loadMoreData: function() {
                        return _this.loadMoreData();
                    },
                    enableMultiElementRows: this.enableMultiElementRows
                };
            }, Slicer.prototype.updateWarnings = function() {
                this.data && (this.slicerHeader.addWarnings(this.data.warningObjectCollection), 
                this.slicerRenderer.addWarnings && this.slicerRenderer.addWarnings(this.data.warningObjectCollection), 
                this.hostServices.setWarnings(this.data.warningObjectCollection.complete()));
            }, Slicer;
        }();
    },
    62224: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            wV: function() {
                return SlicerWebBehavior;
            }
        });
        var _Visuals_capabilities_slicer_capabilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9434), _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90120), _Visuals_types_slicerOrientation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3212), _VisualsCommon_DOMConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(65195), _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(59107), _VisualsCommon_Utility_keyUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9795), _slicerUtil1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68447), SlicerWebBehavior = function() {
            function SlicerWebBehavior() {}
            return SlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.behavior = this.createWebBehavior(options), this.behavior.bindEvents(options.behaviorOptions, selectionHandler);
            }, SlicerWebBehavior.prototype.renderSelection = function() {
                this.behavior && this.behavior.renderSelection();
            }, SlicerWebBehavior.bindSlicerEvents = function(behaviorOptions, slicers, selectionHandler, slicerSettings) {
                SlicerWebBehavior.bindSlicerItemSelectionEvent(slicers, selectionHandler, slicerSettings), 
                behaviorOptions.searchInput && SlicerWebBehavior.bindSlicerSearchEvent(behaviorOptions.searchInput, behaviorOptions.clearSearchTextButton, selectionHandler);
            }, SlicerWebBehavior.setSelectionOnSlicerItems = function(selectableItems, selectionHandler, style) {
                var isSelectionInverted = selectionHandler.isSelectionModeInverted(), hasSelection = selectionHandler.hasSelection();
                selectableItems.each(function(d, i) {
                    var partially = !!d.partially || d.isSelectAllDataPoint && hasSelection, shouldCheck = !hasSelection && isSelectionInverted || hasSelection && !partially && (0, 
                    _slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.OO)(d, isSelectionInverted);
                    if ($(this).toggleClass("selected", shouldCheck), $(this).toggleClass("partiallySelected", !!partially), 
                    style.isHighContrast) {
                        var span = this.getElementsByTagName("span")[0];
                        if (shouldCheck) {
                            var selectedColor = _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_1__.v.getThemeColor(style, "foregroundSelected");
                            span && (span.style.backgroundColor = selectedColor, span.style.borderColor = selectedColor);
                        } else {
                            var borderColor = _Visuals_common_colorHelper__WEBPACK_IMPORTED_MODULE_1__.v.getThemeColor(style, "foreground");
                            span && (span.style.backgroundColor = "", span.style.borderColor = borderColor, 
                            span.style.boxShadow = "none");
                        }
                    }
                    var input = this.getElementsByTagName("input")[0];
                    input && (input.checked = shouldCheck);
                });
            }, SlicerWebBehavior.bindSlicerItemSelectionEvent = function(slicers, selectionHandler, slicerSettings) {
                var _this = this;
                slicers.on("keydown", function(d) {
                    var event = d3.event, keyCode = event.keyCode;
                    32 !== keyCode && 13 !== keyCode || (32 === keyCode && event.preventDefault(), _this.toggleItemSelection(d, selectionHandler, slicerSettings));
                }).on("click", function(d) {
                    $(d3.event.target).trigger("slicer.dataPointSelected"), _this.toggleItemSelection(d, selectionHandler, slicerSettings);
                });
            }, SlicerWebBehavior.toggleItemSelection = function(d, selectionHandler, slicerSettings, event) {
                if (!d.disabled) {
                    var d3Event = event || d3.event;
                    if (d.isSelectAllDataPoint) selectionHandler.toggleSelectionModeInversion(), selectionHandler.persistSelectionFilter(_Visuals_capabilities_slicer_capabilities__WEBPACK_IMPORTED_MODULE_2__.gO.general.filter); else {
                        var selectMode = SlicerWebBehavior.isMultiSelect(d, d3Event, slicerSettings, selectionHandler) ? 3 : 0;
                        selectionHandler.handleSelection(d, selectMode, {
                            x: d3Event.clientX,
                            y: d3Event.clientY
                        }) && selectionHandler.persistSelectionFilter(_Visuals_capabilities_slicer_capabilities__WEBPACK_IMPORTED_MODULE_2__.gO.general.filter);
                    }
                }
            }, SlicerWebBehavior.toggleItemSelectionFromExternal = function(event, d, selectionHandler, slicerSettings) {
                this.toggleItemSelection(d, selectionHandler, slicerSettings, event);
            }, SlicerWebBehavior.bindSlicerSearchEvent = function(slicerSearch, clearSearchTextButton, selectionHandler) {
                var _this = this;
                slicerSearch.empty() || (slicerSearch.on(_VisualsCommon_DOMConstants__WEBPACK_IMPORTED_MODULE_3__.n, function() {
                    var d3Event = d3.event;
                    _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_4__.M.isCtrlOrMeta(d3Event) && (0, 
                    _VisualsCommon_Utility_keyUtils__WEBPACK_IMPORTED_MODULE_5__.iZ)(d3Event.keyCode) || (0, 
                    _VisualsCommon_Utility_keyUtils__WEBPACK_IMPORTED_MODULE_5__.Wl)(d3Event.keyCode) || (0, 
                    _VisualsCommon_Utility_keyUtils__WEBPACK_IMPORTED_MODULE_5__.rH)(d3Event.keyCode) ? d3Event.stopPropagation() : 27 === d3Event.keyCode ? (_this.clearSearch(selectionHandler, slicerSearch), 
                    d3Event.preventDefault()) : 13 === d3Event.keyCode && (SlicerWebBehavior.startSearch(slicerSearch, selectionHandler), 
                    d3Event.stopPropagation());
                }).on(_VisualsCommon_DOMConstants__WEBPACK_IMPORTED_MODULE_3__.cp, function() {
                    var d3Event = d3.event;
                    _.debounce(function() {
                        9 !== d3Event.keyCode && 16 !== d3Event.keyCode && SlicerWebBehavior.startSearch(slicerSearch, selectionHandler);
                    }, SlicerWebBehavior.searchInputTimeoutDuration)();
                }), clearSearchTextButton && !clearSearchTextButton.empty() && clearSearchTextButton.on(_VisualsCommon_DOMConstants__WEBPACK_IMPORTED_MODULE_3__.G6, function() {
                    _this.clearSearch(selectionHandler, slicerSearch), d3.event.stopPropagation();
                }));
            }, SlicerWebBehavior.clearSearch = function(selectionHandler, slicerSearch) {
                selectionHandler.setSearchMode(!0), selectionHandler.persistSelfFilter(_Visuals_capabilities_slicer_capabilities__WEBPACK_IMPORTED_MODULE_2__.gO.general.selfFilter, null), 
                slicerSearch.property("value", "");
                var headerContainer = d3.select(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.s8.selector);
                (new _slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.gy).configureSearchBoxIcon(headerContainer, void 0);
            }, SlicerWebBehavior.startSearch = function(slicerSearch, selectionHandler) {
                var element = slicerSearch.node(), searchKey = element && element.value;
                selectionHandler.setSearchMode(!0), selectionHandler.persistSelfFilter(_Visuals_capabilities_slicer_capabilities__WEBPACK_IMPORTED_MODULE_2__.gO.general.selfFilter, searchKey);
            }, SlicerWebBehavior.isMultiSelect = function(d, event, settings, selectionHandler) {
                return !settings.selection.strictSingleSelect && !selectionHandler.isDisableMultipleSelectForMappedColumn() && (selectionHandler.isSelectionModeInverted() || !settings.selection.singleSelect || _VisualsCommon_Utility_browserUtils__WEBPACK_IMPORTED_MODULE_4__.M.isCtrlOrMeta(event) || 1 === selectionHandler.getDataMultiSelectMode() || SlicerWebBehavior.hasParentSelected(d));
            }, SlicerWebBehavior.hasParentSelected = function(d) {
                for (;d.parent; ) {
                    if (d.parent.selected) return !0;
                    d = d.parent;
                }
            }, SlicerWebBehavior.prototype.createWebBehavior = function(options) {
                return options.orientation === _Visuals_types_slicerOrientation__WEBPACK_IMPORTED_MODULE_6__.i.Horizontal ? new HorizontalSlicerWebBehavior : new VerticalSlicerWebBehavior;
            }, SlicerWebBehavior.searchInputTimeoutDuration = 500, SlicerWebBehavior;
        }(), HorizontalSlicerWebBehavior = function() {
            function HorizontalSlicerWebBehavior() {}
            return HorizontalSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.selectionHandler = selectionHandler, this.slicerSettings = options.settings, 
                this.style = options.style, this.items = options.itemsContainer, SlicerWebBehavior.bindSlicerEvents(options, this.items, selectionHandler, this.slicerSettings);
            }, HorizontalSlicerWebBehavior.prototype.renderSelection = function() {
                SlicerWebBehavior.setSelectionOnSlicerItems(this.items, this.selectionHandler, this.style);
            }, HorizontalSlicerWebBehavior;
        }(), VerticalSlicerWebBehavior = function() {
            function VerticalSlicerWebBehavior() {}
            return VerticalSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                this.itemContainers = options.itemContainers, this.itemInputs = options.itemInputs, 
                this.selectionHandler = selectionHandler, this.settings = options.settings, this.style = options.style, 
                SlicerWebBehavior.bindSlicerEvents(options, this.itemContainers, selectionHandler, this.settings);
            }, VerticalSlicerWebBehavior.prototype.renderSelection = function() {
                SlicerWebBehavior.setSelectionOnSlicerItems(this.itemInputs, this.selectionHandler, this.style);
            }, VerticalSlicerWebBehavior;
        }();
    },
    82085: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            v: function() {
                return SlicerSearchInput;
            }
        });
        var _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64329), _slicerUtil1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68447), SlicerSearchInput = function() {
            function SlicerSearchInput(hostServices) {
                this.hostServices = hostServices, this.domHelper = new _slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.gy;
            }
            return SlicerSearchInput.fromSlicerSettings = function(settings, searchKey, isVisible, hasClearSearchButton, featureSwitches) {
                var _a, _b, _c, _d, _e, _f;
                if (settings) return {
                    isVisible,
                    hasClearSearchButton,
                    searchKey,
                    style: {
                        borderStyle: null === (_a = settings.search) || void 0 === _a ? void 0 : _a.outlineStyle,
                        borderColor: null === (_b = settings.search) || void 0 === _b ? void 0 : _b.borderColor,
                        background: null === (_c = settings.search) || void 0 === _c ? void 0 : _c.background,
                        color: null === (_d = settings.slicerText) || void 0 === _d ? void 0 : _d.color,
                        textSize: null === (_e = settings.slicerText) || void 0 === _e ? void 0 : _e.textSize,
                        fontFamily: null === (_f = settings.slicerText) || void 0 === _f ? void 0 : _f.fontFamily
                    }
                };
            }, SlicerSearchInput.prototype.create = function(container) {
                this.container = this.domHelper.addSearch(this.hostServices, container), this.input = this.container.select(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.Mj.selector);
            }, SlicerSearchInput.prototype.addClearButton = function() {
                this.clear = this.domHelper.addClearSearchButton(this.hostServices, this.container);
            }, SlicerSearchInput.prototype.clearSearchText = function() {
                this.container.select(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.Mj.selector).property("value", "");
            }, SlicerSearchInput.prototype.getHeight = function(scale) {
                var element = this.container.node();
                return $(element).outerHeight(!0);
            }, SlicerSearchInput.prototype.update = function(settings) {
                if (!settings || !settings.isVisible) return this.container.classed(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.pD.class, !1), 
                void this.container.classed(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.AM.class, !0);
                void 0 !== settings.bottomMargin && this.container.style("margin-bottom", settings.bottomMargin + "px");
                var wasShowingSearchHeader = this.container.classed(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.pD.class);
                this.container.classed(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.pD.class, settings.isVisible), 
                this.container.classed(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.AM.class, !settings.isVisible);
                var style = settings.style, searchInput = this.container.select(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.Mj.selector), searchIcon = this.container.select(_slicerUtil1__WEBPACK_IMPORTED_MODULE_0__.uN.selector);
                if (searchInput.empty()) settings.hasClearSearchButton && this.domHelper.configureSearchBoxIcon(this.container, void 0); else {
                    var element = searchInput.node(), existingSearchKey = element && element.value;
                    settings.hasClearSearchButton && this.domHelper.configureSearchBoxIcon(this.container, existingSearchKey), 
                    (_.isEmpty(existingSearchKey) || _.isEmpty(settings.searchKey) && settings.isVisible !== wasShowingSearchHeader) && searchInput.property("value", settings.searchKey);
                    var fontHeight = Math.ceil(_VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__.FP.fromPointToPixel(style.textSize));
                    this.height = fontHeight, this.container.styles({
                        color: style.color,
                        "border-style": style.borderStyle,
                        "border-color": style.borderColor,
                        background: style.background,
                        height: fontHeight + "px"
                    }), searchInput.styles({
                        background: style.background,
                        color: style.color,
                        "font-size": _VisualsCommon_Utility_StandaloneUtility1__WEBPACK_IMPORTED_MODULE_1__.FP.fromPoint(style.textSize),
                        "font-family": style.fontFamily
                    }), searchIcon.styles({
                        color: style.color
                    });
                }
            }, SlicerSearchInput;
        }();
    },
    60810: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            G: function() {
                return LoadMoreDataStatus;
            },
            J: function() {
                return SimpleLoadMoreDataHandler;
            }
        });
        var LoadMoreDataStatus = function(LoadMoreDataStatus) {
            return LoadMoreDataStatus[LoadMoreDataStatus.NoOperation = 0] = "NoOperation", LoadMoreDataStatus[LoadMoreDataStatus.WaitingForData = 1] = "WaitingForData", 
            LoadMoreDataStatus[LoadMoreDataStatus.TriggeredLoadMore = 2] = "TriggeredLoadMore", 
            LoadMoreDataStatus;
        }({}), SimpleLoadMoreDataHandler = function() {
            function SimpleLoadMoreDataHandler(hostServices) {
                this.hostServices = hostServices, this.waitingForData = !1;
            }
            return SimpleLoadMoreDataHandler.prototype.shouldLoadMoreData = function() {
                return this.shouldLoadMoreDataInternal() === LoadMoreDataStatus.TriggeredLoadMore;
            }, SimpleLoadMoreDataHandler.prototype.isLoadingMoreData = function() {
                return this.waitingForData;
            }, SimpleLoadMoreDataHandler.prototype.updateDataView = function(dataView) {
                this.dataView = dataView;
            }, SimpleLoadMoreDataHandler.prototype.loadMoreData = function() {
                var status = this.shouldLoadMoreDataInternal();
                return status === LoadMoreDataStatus.TriggeredLoadMore && (this.hostServices.loadMoreData(), 
                this.waitingForData = !0), status;
            }, SimpleLoadMoreDataHandler.prototype.onLoadMoreDataCompleted = function() {
                this.waitingForData = !1;
            }, SimpleLoadMoreDataHandler.prototype.shouldLoadMoreDataInternal = function() {
                if (!this.dataView) return LoadMoreDataStatus.NoOperation;
                var dataViewMetadata = this.dataView.metadata;
                return this.waitingForData ? LoadMoreDataStatus.WaitingForData : dataViewMetadata && dataViewMetadata.segment ? LoadMoreDataStatus.TriggeredLoadMore : LoadMoreDataStatus.NoOperation;
            }, SimpleLoadMoreDataHandler;
        }();
    }
} ]);