"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "accessibleTable" ], {
    35572: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            AccessibleTable: function() {
                return AccessibleTable;
            }
        });
        var Utility = __webpack_require__(38078), valueFormatter = __webpack_require__(72489);
        function parseHierarchy(matrix, hostServices, columnLeavesCount) {
            var root, levels, hierarchy = {
                root: null,
                leaves: []
            };
            if (null != columnLeavesCount ? (root = matrix.rows.root, levels = matrix.rows.levels) : (root = matrix.columns.root, 
            levels = matrix.columns.levels), root && root.children) {
                var header = {
                    index: 0,
                    indexInSiblings: 0,
                    parent: null,
                    span: 0,
                    levelsSpan: 1,
                    id: null == columnLeavesCount ? "c" : "r",
                    text: "",
                    level: -1,
                    children: void 0
                };
                return parseNode(root, header, hierarchy.leaves, levels, hostServices, matrix.valueSources, columnLeavesCount), 
                hierarchy.root = header, hierarchy;
            }
        }
        function parseNode(node, header, leafHeaders, hierarchyLevels, hostServices, columns, columnLeavesCount) {
            hierarchyLevels[node.level] ? header.text = function(node, level, hostServices) {
                var buffer = [], source = level.sources[node.levelSourceIndex || 0];
                if (node.isSubtotal && !source.isMeasure) return hostServices.getLocalizedString("TableTotalLabel");
                if (node.levelValues) for (var _i = 0, _a = node.levelValues; _i < _a.length; _i++) {
                    var levelValue = _a[_i];
                    buffer.push(levelValue.value ? levelValue.value.toString() : hostServices.getLocalizedString("NullValue"));
                } else buffer.push(source.displayName);
                return buffer.join(", ");
            }(node, hierarchyLevels[node.level], hostServices) : node.level > -1 && (header.id = null);
            var maxLevel = hierarchyLevels.length - 1, lastSibling = null, children = node.children;
            if (_.isEmpty(children)) {
                if (node.level < maxLevel && (header.levelsSpan = maxLevel - node.level + 1), header.span = 1, 
                leafHeaders.push(header), node.values && null != columnLeavesCount) for (header.values = [], 
                i = 0; i < columnLeavesCount; i++) {
                    var value = node.values[i];
                    header.values.push(value && null != value.value ? (0, valueFormatter.WU)(value.value, columns[value.valueSourceIndex || 0].format) : "&nbsp;");
                }
            } else {
                header.levelsSpan = _.head(children).level - node.level, header.children = [];
                for (var i = 0, len = children.length; i < len; i++) {
                    var childNode = children[i], childHeader = {
                        index: 0,
                        span: 0,
                        levelsSpan: 1,
                        text: "",
                        id: header.id + "-" + i,
                        level: childNode.level,
                        children: void 0,
                        parent: header,
                        indexInSiblings: i
                    };
                    childHeader.index = lastSibling ? lastSibling.index + lastSibling.span : header.index, 
                    lastSibling = childHeader, parseNode(childNode, childHeader, leafHeaders, hierarchyLevels, hostServices, columns, columnLeavesCount), 
                    header.span += childHeader.span, header.children.push(childHeader);
                }
            }
        }
        var AccessibleTableRenderer = function() {
            function AccessibleTableRenderer(element, hostServices) {
                this.element = element, this.hostServices = hostServices;
            }
            return AccessibleTableRenderer.prototype.render = function(matrix, viewport) {
                var vm = function(matrix, hostServices) {
                    var columns = parseHierarchy(matrix, hostServices);
                    return {
                        columns,
                        rows: parseHierarchy(matrix, hostServices, columns.root.span)
                    };
                }(matrix, this.hostServices), buffer = [];
                buffer.push('<div class="accessibleTable-container" style="width: '.concat(viewport.width, "px; height: ").concat(viewport.height, 'px">')), 
                buffer.push('<table class="accessibleTable" tabindex="0">'), buffer.push(this.renderColumnHeaders(matrix, vm)), 
                buffer.push(this.renderRowHeaders(vm)), buffer.push("</table>"), buffer.push("</div>"), 
                this.element.innerHTML = buffer.join("");
                var table = $(this.element).find("table");
                this.hostServices.requestFocus(table[0]);
            }, AccessibleTableRenderer.prototype.clear = function() {
                this.element.innerHTML = "";
            }, AccessibleTableRenderer.prototype.renderColumnHeaders = function(matrix, vm) {
                for (var buffers = [], rowLevelsCount = matrix.rows.levels.length, columnLevelsCount = matrix.columns.levels.length, level = 0; level < columnLevelsCount; level++) if ((buffer = buffers[level] = []).push("<tr>"), 
                0 === rowLevelsCount) buffer.push('<td class="'.concat("colHeader", '">&nbsp;</td>')); else if (level < columnLevelsCount - 1) {
                    for (var i = 0; i < rowLevelsCount - 1; i++) buffer.push('<td class="'.concat("colHeader", '">&nbsp;</td>'));
                    buffer.push('<th class="'.concat("colHeader", ' rowLeaf">')), buffer.push(AccessibleTableRenderer.getHierachyLevelDisplayName(matrix.columns.levels[level])), 
                    buffer.push("</th>");
                } else for (var rowLevelIndex = 0; rowLevelIndex < rowLevelsCount; rowLevelIndex++) buffer.push('<th class="'.concat("colHeader", " columnLeaf")), 
                rowLevelIndex === rowLevelsCount - 1 && buffer.push(" rowLeaf"), buffer.push('">'), 
                buffer.push(AccessibleTableRenderer.getHierachyLevelDisplayName(matrix.rows.levels[rowLevelIndex])), 
                buffer.push("</th>");
                var columnHeaders = vm.columns.root.children;
                if (columnHeaders && columnHeaders.length > 0) {
                    i = 0;
                    for (var len = columnHeaders.length; i < len; i++) this.renderColumnHeader(buffers, columnHeaders[i]);
                }
                for (level = 0; level < columnLevelsCount; level++) buffers[level].push("</tr>");
                for (var output = "", _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
                    var buffer;
                    output += (buffer = buffers_1[_i]).join("");
                }
                return output;
            }, AccessibleTableRenderer.prototype.renderColumnHeader = function(buffers, header) {
                var buffer = buffers[header.level], children = header.children;
                if (buffer.push('<th  id="'.concat(header.id, '" class="').concat("colHeader")), 
                header.children || buffer.push(" columnLeaf"), buffer.push('"'), header.span > 1 && buffer.push(" colSpan=" + header.span), 
                header.levelsSpan > 1 && buffer.push(" rowSpan=" + header.levelsSpan), buffer.push(">" + (0, 
                Utility.HZ)(header.text) + "</th>"), children) for (var _i = 0, children_1 = children; _i < children_1.length; _i++) this.renderColumnHeader(buffers, children_1[_i]);
            }, AccessibleTableRenderer.prototype.renderRowHeaders = function(vm) {
                var buffer = [], rowHeaders = vm.rows.root.children;
                if (rowHeaders && rowHeaders.length > 0) for (var _i = 0, rowHeaders_1 = rowHeaders; _i < rowHeaders_1.length; _i++) {
                    var header = rowHeaders_1[_i];
                    buffer.push("<tr>"), buffer.push(this.renderRowHeader(header, vm.columns.leaves)), 
                    buffer.push("</tr>");
                }
                return buffer.join("");
            }, AccessibleTableRenderer.prototype.renderRowHeader = function(header, columnLeaves) {
                var buffer = [];
                if (buffer.push('<th id="'.concat(header.id, '" rowSpan="').concat(header.span, '"')), 
                header.levelsSpan > 1 && buffer.push(' colSpan = "'.concat(header.levelsSpan, '"')), 
                buffer.push(' class="'.concat("rowHeader")), header.children || buffer.push(" rowLeaf"), 
                buffer.push('">'), buffer.push((0, Utility.HZ)(header.text)), buffer.push("</th>"), 
                header.children) for (var _i = 0, _a = header.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child === header.children[0] || buffer.push("</tr><tr>"), buffer.push(this.renderRowHeader(child, columnLeaves));
                } else buffer.push(this.renderValues(header, columnLeaves));
                return buffer.join("");
            }, AccessibleTableRenderer.prototype.renderValues = function(rowLeaves, columnLeaves) {
                if (!_.isEmpty(rowLeaves.values)) {
                    for (var buffer = [], evenRow = rowLeaves.index % 2 == 0, valIndex = 0, columnLeavesCount = columnLeaves.length; valIndex < columnLeavesCount; valIndex++) {
                        var columnLeaf = columnLeaves[valIndex], value = (0, Utility.HZ)(rowLeaves.values[valIndex], !1, !0);
                        buffer.push('<td class="value'), buffer.push(evenRow ? " even" : " odd");
                        var headerIds = AccessibleTableRenderer.getHeadersId(rowLeaves);
                        headerIds.push.apply(headerIds, AccessibleTableRenderer.getHeadersId(columnLeaf) || []), 
                        buffer.push('" headers="' + headerIds.join(" ") + '"'), buffer.push(">"), buffer.push(value), 
                        buffer.push("</td>");
                    }
                    return buffer.join("");
                }
            }, AccessibleTableRenderer.getHeadersId = function(leafHeader) {
                for (var buffer = [], node = leafHeader; node.parent && node.id; ) buffer.splice(0, 0, node.id), 
                node = node.parent;
                return buffer;
            }, AccessibleTableRenderer.getHierachyLevelDisplayName = function(level) {
                for (var buffer = [], _i = 0, _a = level.sources; _i < _a.length; _i++) {
                    var source = _a[_i];
                    source.isMeasure || buffer.push((0, Utility.HZ)(source.displayName));
                }
                return buffer.join(",");
            }, AccessibleTableRenderer;
        }(), AccessibleTable = function() {
            function AccessibleTable() {}
            return AccessibleTable.prototype.init = function(options) {
                this.renderer = new AccessibleTableRenderer(options.element.get(0), options.host);
            }, AccessibleTable.prototype.update = function(options) {
                var dataView;
                _.isEmpty(options.dataViews) || (dataView = options.dataViews[0]);
                var matrix = dataView && dataView.matrix;
                matrix ? this.renderer.render(matrix, options.viewport) : this.renderer.clear();
            }, AccessibleTable.prototype.enumerateObjectInstances = function(options) {
                return [];
            }, AccessibleTable;
        }();
    }
} ]);