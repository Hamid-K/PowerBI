"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "treemap" ], {
    32860: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            TreeMapHitTester: function() {
                return TreeMapHitTester;
            },
            Treemap: function() {
                return Treemap;
            },
            TreemapWebBehavior: function() {
                return TreemapWebBehavior;
            },
            WebTreemapAnimator: function() {
                return WebTreemapAnimator;
            },
            webAnimator: function() {
                return webAnimator;
            },
            webBehavior: function() {
                return webBehavior;
            }
        });
        var tslib_es6 = __webpack_require__(81337), animatorCommon = __webpack_require__(94478), treemap_capabilities = __webpack_require__(92947), renderUtil = __webpack_require__(60066), colorEnumerationHelper2 = __webpack_require__(32554), common_colorHelper = __webpack_require__(90120), converterHelper = __webpack_require__(54522), dataLabelUtil = __webpack_require__(46769), dataLabelViewModel1 = __webpack_require__(21181), fontProperties = __webpack_require__(18664), gradientUtils = __webpack_require__(52083), invalidDataValuesChecker = __webpack_require__(33777), navigationUtils = __webpack_require__(49203), onObjectUtil = __webpack_require__(80065), plotAreaLassoManager = __webpack_require__(11745), htmlSubSelectionHelper = __webpack_require__(52287), subSelectionOutlineRenderer = __webpack_require__(86900), tooltipUtils = __webpack_require__(38400), treemapUtils = __webpack_require__(70249), dataViewCategoricalReader = __webpack_require__(51129), legend_converter = __webpack_require__(79811), legend_formatting = __webpack_require__(86727), legend = __webpack_require__(65741), legend_util = __webpack_require__(77686), interactivityService = __webpack_require__(72902), tooltipService = __webpack_require__(40739), tooltip = __webpack_require__(11305), visualWarnings = __webpack_require__(45296), debug = __webpack_require__(62458), Double = __webpack_require__(41640), shapes6 = __webpack_require__(80758), textMeasurementService = __webpack_require__(32041), browserUtils = __webpack_require__(59107), build_control_util = __webpack_require__(56578), StandaloneUtility1 = __webpack_require__(64329), enums = __webpack_require__(46135), contracts_selector = __webpack_require__(32379), dataViewObject2 = __webpack_require__(82755), dataViewWildcard = __webpack_require__(96915), valueFormatter = __webpack_require__(72489), selectionId = __webpack_require__(26543), WebTreemapAnimator = function(_super) {
            function WebTreemapAnimator(options) {
                return _super.call(this, options) || this;
            }
            return (0, tslib_es6.__extends)(WebTreemapAnimator, _super), WebTreemapAnimator.prototype.animate = function(options) {
                var result = {
                    failed: !0,
                    shapes: null,
                    highlightShapes: null,
                    majorLabels: null,
                    minorLabels: null
                }, viewModel = options.viewModel, previousViewModel = this.previousViewModel;
                return previousViewModel && (viewModel.hasHighlights && !previousViewModel.hasHighlights ? result = this.animateNormalToHighlighted(options) : viewModel.hasHighlights && previousViewModel.hasHighlights ? result = this.animateHighlightedToHighlighted(options) : !viewModel.hasHighlights && previousViewModel.hasHighlights && (result = this.animateHighlightedToNormal(options))), 
                this.previousViewModel = viewModel, result;
            }, WebTreemapAnimator.prototype.animateNormalToHighlighted = function(options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection(), shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, !0, options.layout), highlightShapes = options.shapeGraphicsContext.selectAll("." + treemapUtils.Sh.highlight).data(options.highlightNodes, function(d) {
                    return d.data.key + "highlight";
                }), highlightEnter = highlightShapes.enter().append("rect").attr("class", options.layout.highlightShapeClass).attrs(options.layout.shapeLayout), allHighlight = highlightShapes.merge(highlightEnter).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !0);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, !0, !0);
                });
                return allHighlight.transition().duration(this.animationDuration).attrs(options.layout.highlightShapeLayout), 
                highlightShapes.exit().remove(), {
                    failed: !1,
                    shapes,
                    highlightShapes: allHighlight,
                    majorLabels: this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.categoryLabelSettings, options.layout),
                    minorLabels: this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.dataLabelSettings, options.layout)
                };
            }, WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function(options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection(), shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, !0, options.layout);
                return options.shapeGraphicsContext.selectAll("." + treemapUtils.Sh.highlight).data(options.highlightNodes, function(d) {
                    return d.data.key + "highlight";
                }), {
                    failed: !1,
                    shapes,
                    highlightShapes: this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, !0, options.layout),
                    majorLabels: this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.categoryLabelSettings, options.layout),
                    minorLabels: this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.dataLabelSettings, options.layout)
                };
            }, WebTreemapAnimator.prototype.animateHighlightedToNormal = function(options) {
                var hasSelection = !!options.interactivityService && options.interactivityService.hasSelection(), shapes = options.shapeGraphicsContext.selectAll("." + treemapUtils.Sh.node).data(options.nodes, function(d) {
                    return d.data.key;
                }), shapeEnter = shapes.enter().append("rect").attr("class", options.layout.shapeClass), allShapes = shapes.merge(shapeEnter);
                allShapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !1);
                }).style("fill-opacity", function(d) {
                    return renderUtil.eR(d.data.selected, !1, d.data.selected, !d.data.selected);
                }).attrs(options.layout.shapeLayout).transition().duration(0).style("fill-opacity", function(d) {
                    return renderUtil.eR(d.data.selected, !1, hasSelection, !1);
                }), shapes.exit().remove();
                var highlightShapes = options.shapeGraphicsContext.selectAll("." + treemapUtils.Sh.highlight).data(options.nodes, function(d) {
                    return d.data.key + "highlight";
                }), highlightEnter = highlightShapes.enter().append("rect").attr("class", options.layout.highlightShapeClass), allHighlights = highlightShapes.merge(highlightEnter).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !0);
                }).style("fill-opacity", function(d) {
                    return renderUtil.eR(d.data.selected, !0, d.data.selected, !d.data.selected);
                });
                return allHighlights.transition().duration(this.animationDuration).attrs(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout).remove(), 
                highlightShapes.exit().remove(), {
                    failed: !1,
                    shapes: allShapes,
                    highlightShapes: allHighlights,
                    majorLabels: this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.categoryLabelSettings, options.layout),
                    minorLabels: this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.dataLabelSettings, options.layout)
                };
            }, WebTreemapAnimator.prototype.animateDefaultShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var shapes = context.selectAll("." + treemapUtils.Sh.node).data(nodes, function(d) {
                    return d.data.key;
                }), shapesEnter = shapes.enter().append("rect").attr("class", layout.shapeClass), allShapes = shapes.merge(shapesEnter);
                return allShapes.transition().duration(this.animationDuration).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !1);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !1);
                }).attrs(layout.shapeLayout), shapes.exit().remove(), allShapes;
            }, WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var highlightShapes = context.selectAll("." + treemapUtils.Sh.highlight).data(nodes, function(d) {
                    return d.data.key + "highlight";
                }), highlightEnter = highlightShapes.enter().append("rect").attr("class", layout.highlightShapeClass), allHighlights = highlightShapes.merge(highlightEnter);
                return allHighlights.transition().duration(this.animationDuration).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !0);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !0);
                }).attrs(layout.highlightShapeLayout), highlightShapes.exit().remove(), allHighlights;
            }, WebTreemapAnimator.prototype.animateDefaultMajorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + treemapUtils.Sh.major).data(nodes, function(d) {
                    return d.data.key;
                }), labelEnter = labels.enter().append("text").attr("class", layout.majorLabelClass), allLabels = labels.merge(labelEnter).text(layout.majorLabelText).styles(function(hNode) {
                    return (0, fontProperties.rL)(labelSettings.fontProperties, {
                        color: hNode.data.categoryLabelFill
                    });
                });
                return allLabels.transition().duration(this.animationDuration).attrs(layout.majorLabelLayout), 
                labels.exit().remove(), allLabels;
            }, WebTreemapAnimator.prototype.animateDefaultMinorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + treemapUtils.Sh.minor).data(nodes, function(d) {
                    return d.data.key;
                }), labelEnter = labels.enter().append("text").attr("class", layout.minorLabelClass), allLabels = labels.merge(labelEnter).text(layout.minorLabelText).styles(function(hNode) {
                    return (0, fontProperties.rL)(labelSettings.fontProperties, {
                        color: hNode.data.labelFill
                    });
                });
                return allLabels.transition().duration(this.animationDuration).attrs(layout.minorLabelLayout), 
                labels.exit().remove(), allLabels;
            }, WebTreemapAnimator;
        }(animatorCommon.r5), interactivityUtils = __webpack_require__(30237), TreemapWebBehavior = function() {
            function TreemapWebBehavior() {}
            return TreemapWebBehavior.prototype.bindEvents = function(options, selectionHandler, dataPointNavigationManagerWithKey, formatMode) {
                this.root = options.root, this.shapes = options.shapes, this.highlightShapes = options.highlightShapes, 
                this.hasHighlights = options.hasHighlights, this.visualInstanceId = options.visualInstanceId;
                var majorLabels = options.majorLabels, minorLabels = options.minorLabels;
                if (this.selectionHandler = selectionHandler, this.hitTester = options.hitTester, 
                formatMode) (0, interactivityUtils.FO)(this.shapes), this.highlightShapes && (0, 
                interactivityUtils.FO)(this.highlightShapes), majorLabels && (0, interactivityUtils.FO)(majorLabels), 
                minorLabels && (0, interactivityUtils.FO)(minorLabels); else {
                    if ((0, interactivityUtils.a0)(this.shapes, selectionHandler), this.highlightShapes && (0, 
                    interactivityUtils.a0)(this.highlightShapes, selectionHandler), dataPointNavigationManagerWithKey) {
                        var dataPointNavigationManager = dataPointNavigationManagerWithKey.dataPointNavigationManager, pointSourceKey = dataPointNavigationManagerWithKey.pointSourceKey;
                        dataPointNavigationManager.isEmpty(pointSourceKey) || ((0, interactivityUtils.lt)(this.root, selectionHandler), 
                        (0, interactivityUtils.I8)(this.shapes, dataPointNavigationManager, pointSourceKey), 
                        (0, interactivityUtils.W3)(this.root, dataPointNavigationManager, pointSourceKey), 
                        (0, interactivityUtils.zV)(this.root, options.visualInstanceId, pointSourceKey, "treeitem"));
                    }
                    majorLabels && (0, interactivityUtils.a0)(majorLabels, selectionHandler), minorLabels && (0, 
                    interactivityUtils.a0)(minorLabels, selectionHandler);
                }
            }, TreemapWebBehavior.prototype.lassoSelectRect = function(e, rect) {
                var selectedDataPoints = this.hitTester.queryRegion(rect);
                (0, interactivityUtils.ct)(e, selectedDataPoints, this.selectionHandler);
            }, TreemapWebBehavior.prototype.renderFocus = function(element) {
                var focusElementId = "".concat(renderUtil.aY, "-").concat(this.visualInstanceId);
                this.root.select("#" + focusElementId).attr("id", null), element && (element.setAttribute("id", focusElementId), 
                browserUtils.M.focus(element));
            }, TreemapWebBehavior.prototype.renderSelection = function(hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.shapes.attr("aria-checked", function(d) {
                    return null === d.parent ? null : d.data.selected;
                }).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !1);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !1);
                }).style("stroke-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !1);
                }), this.highlightShapes.attr("aria-checked", function(d) {
                    return null === d.parent ? null : d.data.selected;
                }).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !0);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !0);
                }).style("stroke-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !0);
                });
            }, TreemapWebBehavior;
        }(), dataLabelViewModel1Consts = __webpack_require__(56707), Treemap = function() {
            function Treemap(options) {
                this.tooltipsEnabled = options && options.tooltipsEnabled, this.cartesianConditionalFormatting = options && options.cartesianConditionalFormatting, 
                this.dataPointLassoSelect = null == options ? void 0 : options.dataPointLassoSelect, 
                options && options.animator && (this.animator = options.animator, this.isScrollable = !!options.isScrollable && options.isScrollable, 
                this.behavior = options.behavior);
            }
            return Treemap.getLayout = function(dataLabelSettings, alternativeScale, categoryLabelSettings) {
                var formattersCache = (0, dataLabelViewModel1.fI)(), majorLabelsEnabled = categoryLabelSettings.show, minorLabelsEnabled = dataLabelSettings.show;
                return {
                    role: function(d) {
                        return Treemap.getNodeAccesibilityRole(d);
                    },
                    ariaHidden: function(d) {
                        return Treemap.isAriaHidden(d);
                    },
                    shapeClass: function(d) {
                        return Treemap.getNodeClass(d, !1);
                    },
                    shapeLayout: Treemap.createTreemapShapeLayout(!1),
                    highlightShapeClass: function(d) {
                        return Treemap.getNodeClass(d, !0);
                    },
                    highlightShapeLayout: Treemap.createTreemapShapeLayout(!0),
                    zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                    majorLabelClass: function(_d) {
                        return treemapUtils.Sh.major;
                    },
                    majorLabelLayout: {
                        x: function(d) {
                            return d.x0 + Treemap.TextMargin;
                        },
                        y: function(d) {
                            return d.y0 + Treemap.TextMargin + categoryLabelSettings.fontProperties.size.px;
                        }
                    },
                    majorLabelText: function(d) {
                        return Treemap.createMajorLabelText(d, categoryLabelSettings, alternativeScale, formattersCache);
                    },
                    majorLabelFullText: function(d) {
                        return d.data.name;
                    },
                    minorLabelClass: function(d) {
                        return treemapUtils.Sh.minor;
                    },
                    minorLabelLayout: {
                        x: function(d) {
                            return d.x0 + Treemap.TextMargin;
                        },
                        y: function(d) {
                            return d.y1 - Treemap.TextMargin;
                        }
                    },
                    minorLabelText: function(d) {
                        return Treemap.createMinorLabelText(d, dataLabelSettings, alternativeScale, formattersCache, categoryLabelSettings);
                    },
                    areMajorLabelsEnabled: function() {
                        return majorLabelsEnabled;
                    },
                    areMinorLabelsEnabled: function() {
                        return minorLabelsEnabled;
                    }
                };
            }, Treemap.prototype.init = function(options) {
                var _a, _this = this;
                this.options = options, this.hostService = options.host, this.featureSwitches = options.featureSwitches || {}, 
                this.behavior && (this.interactivityService = (0, interactivityService.ub)(this.hostService, this.featureSwitches));
                var element = options.element;
                if (element.empty(), this.style = options.style, this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(Treemap.ClassName, !0), 
                this.shapeGraphicsContext = this.svg.append("g").style("stroke", common_colorHelper.v.getThemeColor(this.style, treemapUtils.oN)).classed(Treemap.ShapesClassName, !0), 
                this.interactivityService) {
                    var isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge();
                    this.shapeGraphicsContext.attr("tabindex", 0).attr("focusable", !0).attr("aria-label", this.hostService.getLocalizedString("Visual_Plot")).attr("role", "tree").classed(renderUtil.Pg, !isEdgeOrIE);
                }
                if (this.labelGraphicsContext = this.svg.append("g").classed(Treemap.LabelsGroupClassName, !0), 
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                    scale: options.viewport.scale
                }, this.treemap = d3.treemap().tile(d3.treemapResquarify).round(!1), this.legend = (0, 
                legend.OG)(element, !1, this.interactivityService, this.isScrollable, void 0, this.style, this.hostService), 
                this.tooltipService = (0, tooltipService.r)(this.hostService), this.dataPointLassoSelect) {
                    this.plotLassoManager = new plotAreaLassoManager.oW(!1);
                    var svgSelection = d3.select(this.svg.node());
                    this.plotLassoManager.init([ svgSelection ], svgSelection, this.hostService, this.featureSwitches), 
                    this.lassoSelectionBehavior = new plotAreaLassoManager.lk(this.behavior), this.plotLassoManager.behaviors.push(this.lassoSelectionBehavior), 
                    this.plotLassoManager.setUiScale(this.currentViewport.scale);
                }
                if (this.featureSwitches.onObject) {
                    var subSelectionHostService = null === (_a = this.hostService) || void 0 === _a ? void 0 : _a.getSubSelectionService(), renderer = null != subSelectionHostService ? subSelectionHostService : subSelectionOutlineRenderer.D.createWithDefaultHost();
                    this.subSelectionHelper = htmlSubSelectionHelper.O5.createHtmlSubselectionHelper({
                        hostElement: element.get(0),
                        hostServices: this.hostService,
                        renderer,
                        targetSource: "format",
                        scale: function() {
                            return _this.currentViewport.scale;
                        },
                        selectorCallback: function(element) {
                            return _this.getSelectorsByColumnSubSelection(element);
                        }
                    }), this.interactivityService.setSubSelectionHelper(this.subSelectionHelper);
                }
            }, Treemap.getDefaultTreemapDataLabelSettings = function(style) {
                var defaultColor = common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl), defaultFontProperties = (0, 
                dataLabelViewModel1.bT)({
                    style,
                    fontSize: StandaloneUtility1.FP.toPoint(dataLabelViewModel1Consts.WP),
                    fontFamily: dataLabelViewModel1Consts.Pq,
                    labelColor: defaultColor,
                    textClassName: "smallLightLabel"
                }).fontProperties;
                return defaultFontProperties = (0, fontProperties.ED)(defaultFontProperties, {
                    color: defaultColor
                }), {
                    show: !1,
                    displayUnits: 0,
                    precision: dataLabelViewModel1Consts.NZ,
                    fontProperties: defaultFontProperties,
                    minFontSize: dataLabelViewModel1Consts.LK,
                    maxFontSize: dataLabelViewModel1Consts.N0,
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, Treemap.getDefaultTreemapCategoryLabelSettings = function(style) {
                var defaultColor = common_colorHelper.v.getThemeColor(style, dataLabelViewModel1Consts.pl), defaultFontProperties = (0, 
                dataLabelViewModel1.bT)({
                    style,
                    fontSize: StandaloneUtility1.FP.toPoint(dataLabelViewModel1Consts.XJ),
                    fontFamily: dataLabelViewModel1Consts.Pq,
                    labelColor: defaultColor,
                    textClassName: "label"
                }).fontProperties;
                return {
                    show: !0,
                    fontProperties: defaultFontProperties = (0, fontProperties.ED)(defaultFontProperties, {
                        color: defaultColor
                    }),
                    bold: !1,
                    italic: !1,
                    underline: !1
                };
            }, Treemap.converter = function(options) {
                var _a, _b, _c, _e, _f, _g, _h, _j, _k, _l, _m, hasNegativeValues, allValuesAreNegative, hasHighlights, dataWasCulled, dataView = options.dataView, style = options.style, dataLabelSettings = options.dataLabelSettings, categoryLabelSettings = options.categoryLabelSettings, interactivityService = options.interactivityService, viewport = options.viewport, tooltipsEnabled = void 0 === (_a = options.tooltipsEnabled) || _a, treemap = options.treemap, valueColumnRoleName = _.some(null !== (_c = null === (_b = null == dataView ? void 0 : dataView.metadata) || void 0 === _b ? void 0 : _b.columns) && void 0 !== _c ? _c : [], function(column) {
                    var _a;
                    return null === (_a = null == column ? void 0 : column.roles) || void 0 === _a ? void 0 : _a[treemap_capabilities.A4.values];
                }) ? treemap_capabilities.A4.values : treemap_capabilities.A4.gradient, formatStringProp = treemap_capabilities._H.general.formatString, reader = (0, 
                dataViewCategoricalReader.G)(dataView, {
                    staticSeriesRoleNames: [ valueColumnRoleName ],
                    formatStringProp
                }), dataReader = reader.data, columnReader = reader.columns, rootNode = {
                    key: "root",
                    name: "root",
                    size: void 0,
                    children: [],
                    originalValue: void 0,
                    selected: !1,
                    highlightMultiplier: 0,
                    identity: selectionId.l0.createNull(),
                    color: void 0,
                    categoryIndex: null,
                    seriesIndex: null
                }, allNodes = [], colorHelper = common_colorHelper.v.create(style, treemap_capabilities._H.dataPoint.fill), defaultLabelColor = dataLabelSettings.fontProperties.color, defaultCategoryLabelColor = categoryLabelSettings.fontProperties.color;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = (objects = dataView.metadata.objects).labels;
                    labelsObj && dataLabelSettings && (0, dataLabelViewModel1.ww)(labelsObj, dataLabelSettings, void 0, style);
                    var categoryLabelsObj = objects.categoryLabels;
                    categoryLabelsObj && categoryLabelSettings && (0, dataLabelViewModel1.ww)(categoryLabelsObj, categoryLabelSettings, void 0, style);
                }
                var hasSeriesData = dataReader.hasSeries(), hasCategoryData = dataReader.hasCategories();
                if (dataReader.hasValues(treemap_capabilities.A4.values) || dataReader.hasValues(treemap_capabilities.A4.gradient)) {
                    var categorical = dataView.categorical, grouped = categorical.values.grouped();
                    hasHighlights = dataReader.hasHighlights();
                    var result = Treemap.getValuesFromCategoricalDataView(dataView, hasHighlights, valueColumnRoleName), values = result.values, highlights = result.highlights;
                    result.highlightsOverflow && (hasHighlights = !1, values = highlights), hasNegativeValues = result.hasNegativeValues, 
                    allValuesAreNegative = result.allValuesAreNegative;
                    var cullableValue = Treemap.getCullableValue(result.totalValue, viewport), hasDynamicSeries = columnReader.hasDynamicSeries();
                    dataWasCulled = !1;
                    var gradientValueColumn = columnReader.getValueColumn(treemap_capabilities.A4.gradient, 0);
                    if (null != categorical.categories || _.isEmpty(values)) {
                        if (categorical.categories && categorical.categories.length > 0) {
                            seriesCount = dataReader.getSeriesCount();
                            for (var omitSecondLevel = !dataReader.hasSeries(), categoryColumn = categorical.categories[0], categoryFormat = (0, 
                            valueFormatter.EO)(categoryColumn.source, formatStringProp), categoryIndex = 0, categoryLen = values.length; categoryIndex < categoryLen; categoryIndex++) {
                                var objects, fillColor = colorHelper.getColorForSeriesValue(objects = categoryColumn.objects && categoryColumn.objects[categoryIndex], categoryColumn.identityFields, categoryColumn.values[categoryIndex]), dataLabelColor = (0, 
                                dataLabelUtil.t$)({
                                    defaultColor: defaultLabelColor,
                                    categoricalDataReader: reader,
                                    categoryIndex
                                }), categoryLabelColor = (0, dataLabelUtil.Sm)({
                                    defaultColor: defaultCategoryLabelColor,
                                    categoricalDataReader: reader,
                                    categoryIndex
                                }), categoryValue = (0, valueFormatter.WU)(categoryColumn.values[categoryIndex], categoryFormat), currentValues = values[categoryIndex], highlightValue = (value = null === (_e = currentValues[seriesIndex = 0]) || void 0 === _e ? void 0 : _e.value, 
                                formatString = null === (_f = currentValues[seriesIndex]) || void 0 === _f ? void 0 : _f.formatString, 
                                hasHighlights && highlights ? highlights[categoryIndex][seriesIndex].value : void 0), highlightFormatString = hasHighlights && highlights ? highlights[categoryIndex][seriesIndex].formatString : void 0, categoryTooltipItem = void (tooltipInfo = void 0);
                                if (tooltipsEnabled) {
                                    (tooltipInfo = []).push(categoryTooltipItem = {
                                        displayName: categoryColumn.source.displayName,
                                        value: categoryValue
                                    }), hasDynamicSeries && (seriesMetadataColumn = columnReader.getSeriesMetadataColumn(), 
                                    seriesValue = dataReader.getSeriesName(seriesIndex), tooltipInfo.push({
                                        displayName: seriesMetadataColumn.displayName,
                                        value: (0, converterHelper.xq)(seriesValue, seriesMetadataColumn, formatStringProp)
                                    }));
                                    var valueColumnMetadata = columnReader.getValueMetadataColumn(valueColumnRoleName, seriesIndex);
                                    null != value && tooltipInfo.push({
                                        displayName: valueColumnMetadata.displayName,
                                        value: (0, converterHelper.xq)(value, valueColumnMetadata, formatStringProp, !1, formatString)
                                    }), null != highlightValue && tooltipInfo.push({
                                        displayName: tooltip.I6.localizationOptions.highlightedValueDisplayName,
                                        value: (0, converterHelper.xq)(highlightValue, valueColumnMetadata, formatStringProp, !1, highlightFormatString)
                                    });
                                    var gradientValueColumnMetadata = gradientValueColumn ? gradientValueColumn.source : void 0;
                                    if (omitSecondLevel && gradientValueColumnMetadata && gradientValueColumnMetadata !== valueColumnMetadata && null != gradientValueColumn.values[categoryIndex]) {
                                        var formatString_1 = (0, dataViewObject2.NA)(null === (_g = gradientValueColumn.objects) || void 0 === _g ? void 0 : _g[categoryIndex], formatStringProp);
                                        tooltipInfo.push({
                                            displayName: gradientValueColumnMetadata.displayName,
                                            value: (0, converterHelper.xq)(gradientValueColumn.values[categoryIndex], gradientValueColumnMetadata, formatStringProp, !1, formatString_1)
                                        });
                                    }
                                    (0, tooltip.VT)(reader, tooltipInfo, categoryIndex, seriesIndex, formatStringProp);
                                }
                                var valueMetadataColumn = columnReader.getValueMetadataColumn(valueColumnRoleName, seriesIndex), isWithMeasure = (valueColumn = columnReader.getValueColumn(valueColumnRoleName, seriesIndex), 
                                omitSecondLevel && valueMetadataColumn);
                                if (identity = selectionId.dw.builder().withCategory([ categoryColumn ], categoryIndex, null === (_h = null == categoryColumn ? void 0 : categoryColumn.source) || void 0 === _h ? void 0 : _h.queryName, !0).withMeasure(isWithMeasure ? valueMetadataColumn.queryName : void 0, isWithMeasure ? valueColumn : void 0, isWithMeasure ? categoryIndex : void 0).createSelectionId(), 
                                key = JSON.stringify({
                                    nodeKey: identity.getKey(),
                                    depth: 1
                                }), columnFormatString = 1 === seriesCount ? (0, valueFormatter.EO)(columnReader.getValueMetadataColumn(valueColumnRoleName, seriesIndex), formatStringProp) : categoryFormat, 
                                node = {
                                    key,
                                    name: categoryValue,
                                    size: void 0,
                                    originalValue: void 0,
                                    color: fillColor,
                                    selected: !1,
                                    identity,
                                    tooltipInfo,
                                    formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                                    highlightedTooltipInfo: tooltipInfo,
                                    labelFormatString: null != formatString ? formatString : columnFormatString,
                                    categoryIndex,
                                    seriesIndex
                                }, categoryLabelColor.color) {
                                    node.categoryLabelFill = categoryLabelColor.color;
                                    var catFontPropColor = (0, dataLabelUtil.B8)(categoryLabelColor) ? categoryLabelColor.color : defaultCategoryLabelColor;
                                    categoryLabelSettings.fontProperties = (0, dataLabelUtil.Vv)(catFontPropColor, categoryLabelSettings.fontProperties);
                                }
                                if (dataLabelColor.color) {
                                    node.labelFill = dataLabelColor.color;
                                    var fontPropColor = (0, dataLabelUtil.B8)(dataLabelColor) ? dataLabelColor.color : defaultLabelColor;
                                    dataLabelSettings.fontProperties = (0, dataLabelUtil.Vv)(fontPropColor, dataLabelSettings.fontProperties);
                                }
                                hasHighlights && (node.highlightMultiplier = 0 !== value ? highlightValue / value : 0, 
                                node.highlightValue = allValuesAreNegative && null != highlightValue ? Math.abs(highlightValue) : highlightValue, 
                                node.originalHighlightValue = highlightValue, node.highlightLabelFormatString = null != highlightFormatString ? highlightFormatString : columnFormatString);
                                for (var total = 0, highlightTotal = 0; seriesIndex < seriesCount; seriesIndex++) {
                                    var valueColumn_1 = columnReader.getValueColumn(valueColumnRoleName, seriesIndex), value_1 = (seriesValueColumn = grouped && grouped[seriesIndex], 
                                    currentValues[seriesIndex].value), highlight = void 0;
                                    if (dataWasCulled = (valueShape = Treemap.checkValueForShape(value_1, cullableValue, allValuesAreNegative, dataWasCulled)).dataWasCulled, 
                                    valueShape.validShape && (total += value_1, hasHighlights && (highlightTotal += highlight = highlights[categoryIndex][seriesIndex].value), 
                                    !omitSecondLevel)) {
                                        var childName;
                                        childName = columnReader.hasDynamicSeries() ? (0, converterHelper.xq)(dataReader.getSeriesName(seriesIndex), columnReader.getSeriesMetadataColumn(), formatStringProp) : reader.data.getSeriesName(seriesIndex);
                                        var categoricalValues = categorical ? categorical.values : null, measureId = valueColumn_1.source.queryName, childIdentity = selectionId.dw.builder().withCategory([ categoryColumn ], categoryIndex, null === (_j = null == categoryColumn ? void 0 : categoryColumn.source) || void 0 === _j ? void 0 : _j.queryName, !0).withSeries(categoricalValues, seriesValueColumn, !0).withMeasure(measureId, valueColumn_1, categoryIndex).createSelectionId(), childKey = JSON.stringify({
                                            nodeKey: childIdentity.getKey(),
                                            depth: 2
                                        }), tooltipInfo_1 = void (highlightedValue = hasHighlights && 0 !== highlight ? highlight : void 0);
                                        tooltipsEnabled && ((tooltipInfo_1 = []).push(categoryTooltipItem), hasDynamicSeries && (categoryColumn && categoryColumn.source === categoricalValues.source || tooltipInfo_1.push({
                                            displayName: categoricalValues.source.displayName,
                                            value: (0, converterHelper.xq)(dataReader.getSeriesName(seriesIndex), categoricalValues.source, formatStringProp)
                                        })), null != value_1 && tooltipInfo_1.push({
                                            displayName: valueColumn_1.source.displayName,
                                            value: (0, converterHelper.xq)(value_1, valueColumn_1.source, formatStringProp, !1, formatString)
                                        }), null != highlightValue && tooltipInfo_1.push({
                                            displayName: tooltip.I6.localizationOptions.highlightedValueDisplayName,
                                            value: (0, converterHelper.xq)(highlightedValue, valueColumn_1.source, formatStringProp, !1, highlightFormatString)
                                        }), (0, tooltip.VT)(reader, tooltipInfo_1, categoryIndex, hasDynamicSeries ? seriesIndex : void 0, formatStringProp));
                                        var columnFormatString_1 = (0, valueFormatter.EO)(valueColumn_1.source, formatStringProp), childNode = {
                                            key: childKey,
                                            name: childName,
                                            size: allValuesAreNegative ? Math.abs(value_1) : value_1,
                                            originalValue: value_1,
                                            color: fillColor,
                                            selected: !1,
                                            identity: childIdentity,
                                            tooltipInfo: tooltipInfo_1,
                                            formattedTooltip: (0, tooltipUtils.X)(tooltipInfo_1),
                                            highlightedTooltipInfo: tooltipInfo_1,
                                            labelFormatString: null != formatString ? formatString : columnFormatString_1,
                                            categoryIndex,
                                            seriesIndex
                                        }, categoryLabelFill = (0, dataLabelUtil.Sm)({
                                            defaultColor: categoryLabelColor.color,
                                            categoricalDataReader: reader,
                                            categoryIndex,
                                            seriesIndex
                                        }), labelFill = (0, dataLabelUtil.t$)({
                                            defaultColor: dataLabelColor.color,
                                            categoricalDataReader: reader,
                                            categoryIndex,
                                            seriesIndex
                                        });
                                        categoryLabelFill.color && (node.categoryLabelFill = categoryLabelFill.color), labelFill.color && (childNode.labelFill = labelFill.color), 
                                        hasHighlights && (childNode.highlightMultiplier = 0 !== value_1 ? highlight / value_1 : 0, 
                                        childNode.highlightValue = allValuesAreNegative && null != highlight ? Math.abs(highlight) : null, 
                                        childNode.originalHighlightValue = highlight, childNode.highlightLabelFormatString = null != highlightFormatString ? highlightFormatString : columnFormatString_1), 
                                        null == node.children && (node.children = []), node.children.push(childNode), allNodes.push(childNode);
                                    }
                                }
                                total && (omitSecondLevel && (node.size = allValuesAreNegative ? Math.abs(total) : total, 
                                node.originalValue = total), rootNode.children.push(node), allNodes.push(node)), 
                                hasHighlights && (node.highlightMultiplier = total ? highlightTotal / total : 0);
                            }
                        }
                    } else for (var seriesIndex = 0, seriesCount = columnReader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                        var value, valueShape, valueColumn = columnReader.getValueColumn(valueColumnRoleName, seriesIndex), seriesValueColumn = grouped && grouped[seriesIndex], formatString = values[0][seriesIndex].formatString;
                        if (dataWasCulled = (valueShape = Treemap.checkValueForShape(value = values[0][seriesIndex].value, cullableValue, allValuesAreNegative, dataWasCulled)).dataWasCulled, 
                        valueShape.validShape) {
                            var nodeName;
                            nodeName = hasDynamicSeries ? (0, converterHelper.xq)(columnReader.getSeriesValueColumnGroup(seriesIndex).name, columnReader.getSeriesMetadataColumn(), formatStringProp) : reader.columns.hasStaticSeries() ? reader.data.getSeriesName(seriesIndex) : reader.data.getValueDisplayName(valueColumnRoleName);
                            var identity, key = (identity = (new selectionId.dw).withSeries(dataView.categorical.values, hasDynamicSeries ? seriesValueColumn : void 0, !0).withMeasure(valueColumn.source.queryName, columnReader.getValueColumn(valueColumnRoleName, seriesIndex), -1).createSelectionId()).getKey(), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(reader.objects.getSeriesDataObjects(seriesIndex), categorical.values.identityFields, (0, 
                            converterHelper.Pl)(valueColumn.source)) : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName), highlightedValue = hasHighlights ? highlights[0][seriesIndex].value : void 0, highlightFormatValue = hasHighlights ? highlights[0][seriesIndex].formatString : void 0, tooltipInfo = void 0;
                            if (tooltipsEnabled) {
                                if (tooltipInfo = [], hasDynamicSeries) {
                                    var seriesMetadataColumn = columnReader.getSeriesMetadataColumn(), seriesValue = dataReader.getSeriesName(seriesIndex);
                                    tooltipInfo.push({
                                        displayName: seriesMetadataColumn.displayName,
                                        value: (0, converterHelper.xq)(seriesValue, seriesMetadataColumn, formatStringProp)
                                    });
                                }
                                null != value && tooltipInfo.push({
                                    displayName: valueColumn.source.displayName,
                                    value: (0, converterHelper.xq)(value, valueColumn.source, formatStringProp, !1, formatString)
                                }), null != highlightedValue && tooltipInfo.push({
                                    displayName: tooltip.I6.localizationOptions.highlightedValueDisplayName,
                                    value: (0, converterHelper.xq)(highlightedValue, valueColumn.source, formatStringProp, !1, highlightFormatValue)
                                }), (0, tooltip.VT)(reader, tooltipInfo, 0, hasDynamicSeries ? seriesIndex : void 0, formatStringProp);
                            }
                            var columnFormatString = (0, valueFormatter.EO)(valueColumn.source, formatStringProp), node = {
                                key,
                                name: nodeName,
                                size: allValuesAreNegative ? Math.abs(value) : value,
                                originalValue: value,
                                color,
                                selected: !1,
                                identity,
                                tooltipInfo,
                                formattedTooltip: (0, tooltipUtils.X)(tooltipInfo),
                                highlightedTooltipInfo: tooltipInfo,
                                labelFormatString: null != formatString ? formatString : columnFormatString,
                                categoryIndex: 0,
                                seriesIndex
                            };
                            hasHighlights && highlights && (node.highlightMultiplier = 0 !== value ? highlightedValue / value : 0, 
                            node.highlightValue = allValuesAreNegative && null != highlightedValue ? Math.abs(highlightedValue) : highlightedValue, 
                            node.originalHighlightValue = highlightedValue, node.highlightLabelFormatString = null != highlightFormatValue ? highlightFormatValue : columnFormatString), 
                            rootNode.children.push(node), allNodes.push(node);
                        }
                    }
                }
                var legendData = hasCategoryData ? (0, legend_converter.xw)({
                    dataView,
                    categoryRole: treemap_capabilities.A4.group,
                    valueRole: treemap_capabilities.A4.values,
                    showByDefault: !1,
                    style
                }) : (0, legend_converter.pq)({
                    dataView,
                    staticSeriesRoleNames: [ treemap_capabilities.A4.values ],
                    showByDefault: !1,
                    style
                });
                return interactivityService && (interactivityService.applySelectionStateToData(allNodes), 
                interactivityService.applySelectionStateToData(legendData.dataPoints)), {
                    root: rootNode,
                    flattenedViewModel: Treemap.flattenViewModel(rootNode, treemap),
                    hasHighlights,
                    legendData,
                    dataLabelSettings,
                    categoryLabelSettings,
                    legendObjectProperties: null !== (_m = null === (_l = null === (_k = dataView.metadata) || void 0 === _k ? void 0 : _k.objects) || void 0 === _l ? void 0 : _l.legend) && void 0 !== _m ? _m : null,
                    dataWasCulled,
                    hasNegativeValues,
                    allValuesAreNegative,
                    hasSeriesData,
                    hasCategoryData
                };
            }, Treemap.normalizedValue = function(value, allValuesAreNegative) {
                return null == value || isNaN(value) ? 0 : value === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : value === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : allValuesAreNegative ? Math.abs(value) : value < 0 ? 0 : value;
            }, Treemap.getValuesFromCategoricalDataView = function(dataView, hasHighlights, valueColumnRoleName) {
                for (var hasNegativeValues, allValuesAreNegative, highlightsOverflow, dataReader = (0, 
                dataViewCategoricalReader.G)(dataView, {
                    staticSeriesRoleNames: [ valueColumnRoleName ],
                    formatStringProp: treemap_capabilities._H.general.formatString
                }).data, categoryCount = dataReader.getCategoryCount() || 1, seriesCount = dataReader.getSeriesCount(), values = [], highlights = [], totalValue = 0, i = 0; i < categoryCount; i++) values.push([]), 
                hasHighlights && highlights.push([]);
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                    var value = dataReader.getValue(valueColumnRoleName, categoryIndex, seriesIndex), formatString = dataReader.getFormatString(valueColumnRoleName, categoryIndex, seriesIndex);
                    values[categoryIndex].push({
                        value,
                        formatString
                    });
                    var highlight = void 0;
                    if (hasHighlights) {
                        highlight = dataReader.getHighlight(valueColumnRoleName, categoryIndex, seriesIndex);
                        var highlightFormatString = dataReader.getHighlightFormatString(valueColumnRoleName, categoryIndex, seriesIndex);
                        null == highlight && (highlight = 0), highlights[categoryIndex].push({
                            value: highlight,
                            formatString: highlightFormatString
                        });
                    }
                    allValuesAreNegative = void 0 === allValuesAreNegative ? (!hasHighlights || highlight <= 0) && value <= 0 : allValuesAreNegative && (!hasHighlights || highlight <= 0) && value <= 0, 
                    hasNegativeValues || (hasNegativeValues = value < 0 || !!hasHighlights && highlight < 0);
                }
                for (allValuesAreNegative = !!allValuesAreNegative, seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) for (categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) totalValue += value = Treemap.normalizedValue(value = values[categoryIndex][seriesIndex].value, allValuesAreNegative), 
                hasHighlights && (highlight = Treemap.normalizedValue(highlight = highlights[categoryIndex][seriesIndex].value, allValuesAreNegative), 
                !highlightsOverflow && (0, Double.aP)(highlight, value) && (highlightsOverflow = !0));
                return {
                    values,
                    highlights: hasHighlights ? highlights : void 0,
                    highlightsOverflow: hasHighlights ? highlightsOverflow : void 0,
                    totalValue: allValuesAreNegative ? Math.abs(totalValue) : totalValue,
                    hasNegativeValues,
                    allValuesAreNegative
                };
            }, Treemap.getCullableValue = function(totalValue, viewport) {
                return Treemap.CullableArea / (viewport.width * viewport.height) * totalValue;
            }, Treemap.prototype.update = function(options) {
                var _a, _b;
                debug.fF.assertValue(options, "options"), this.featureSwitches.onObject && options.formatMode !== this.formatMode && (this.subSelectionHelper.setFormatMode(options.formatMode), 
                this.interactivityService.setFormatMode(options.formatMode), this.formatMode = options.formatMode);
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport, null === (_a = this.plotLassoManager) || void 0 === _a || _a.setUiScale(this.currentViewport.scale);
                var dataLabelSettings = Treemap.getDefaultTreemapDataLabelSettings(this.style), categoryLabelSettings = Treemap.getDefaultTreemapCategoryLabelSettings(this.style);
                if (this.data = (null === (_b = null == dataViews ? void 0 : dataViews[0]) || void 0 === _b ? void 0 : _b.categorical) ? Treemap.converter({
                    dataView: dataViews[0],
                    style: this.style,
                    dataLabelSettings,
                    categoryLabelSettings,
                    interactivityService: this.interactivityService,
                    viewport: this.currentViewport,
                    treemap: this.treemap,
                    tooltipsEnabled: this.tooltipsEnabled,
                    dataPointLassoSelect: this.dataPointLassoSelect
                }) : {
                    root: {
                        key: "root",
                        name: "root",
                        originalValue: void 0,
                        size: void 0,
                        children: [],
                        selected: !1,
                        highlightMultiplier: 0,
                        identity: selectionId.l0.createNull(),
                        color: void 0,
                        categoryIndex: null,
                        seriesIndex: null
                    },
                    flattenedViewModel: [],
                    hasHighlights: !1,
                    legendData: (0, legend_converter.Fe)(this.style),
                    dataLabelSettings,
                    categoryLabelSettings,
                    dataWasCulled: !1,
                    hasNegativeValues: !1,
                    allValuesAreNegative: !1
                }, this.updateInternal(options.suppressAnimations), dataViews) {
                    var warnings = (0, invalidDataValuesChecker.b)(dataViews, !1, !1, !1, [ "Tooltips" ]);
                    this.data.allValuesAreNegative ? warnings.push(new visualWarnings.fi) : this.data.hasNegativeValues && warnings.push(new visualWarnings.v3), 
                    this.hostService.setWarnings(warnings);
                }
                var shouldAlertScreenReader = options.type & enums.EP.FormattingSubSelectionChange;
                if (this.subSelectionHelper && (options.type & enums.EP.Data || options.type & enums.EP.FormattingSubSelectionChange) && (this.subSelectionHelper.updateOutlinesFromSubSelections(options.subSelections, !0), 
                this.hostService.alertScreenReader && shouldAlertScreenReader)) {
                    var labels = this.subSelectionHelper.getLabelsFromSubSelections(options.subSelections, [ "aria-label" ]), message = (null == labels ? void 0 : labels.length) && labels.join(" ");
                    message && this.hostService.alertScreenReader(message);
                }
            }, Treemap.prototype.onDataChanged = function(options) {
                this.update({
                    suppressAnimations: options.suppressAnimations,
                    dataViews: options.dataViews,
                    viewport: this.currentViewport
                });
            }, Treemap.prototype.onResizing = function(viewport) {
                this.update({
                    suppressAnimations: !0,
                    dataViews: this.dataViews,
                    viewport
                });
            }, Treemap.prototype.onClearSelection = function() {
                this.interactivityService && this.interactivityService.clearSelection();
            }, Treemap.prototype.onRestoreSelection = function(options) {
                return !!this.interactivityService && this.interactivityService.restoreSelection(options.selection);
            }, Treemap.prototype.getFormattingModel = function() {
                var _this = this;
                if (this.data) return new build_control_util.Nq(function() {
                    return _this.getLegendCard();
                }, function() {
                    return _this.getDataPointCard(_this.data);
                }, function() {
                    return _this.getLabelsCard(_this.data.dataLabelSettings, !0);
                }, function() {
                    return _this.getCategoryLabelsCard(_this.data.categoryLabelSettings, !1);
                }).build();
            }, Treemap.prototype.getDataPointCard = function(data) {
                var dataView = this.dataViews && this.dataViews.length > 0 && this.dataViews[0], dataViewCat = dataView && this.dataViews[0].categorical, hasGradientRole = (0, 
                gradientUtils.Q1)(dataViewCat), rootChildren = data.root.children;
                if (!_.isEmpty(rootChildren) && !hasGradientRole) {
                    var hasDynamicSeries = !!(dataViewCat && dataViewCat.values && dataViewCat.values.source), dataPoints = _.map(rootChildren, function(treemapNode) {
                        return {
                            color: treemapNode.color,
                            displayName: treemapNode.name,
                            identity: treemapNode.identity
                        };
                    });
                    return hasDynamicSeries || !this.cartesianConditionalFormatting ? (0, colorEnumerationHelper2.xr)(dataPoints, this.hostService, this.featureSwitches) : (0, 
                    colorEnumerationHelper2.k2)({
                        dataView,
                        style: this.style,
                        categories: dataPoints,
                        fillInstanceKind: 2,
                        hideShowAllToggle: !0,
                        showAllDataPoints: !0,
                        noDefaultFillColor: !0
                    }, this.featureSwitches, this.hostService);
                }
            }, Treemap.prototype.getLegendCard = function() {
                return (0, legend_formatting.ZF)({
                    legendData: this.data.legendData
                }, this.hostService, this.featureSwitches);
            }, Treemap.prototype.getLabelsCard = function(dataLabelsSettings, isNum) {
                var _a, _b, _this = this;
                if (!_.isEmpty(this.dataViews)) return (0, dataLabelViewModel1.XQ)({
                    cardBuilder: new build_control_util.CQ(new build_control_util.lg("labels"), "Visual_DataPointsLabels", treemap_capabilities._H.labels, function(key) {
                        return _this.hostService.getLocalizedString(key);
                    }),
                    dataLabelsProps: treemap_capabilities._H.labels,
                    featureSwitches: this.featureSwitches,
                    hostServices: this.hostService,
                    options: {
                        dataLabelsSettings,
                        show: !0,
                        displayUnits: isNum,
                        precision: isNum,
                        fontSize: !0,
                        fontFamily: !0,
                        fontSizeRange: !0,
                        style: this.style,
                        bold: !0,
                        italic: !0,
                        underline: !0
                    },
                    individualSelector: (0, dataLabelViewModel1.WD)({
                        featureSwitches: this.featureSwitches,
                        hasCategories: this.data.hasCategoryData,
                        hasDynamicSeries: !!(null === (_b = null === (_a = _.first(this.dataViews).categorical) || void 0 === _a ? void 0 : _a.values) || void 0 === _b ? void 0 : _b.source),
                        hasSeriesSelector: !1
                    })
                });
            }, Treemap.prototype.getCategoryLabelsCard = function(dataLabelsSettings, isNum) {
                var _a, _b, _c, _e, _this = this;
                return (0, dataLabelViewModel1.XQ)({
                    cardBuilder: new build_control_util.CQ(new build_control_util.lg("categoryLabels"), "Visual_CategoryLabels", treemap_capabilities._H.categoryLabels, function(key) {
                        return _this.hostService.getLocalizedString(key);
                    }),
                    dataLabelsProps: treemap_capabilities._H.categoryLabels,
                    featureSwitches: this.featureSwitches,
                    hostServices: this.hostService,
                    options: {
                        dataLabelsSettings,
                        show: !0,
                        displayUnits: isNum,
                        precision: isNum,
                        fontSize: !0,
                        fontFamily: !0,
                        fontSizeRange: !0,
                        style: this.style,
                        bold: !0,
                        italic: !0,
                        underline: !0
                    },
                    individualSelector: (0, dataLabelViewModel1.WD)({
                        featureSwitches: this.featureSwitches,
                        hasCategories: null === (_a = this.data) || void 0 === _a ? void 0 : _a.hasCategoryData,
                        hasDynamicSeries: Boolean(null === (_e = null === (_c = null === (_b = _.first(this.dataViews)) || void 0 === _b ? void 0 : _b.categorical) || void 0 === _c ? void 0 : _c.values) || void 0 === _e ? void 0 : _e.source),
                        hasSeriesSelector: !1
                    })
                });
            }, Treemap.checkValueForShape = function(value, cullableValue, allValuesAreNegative, dataWasCulled) {
                var shouldCullValue;
                return value ? (shouldCullValue = allValuesAreNegative ? Math.abs(value) < cullableValue : value < cullableValue) ? {
                    validShape: !1,
                    dataWasCulled: dataWasCulled = dataWasCulled || shouldCullValue
                } : {
                    validShape: !0,
                    dataWasCulled
                } : {
                    validShape: !1,
                    dataWasCulled
                };
            }, Treemap.prototype.calculateTreemapSize = function() {
                var legendMargins = this.legend.getMargins();
                return {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
            }, Treemap.prototype.initViewportDependantProperties = function(duration) {
                void 0 === duration && (duration = 0);
                var viewport = this.calculateTreemapSize();
                this.svg.attr("width", viewport.width).attr("height", viewport.height), (0, legend_util.xz)(this.svg, this.legend);
            }, Treemap.canDisplayMajorLabel = function(node, labelSettings) {
                return !(1 !== node.depth || _.isEmpty(node.data.name) || node.x1 - node.x0 - 2 * Treemap.TextMargin < Treemap.MinTextWidthForMajorLabel || node.y1 - node.y0 < labelSettings.fontProperties.size.px + 2 * Treemap.TextMargin);
            }, Treemap.canDisplayMinorLabel = function(node, dataLabelSettings, categoryLabelSettings) {
                if (node.depth < 1 || node.depth > 2) return !1;
                if (1 === node.depth && (node.children || !dataLabelSettings.show)) return !1;
                if (_.isEmpty(node.data.name)) return !1;
                var nodeHeight = node.y1 - node.y0;
                if (node.x1 - node.x0 - 2 * Treemap.TextMargin < Treemap.MinTextWidthForMinorLabel) return !1;
                var textHeightWithMargin = dataLabelSettings.fontProperties.size.px + 2 * Treemap.TextMargin;
                if (nodeHeight < textHeightWithMargin) return !1;
                if (1 === node.depth) {
                    if (node.y0 + nodeHeight - (roomTop = node.y0 + categoryLabelSettings.fontProperties.size.px + 2 * Treemap.TextMargin) < textHeightWithMargin) return !1;
                } else if (2 === node.depth) {
                    var roomTop = Math.max(node.parent.y0 + categoryLabelSettings.fontProperties.size.px + 2 * Treemap.TextMargin, node.y0);
                    if (node.y0 + nodeHeight - roomTop < textHeightWithMargin) return !1;
                }
                return !0;
            }, Treemap.createMajorLabelText = function(node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.x1 - node.x0 - 2 * Treemap.TextMargin, textProperties = (0, 
                fontProperties.qk)(labelsSettings.fontProperties, node.data.name);
                return textMeasurementService.b.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
            }, Treemap.createMinorLabelText = function(node, dataLabelsSettings, alternativeScale, formattersCache, categoryLabelsSettings) {
                var spaceAvailableForLabels = node.x1 - node.x0 - 2 * Treemap.TextMargin, nodeData = node.data, label = nodeData.name;
                if (dataLabelsSettings.show) {
                    var measureFormatter = formattersCache.getOrCreate(nodeData.labelFormatString, dataLabelsSettings, alternativeScale), highlightFormatter = formattersCache.getOrCreate(nodeData.highlightLabelFormatString, dataLabelsSettings, alternativeScale);
                    label = (0, dataLabelViewModel1.Gv)({
                        label: null != nodeData.originalHighlightValue ? nodeData.originalHighlightValue : nodeData.originalValue,
                        maxWidth: spaceAvailableForLabels,
                        formatter: null != nodeData.originalHighlightValue ? highlightFormatter : measureFormatter,
                        fontProperties: dataLabelsSettings.fontProperties
                    }), categoryLabelsSettings.show && 2 === node.depth && (label = (0, dataLabelViewModel1.Gv)({
                        label: nodeData.name,
                        maxWidth: spaceAvailableForLabels,
                        fontProperties: dataLabelsSettings.fontProperties
                    }) + " " + label);
                }
                return (0, dataLabelViewModel1.Gv)({
                    label,
                    maxWidth: spaceAvailableForLabels,
                    fontProperties: dataLabelsSettings.fontProperties
                });
            }, Treemap.prototype.updateInternal = function(suppressAnimations) {
                var data = this.data, hasHighlights = data && data.hasHighlights, dataLabelSettings = data ? data.dataLabelSettings : Treemap.getDefaultTreemapDataLabelSettings(this.style), categoryLabelsSettings = data ? data.categoryLabelSettings : Treemap.getDefaultTreemapCategoryLabelSettings(this.style), duration = (0, 
                animatorCommon.Mb)(this.animator, suppressAnimations);
                this.options.interactivity && this.options.interactivity.mobileTileInteractive || !this.data || this.renderLegend(), 
                this.initViewportDependantProperties(duration);
                var viewport = this.calculateTreemapSize();
                this.treemap = this.treemap.size([ viewport.width, viewport.height ]);
                var nodes = [];
                if (data && data.root) {
                    var rootHierarchy = d3.hierarchy(data.root).sum(function(d) {
                        return d.size;
                    }).sort(function(a, b) {
                        return b.value - a.value;
                    });
                    this.treemap(rootHierarchy).each(function(node) {
                        nodes.push(node);
                    });
                }
                var highlightNodes = nodes.filter(function(value) {
                    return null != value.data.highlightMultiplier && (!value.children || 0 === value.children.length);
                }), majorLabeledNodes = [], minorLabeledNodes = [], alternativeScale = null;
                categoryLabelsSettings.show && (majorLabeledNodes = nodes.filter(function(d) {
                    return Treemap.canDisplayMajorLabel(d, categoryLabelsSettings);
                })), (dataLabelSettings.show || categoryLabelsSettings.show) && (minorLabeledNodes = nodes.filter(function(d) {
                    return Treemap.canDisplayMinorLabel(d, dataLabelSettings, categoryLabelsSettings);
                }), 0 === dataLabelSettings.displayUnits && (alternativeScale = d3.max(minorLabeledNodes, function(d) {
                    return Math.abs(d.value);
                })));
                var shapes, highlightShapes, majorLabels, minorLabels, result, treemapLayout = Treemap.getLayout(dataLabelSettings, alternativeScale, categoryLabelsSettings);
                if (this.animator && !suppressAnimations && (shapes = (result = this.animator.animate({
                    viewModel: data,
                    nodes,
                    highlightNodes,
                    majorLabeledNodes,
                    minorLabeledNodes,
                    shapeGraphicsContext: this.shapeGraphicsContext,
                    labelGraphicsContext: this.labelGraphicsContext,
                    interactivityService: this.interactivityService,
                    layout: treemapLayout,
                    dataLabelSettings,
                    categoryLabelSettings: categoryLabelsSettings
                })).shapes, highlightShapes = result.highlightShapes, majorLabels = result.majorLabels, 
                minorLabels = result.minorLabels), !this.animator || suppressAnimations || result.failed) {
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), shapeGraphicsContext = this.shapeGraphicsContext;
                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasHighlights, treemapLayout, this.interactivityService), 
                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights, treemapLayout);
                    var labelGraphicsContext = this.labelGraphicsContext;
                    majorLabels = Treemap.drawDefaultMajorLabels(labelGraphicsContext, majorLabeledNodes, categoryLabelsSettings, treemapLayout), 
                    minorLabels = Treemap.drawDefaultMinorLabels(labelGraphicsContext, minorLabeledNodes, dataLabelSettings, treemapLayout);
                }
                if (this.featureSwitches.onObject && ((0, treemapUtils.rI)(shapes, this.hostService, treemapLayout), 
                (0, treemapUtils.$s)(majorLabels, "category-labels"), dataLabelSettings.show ? (0, 
                treemapUtils.$s)(minorLabels, "data-labels") : (0, treemapUtils.Vi)(minorLabels)), 
                this.interactivityService) {
                    this.navigationStrategy = !this.data.hasCategoryData && this.data.hasSeriesData ? interactivityService.jN.SeriesOnly : this.data.hasCategoryData && this.data.hasSeriesData ? interactivityService.jN.CategoryFirst : interactivityService.jN.CategoryOnly;
                    var interactivityServiceOptions = {
                        navigationOptions: {
                            navigationStrategy: this.navigationStrategy,
                            helper: this
                        },
                        pointSourceKey: "treemap"
                    }, behaviorOptions = {
                        root: this.shapeGraphicsContext,
                        shapes,
                        highlightShapes,
                        majorLabels,
                        minorLabels,
                        nodes,
                        hasHighlights: data.hasHighlights,
                        visualInstanceId: this.hostService.instanceId,
                        hitTester: new TreeMapHitTester({
                            nodes
                        })
                    };
                    this.interactivityService.bind(_.map(nodes, function(node) {
                        return node.data;
                    }), this.behavior, behaviorOptions, interactivityServiceOptions);
                }
                this.tooltipsEnabled && this.addTooltips(shapes, highlightShapes);
            }, Treemap.prototype.getSelectorsByColumnSubSelection = function(e) {
                if ("category" === d3.select(e).attr(htmlSubSelectionHelper.Ez)) {
                    var selectorsByColumn = d3.select(e).datum().data.identity.getSelectorsByColumn();
                    if (selectorsByColumn) return selectorsByColumn;
                }
                return {};
            }, Treemap.prototype.getSubSelectionShortcuts = function(subSelections, filter) {
                var _a, _b, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0 && !_.isEmpty(visualObjects[0])) {
                    var deleteKeyboardShortcut = {
                        key: "Delete",
                        nextValue: !1
                    };
                    switch (visualObjects[0].objectName) {
                      case "legend-title":
                        return (0, legend_formatting.tV)(this.hostService);

                      case "legend-items":
                        return (0, legend_formatting.tY)({
                            hostServices: this.hostService,
                            showSort: !1
                        });

                      case "category":
                        var hasDynamicSeries = !!(null === (_b = null === (_a = _.first(this.dataViews).categorical) || void 0 === _a ? void 0 : _a.values) || void 0 === _b ? void 0 : _b.source);
                        return [ {
                            type: 0,
                            excludedResetFormattingIds: [ treemap_capabilities._H.categoryLabels.show, treemap_capabilities._H.labels.show ]
                        }, (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, treemap_capabilities._H.categoryLabels.show), {
                            enabledLabel: this.hostService.getLocalizedString("Visual_Add_CategoryLabel")
                        }), (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, treemap_capabilities._H.labels.show), {
                            enabledLabel: this.hostService.getLocalizedString("Format_AddDataLabels")
                        }), {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("colors"),
                                groupUid: hasDynamicSeries || !this.cartesianConditionalFormatting ? "".concat("colors", "-").concat("default") : "".concat("colors", "-").concat("colors")
                            },
                            label: this.hostService.getLocalizedString("Format_Categories")
                        } ];

                      case "category-labels":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, treemap_capabilities._H.categoryLabels.show), {
                            disabledLabel: this.hostService.getLocalizedString("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            excludedResetFormattingIds: [ treemap_capabilities._H.categoryLabels.show ]
                        }, {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("categoryLabels"),
                                groupUid: "".concat("categoryLabels", "-").concat("values")
                            },
                            label: this.hostService.getLocalizedString("Format_Category_Labels")
                        } ];

                      case "data-labels":
                        return [ (0, tslib_es6.__assign)((0, tslib_es6.__assign)({
                            type: 2
                        }, treemap_capabilities._H.labels.show), {
                            disabledLabel: this.hostService.getLocalizedString("Delete"),
                            keyboardShortcuts: [ deleteKeyboardShortcut ]
                        }), {
                            type: 0,
                            excludedResetFormattingIds: [ treemap_capabilities._H.labels.show ]
                        }, {
                            type: 1,
                            destinationInfo: {
                                cardUid: "".concat("Visual", "-").concat("labels")
                            },
                            label: this.hostService.getLocalizedString("Format_Data_Labels")
                        } ];

                      default:
                        return;
                    }
                }
            }, Treemap.prototype.getSubSelectionStyles = function(subSelections) {
                var _a, _b, visualObject, selector, visualObjects = _.first(subSelections).visualObjects;
                if (visualObjects.length > 0) switch ((visualObject = visualObjects[0]) && visualObject.selectorsByColumn && (selector = (0, 
                contracts_selector.fd)((0, contracts_selector.tV)(visualObject.selectorsByColumn))), 
                visualObject.objectName) {
                  case "legend-title":
                    return (0, legend_formatting.aJ)();

                  case "legend-items":
                    return (0, legend_formatting.Gh)(this.hostService);

                  case "category":
                    return (0, onObjectUtil.w3)(this.hostService, void 0, (0, tslib_es6.__assign)({
                        selector
                    }, treemap_capabilities._H.dataPoint.fill));

                  case "category-labels":
                    var categoryLabels = treemap_capabilities._H.categoryLabels;
                    return (0, onObjectUtil.un)(this.hostService, {
                        fontFamilyReference: categoryLabels.fontFamily,
                        fontSizeReference: categoryLabels.fontSize,
                        boldReference: categoryLabels.bold,
                        italicReference: categoryLabels.italic,
                        underlineReference: categoryLabels.underline,
                        fontColorReference: (0, tslib_es6.__assign)((0, tslib_es6.__assign)({}, categoryLabels.color), {
                            selector: {
                                data: [ (0, dataViewWildcard.Ue)(1) ]
                            }
                        })
                    });

                  case "data-labels":
                    var labels = treemap_capabilities._H.labels, labelReferences = {
                        fontFamilyReference: labels.fontFamily,
                        fontSizeReference: labels.fontSize,
                        boldReference: labels.bold,
                        italicReference: labels.italic,
                        underlineReference: labels.underline,
                        fontColorReference: labels.color,
                        displayUnitsReference: labels.labelDisplayUnits,
                        precisionReference: labels.labelPrecision
                    };
                    return (0, onObjectUtil.Jf)({
                        hostServices: this.hostService,
                        omitSelectorForSingleSeries: !1,
                        individualSelector: (0, dataLabelViewModel1.WD)({
                            featureSwitches: this.featureSwitches,
                            hasCategories: this.data.hasCategoryData,
                            hasDynamicSeries: !!(null === (_b = null === (_a = _.first(this.dataViews).categorical) || void 0 === _a ? void 0 : _a.values) || void 0 === _b ? void 0 : _b.source),
                            hasSeriesSelector: !1
                        }),
                        selector: void 0,
                        repetitionSelector: void 0
                    }, labelReferences);

                  default:
                    return;
                }
            }, Treemap.prototype.getNextSubSelectable = function(currentSubSelectable, backwards) {
                return this.subSelectionHelper.getNextSubSelectable(currentSubSelectable, backwards);
            }, Treemap.prototype.getSubSelectables = function(filterType) {
                return this.subSelectionHelper.getAllSubSelectables(filterType);
            }, Treemap.prototype.getFirstElement = function() {
                var pointData = this.data.flattenedViewModel;
                return _.isEmpty(pointData) ? {
                    element: null
                } : {
                    element: this.findHTMLElement(pointData[0].categoryIndex, pointData[0].seriesIndex)
                };
            }, Treemap.prototype.getNextDataPoint = function(categoryIndex, seriesIndex, direction) {
                var nextDataPoint = (0, navigationUtils.R)(this.data.flattenedViewModel, categoryIndex, seriesIndex, this.navigationStrategy, direction);
                return {
                    element: this.findHTMLElement(nextDataPoint.categoryIndex, nextDataPoint.seriesIndex)
                };
            }, Treemap.prototype.findHTMLElement = function(categoryIndex, seriesIndex) {
                return this.shapeGraphicsContext.selectAll("." + (this.navigationStrategy === interactivityService.jN.CategoryFirst ? Treemap.NodeGroupClassName : Treemap.ParentGroupClassName)).filter("." + treemapUtils.Sh.node).filter(function(d) {
                    return d.data.categoryIndex === categoryIndex && d.data.seriesIndex === seriesIndex;
                }).node();
            }, Treemap.flattenViewModel = function(root, treemap) {
                return treemap(d3.hierarchy(root).sum(function(d) {
                    return d.size;
                }).sort(function(a, b) {
                    return b.value - a.value;
                })).leaves().map(function(leaf) {
                    return {
                        categoryIndex: leaf.data.categoryIndex,
                        seriesIndex: leaf.data.seriesIndex
                    };
                });
            }, Treemap.prototype.addTooltips = function(shapes, highlightShapes) {
                this.tooltipService.addTooltip(shapes, function(args) {
                    return args.data && (args.data.data.highlightedTooltipInfo ? args.data.data.highlightedTooltipInfo : args.data.data.tooltipInfo);
                }, function(args) {
                    return args.data && args.data.data.identity && [ args.data.data.identity ];
                }), this.tooltipService.addTooltip(highlightShapes, function(args) {
                    return args.data && args.data.data.highlightedTooltipInfo;
                }, function(args) {
                    return args.data && args.data.data.identity && [ args.data.data.identity ];
                });
            }, Treemap.prototype.renderLegend = function() {
                var legendData = this.data.legendObjectProperties ? this.data.legendData : (0, legend_converter.Fe)(this.style);
                null != legendData.position && this.legend.setPosition(legendData.position), this.legend.drawLegend({
                    data: legendData,
                    parentViewport: this.currentViewport,
                    formatMode: this.formatMode,
                    onObject: this.featureSwitches.onObject,
                    titleSliceUid: "".concat("legend", "-").concat("title", "-titleText")
                });
            }, Treemap.getNodeClass = function(d, highlight) {
                var nodeClass;
                switch (d.depth) {
                  case 1:
                    nodeClass = Treemap.ParentGroupClassName;
                    break;

                  case 2:
                    nodeClass = Treemap.NodeGroupClassName;
                    break;

                  case 0:
                    nodeClass = Treemap.RootNodeClassName;
                    break;

                  default:
                    debug.fF.assertFail("Treemap only supports 2 levels maxiumum");
                }
                return nodeClass + " " + (highlight ? treemapUtils.Sh.highlight : treemapUtils.Sh.node);
            }, Treemap.isAriaHidden = function(d) {
                return 0 === d.depth;
            }, Treemap.getNodeAccesibilityRole = function(d) {
                switch (d.depth) {
                  case 1:
                    return d.data.seriesIndex ? "group" : "treeitem";

                  case 2:
                  case 0:
                    return "treeitem";

                  default:
                    debug.fF.assertFail("Treemap only supports 2 levels maxiumum");
                }
            }, Treemap.createTreemapShapeLayout = function(isHighlightRect) {
                return void 0 === isHighlightRect && (isHighlightRect = !1), isHighlightRect ? {
                    x: function(d) {
                        return d.x0 + .2;
                    },
                    y: function(d) {
                        return d.y0 + (d.y1 - d.y0) * (1 - d.data.highlightMultiplier);
                    },
                    width: function(d) {
                        return Math.max(0, d.x1 - d.x0 - .4);
                    },
                    height: function(d) {
                        return Math.max(0, (d.y1 - d.y0) * d.data.highlightMultiplier);
                    },
                    "stroke-dasharray": function(d) {
                        var width = d.x1 - d.x0;
                        return "0.6," + (width - 1.2) + "," + (2 * (d.y1 - d.y0) + width);
                    }
                } : {
                    x: function(d) {
                        return d.x0;
                    },
                    y: function(d) {
                        return d.y0;
                    },
                    width: function(d) {
                        return Math.max(0, d.x1 - d.x0);
                    },
                    height: function(d) {
                        return Math.max(0, d.y1 - d.y0);
                    },
                    "stroke-dasharray": null
                };
            }, Treemap.createTreemapZeroShapeLayout = function() {
                return {
                    x: function(d) {
                        return d.x0;
                    },
                    y: function(d) {
                        return d.y1;
                    },
                    width: function(d) {
                        return Math.max(0, d.x1 - d.x0);
                    },
                    height: function(_d) {
                        return 0;
                    }
                };
            }, Treemap.drawDefaultShapes = function(context, nodes, hasHighlights, layout, interactivityService) {
                var shapes = context.selectAll("." + treemapUtils.Sh.node).data(nodes, function(d) {
                    return d.data.key;
                }), isEdgeOrIE = browserUtils.M.isInternetExplorerOrEdge(), hasSelection = interactivityService && interactivityService.hasSelection(), shapeEnter = shapes.enter().append("rect").attr("class", layout.shapeClass), allShapes = shapes.merge(shapeEnter).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !1);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !1);
                }).attr("aria-label", function(d) {
                    return d.data.formattedTooltip;
                }).attr("role", layout.role).attr("aria-hidden", layout.ariaHidden).attr("aria-checked", function(d) {
                    return null === d.parent ? null : d.data.selected;
                }).attrs(layout.shapeLayout);
                return interactivityService && allShapes.attr("tabindex", function(d) {
                    return null == d.value || layout.ariaHidden(d) ? null : 0;
                }).attr("focusable", function(d) {
                    return null != d.value && !layout.ariaHidden(d) || null;
                }).classed(renderUtil.Pg, !isEdgeOrIE), shapes.exit().remove(), allShapes;
            }, Treemap.drawDefaultHighlightShapes = function(context, nodes, hasSelection, hasHighlights, layout) {
                var highlightShapes = context.selectAll("." + treemapUtils.Sh.highlight).data(nodes, function(d) {
                    return d.data.key + "highlight";
                }), highlightEnter = highlightShapes.enter().append("rect").attr("class", layout.highlightShapeClass), allShapes = highlightShapes.merge(highlightEnter).style("fill", function(d) {
                    return (0, treemapUtils._M)(d, !0);
                }).style("fill-opacity", function(d) {
                    return (0, treemapUtils.eR)(d, hasSelection, hasHighlights, !0);
                }).attrs(layout.highlightShapeLayout);
                return highlightShapes.exit().remove(), allShapes;
            }, Treemap.drawDefaultMajorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + treemapUtils.Sh.major).data(nodes, function(d) {
                    return d.data.key;
                }), labelEnter = labels.enter().append("text").attr("class", layout.majorLabelClass), allLabels = labels.merge(labelEnter).attrs(layout.majorLabelLayout).text(layout.majorLabelText).styles(function(hNode) {
                    return (0, fontProperties.rL)(labelSettings.fontProperties, {
                        color: hNode.data.categoryLabelFill
                    });
                });
                return labels.exit().remove(), allLabels;
            }, Treemap.drawDefaultMinorLabels = function(context, nodes, labelSettings, layout) {
                var labels = context.selectAll("." + treemapUtils.Sh.minor).data(nodes, function(d) {
                    return d.data.key;
                }), labelEnter = labels.enter().append("text").attr("class", layout.minorLabelClass), allLabels = labels.merge(labelEnter).attrs(layout.minorLabelLayout).text(layout.minorLabelText).styles(function(hNode) {
                    return (0, fontProperties.rL)(labelSettings.fontProperties, {
                        color: hNode.data.labelFill
                    });
                });
                return labels.exit().remove(), allLabels;
            }, Treemap.cleanMinorLabels = function(context) {
                context.selectAll("." + Treemap.LabelsGroupClassName).selectAll("." + treemapUtils.Sh.minor).data([]).exit().remove();
            }, Treemap.ClassName = "treemap", Treemap.LabelsGroupClassName = "labels", Treemap.ShapesClassName = "shapes", 
            Treemap.RootNodeClassName = "rootNode", Treemap.ParentGroupClassName = "parentGroup", 
            Treemap.NodeGroupClassName = "nodeGroup", Treemap.MinTextWidthForMinorLabel = 18, 
            Treemap.MinTextWidthForMajorLabel = 22, Treemap.TextMargin = 5, Treemap.CullableArea = 9, 
            Treemap;
        }(), TreeMapHitTester = function() {
            function TreeMapHitTester(options) {
                this.nodes = options.nodes;
            }
            return TreeMapHitTester.prototype.queryRegion = function(rect) {
                return this.getSelectedDataPoints(this.nodes, rect);
            }, TreeMapHitTester.prototype.getSelectedDataPoints = function(nodes, rect) {
                for (var result = [], _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                    var node = nodes_1[_i];
                    node.children && node.children.length || this.isNodeOverlapingBounds(node, rect) && result.push(node.data);
                }
                return result;
            }, TreeMapHitTester.prototype.isNodeOverlapingBounds = function(node, rect) {
                var nodePosition = this.getNodeCoordinate(node);
                return (0, shapes6.WN)(nodePosition.left, nodePosition.right, rect.left, rect.right) && (0, 
                shapes6.WN)(nodePosition.top, nodePosition.bottom, rect.top, rect.bottom);
            }, TreeMapHitTester.prototype.getNodeCoordinate = function(node) {
                return {
                    left: node.x0,
                    right: node.x1,
                    top: node.y0,
                    bottom: node.y1
                };
            }, TreeMapHitTester;
        }();
        function webAnimator() {
            return new WebTreemapAnimator;
        }
        function webBehavior() {
            return new TreemapWebBehavior;
        }
    }
} ]);