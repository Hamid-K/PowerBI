"use strict";

(self.webpackChunkdesktop = self.webpackChunkdesktop || []).push([ [ "leads-collection-dialog" ], {
    62113: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Q: function() {
                return AccessTokenProviderService;
            }
        });
        var AuthorityType, tslib_es6 = __webpack_require__(81337), InteractionRequiredAuthError = __webpack_require__(29019), utils_Constants = __webpack_require__(66422), _tslib = __webpack_require__(37241), AuthError = __webpack_require__(41170), ClientAuthError_ClientAuthError = function(_super) {
            function ClientAuthError(errorCode, errorMessage) {
                var _this = _super.call(this, errorCode, errorMessage) || this;
                return _this.name = "ClientAuthError", Object.setPrototypeOf(_this, ClientAuthError.prototype), 
                _this;
            }
            return (0, _tslib.ZT)(ClientAuthError, _super), ClientAuthError.createClientInfoDecodingError = function(caughtError) {
                return new ClientAuthError("client_info_decoding_error", "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause. Failed with error: " + caughtError);
            }, ClientAuthError.createClientInfoEmptyError = function() {
                return new ClientAuthError("client_info_empty_error", "The client info was empty. Please review the trace to determine the root cause.");
            }, ClientAuthError.createTokenParsingError = function(caughtExtractionError) {
                return new ClientAuthError("token_parsing_error", "Token cannot be parsed. Please review stack trace to determine root cause. Failed with error: " + caughtExtractionError);
            }, ClientAuthError.createTokenNullOrEmptyError = function(invalidRawTokenString) {
                return new ClientAuthError("null_or_empty_token", "The token is null or empty. Please review the trace to determine the root cause. Raw Token Value: " + invalidRawTokenString);
            }, ClientAuthError.createEndpointDiscoveryIncompleteError = function(errDetail) {
                return new ClientAuthError("endpoints_resolution_error", "Error: could not resolve endpoints. Please check network and try again. Detail: " + errDetail);
            }, ClientAuthError.createNetworkError = function(endpoint, errDetail) {
                return new ClientAuthError("network_error", "Network request failed. Please check network trace to determine root cause. | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
            }, ClientAuthError.createUnableToGetOpenidConfigError = function(errDetail) {
                return new ClientAuthError("openid_config_error", "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints. Attempted to retrieve endpoints from: " + errDetail);
            }, ClientAuthError.createHashNotDeserializedError = function(hashParamObj) {
                return new ClientAuthError("hash_not_deserialized", "The hash parameters could not be deserialized. Please review the trace to determine the root cause. Given Object: " + hashParamObj);
            }, ClientAuthError.createInvalidStateError = function(invalidState, errorString) {
                return new ClientAuthError("invalid_state", "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState(). Invalid State: " + invalidState + ", Root Err: " + errorString);
            }, ClientAuthError.createStateMismatchError = function() {
                return new ClientAuthError("state_mismatch", "State mismatch error. Please check your network. Continued requests may cause cache overflow.");
            }, ClientAuthError.createStateNotFoundError = function(missingState) {
                return new ClientAuthError("state_not_found", "State not found:  " + missingState);
            }, ClientAuthError.createNonceMismatchError = function() {
                return new ClientAuthError("nonce_mismatch", "Nonce mismatch error. This may be caused by a race condition in concurrent requests.");
            }, ClientAuthError.createNonceNotFoundError = function(missingNonce) {
                return new ClientAuthError("nonce_not_found", "nonce not found:  " + missingNonce);
            }, ClientAuthError.createMultipleMatchingTokensInCacheError = function() {
                return new ClientAuthError("multiple_matching_tokens", "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account..");
            }, ClientAuthError.createMultipleMatchingAccountsInCacheError = function() {
                return new ClientAuthError("multiple_matching_accounts", "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account");
            }, ClientAuthError.createMultipleMatchingAppMetadataInCacheError = function() {
                return new ClientAuthError("multiple_matching_appMetadata", "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata");
            }, ClientAuthError.createTokenRequestCannotBeMadeError = function() {
                return new ClientAuthError("request_cannot_be_made", "Token request cannot be made without authorization code or refresh token.");
            }, ClientAuthError.createAppendEmptyScopeToSetError = function(givenScope) {
                return new ClientAuthError("cannot_append_empty_scope", "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info. Given Scope: " + givenScope);
            }, ClientAuthError.createRemoveEmptyScopeFromSetError = function(givenScope) {
                return new ClientAuthError("cannot_remove_empty_scope", "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info. Given Scope: " + givenScope);
            }, ClientAuthError.createAppendScopeSetError = function(appendError) {
                return new ClientAuthError("cannot_append_scopeset", "Cannot append ScopeSet due to error. Detail Error: " + appendError);
            }, ClientAuthError.createEmptyInputScopeSetError = function() {
                return new ClientAuthError("empty_input_scopeset", "Empty input ScopeSet cannot be processed.");
            }, ClientAuthError.createDeviceCodeCancelledError = function() {
                return new ClientAuthError("device_code_polling_cancelled", "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.");
            }, ClientAuthError.createDeviceCodeExpiredError = function() {
                return new ClientAuthError("device_code_expired", "Device code is expired.");
            }, ClientAuthError.createDeviceCodeUnknownError = function() {
                return new ClientAuthError("device_code_unknown_error", "Device code stopped polling for unknown reasons.");
            }, ClientAuthError.createNoAccountInSilentRequestError = function() {
                return new ClientAuthError("no_account_in_silent_request", "Please pass an account object, silent flow is not supported without account information");
            }, ClientAuthError.createNullOrUndefinedCacheRecord = function() {
                return new ClientAuthError("invalid_cache_record", "Cache record object was null or undefined.");
            }, ClientAuthError.createInvalidCacheEnvironmentError = function() {
                return new ClientAuthError("invalid_cache_environment", "Invalid environment when attempting to create cache entry");
            }, ClientAuthError.createNoAccountFoundError = function() {
                return new ClientAuthError("no_account_found", "No account found in cache for given key.");
            }, ClientAuthError.createCachePluginError = function() {
                return new ClientAuthError("no cache plugin set on CacheManager", "ICachePlugin needs to be set before using readFromStorage or writeFromStorage");
            }, ClientAuthError.createNoCryptoObjectError = function(operationName) {
                return new ClientAuthError("no_crypto_object", "No crypto object detected. This is required for the following operation: " + operationName);
            }, ClientAuthError.createInvalidCacheTypeError = function() {
                return new ClientAuthError("invalid_cache_type", "Invalid cache type");
            }, ClientAuthError.createUnexpectedAccountTypeError = function() {
                return new ClientAuthError("unexpected_account_type", "Unexpected account type.");
            }, ClientAuthError.createUnexpectedCredentialTypeError = function() {
                return new ClientAuthError("unexpected_credential_type", "Unexpected credential type.");
            }, ClientAuthError.createInvalidAssertionError = function() {
                return new ClientAuthError("invalid_assertion", "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515");
            }, ClientAuthError.createInvalidCredentialError = function() {
                return new ClientAuthError("invalid_client_credential", "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential");
            }, ClientAuthError.createRefreshRequiredError = function() {
                return new ClientAuthError("token_refresh_required", "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.");
            }, ClientAuthError.createUserTimeoutReachedError = function() {
                return new ClientAuthError("user_timeout_reached", "User defined timeout for device code polling reached");
            }, ClientAuthError.createTokenClaimsRequiredError = function() {
                return new ClientAuthError("token_claims_cnf_required_for_signedjwt", "Cannot generate a POP jwt if the token_claims are not populated");
            }, ClientAuthError.createNoAuthCodeInServerResponseError = function() {
                return new ClientAuthError("authorization_code_missing_from_server_response", "Server response does not contain an authorization code to proceed");
            }, ClientAuthError.createBindingKeyNotRemovedError = function() {
                return new ClientAuthError("binding_key_not_removed", "Could not remove the credential's binding key from storage.");
            }, ClientAuthError.createLogoutNotSupportedError = function() {
                return new ClientAuthError("end_session_endpoint_not_supported", "Provided authority does not support logout.");
            }, ClientAuthError.createKeyIdMissingError = function() {
                return new ClientAuthError("key_id_missing", "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.");
            }, ClientAuthError;
        }(AuthError.l), StringUtils_StringUtils = function() {
            function StringUtils() {}
            return StringUtils.decodeAuthToken = function(authToken) {
                if (StringUtils.isEmpty(authToken)) throw ClientAuthError_ClientAuthError.createTokenNullOrEmptyError(authToken);
                var matches = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/.exec(authToken);
                if (!matches || matches.length < 4) throw ClientAuthError_ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
                return {
                    header: matches[1],
                    JWSPayload: matches[2],
                    JWSSig: matches[3]
                };
            }, StringUtils.isEmpty = function(str) {
                return void 0 === str || !str || 0 === str.length;
            }, StringUtils.isEmptyObj = function(strObj) {
                if (strObj && !StringUtils.isEmpty(strObj)) try {
                    var obj = JSON.parse(strObj);
                    return 0 === Object.keys(obj).length;
                } catch (e) {}
                return !0;
            }, StringUtils.startsWith = function(str, search) {
                return 0 === str.indexOf(search);
            }, StringUtils.endsWith = function(str, search) {
                return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
            }, StringUtils.queryStringToObject = function(query) {
                var obj = {}, params = query.split("&"), decode = function(s) {
                    return decodeURIComponent(s.replace(/\+/g, " "));
                };
                return params.forEach(function(pair) {
                    if (pair.trim()) {
                        var _a = pair.split(/=(.+)/g, 2), key = _a[0], value = _a[1];
                        key && value && (obj[decode(key)] = decode(value));
                    }
                }), obj;
            }, StringUtils.trimArrayEntries = function(arr) {
                return arr.map(function(entry) {
                    return entry.trim();
                });
            }, StringUtils.removeEmptyStringsFromArray = function(arr) {
                return arr.filter(function(entry) {
                    return !StringUtils.isEmpty(entry);
                });
            }, StringUtils.jsonParseHelper = function(str) {
                try {
                    return JSON.parse(str);
                } catch (e) {
                    return null;
                }
            }, StringUtils.matchPattern = function(pattern, input) {
                return new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?")).test(input);
            }, StringUtils;
        }();
        !function(AuthorityType) {
            AuthorityType[AuthorityType.Default = 0] = "Default", AuthorityType[AuthorityType.Adfs = 1] = "Adfs";
        }(AuthorityType || (AuthorityType = {}));
        var AccountEntity = function() {
            function AccountEntity() {}
            return AccountEntity.prototype.generateAccountId = function() {
                return [ this.homeAccountId, this.environment ].join(utils_Constants.Bv.CACHE_KEY_SEPARATOR).toLowerCase();
            }, AccountEntity.prototype.generateAccountKey = function() {
                return AccountEntity.generateAccountCacheKey({
                    homeAccountId: this.homeAccountId,
                    environment: this.environment,
                    tenantId: this.realm,
                    username: this.username,
                    localAccountId: this.localAccountId
                });
            }, AccountEntity.prototype.generateType = function() {
                switch (this.authorityType) {
                  case utils_Constants.iR.ADFS_ACCOUNT_TYPE:
                    return utils_Constants.LL.ADFS;

                  case utils_Constants.iR.MSAV1_ACCOUNT_TYPE:
                    return utils_Constants.LL.MSA;

                  case utils_Constants.iR.MSSTS_ACCOUNT_TYPE:
                    return utils_Constants.LL.MSSTS;

                  case utils_Constants.iR.GENERIC_ACCOUNT_TYPE:
                    return utils_Constants.LL.GENERIC;

                  default:
                    throw ClientAuthError_ClientAuthError.createUnexpectedAccountTypeError();
                }
            }, AccountEntity.prototype.getAccountInfo = function() {
                return {
                    homeAccountId: this.homeAccountId,
                    environment: this.environment,
                    tenantId: this.realm,
                    username: this.username,
                    localAccountId: this.localAccountId,
                    name: this.name,
                    idTokenClaims: this.idTokenClaims,
                    nativeAccountId: this.nativeAccountId
                };
            }, AccountEntity.generateAccountCacheKey = function(accountInterface) {
                return [ accountInterface.homeAccountId, accountInterface.environment || utils_Constants.gT.EMPTY_STRING, accountInterface.tenantId || utils_Constants.gT.EMPTY_STRING ].join(utils_Constants.Bv.CACHE_KEY_SEPARATOR).toLowerCase();
            }, AccountEntity.createAccount = function(clientInfo, homeAccountId, idToken, authority, oboAssertion, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
                var _a, _b, _c, _d, _e, _f, account = new AccountEntity;
                account.authorityType = utils_Constants.iR.MSSTS_ACCOUNT_TYPE, account.clientInfo = clientInfo, 
                account.homeAccountId = homeAccountId, account.nativeAccountId = nativeAccountId;
                var env = environment || authority && authority.getPreferredCache();
                if (!env) throw ClientAuthError_ClientAuthError.createInvalidCacheEnvironmentError();
                return account.environment = env, account.realm = (null === (_a = null == idToken ? void 0 : idToken.claims) || void 0 === _a ? void 0 : _a.tid) || utils_Constants.gT.EMPTY_STRING, 
                account.oboAssertion = oboAssertion, idToken && (account.idTokenClaims = idToken.claims, 
                account.localAccountId = (null === (_b = null == idToken ? void 0 : idToken.claims) || void 0 === _b ? void 0 : _b.oid) || (null === (_c = null == idToken ? void 0 : idToken.claims) || void 0 === _c ? void 0 : _c.sub) || utils_Constants.gT.EMPTY_STRING, 
                account.username = (null === (_d = null == idToken ? void 0 : idToken.claims) || void 0 === _d ? void 0 : _d.preferred_username) || ((null === (_e = null == idToken ? void 0 : idToken.claims) || void 0 === _e ? void 0 : _e.emails) ? idToken.claims.emails[0] : utils_Constants.gT.EMPTY_STRING), 
                account.name = null === (_f = null == idToken ? void 0 : idToken.claims) || void 0 === _f ? void 0 : _f.name), 
                account.cloudGraphHostName = cloudGraphHostName, account.msGraphHost = msGraphHost, 
                account;
            }, AccountEntity.createGenericAccount = function(homeAccountId, idToken, authority, oboAssertion, cloudGraphHostName, msGraphHost, environment) {
                var _a, _b, _c, _d, account = new AccountEntity;
                account.authorityType = authority && authority.authorityType === AuthorityType.Adfs ? utils_Constants.iR.ADFS_ACCOUNT_TYPE : utils_Constants.iR.GENERIC_ACCOUNT_TYPE, 
                account.homeAccountId = homeAccountId, account.realm = utils_Constants.gT.EMPTY_STRING, 
                account.oboAssertion = oboAssertion;
                var env = environment || authority && authority.getPreferredCache();
                if (!env) throw ClientAuthError_ClientAuthError.createInvalidCacheEnvironmentError();
                return idToken && (account.localAccountId = (null === (_a = null == idToken ? void 0 : idToken.claims) || void 0 === _a ? void 0 : _a.oid) || (null === (_b = null == idToken ? void 0 : idToken.claims) || void 0 === _b ? void 0 : _b.sub) || utils_Constants.gT.EMPTY_STRING, 
                account.username = (null === (_c = null == idToken ? void 0 : idToken.claims) || void 0 === _c ? void 0 : _c.upn) || utils_Constants.gT.EMPTY_STRING, 
                account.name = (null === (_d = null == idToken ? void 0 : idToken.claims) || void 0 === _d ? void 0 : _d.name) || utils_Constants.gT.EMPTY_STRING, 
                account.idTokenClaims = null == idToken ? void 0 : idToken.claims), account.environment = env, 
                account.cloudGraphHostName = cloudGraphHostName, account.msGraphHost = msGraphHost, 
                account;
            }, AccountEntity.generateHomeAccountId = function(serverClientInfo, authType, logger, cryptoObj, idToken) {
                var _a, accountId = (null === (_a = null == idToken ? void 0 : idToken.claims) || void 0 === _a ? void 0 : _a.sub) ? idToken.claims.sub : utils_Constants.gT.EMPTY_STRING;
                if (authType === AuthorityType.Adfs) return accountId;
                if (serverClientInfo) try {
                    var clientInfo = function(rawClientInfo, crypto) {
                        if (StringUtils_StringUtils.isEmpty(rawClientInfo)) throw ClientAuthError_ClientAuthError.createClientInfoEmptyError();
                        try {
                            var decodedClientInfo = crypto.base64Decode(rawClientInfo);
                            return JSON.parse(decodedClientInfo);
                        } catch (e) {
                            throw ClientAuthError_ClientAuthError.createClientInfoDecodingError(e);
                        }
                    }(serverClientInfo, cryptoObj);
                    if (!StringUtils_StringUtils.isEmpty(clientInfo.uid) && !StringUtils_StringUtils.isEmpty(clientInfo.utid)) return "" + clientInfo.uid + utils_Constants.Bv.CLIENT_INFO_SEPARATOR + clientInfo.utid;
                } catch (e) {}
                return logger.verbose("No client info in response"), accountId;
            }, AccountEntity.isAccountEntity = function(entity) {
                return !!entity && entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
            }, AccountEntity.accountInfoIsEqual = function(accountA, accountB, compareClaims) {
                if (!accountA || !accountB) return !1;
                var claimsMatch = !0;
                if (compareClaims) {
                    var accountAClaims = accountA.idTokenClaims || {}, accountBClaims = accountB.idTokenClaims || {};
                    claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
                }
                return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
            }, AccountEntity;
        }(), Telemetry = __webpack_require__(21617), simple_confirmation_dialog_component = __webpack_require__(98049), msal_service = __webpack_require__(19270), src = __webpack_require__(66070), AccessTokenError = function(_super) {
            function AccessTokenError(message, msalError) {
                var _this = _super.call(this, message) || this;
                return _this.message = message, _this.msalError = msalError, _this;
            }
            return (0, tslib_es6.__extends)(AccessTokenError, _super), AccessTokenError;
        }(Error), telemetryHelpers = __webpack_require__(41114), AppAdHocTokenAcquisition = telemetryHelpers.cx["PBI.App.AdHocTokenAcquisition"] = (0, 
        telemetryHelpers.b1)("PBI.App.AdHocTokenAcquisition"), AppAdHocTokenAcquisitionUserConfirmation = telemetryHelpers.cx["PBI.App.AdHocTokenAcquisition.UserConfirmation"] = (0, 
        telemetryHelpers.b1)("PBI.App.AdHocTokenAcquisition.UserConfirmation"), core = __webpack_require__(50423), dialog_service = __webpack_require__(58938), localization_service = __webpack_require__(65181), commonGlobals = window, AccessTokenProviderService = function() {
            function AccessTokenProviderService(dialogService, localizationService, telemetryService) {
                this.dialogService = dialogService, this.localizationService = localizationService, 
                this.telemetryService = telemetryService, this.msalClientApplication = commonGlobals.msalClientApplication;
            }
            return AccessTokenProviderService.prototype.acquireToken = function(scenarioName, scopes, forceRefresh) {
                var _a;
                return void 0 === forceRefresh && (forceRefresh = !1), (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var signedInAccount, acquireTokenEvent, authResult, error_1, errorMessage;
                    return (0, tslib_es6.__generator)(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            if (signedInAccount = this.retrieveSignedInAccount(), acquireTokenEvent = this.telemetryService.startActivity(null, AppAdHocTokenAcquisition, {
                                scenarioName,
                                authMethod: "Silent"
                            }), !signedInAccount) return [ 3, 5 ];
                            _b.label = 1;

                          case 1:
                            return _b.trys.push([ 1, 3, , 4 ]), [ 4, this.msalClientApplication.acquireTokenSilent({
                                scopes,
                                account: signedInAccount,
                                forceRefresh
                            }) ];

                          case 2:
                            return authResult = _b.sent(), acquireTokenEvent.resolve(), [ 2, {
                                token: authResult.accessToken,
                                expiry: authResult.expiresOn
                            } ];

                          case 3:
                            throw (error_1 = _b.sent()).constructor.name === InteractionRequiredAuthError.Yo.name ? (acquireTokenEvent.reject({
                                errorSource: "External",
                                errorMessage: errorMessage = msal_service.fW.UserInteractionRequired,
                                errorCode: "UserInteractionRequired"
                            }), new AccessTokenError(errorMessage, error_1)) : (errorMessage = null !== (_a = error_1.message) && void 0 !== _a ? _a : error_1, 
                            acquireTokenEvent.reject({
                                errorSource: "External",
                                errorMessage,
                                errorCode: error_1.code
                            }), new AccessTokenError("Error code: ".concat(error_1.code, ", error message: ").concat(errorMessage), error_1));

                          case 4:
                            return [ 3, 6 ];

                          case 5:
                            throw acquireTokenEvent.reject({
                                errorSource: "PowerBI",
                                errorMessage: errorMessage = msal_service.fW.UserNotSignedIn,
                                errorCode: "UserNotSignedIn"
                            }), Error(errorMessage);

                          case 6:
                            return [ 2 ];
                        }
                    });
                });
            }, AccessTokenProviderService.prototype.acquireTokenPopup = function(scenarioName, scopes) {
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var _this = this;
                    return (0, tslib_es6.__generator)(this, function(_a) {
                        return [ 2, src.kB.retryOnInteractionInProgressError(function() {
                            return _this.acquireTokenPopupInternal(scenarioName, scopes);
                        }) ];
                    });
                });
            }, AccessTokenProviderService.prototype.acquireTokenPopupInternal = function(scenarioName, scopes) {
                var _a;
                return (0, tslib_es6.__awaiter)(this, void 0, void 0, function() {
                    var result, signedInAccount, acquireTokenEvent, authResult, error_2, errorMessage;
                    return (0, tslib_es6.__generator)(this, function(_b) {
                        switch (_b.label) {
                          case 0:
                            return [ 4, this.dialogService.open(simple_confirmation_dialog_component.J, {
                                data: {
                                    title: this.localizationService.get("AcquireToken_Dialog_VerifyIdentity"),
                                    ariaLabel: this.localizationService.get("AcquireToken_Dialog_SelectContinue"),
                                    message: this.localizationService.get("AcquireToken_Dialog_SelectContinue"),
                                    okButtonText: this.localizationService.get("ModalDialogButtonText_Continue"),
                                    cancelButtonText: this.localizationService.get("ModalDialog_Cancel")
                                },
                                autoFocus: !0
                            }).afterClosed().toPromise() ];

                          case 1:
                            if (result = _b.sent(), this.telemetryService.logEvent(AppAdHocTokenAcquisitionUserConfirmation, {
                                scenarioName,
                                authMethod: "Popup",
                                result: 1 === result
                            }), 1 !== result) throw Error(msal_service.fW.UserInteractionDeclined);
                            signedInAccount = this.retrieveSignedInAccount(), acquireTokenEvent = this.telemetryService.startActivity(null, AppAdHocTokenAcquisition, {
                                scenarioName,
                                authMethod: "Popup"
                            }), _b.label = 2;

                          case 2:
                            return _b.trys.push([ 2, 4, , 5 ]), [ 4, this.msalClientApplication.acquireTokenPopup({
                                scopes,
                                account: signedInAccount
                            }) ];

                          case 3:
                            return authResult = _b.sent(), this.msalClientApplication.setActiveAccount(authResult.account), 
                            [ 3, 5 ];

                          case 4:
                            throw error_2 = _b.sent(), errorMessage = null !== (_a = error_2.message) && void 0 !== _a ? _a : error_2, 
                            acquireTokenEvent.reject({
                                errorSource: "External",
                                errorMessage,
                                errorCode: error_2.code
                            }), new AccessTokenError("Error code: ".concat(error_2.code, ", error message: ").concat(errorMessage), error_2);

                          case 5:
                            if (!AccountEntity.accountInfoIsEqual(null != signedInAccount ? signedInAccount : null, authResult.account)) throw acquireTokenEvent.reject({
                                errorSource: "External",
                                errorMessage: msal_service.fW.UserAccountChanged,
                                errorCode: "UserAccountChanged"
                            }), this.reloadPage(), Error(msal_service.fW.UserAccountChanged);
                            return acquireTokenEvent.resolve(), [ 2, {
                                token: authResult.accessToken,
                                expiry: authResult.expiresOn
                            } ];
                        }
                    });
                });
            }, AccessTokenProviderService.prototype.reloadPage = function() {
                window.location.reload();
            }, AccessTokenProviderService.prototype.retrieveSignedInAccount = function() {
                return commonGlobals.signInProviderService.retrieveSignedInAccount();
            }, AccessTokenProviderService.\u0275fac = function(t) {
                return new (t || AccessTokenProviderService)(core["\u0275\u0275inject"](dialog_service.x), core["\u0275\u0275inject"](localization_service.o), core["\u0275\u0275inject"](Telemetry.y0));
            }, AccessTokenProviderService.\u0275prov = core["\u0275\u0275defineInjectable"]({
                token: AccessTokenProviderService,
                factory: AccessTokenProviderService.\u0275fac,
                providedIn: "root"
            }), AccessTokenProviderService;
        }();
    },
    38022: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
            LeadsCollectionDialogModule: function() {
                return LeadsCollectionDialogModule;
            }
        });
        var pbi_spinner_module = __webpack_require__(16748), dialogs_module = __webpack_require__(76966), access_token_provider_service = __webpack_require__(62113), core = __webpack_require__(50423), AccessTokenProviderModule = function() {
            function AccessTokenProviderModule() {}
            return AccessTokenProviderModule.\u0275fac = function(t) {
                return new (t || AccessTokenProviderModule);
            }, AccessTokenProviderModule.\u0275mod = core["\u0275\u0275defineNgModule"]({
                type: AccessTokenProviderModule
            }), AccessTokenProviderModule.\u0275inj = core["\u0275\u0275defineInjector"]({
                providers: [ access_token_provider_service.Q ],
                imports: [ dialogs_module.c ]
            }), AccessTokenProviderModule;
        }(), dialog = __webpack_require__(32293), common = __webpack_require__(77476), localization_module = __webpack_require__(79061), userInfo = __webpack_require__(4444), formatUtil = __webpack_require__(59694), frontEndUrl = __webpack_require__(40580), BehaviorSubject = __webpack_require__(35510), debounceTime = __webpack_require__(6754), platform_browser = __webpack_require__(18942), localization_service = __webpack_require__(65181), http_service = __webpack_require__(73875), dialog_service = __webpack_require__(58938), user_info_service = __webpack_require__(79474), feature_switch_service = __webpack_require__(9380), localize_attr_directive = __webpack_require__(22844), localize_tooltip_directive = __webpack_require__(50057), pbi_spinner_component = __webpack_require__(24326), _c0 = [ "iframe" ];
        function LeadsCollectionDialogComponent_pbi_spinner_5_Template(rf, ctx) {
            1 & rf && core["\u0275\u0275element"](0, "pbi-spinner", 6);
        }
        var _c1 = function() {
            return {
                "aria-label": "Close"
            };
        }, commonGlobals = window, lazyDialogManifests = [ {
            componentType: function() {
                function LeadsCollectionDialogComponent(frontEndUrl, sanitizer, dialogRef, localizationService, httpService, accessTokenProviderService, dialogService, userInfoService, featureSwitch) {
                    var _this = this;
                    this.frontEndUrl = frontEndUrl, this.sanitizer = sanitizer, this.dialogRef = dialogRef, 
                    this.localizationService = localizationService, this.httpService = httpService, 
                    this.accessTokenProviderService = accessTokenProviderService, this.dialogService = dialogService, 
                    this.userInfoService = userInfoService, this.tokenScopes = [ commonGlobals.microsoftGraphUrl + "/User.Read" ], 
                    this.isLoading = new BehaviorSubject.X(!0), this.baseUrl = featureSwitch.featureSwitches.newLeadsUrl ? "https://www.microsoft.com/" : "https://powerbi.microsoft.com/", 
                    featureSwitch.featureSwitches.leadsTip1 && (this.baseUrl = "https://tip1.powerbi.microsoft.com/"), 
                    featureSwitch.featureSwitches.leadsTip2 && (this.baseUrl = "https://tip2.powerbi.microsoft.com/"), 
                    featureSwitch.featureSwitches.leadsDevUrl && (this.baseUrl = "https://powerbi-frontend-tip2-eastus.azurewebsites.net/"), 
                    this.leadsCollectionUrl = this.sanitizer.bypassSecurityTrustResourceUrl(featureSwitch.featureSwitches.newLeadsUrl ? this.baseUrl + this.localizationService.currentLanguageLocale + "/product-leadcollection/lead-collection/" : this.baseUrl + this.localizationService.currentLanguageLocale + "/lead-collection/"), 
                    this.title = this.localizationService.get("CustomerVoiceSurveyTitle"), featureSwitch.featureSwitches.leadsTesting || this.isLoading.pipe((0, 
                    debounceTime.b)(1e4)).subscribe(function(isLoading) {
                        return isLoading ? _this.closeDialog(!1, "timeout") : null;
                    });
                }
                return LeadsCollectionDialogComponent.prototype.ngOnInit = function() {
                    var _this = this;
                    commonGlobals.clientAuthEnabled ? (this.graphTokenPromiseV2 = this.accessTokenProviderService.acquireToken("LeadsCollectionDialog", this.tokenScopes), 
                    this.graphTokenPromiseV2.catch(function(result) {
                        _this.closeDialog(!1, result);
                    })) : (this.graphTokenPromise = this.httpService.get((0, formatUtil.W)("{0}/graph", this.frontEndUrl), this.httpService.powerbiRequestOptions()).toPromise(), 
                    this.graphTokenPromise.catch(function(result) {
                        var _a;
                        _this.closeDialog(!1, (null === (_a = null == result ? void 0 : result.data) || void 0 === _a ? void 0 : _a.message) || result.status);
                    })), this.isNotFirstTrial = this.userInfoService.userFreeTrialExpired || this.userInfoService.userFreeTrialDaysRemaining >= 0, 
                    this.messageHandler = function(message) {
                        return _this.handleMessage(message);
                    }, window.addEventListener("message", this.messageHandler);
                }, LeadsCollectionDialogComponent.prototype.postData = function(localization, token) {
                    var userObjId = (0, userInfo.bG)().uoid, tenantID = commonGlobals.tenantId, headerText = localization.get("Leads_Dialog_Header"), subHeaderText = localization.get(this.isNotFirstTrial ? "Leads_Dialog_Subheader_Trial_Renewal" : "Leads_Dialog_Subheader"), ctaText = localization.get(this.isNotFirstTrial ? "Leads_Dialog_Button_Renewal" : "Leads_Dialog_Button"), iframeEl = this.iframe.nativeElement, jsonData = JSON.stringify({
                        token,
                        userObjId,
                        headerText,
                        subHeaderText,
                        ctaText,
                        tenantID,
                        offerID: this.isNotFirstTrial ? "CO-DBI-Account-PowerBI-TrialRenewal-OfferID" : "CO-DBI-ACCOUNT-POWERBI-TRIALINITIATION-OFFERID",
                        GraphUrl: commonGlobals.microsoftGraphUrl
                    });
                    iframeEl.contentWindow.postMessage("" + jsonData, "*");
                }, LeadsCollectionDialogComponent.prototype.ngOnDestroy = function() {
                    window.removeEventListener("message", this.messageHandler);
                }, LeadsCollectionDialogComponent.prototype.close = function(event) {
                    this.closeDialog();
                }, LeadsCollectionDialogComponent.prototype.closeOnOverlayClicked = function(event) {
                    if (this.isNotFirstTrial) {
                        var className = (null == event ? void 0 : event.target).className;
                        (null == className ? void 0 : className.includes("cdk-overlay-backdrop")) && this.showNoTrialDialog();
                    }
                }, LeadsCollectionDialogComponent.prototype.closeDialog = function(isComplete, error) {
                    var _this = this;
                    document.getElementById("leads").remove(), this.dialogRef.close({
                        isComplete,
                        error
                    }), this.isNotFirstTrial && this.dialogRef.afterClosed().subscribe(function() {
                        return _this.showNoTrialDialog();
                    });
                }, LeadsCollectionDialogComponent.prototype.showNoTrialDialog = function() {
                    var _a, title = (_a = this.getNoTrialDialogContentByServicePlan()).title;
                    this.dialogService.showSimpleDialog(title, _a.message, {
                        panelClass: [ "no-trial-dialog" ],
                        maxHeight: "min-content",
                        maxWidth: "340px"
                    }, {
                        url: "https://go.microsoft.com/fwlink/?linkid=2222575",
                        text: "LearnMore",
                        showIcon: !0
                    }, this.localizationService.get("ModalDialogButtonText_GotIt"));
                }, LeadsCollectionDialogComponent.prototype.getNoTrialDialogContentByServicePlan = function() {
                    var userLicense, trialLicense;
                    return this.userInfoService.userHasProPlan ? (userLicense = this.localizationService.get("Workspace_LicenseMode_Pro"), 
                    trialLicense = this.localizationService.get("PowerBI_PremiumPerUser")) : (userLicense = this.localizationService.get("PowerBI_Free"), 
                    trialLicense = this.localizationService.get("Workspace_LicenseMode_Pro")), {
                        title: this.localizationService.format("TrialRenewalRefused_Dialog_Title", [ userLicense ]),
                        message: this.localizationService.format("TrialRenewalRefused_Dialog_Message", [ userLicense, trialLicense ])
                    };
                }, LeadsCollectionDialogComponent.prototype.handleMessage = function(event) {
                    var _this = this;
                    if (this.isTrustedOrigin(event.origin) && this.isTrustedSource(event.source) && this.isTrustedData(event.data)) {
                        var data;
                        try {
                            data = JSON.parse(event.data);
                        } catch (e) {
                            return void this.dialogRef.close({
                                error: e
                            });
                        }
                        if (data.Error && 2 !== data.FormEvent) this.dialogRef.close({
                            isComplete: 6 === data.FormEvent,
                            error: data.Error
                        }); else switch (data.FormEvent) {
                          case 1:
                            commonGlobals.clientAuthEnabled ? this.graphTokenPromiseV2.then(function(result) {
                                _this.postData(_this.localizationService, result.token);
                            }) : this.graphTokenPromise.then(function(result) {
                                _this.postData(_this.localizationService, result.data);
                            });
                            break;

                          case 4:
                            this.isLoading.next(!1);
                            break;

                          case 6:
                            this.dialogRef.close({
                                isComplete: !0,
                                error: data.Error
                            });
                        }
                    }
                }, LeadsCollectionDialogComponent.prototype.isTrustedOrigin = function(origin) {
                    return new URL(origin).origin === new URL(this.baseUrl).origin;
                }, LeadsCollectionDialogComponent.prototype.isTrustedSource = function(source) {
                    return source === this.iframe.nativeElement.contentWindow;
                }, LeadsCollectionDialogComponent.prototype.isTrustedData = function(data) {
                    return "string" == typeof data;
                }, LeadsCollectionDialogComponent.\u0275fac = function(t) {
                    return new (t || LeadsCollectionDialogComponent)(core["\u0275\u0275directiveInject"](frontEndUrl.Zp), core["\u0275\u0275directiveInject"](platform_browser.H7), core["\u0275\u0275directiveInject"](dialog.so), core["\u0275\u0275directiveInject"](localization_service.o), core["\u0275\u0275directiveInject"](http_service.O), core["\u0275\u0275directiveInject"](access_token_provider_service.Q), core["\u0275\u0275directiveInject"](dialog_service.x), core["\u0275\u0275directiveInject"](user_info_service.a), core["\u0275\u0275directiveInject"](feature_switch_service.vZ));
                }, LeadsCollectionDialogComponent.\u0275cmp = core["\u0275\u0275defineComponent"]({
                    type: LeadsCollectionDialogComponent,
                    selectors: [ [ "leads-collection-dialog" ] ],
                    viewQuery: function(rf, ctx) {
                        var _t;
                        1 & rf && core["\u0275\u0275viewQuery"](_c0, 5, core.ElementRef), 2 & rf && core["\u0275\u0275queryRefresh"](_t = core["\u0275\u0275loadQuery"]()) && (ctx.iframe = _t.first);
                    },
                    hostBindings: function(rf, ctx) {
                        1 & rf && core["\u0275\u0275listener"]("keyup.escape", function($event) {
                            return ctx.close($event);
                        }, !1, core["\u0275\u0275resolveWindow"])("click", function($event) {
                            return ctx.closeOnOverlayClicked($event);
                        }, !1, core["\u0275\u0275resolveBody"]);
                    },
                    decls: 10,
                    vars: 10,
                    consts: [ [ 1, "header-container" ], [ 1, "header-actions" ], [ "id", "close-button", "mat-button", "", "localizeTooltip", "Close", 1, "glyphicon", "pbi-glyph-close", "glyph-small", "close-button", 3, "localizeAttr", "click" ], [ "class", "pbi-spinner-large", 4, "ngIf" ], [ "id", "leads", "width", "100%", "height", "100%", "frameborder", "0", "marginwidth", "0", "marginheight", "0", "scrolling", "auto", "seamless", "seamless", "sandbox", "allow-forms allow-presentation allow-same-origin allow-scripts allow-popups", "allowfullscreen", "", "webkitallowfullscreen", "", "mozallowfullscreen", "", "msallowfullscreen", "", 1, "leads-form", 3, "hidden", "title", "src" ], [ "iframe", "" ], [ 1, "pbi-spinner-large" ] ],
                    template: function(rf, ctx) {
                        1 & rf && (core["\u0275\u0275elementStart"](0, "mat-dialog-content")(1, "div", 0)(2, "header")(3, "div", 1)(4, "button", 2), 
                        core["\u0275\u0275listener"]("click", function() {
                            return ctx.closeDialog();
                        }), core["\u0275\u0275elementEnd"]()()()(), core["\u0275\u0275template"](5, LeadsCollectionDialogComponent_pbi_spinner_5_Template, 1, 0, "pbi-spinner", 3), 
                        core["\u0275\u0275pipe"](6, "async"), core["\u0275\u0275element"](7, "iframe", 4, 5), 
                        core["\u0275\u0275pipe"](9, "async"), core["\u0275\u0275elementEnd"]()), 2 & rf && (core["\u0275\u0275advance"](4), 
                        core["\u0275\u0275property"]("localizeAttr", core["\u0275\u0275pureFunction0"](9, _c1)), 
                        core["\u0275\u0275advance"](1), core["\u0275\u0275property"]("ngIf", core["\u0275\u0275pipeBind1"](6, 5, ctx.isLoading)), 
                        core["\u0275\u0275advance"](2), core["\u0275\u0275propertyInterpolate"]("title", ctx.title), 
                        core["\u0275\u0275property"]("hidden", core["\u0275\u0275pipeBind1"](9, 7, ctx.isLoading))("src", ctx.leadsCollectionUrl, core["\u0275\u0275sanitizeResourceUrl"]));
                    },
                    dependencies: [ dialog.xY, common.NgIf, localize_attr_directive.b, localize_tooltip_directive.r, pbi_spinner_component.k, common.AsyncPipe ],
                    styles: [ "pbi-spinner[_ngcontent-%COMP%]{height:650px;background-color:var(--fluent-theme-light-gray-color, #c8c8c8);display:flex;align-items:center;justify-content:center}.mat-mdc-dialog-content[_ngcontent-%COMP%]{padding:0;height:100%;position:relative;overflow:hidden}.header-container[_ngcontent-%COMP%]{position:absolute;top:10px;width:100%}.header-container[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:flex-end;background-color:transparent}.header-container[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .header-actions[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;margin:0 24px;flex-direction:column;align-items:flex-end}.header-container[_ngcontent-%COMP%]   header[_ngcontent-%COMP%]   .header-actions[_ngcontent-%COMP%]   .close-button[_ngcontent-%COMP%]{height:32px;border:none;padding:0;background-color:transparent}.leads-form[_ngcontent-%COMP%]{border:none;max-width:100%;max-height:100%}  .no-trial-dialog mat-dialog-container .mdc-dialog__surface{padding:0 24px}  .no-trial-dialog mat-dialog-container .pbi-dialog-header{margin-bottom:16px;margin-top:16px;align-items:baseline}  .no-trial-dialog mat-dialog-container .pbi-dialog-body{margin-bottom:32px}  .no-trial-dialog mat-dialog-container .pbi-dialog-footer{padding:0!important;height:72px}" ],
                    changeDetection: 0
                }), LeadsCollectionDialogComponent;
            }(),
            componentIdentifier: __webpack_require__(71209).Q
        } ], LeadsCollectionDialogModule = function() {
            function LeadsCollectionDialogModule() {}
            return LeadsCollectionDialogModule.\u0275fac = function(t) {
                return new (t || LeadsCollectionDialogModule);
            }, LeadsCollectionDialogModule.\u0275mod = core["\u0275\u0275defineNgModule"]({
                type: LeadsCollectionDialogModule
            }), LeadsCollectionDialogModule.\u0275inj = core["\u0275\u0275defineInjector"]({
                imports: [ dialog.Is, common.CommonModule, localization_module.v, pbi_spinner_module.H, AccessTokenProviderModule, dialogs_module.c.withManifest(lazyDialogManifests) ]
            }), LeadsCollectionDialogModule;
        }();
    }
} ]);