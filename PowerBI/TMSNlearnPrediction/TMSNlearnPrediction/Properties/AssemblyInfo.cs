using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using Microsoft.MachineLearning;
using Microsoft.MachineLearning.Command;
using Microsoft.MachineLearning.Data;
using Microsoft.MachineLearning.Data.IO;
using Microsoft.MachineLearning.Dracula;
using Microsoft.MachineLearning.Dracula.FeatureInference;
using Microsoft.MachineLearning.Learners;
using Microsoft.MachineLearning.Model;
using Microsoft.MachineLearning.Tools;
using Microsoft.TMSN.TMSNlearn;
using Microsoft.TMSN.TMSNlearn.DataPipe;

[assembly: AssemblyVersion("3.5.79.0")]
[assembly: AssemblyTrademark("")]
[assembly: LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(TermLookupTransform), null, typeof(SignatureLoadDataTransform), "Term Lookup Transform", new string[] { "TermLookupTransform" })]
[assembly: LoadableClass("Filters out rows that contain missing values.", typeof(MissingValueFilter), typeof(MissingValueFilter.Arguments), typeof(SignatureDataTransform), "Missing Value Filter", new string[] { "MissingValueFilter", "MissingFilter" })]
[assembly: AssemblyCopyright("Copyright © Microsoft")]
[assembly: AssemblyTitle("TMSNLearn.Prediction")]
[assembly: AssemblyDescription("")]
[assembly: InternalsVisibleTo("RunTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")]
[assembly: InternalsVisibleTo("RunTestsMore, PublicKey=0024000004800000940000000602000000240000525341310004000001000100bd8dded65b44bf8183068bd6dae3b68ba499202b2909640604cf63c7c0ea95bec94a400af533d1132e0dba214f310f666486b50ea91f2697a4fe331eb6a8d7306029344e320dabb7c4c3617472e3088c28dbfcf761a3f1b954a2a64cb865aae873b1d3c3cab344661cd7d5929d1043912908b8dd321889ca11f29d6bf9b9b9a9")]
[assembly: LoadableClass("This model was introduced by Platt in the paper Probabilistic Outputs for Support Vector Machines and Comparisons to Regularized Likelihood Methods", typeof(PlattCalibratorTrainer), null, typeof(SignatureCalibrator), "Sigmoid Calibration", new string[] { "PlattCalibration", "SigmoidCalibration" })]
[assembly: LoadableClass("Sigmoid calibrator with configurable slope and offset.", typeof(FixedPlattCalibratorTrainer), typeof(FixedPlattCalibratorTrainer.Arguments), typeof(SignatureCalibrator), "Fixed Sigmoid Calibration", new string[] { "FixedPlattCalibration", "FixedSigmoidCalibration" })]
[assembly: LoadableClass("Piecewise linear calibrator.", typeof(PAVCalibratorTrainer), null, typeof(SignatureCalibrator), "PAV Calibration", new string[] { "PAVCalibration", "PAV" })]
[assembly: LoadableClass("Naïve calibrator divides the range of the outputs into equally sized bins. In each bin, the probability of belonging to class 1 is the number of class 1 instances in the bin, divided by the total number of instances in the bin.", typeof(NaiveCalibratorTrainer), null, typeof(SignatureCalibrator), "Naive Calibrator", new string[] { "NaiveCalibrator", "Naive", "NaiveCalibration" })]
[assembly: LoadableClass(typeof(PlattCalibrator), null, typeof(SignatureLoadModel), "Platt Calibration Executor", new string[] { "PlattCaliExec" })]
[assembly: LoadableClass(typeof(PAVCalibrator), null, typeof(SignatureLoadModel), "PAV Calibration Executor", new string[] { "PAVCaliExec" })]
[assembly: LoadableClass(typeof(NaiveCalibrator), null, typeof(SignatureLoadModel), "Naive Calibration Executor", new string[] { "NaiveCaliExec" })]
[assembly: LoadableClass(typeof(CalibratedPredictor), null, typeof(SignatureLoadModel), "Calibrated Predictor Executor", new string[] { "CaliPredExec", "BulkCaliPredExec" })]
[assembly: LoadableClass(typeof(ParameterMixingCalibratedPredictor), null, typeof(SignatureLoadModel), "Parameter Mixing Calibrated Predictor Executor", new string[] { "PMixCaliPredExec" })]
[assembly: LoadableClass(typeof(TolerantEarlyStoppingCriterion), typeof(TolerantEarlyStoppingCriterion.Arguments), typeof(SignatureEarlyStoppingCriterion), "Tolerant (TR)", new string[] { "tr" })]
[assembly: LoadableClass(typeof(GLEarlyStoppingCriterion), typeof(GLEarlyStoppingCriterion.Arguments), typeof(SignatureEarlyStoppingCriterion), "Loss of Generality (GL)", new string[] { "gl" })]
[assembly: LoadableClass(typeof(LPEarlyStoppingCriterion), typeof(MovingWindowEarlyStoppingCriterion.Arguments), typeof(SignatureEarlyStoppingCriterion), "Low Progress (LP)", new string[] { "lp" })]
[assembly: LoadableClass(typeof(PQEarlyStoppingCriterion), typeof(MovingWindowEarlyStoppingCriterion.Arguments), typeof(SignatureEarlyStoppingCriterion), "Generality to Progress Ratio (PQ)", new string[] { "pq" })]
[assembly: LoadableClass(typeof(UPEarlyStoppingCriterion), typeof(UPEarlyStoppingCriterion.Arguments), typeof(SignatureEarlyStoppingCriterion), "Consecutive Loss in Generality (UP)", new string[] { "up" })]
[assembly: LoadableClass("Given a TLC model file with a predictor, we can output this same predictor in multiple export formats.", typeof(SavePredictorCommand), typeof(SavePredictorCommand.Arguments), typeof(SignatureCommand), "Save Predictor As", new string[] { "SavePredictorAs", "SavePredictor", "SaveAs", "SaveModel" })]
[assembly: LoadableClass(typeof(RandomPartitioner), null, typeof(SignaturePartitioner), "RandomPartitioner", new string[] { })]
[assembly: LoadableClass(typeof(ReplacementPartitioner), typeof(ReplacementPartitioner.Arguments), typeof(SignaturePartitioner), "ReplacementPartitioner", new string[] { })]
[assembly: LoadableClass(typeof(ParallelMultiCountTable), null, typeof(SignatureLoadModel), "Parallel Multi Count Table", new string[] { "ParallelMultiCountTable" })]
[assembly: LoadableClass(typeof(SharedMultiCountTable), null, typeof(SignatureLoadModel), "Shared Multi Count Table", new string[] { "SharedMultiCountTable" })]
[assembly: LoadableClass(typeof(DraculaFeaturizer), typeof(DraculaFeaturizer.Arguments), typeof(SignatureCountFeaturizer), "Dracula", new string[] { })]
[assembly: LoadableClass(typeof(DraculaFeaturizer), null, typeof(SignatureLoadCountFeaturizer), "Dracula Featurizer Executor", new string[] { "DraculaFeaturizer" })]
[assembly: LoadableClass(typeof(SimpleSlotMapBuilder), typeof(SimpleSlotMapBuilder.Arguments), typeof(SignatureDraculaSlotMapBuilder), "Simple Slot Map Builder", new string[] { "SimpleSlotMapBuilder", "Simple" })]
[assembly: LoadableClass("Tries to find the combinations of slots that are giving the best performance for a Dracula transform.", typeof(DraculaInferSlotMapCommand), typeof(DraculaInferSlotMapCommand.Arguments), typeof(SignatureCommand), "Dracula Infer Combinations", new string[] { "DraculaInfer" })]
[assembly: LoadableClass(typeof(DictCountTableBuilder), typeof(DictCountTableBuilder.Arguments), typeof(SignatureCountTableBuilder), "Dictionary Based Count Table Builder", new string[] { "Dictionary", "Dict" })]
[assembly: LoadableClass(typeof(DictCountTable), null, typeof(SignatureLoadModel), "Dictionary Count Table", new string[] { "DictCountTable" })]
[assembly: LoadableClass(typeof(CMCountTableBuilder), typeof(CMCountTableBuilder.Arguments), typeof(SignatureCountTableBuilder), "Count Min Table Builder", new string[] { "CMSketch", "CMTable" })]
[assembly: LoadableClass(typeof(CMCountTable), null, typeof(SignatureLoadModel), "Count Min Table Executor", new string[] { "CMCountTable" })]
[assembly: LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by hashing each ngram and using the hash value as the index in the bag.", typeof(IDataTransform), typeof(WordHashBagTransform), typeof(WordHashBagTransform.Arguments), typeof(SignatureDataTransform), "Word Hash Bag Transform", new string[] { "WordHashBagTransform", "WordHashBag" })]
[assembly: LoadableClass("A transform\u00a0that turns a collection of tokenized text (vector of DvText) into numerical feature vectors using the hashing trick.", typeof(INgramExtractorFactory), typeof(NgramHashExtractorTransform), typeof(NgramHashExtractorTransform.NgramHashExtractorArguments), typeof(SignatureNgramExtractorFactory), "Ngram Hash Extractor Transform", new string[] { "NgramHashExtractorTransform", "NgramHash", "NgramHashExtractor" })]
[assembly: LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive words of length 1-n) in a given text. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(IDataTransform), typeof(WordBagTransform), typeof(WordBagTransform.Arguments), typeof(SignatureDataTransform), "Word Bag Transform", new string[] { "WordBagTransform", "WordBag" })]
[assembly: LoadableClass("A transform\u00a0that turns a collection of tokenized text (vector of DvText), or vectors of keys into numerical feature vectors. The feature vectors are counts of ngrams (sequences of consecutive *tokens* -words or keys- of length 1-n).", typeof(INgramExtractorFactory), typeof(NgramExtractorTransform), typeof(NgramExtractorTransform.NgramExtractorArguments), typeof(SignatureNgramExtractorFactory), "Ngram Extractor Transform", new string[] { "NgramExtractorTransform", "Ngram", "NgramExtractor" })]
[assembly: LoadableClass("Applies PCA or ZCA whitening algorithm to the input.", typeof(WhiteningTransform), typeof(WhiteningTransform.Arguments), typeof(SignatureDataTransform), "Whitening Transform", new string[] { "WhiteningTransform", "Whitening" })]
[assembly: LoadableClass("Applies PCA or ZCA whitening algorithm to the input.", typeof(WhiteningTransform), null, typeof(SignatureLoadDataTransform), "Whitening Transform", new string[] { "WhiteningTransform", "WhiteningFunction" })]
[assembly: LoadableClass("Trains a predictor using the train file and then scores and evaluates the predictor using the test file.", typeof(TrainTestCommand), typeof(TrainTestCommand.Arguments), typeof(SignatureCommand), "Train Test", new string[] { "TrainTest" })]
[assembly: LoadableClass("Trains a predictor.", typeof(TrainCommand), typeof(TrainCommand.Arguments), typeof(SignatureCommand), "Train Predictor", new string[] { "Train" })]
[assembly: LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(DelimitedTokenizeTransform), typeof(DelimitedTokenizeTransform.Arguments), typeof(SignatureDataTransform), "Word Tokenizer Transform", new string[] { "WordTokenizeTransform", "DelimitedTokenizeTransform", "WordToken", "DelimitedTokenize", "Token" })]
[assembly: LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(DelimitedTokenizeTransform), typeof(DelimitedTokenizeTransform.TokenizeArguments), typeof(SignatureTokenizeTransform), "Word Tokenizer Transform", new string[] { "WordTokenizeTransform", "DelimitedTokenizeTransform", "WordToken", "DelimitedTokenize", "Token" })]
[assembly: LoadableClass("The input to this transform is text, and the output is a vector of text containing the words (tokens) in the original text. The separator is space, but can be specified as any other character (or multiple characters) if needed.", typeof(DelimitedTokenizeTransform), null, typeof(SignatureLoadDataTransform), "Word Tokenizer Transform", new string[] { "TokenizeTextTransform" })]
[assembly: LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(UngroupTransform), typeof(UngroupTransform.Arguments), typeof(SignatureDataTransform), "Un-group Transform", new string[] { "Ungroup" })]
[assembly: LoadableClass("Un-groups vector columns into sequences of rows, inverse of Group transform", typeof(UngroupTransform), null, typeof(SignatureLoadDataTransform), "Un-group Transform", new string[] { "UngroupTransform" })]
[assembly: LoadableClass("Maps text values columns to new columns using a map dataset.", typeof(TermLookupTransform), typeof(TermLookupTransform.Arguments), typeof(SignatureDataTransform), "Term Lookup Transform", new string[] { "TermLookup", "Lookup", "LookupTransform", "TermLookupTransform" })]
[assembly: LoadableClass("Filters out rows that contain missing values.", typeof(MissingValueFilter), null, typeof(SignatureLoadDataTransform), "Missing Value Filter", new string[] { "MissingValueFilter", "MissingFeatureFilter" })]
[assembly: LoadableClass("Writes data into a text file.", typeof(TextSaver), typeof(TextSaver.Arguments), typeof(SignatureDataSaver), "Text Saver", new string[] { "TextSaver", "Text" })]
[assembly: LoadableClass("Loads text data file.", typeof(TextLoader), typeof(TextLoader.Arguments), typeof(SignatureDataLoader), "Text Loader", new string[] { "TextLoader", "Text" })]
[assembly: LoadableClass("Loads text data file.", typeof(TextLoader), null, typeof(SignatureLoadDataLoader), "Text Loader", new string[] { "TextLoader" })]
[assembly: LoadableClass("Scores a data file.", typeof(ScoreCommand), typeof(ScoreCommand.Arguments), typeof(SignatureCommand), "Score Predictor", new string[] { "Score" })]
[assembly: LoadableClass("Scores and evaluates a data file.", typeof(TestCommand), typeof(TestCommand.Arguments), typeof(SignatureCommand), "Test Predictor", new string[] { "Test" })]
[assembly: LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(TermTransform), typeof(TermTransform.Arguments), typeof(SignatureDataTransform), "Term Transform", new string[] { "Term", "AutoLabel", "TermTransform", "AutoLabelTransform" })]
[assembly: LoadableClass("Converts input values (words, numbers, etc.) to index in a dictionary.", typeof(TermTransform), null, typeof(SignatureLoadDataTransform), "Term Transform", new string[] { "TermTransform" })]
[assembly: LoadableClass(typeof(DataPerformanceTestCommand), typeof(DataPerformanceTestCommand.Arguments), typeof(SignatureCommand), "", new string[] { "DataPerformanceTest", "dataperf" })]
[assembly: LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(PixelExtractorTransform), typeof(PixelExtractorTransform.Arguments), typeof(SignatureDataTransform), "Pixel Extractor Transform", new string[] { "PixelExtractorTransform", "PixelExtractor" })]
[assembly: LoadableClass("Extract color plane(s) from an image. Options include scaling, offset and conversion to floating point.", typeof(PixelExtractorTransform), null, typeof(SignatureLoadDataTransform), "Pixel Extractor Transform", new string[] { "PixelExtractorTransform", "PixelExtractorFunction" })]
[assembly: LoadableClass(typeof(IDataLoader), typeof(CompositeDataLoader), typeof(CompositeDataLoader.Arguments), typeof(SignatureDataLoader), "Composite Data Loader", new string[] { "CompositeDataLoader", "Composite", "PipeData", "Pipe", "PipeDataLoader" })]
[assembly: LoadableClass(typeof(IDataLoader), typeof(CompositeDataLoader), null, typeof(SignatureLoadDataLoader), "Pipe DataL Loader", new string[] { "PipeDataLoader" })]
[assembly: LoadableClass(typeof(NormalizeTransform), null, typeof(SignatureLoadDataTransform), "Normalizer", new string[] { "NormalizeTransform", "NormalizeFunction" })]
[assembly: LoadableClass("Normalizes the data based on the observed minimum and maximum values of the data.", typeof(NormalizeTransform), typeof(NormalizeTransform.MinMaxArguments), typeof(SignatureDataTransform), "Min-Max Normalizer", new string[] { "MinMaxNormalizer", "MinMax" })]
[assembly: LoadableClass("Normalizes the data based on the computed mean and variance of the data.", typeof(NormalizeTransform), typeof(NormalizeTransform.MeanVarArguments), typeof(SignatureDataTransform), "MeanVar Normalizer", new string[] { "MeanVarNormalizer", "MeanVar", "ZScoreNormalizer", "ZScore", "GaussianNormalizer", "Gaussian" })]
[assembly: LoadableClass("Normalizes the data based on the computed mean and variance of the logarithm of the data.", typeof(NormalizeTransform), typeof(NormalizeTransform.LogMeanVarArguments), typeof(SignatureDataTransform), "LogMeanVar Normalizer", new string[] { "LogMeanVarNormalizer", "LogMeanVar", "LogNormalNormalizer", "LogNormal" })]
[assembly: LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(NormalizeTransform), typeof(NormalizeTransform.BinArguments), typeof(SignatureDataTransform), "Binning Normalizer", new string[] { "BinNormalizer", "Bin" })]
[assembly: LoadableClass("Similar to BinNormalizer, but calculates bins based on correlation with the label column, not equi-density. The new value is bin_number / number_of_bins.", typeof(NormalizeTransform), typeof(NormalizeTransform.SupervisedBinArguments), typeof(SignatureDataTransform), "Supervised Binning Normalizer", new string[] { "SupervisedBinNormalizer", "SupBin" })]
[assembly: LoadableClass(typeof(NormalizeTransform.AffineColumnFunction), null, typeof(SignatureLoadColumnFunction), "Affine Normalizer", new string[] { "AffineNormExec" })]
[assembly: LoadableClass(typeof(NormalizeTransform.CdfColumnFunction), null, typeof(SignatureLoadColumnFunction), "CDF Normalizer", new string[] { "CdfNormalizeFunction" })]
[assembly: LoadableClass("The values are assigned into equidensity bins and a value is mapped to its bin_number/number_of_bins.", typeof(NormalizeTransform.BinColumnFunction), null, typeof(SignatureLoadColumnFunction), "Bin Normalizer", new string[] { "BinNormalizeFunction" })]
[assembly: LoadableClass(typeof(MissingValueIndicatorTransform), typeof(MissingValueIndicatorTransform.Arguments), typeof(SignatureDataTransform), "Missing Value Indicator Transform", new string[] { "MissingValueIndicatorTransform", "MissingValueTransform", "MissingTransform", "Missing" })]
[assembly: LoadableClass(typeof(MissingValueIndicatorTransform), null, typeof(SignatureLoadDataTransform), "Missing Value Indicator Transform", new string[] { "MissingIndicatorFunction", "MissingFeatureFunction" })]
[assembly: LoadableClass("Writes data into a native binary IDV file.", typeof(BinarySaver), typeof(BinarySaver.Arguments), typeof(SignatureDataSaver), "Binary Saver", new string[] { "BinarySaver", "Binary" })]
[assembly: LoadableClass("Loads native Binary IDV data file.", typeof(BinaryLoader), typeof(BinaryLoader.Arguments), typeof(SignatureDataLoader), "Binary Loader", new string[] { "BinaryLoader", "Binary", "Bin" })]
[assembly: LoadableClass("Loads native Binary IDV data file.", typeof(BinaryLoader), null, typeof(SignatureLoadDataLoader), "Binary Data View Loader", new string[] { "BinaryLoader" })]
[assembly: LoadableClass(typeof(BinaryLoader.InfoCommand), typeof(BinaryLoader.InfoCommand.Arguments), typeof(SignatureCommand), "", new string[] { "IdvInfo", "idv" })]
[assembly: LoadableClass(typeof(Compression.NoneImpl), null, typeof(SignatureCompression), "No Compression", new string[] { "none" })]
[assembly: LoadableClass(typeof(Compression.ZlibImpl), typeof(Compression.ZlibImpl.DeflateArguments), typeof(SignatureCompression), "DEFLATE Compression", new string[] { "deflate" })]
[assembly: LoadableClass(typeof(Compression.ZlibImpl), typeof(Compression.ZlibImpl.ZlibArguments), typeof(SignatureCompression), "Zlib Compression", new string[] { "zlib" })]
[assembly: LoadableClass(typeof(IDataTransform), typeof(DraculaTransform), typeof(DraculaTransform.Arguments), typeof(SignatureDataTransform), "Dracula Transform", new string[] { "DraculaTransform", "Dracula" })]
[assembly: LoadableClass("Given input data, a loader, and possibly transforms, save the data to a new file as parameterized by a saver.", typeof(SaveDataCommand), typeof(SaveDataCommand.Arguments), typeof(SignatureCommand), "Save Data", new string[] { "SaveData", "save" })]
[assembly: LoadableClass("Given input data, a loader, and possibly transforms, display a sample of the data file.", typeof(ShowDataCommand), typeof(ShowDataCommand.Arguments), typeof(SignatureCommand), "Show Data", new string[] { "ShowData", "show" })]
[assembly: LoadableClass(typeof(MultiClassClassifierEvaluator), typeof(MultiClassClassifierEvaluator), typeof(MultiClassClassifierEvaluator.Arguments), typeof(SignatureEvaluator), "Multi-Class Classifier Evaluator", new string[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })]
[assembly: LoadableClass(typeof(MultiClassMamlEvaluator), typeof(MultiClassMamlEvaluator), typeof(MultiClassMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Multi-Class Classifier Evaluator", new string[] { "MultiClassClassifierEvaluator", "MultiClassClassifier", "MultiClass" })]
[assembly: LoadableClass(typeof(MultiClassPerInstanceEvaluator), null, typeof(SignatureLoadRowMapper), "", new string[] { "MulticlassPerInstance" })]
[assembly: LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(RffTransform), typeof(RffTransform.Arguments), typeof(SignatureDataTransform), "Random Fourier Features Transform", new string[] { "RffTransform", "Rff" })]
[assembly: LoadableClass("This transform maps numeric vectors to a random low-dimensional feature space. It is useful when data has non-linear features, since the transform is designed so that the inner products of the transformed data are approximately equal to those in the feature space of a user specified shift-invariant kernel.", typeof(RffTransform), null, typeof(SignatureLoadDataTransform), "Random Fourier Features Transform", new string[] { "RffTransform" })]
[assembly: LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(HashTransform), typeof(HashTransform.Arguments), typeof(SignatureDataTransform), "Hash Transform", new string[] { "HashTransform", "Hash" })]
[assembly: LoadableClass("Converts column values into hashes. This transform accepts text and keys as inputs. It works on single- and vector-valued columns, and hashes each slot in a vector separately.", typeof(HashTransform), null, typeof(SignatureLoadDataTransform), "Hash Transform", new string[] { "HashTransform" })]
[assembly: LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(LpNormNormalizerTransform), typeof(LpNormNormalizerTransform.GcnArguments), typeof(SignatureDataTransform), "Global Contrast Normalization Transform", new string[] { "GcnTransform", "Gcn" })]
[assembly: LoadableClass("Performs a global contrast normalization on input values: Y = (s * X - M) / D, where s is a scale, M is mean and D is either L2 norm or standard deviation.", typeof(LpNormNormalizerTransform), null, typeof(SignatureLoadDataTransform), "Global Contrast Normalization Transform", new string[] { "GcnTransform", "GcnFunction" })]
[assembly: LoadableClass("Normalize vectors (rows) individually by rescaling them to unit norm (L2, L1 or LInf). Performs the following operation on a vector X: Y = (X - M) / D, where M is mean and D is either L2 norm, L1 norm or LInf norm.", typeof(LpNormNormalizerTransform), typeof(LpNormNormalizerTransform.Arguments), typeof(SignatureDataTransform), "Lp-Norm Normalizer", new string[] { "LpNormNormalizer", "lpnorm" })]
[assembly: LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(NgramTransform), typeof(NgramTransform.Arguments), typeof(SignatureDataTransform), "Ngram Transform", new string[] { "NgramTransform", "Ngram" })]
[assembly: LoadableClass("Produces a bag of counts of ngrams (sequences of consecutive values of length 1-n) in a given vector of keys. It does so by building a dictionary of ngrams and using the id in the dictionary as the index in the bag.", typeof(NgramTransform), null, typeof(SignatureLoadDataTransform), "Ngram Transform", new string[] { "NgramTransform" })]
[assembly: LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(RangeFilter), typeof(RangeFilter.Arguments), typeof(SignatureDataTransform), "Range Filter", new string[] { "RangeFilter" })]
[assembly: LoadableClass("Filters a dataview on a column of type Single, Double or Key (contiguous). Keeps the values that are in the specified min/max range. NaNs are always filtered out. If the input is a Key type, the min/max are considered percentages of the number of values.", typeof(RangeFilter), null, typeof(SignatureLoadDataTransform), "Range Filter", new string[] { "RangeFilter" })]
[assembly: LoadableClass("Converts a key column to an indicator vector.", typeof(KeyToVectorTransform), typeof(KeyToVectorTransform.Arguments), typeof(SignatureDataTransform), "Key To Vector Transform", new string[] { "KeyToVectorTransform", "KeyToVector", "ToVector" })]
[assembly: LoadableClass("Converts a key column to an indicator vector.", typeof(KeyToVectorTransform), null, typeof(SignatureLoadDataTransform), "Key To Vector Transform", new string[] { "KeyToVectorTransform" })]
[assembly: LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(SkipTakeFilter), typeof(SkipTakeFilter.Arguments), typeof(SignatureDataTransform), "Skip and Take Filter", new string[] { "SkipTakeFilter", "SkipTake" })]
[assembly: LoadableClass("Allows limiting input to a subset of rows by skipping a number of rows.", typeof(SkipTakeFilter), typeof(SkipTakeFilter.SkipArguments), typeof(SignatureDataTransform), "Skip Filter", new string[] { "SkipFilter", "Skip" })]
[assembly: LoadableClass("Allows limiting input to a subset of rows by taking N first rows.", typeof(SkipTakeFilter), typeof(SkipTakeFilter.TakeArguments), typeof(SignatureDataTransform), "Take Filter", new string[] { "TakeFilter", "Take" })]
[assembly: LoadableClass("Allows limiting input to a subset of rows at an optional offset.  Can be used to implement data paging.", typeof(SkipTakeFilter), null, typeof(SignatureLoadDataTransform), "Skip and Take Filter", new string[] { "SkipTakeFilter" })]
[assembly: LoadableClass(typeof(RegressionEvaluator), typeof(RegressionEvaluator), typeof(RegressionEvaluator.Arguments), typeof(SignatureEvaluator), "Regression Evaluator", new string[] { "RegressionEvaluator", "Regression" })]
[assembly: LoadableClass(typeof(RegressionMamlEvaluator), typeof(RegressionMamlEvaluator), typeof(RegressionMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Regression Evaluator", new string[] { "RegressionEvaluator", "Regression" })]
[assembly: LoadableClass(typeof(RegressionPerInstanceEvaluator), null, typeof(SignatureLoadRowMapper), "", new string[] { "RegressionPerInstance" })]
[assembly: LoadableClass("Runs a previously trained predictor on the data.", typeof(IDataTransform), typeof(EvaluateTransform), typeof(EvaluateTransform.Arguments), typeof(SignatureDataTransform), "Evaluate Predictor", new string[] { "Evaluate" })]
[assembly: LoadableClass("Evaluates the metrics for a scored data file.", typeof(EvaluateCommand), typeof(EvaluateCommand.Arguments), typeof(SignatureCommand), "Evaluate Predictor", new string[] { "Evaluate" })]
[assembly: LoadableClass("Transforms the categorical column into the set of features: count of each label class, log-odds for each label class, back-off indicator. The input columns must be keys. This is a part of the Dracula transform.", typeof(CountTableTransform), typeof(CountTableTransform.Arguments), typeof(SignatureDataTransform), "Count Table Transform", new string[] { "CountTableTransform", "CountTable", "count" })]
[assembly: LoadableClass("Transforms the categorical column into the set of features: count of each label class, log-odds for each label class, back-off indicator. The input columns must be keys. This is a part of the Dracula transform.", typeof(CountTableTransform), null, typeof(SignatureLoadDataTransform), "Count Table Transform", new string[] { "CountTableTransform", "CountTableFunction" })]
[assembly: LoadableClass("Converts a column to a different type, using standard conversions.", typeof(ConvertTransform), typeof(ConvertTransform.Arguments), typeof(SignatureDataTransform), "Convert Transform", new string[] { "Convert", "ConvertTransform" })]
[assembly: LoadableClass("Converts a column to a different type, using standard conversions.", typeof(ConvertTransform), null, typeof(SignatureLoadDataTransform), "Convert Transform", new string[] { "ConvertTransform", "ConvertFunction" })]
[assembly: LoadableClass("Concatenates two columns of the same item type.", typeof(ConcatTransform), typeof(ConcatTransform.TaggedArguments), typeof(SignatureDataTransform), "Concat Transform", new string[] { "Concat", "ConcatTransform" })]
[assembly: LoadableClass("Concatenates two columns of the same item type.", typeof(ConcatTransform), null, typeof(SignatureLoadDataTransform), "Concat Transform", new string[] { "ConcatTransform", "ConcatFunction" })]
[assembly: LoadableClass(typeof(IDataTransform), typeof(CompositeTransform), null, typeof(SignatureLoadDataTransform), "Composite Transform", new string[] { "CompositeRowFunction" })]
[assembly: LoadableClass(typeof(ChooseColumnsTransform), typeof(ChooseColumnsTransform.Arguments), typeof(SignatureDataTransform), "Choose Columns Transform", new string[] { "ChooseColumnsTransform", "ChooseColumns", "Choose" })]
[assembly: LoadableClass(typeof(ChooseColumnsTransform), null, typeof(SignatureLoadDataTransform), "Choose Columns Transform", new string[] { "ChooseColumnsTransform", "ChooseColumnsFunction" })]
[assembly: LoadableClass(typeof(ChooseColumnsByIndexTransform), typeof(ChooseColumnsByIndexTransform.Arguments), typeof(SignatureDataTransform), "", new string[] { "ChooseColumnsByIndexTransform", "ChooseColumnsByIndex" })]
[assembly: LoadableClass(typeof(ChooseColumnsByIndexTransform), null, typeof(SignatureLoadDataTransform), "", new string[] { "ChooseColumnsIdxTrans", "ChooseColumnsIdxFunc" })]
[assembly: LoadableClass("Converts the categorical value into an indicator array by building a dictionary of categories based on the data and using the id in the dictionary as the index in the array.", typeof(IDataTransform), typeof(CategoricalTransform), typeof(CategoricalTransform.Arguments), typeof(SignatureDataTransform), "Categorical Transform", new string[] { "CategoricalTransform", "CatTransform", "Categorical", "Cat" })]
[assembly: LoadableClass("Converts the categorical value into an indicator array by hashing the value and using the hash as an index in the bag. If the input column is a vector, a single indicator bag is returned for it.", typeof(IDataTransform), typeof(CategoricalHashTransform), typeof(CategoricalHashTransform.Arguments), typeof(SignatureDataTransform), "Categorical Hash Transform", new string[] { "CategoricalHashTransform", "CatHashTransform", "CategoricalHash", "CatHash" })]
[assembly: LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(BitmapScalerTransform), typeof(BitmapScalerTransform.Arguments), typeof(SignatureDataTransform), "Bitmap Scaler Transform", new string[] { "BitmapScalerTransform", "BitmapScaler" })]
[assembly: LoadableClass("Scales an image to specified dimensions using one of the three scale types: isotropic with padding, isotropic with cropping or anisotropic. In case of isotropic padding, transparent color is used to pad resulting image.", typeof(BitmapScalerTransform), null, typeof(SignatureLoadDataTransform), "Bitmap Scaler Transform", new string[] { "BitmapScalerTransform", "BitmapScalerFunction" })]
[assembly: LoadableClass("Loads a Bitmap image from a file.", typeof(BitmapLoaderTransform), typeof(BitmapLoaderTransform.Arguments), typeof(SignatureDataTransform), "Bitmap Loader Transform", new string[] { "BitmapLoaderTransform", "BitmapLoader" })]
[assembly: LoadableClass("Loads a Bitmap image from a file.", typeof(BitmapLoaderTransform), null, typeof(SignatureLoadDataTransform), "Bitmap Loader Transform", new string[] { "BitmapLoaderTransform" })]
[assembly: LoadableClass(typeof(BinaryClassifierScorer), typeof(BinaryClassifierScorer.Arguments), typeof(SignatureDataScorer), "Binary Classifier Scorer", new string[] { "BinaryClassifierScorer", "BinaryClassifier", "Binary", "bin", "BinaryClassification" })]
[assembly: LoadableClass(typeof(BinaryClassifierScorer), null, typeof(SignatureLoadDataTransform), "Binary Classifier Scorer", new string[] { "BinClassScoreTransform" })]
[assembly: LoadableClass(typeof(BinaryClassifierEvaluator), typeof(BinaryClassifierEvaluator), typeof(BinaryClassifierEvaluator.Arguments), typeof(SignatureEvaluator), "Binary Classifier Evaluator", new string[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })]
[assembly: LoadableClass(typeof(BinaryClassifierMamlEvaluator), typeof(BinaryClassifierMamlEvaluator), typeof(BinaryClassifierMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Binary Classifier Evaluator", new string[] { "BinaryClassifierEvaluator", "BinaryClassifier", "Binary", "bin" })]
[assembly: LoadableClass(typeof(BinaryPerInstanceEvaluator), null, typeof(SignatureLoadRowMapper), "", new string[] { "BinaryPerInstance" })]
[assembly: LoadableClass("Adds a column with a generated number sequence.", typeof(GenerateNumberTransform), typeof(GenerateNumberTransform.Arguments), typeof(SignatureDataTransform), "Generate Number Transform", new string[] { "GenerateNumberTransform", "GenerateNumber", "Generate" })]
[assembly: LoadableClass("Adds a column with a generated number sequence.", typeof(GenerateNumberTransform), null, typeof(SignatureLoadDataTransform), "Generate Number Transform", new string[] { "GenNumTransform" })]
[assembly: LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(ShuffleTransform), typeof(ShuffleTransform.Arguments), typeof(SignatureDataTransform), "Shuffle Transform", new string[] { "ShuffleTransform", "Shuffle", "shuf" })]
[assembly: LoadableClass("Reorders rows in the dataset by pseudo-random shuffling.", typeof(ShuffleTransform), null, typeof(SignatureLoadDataTransform), "Shuffle Transform", new string[] { "ShuffleTrans" })]
[assembly: LoadableClass(typeof(SchemaBindablePredictorWrapper), null, typeof(SignatureLoadModel), "Bindable Mapper", new string[] { "SchemaBindableWrapper" })]
[assembly: LoadableClass(typeof(SchemaBindableQuantileRegressionPredictor), null, typeof(SignatureLoadModel), "Regression Bindable Mapper", new string[] { "QuantileSchemaBindable" })]
[assembly: LoadableClass(typeof(SchemaBindableBinaryPredictorWrapper), null, typeof(SignatureLoadModel), "Binary Classification Bindable Mapper", new string[] { "BinarySchemaBindable" })]
[assembly: LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. This is a part of the Dracula transform.", typeof(HashJoinTransform), typeof(HashJoinTransform.Arguments), typeof(SignatureDataTransform), "Hash Join Transform", new string[] { "HashJoinTransform", "HashJoin" })]
[assembly: LoadableClass("Converts column values into hashes. This transform accepts both numeric and text inputs, both single and vector-valued columns. This is a part of the Dracula transform.", typeof(HashJoinTransform), null, typeof(SignatureLoadDataTransform), "Hash Join Transform", new string[] { "HashJoinTransform", "HashJoinFunction" })]
[assembly: LoadableClass(typeof(NgramHashTransform), typeof(NgramHashTransform.Arguments), typeof(SignatureDataTransform), "Ngram Hash Transform", new string[] { "NgramHashTransform", "NgramHash" })]
[assembly: LoadableClass(typeof(NgramHashTransform), null, typeof(SignatureLoadDataTransform), "Ngram Hash Transform", new string[] { "NgramHashTransform" })]
[assembly: LoadableClass(typeof(GenericScorer), typeof(GenericScorer.Arguments), typeof(SignatureDataScorer), "Generic Scorer", new string[] { "GenericScorer", "Generic" })]
[assembly: LoadableClass(typeof(GenericScorer), null, typeof(SignatureLoadDataTransform), "Generic Scorer", new string[] { "GenericScoreTransform" })]
[assembly: LoadableClass(typeof(MultiOutputRegressionEvaluator), typeof(MultiOutputRegressionEvaluator), typeof(MultiOutputRegressionEvaluator.Arguments), typeof(SignatureEvaluator), "Multi Output Regression Evaluator", new string[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })]
[assembly: LoadableClass(typeof(MultiOutputRegressionMamlEvaluator), typeof(MultiOutputRegressionMamlEvaluator), typeof(MultiOutputRegressionMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Multi Output Regression Evaluator", new string[] { "MultiRegressionEvaluator", "MultiOutputRegression", "MRE" })]
[assembly: LoadableClass(typeof(MultiOutputRegressionPerInstanceEvaluator), null, typeof(SignatureLoadRowMapper), "", new string[] { "MultiRegPerInstance" })]
[assembly: LoadableClass("Loads specified transforms from the model file and applies them to current data.", typeof(IDataTransform), typeof(LoadTransform), typeof(LoadTransform.Arguments), typeof(SignatureDataTransform), "Load Transform", new string[] { "LoadTransform", "Load" })]
[assembly: LoadableClass("Removes a column from the dataset.", typeof(DropColumnsTransform), typeof(DropColumnsTransform.Arguments), typeof(SignatureDataTransform), "Drop Columns Transform", new string[] { "DropColumns", "DropColumnsTransform", "Drop" })]
[assembly: LoadableClass("Selects which columns from the dataset to keep.", typeof(DropColumnsTransform), typeof(DropColumnsTransform.KeepArguments), typeof(SignatureDataTransform), "Keep Columns Transform", new string[] { "KeepColumns", "KeepColumnsTransform", "Keep" })]
[assembly: LoadableClass("Removes a column from the dataset.", typeof(DropColumnsTransform), null, typeof(SignatureLoadDataTransform), "Drop Columns Transform", new string[] { "DropColumnsTransform" })]
[assembly: LoadableClass(typeof(CrossValidationCommand), typeof(CrossValidationCommand.Arguments), typeof(SignatureCommand), "Cross Validation", new string[] { "CV" })]
[assembly: LoadableClass(typeof(RankerEvaluator), typeof(RankerEvaluator), typeof(RankerEvaluator.Arguments), typeof(SignatureEvaluator), "Ranking Evaluator", new string[] { "RankingEvaluator", "Ranking", "rank" })]
[assembly: LoadableClass(typeof(RankerMamlEvaluator), typeof(RankerMamlEvaluator), typeof(RankerMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Ranking Evaluator", new string[] { "RankingEvaluator", "Ranking", "rank" })]
[assembly: LoadableClass(typeof(RankerPerInstanceTransform), null, typeof(SignatureLoadDataTransform), "", new string[] { "RankerPerInstTransform" })]
[assembly: LoadableClass(typeof(QuantileRegressionEvaluator), typeof(QuantileRegressionEvaluator), typeof(QuantileRegressionEvaluator.Arguments), typeof(SignatureEvaluator), "Quantile Regression Evaluator", new string[] { "QuantileRegressionEvaluator", "QuantileRegression" })]
[assembly: LoadableClass(typeof(QuantileRegressionMamlEvaluator), typeof(QuantileRegressionMamlEvaluator), typeof(QuantileRegressionMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Quantile Regression Evaluator", new string[] { "QuantileRegressionEvaluator", "QuantileRegression" })]
[assembly: LoadableClass(typeof(QuantileRegressionPerInstanceEvaluator), null, typeof(SignatureLoadRowMapper), "", new string[] { "QuantileRegPerInstance" })]
[assembly: LoadableClass(typeof(MultiClassClassifierScorer), typeof(MultiClassClassifierScorer.Arguments), typeof(SignatureDataScorer), "Multi-Class Classifier Scorer", new string[] { "MultiClassClassifierScorer", "MultiClassClassifier", "MultiClass", "MultiClassClassification" })]
[assembly: LoadableClass(typeof(MultiClassClassifierScorer), null, typeof(SignatureLoadDataTransform), "Multi-Class Classifier Scorer", new string[] { "MultiClassScoreTrans" })]
[assembly: LoadableClass("Executes a given lambda expression on input column values to produce an output column value. Accepts multiple input columns to produce an output column. The input column types currently supported are Float, 4 byte integer, and Boolean. At most one input column can be vector valued, in which case the output column is also vector valued and the lambda is executed on each slot of the input vector. Here are some examples assuming one floating point valued input (possibly vector valued):\r\n1) expr={x : x / 256} divides the input value by 256, useful for pixel data.\r\n2) expr={x : x ?? -1} replaces missing values with -1.\r\n3) expr={x : isna(x) ? 1.0 : 0.0} and expr={x : float(isna(x))} both produce missing value indicator values.\r\nThese examples assume two numeric inputs, with at most one vector valued:\r\n1) expr={(x, y) : log(x / y)} computes log odds.\r\n2) expr={(x, y) : (x - y)^2} computes the square of the difference.\r\n3) expr={(x, y) : abs(x - y)^0.5} and expr={x : sqrt(abs(x - y))} both compute the square root of the absolute value of the difference.\r\n4) expr={(x, y) : x ?? y} produces x if it is not an NA value and y otherwise.\r\n5) expr={(r, a) : r * cosd(a)} and expr={(r, a) : r * sind(a)} convert from polar coordinates, with the angle in degrees, to rectangular coordinates. This is useful, for example, to convert wind speed and compass direction to north-ward and east-ward wind velocity components.", typeof(ExprTransform), typeof(ExprTransform.Arguments), typeof(SignatureDataTransform), "Expression Transform", new string[] { "Expression", "ExpressionTransform", "Expr", "ExprTransform" })]
[assembly: LoadableClass("Executes a given lambda expression on input column values to produce an output column value. Accepts multiple input columns to produce an output column. The input column types currently supported are Float, 4 byte integer, and Boolean. At most one input column can be vector valued, in which case the output column is also vector valued and the lambda is executed on each slot of the input vector. Here are some examples assuming one floating point valued input (possibly vector valued):\r\n1) expr={x : x / 256} divides the input value by 256, useful for pixel data.\r\n2) expr={x : x ?? -1} replaces missing values with -1.\r\n3) expr={x : isna(x) ? 1.0 : 0.0} and expr={x : float(isna(x))} both produce missing value indicator values.\r\nThese examples assume two numeric inputs, with at most one vector valued:\r\n1) expr={(x, y) : log(x / y)} computes log odds.\r\n2) expr={(x, y) : (x - y)^2} computes the square of the difference.\r\n3) expr={(x, y) : abs(x - y)^0.5} and expr={x : sqrt(abs(x - y))} both compute the square root of the absolute value of the difference.\r\n4) expr={(x, y) : x ?? y} produces x if it is not an NA value and y otherwise.\r\n5) expr={(r, a) : r * cosd(a)} and expr={(r, a) : r * sind(a)} convert from polar coordinates, with the angle in degrees, to rectangular coordinates. This is useful, for example, to convert wind speed and compass direction to north-ward and east-ward wind velocity components.", typeof(ExprTransform), null, typeof(SignatureLoadDataTransform), "Expression Transform", new string[] { "ExprTransform", "DemoTransform" })]
[assembly: LoadableClass("Runs a previously trained predictor on the data.", typeof(IDataTransform), typeof(ScoreTransform), typeof(ScoreTransform.Arguments), typeof(SignatureDataTransform), "Score Predictor", new string[] { "Score" })]
[assembly: LoadableClass("Trains a predictor, or loads it from a file, and runs it on the data.", typeof(IDataTransform), typeof(TrainAndScoreTransform), typeof(TrainAndScoreTransform.Arguments), typeof(SignatureDataTransform), "Train and Score Predictor", new string[] { "TrainScore" })]
[assembly: LoadableClass(typeof(ShowSchemaCommand), typeof(ShowSchemaCommand.Arguments), typeof(SignatureCommand), "Show Schema", new string[] { "ShowSchema", "schema" })]
[assembly: LoadableClass(typeof(RowToRowMapperTransform), null, typeof(SignatureLoadDataTransform), "", new string[] { "RowToRowMapper" })]
[assembly: LoadableClass(typeof(IDataScorerTransform), typeof(QuantileRegressionScorerTransform), typeof(QuantileRegressionScorerTransform.Arguments), typeof(SignatureDataScorer), "Quantile Regression Scorer", new string[] { "QuantileRegressionScorer", "QuantileRegression" })]
[assembly: LoadableClass(typeof(ISchemaBindableMapper), typeof(QuantileRegressionScorerTransform), typeof(QuantileRegressionScorerTransform.Arguments), typeof(SignatureBindableMapper), "Quantile Regression Mapper", new string[] { "QuantileRegressionScorer", "QuantileRegression" })]
[assembly: LoadableClass("Produces a new column with the row ID.", typeof(ProduceIdTransform), typeof(ProduceIdTransform.Arguments), typeof(SignatureDataTransform), "", new string[] { "ProduceIdTransform", "ProduceId" })]
[assembly: LoadableClass("Produces a new column with the row ID.", typeof(ProduceIdTransform), null, typeof(SignatureLoadDataTransform), "Produce ID Transform", new string[] { "ProduceIdTransform" })]
[assembly: LoadableClass("Does nothing.", typeof(NopTransform), null, typeof(SignatureLoadDataTransform), "", new string[] { "NopTransform" })]
[assembly: LoadableClass("Selects the top k slots ordered by their mutual information with the label column.", typeof(IDataTransform), typeof(MutualInformationFeatureSelectionTransform), typeof(MutualInformationFeatureSelectionTransform.Arguments), typeof(SignatureDataTransform), "Mutual Information Feature Selection Transform", new string[] { "MutualInformationFeatureSelection", "MutualInformationFeatureSelectionTransform", "MIFeatureSelection" })]
[assembly: LoadableClass("Performs the logical inner join or left-outer join of two data views.", typeof(IDataTransform), typeof(LeftJoinTransform), typeof(LeftJoinTransform.Arguments), typeof(SignatureDataTransform), "Left Join Transform", new string[] { "LeftJoin", "LeftJoinTransform" })]
[assembly: LoadableClass("Performs the logical inner join or left-outer join of two data views.", typeof(LeftJoinTransform), null, typeof(SignatureLoadDataTransform), "Left Join Transform", new string[] { "LeftJoinTransform" })]
[assembly: LoadableClass("Performs the logical left semi-join of two data views.", typeof(IDataTransform), typeof(LeftSemiJoinTransform), typeof(LeftSemiJoinTransform.Arguments), typeof(SignatureDataTransform), "Left Semi-Join Transform", new string[] { "LeftSemiJoin", "LeftSemiJoinTransform" })]
[assembly: LoadableClass("Performs the logical left semi-join of two data views.", typeof(LeftSemiJoinTransform), null, typeof(SignatureLoadDataTransform), "Left Semi-Join Transform", new string[] { "LeftSemiJoinTransform" })]
[assembly: LoadableClass("Selects the slots for which the absolute value of the corresponding weight in a linear learner is greater than a threshold.", typeof(IDataTransform), typeof(LearnerFeatureSelectionTransform), typeof(LearnerFeatureSelectionTransform.Arguments), typeof(SignatureDataTransform), "Learner Feature Selection Transform", new string[] { "LearnerFeatureSelectionTransform", "LearnerFeatureSelection" })]
[assembly: LoadableClass("Convert a label column into a standard floating point representation.", typeof(LabelConvertTransform), typeof(LabelConvertTransform.Arguments), typeof(SignatureDataTransform), "", new string[] { "LabelConvert", "LabelConvertTransform" })]
[assembly: LoadableClass("Convert a label column into a standard floating point representation.", typeof(LabelConvertTransform), null, typeof(SignatureLoadDataTransform), "Label Convert Transform", new string[] { "LabelConvertTransform" })]
[assembly: LoadableClass("Writes data into a transposed binary TDV file.", typeof(TransposeSaver), typeof(TransposeSaver.Arguments), typeof(SignatureDataSaver), "Transpose Saver", new string[] { "TransposeSaver", "TransposedSaver", "Transpose", "Transposed", "trans" })]
[assembly: LoadableClass("Loads a binary transposed data file.", typeof(TransposeLoader), typeof(TransposeLoader.Arguments), typeof(SignatureDataLoader), "Transpose Loader", new string[] { "TransposeLoader", "Transpose", "trans" })]
[assembly: LoadableClass("Loads a binary transposed data file.", typeof(TransposeLoader), null, typeof(SignatureLoadDataLoader), "Transpose Data View Loader", new string[] { "TransposeLoader" })]
[assembly: LoadableClass(typeof(NAIndicatorTransform), typeof(NAIndicatorTransform.Arguments), typeof(SignatureDataTransform), "NA Indicator Transform", new string[] { "NAIndicatorTransform", "NAIndicator", "NAInd" })]
[assembly: LoadableClass(typeof(NAIndicatorTransform), null, typeof(SignatureLoadDataTransform), "NA Indicator Transform", new string[] { "NaIndicatorTransform" })]
[assembly: LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(GroupTransform), typeof(GroupTransform.Arguments), typeof(SignatureDataTransform), "Group Transform", new string[] { "Group" })]
[assembly: LoadableClass("Groups values of a scalar column into a vector, by a contiguous group ID", typeof(GroupTransform), null, typeof(SignatureLoadDataTransform), "Group Transform", new string[] { "GroupTransform" })]
[assembly: LoadableClass(typeof(GaussianFourierSampler), typeof(GaussianFourierSampler.Arguments), typeof(SignatureFourierDistributionSampler), "Gaussian Kernel", new string[] { "GaussianRandom", "Gaussian" })]
[assembly: LoadableClass(typeof(LaplacianFourierSampler), typeof(LaplacianFourierSampler.Arguments), typeof(SignatureFourierDistributionSampler), "Laplacian Kernel", new string[] { "LaplacianRandom", "Laplacian" })]
[assembly: LoadableClass(typeof(GaussianFourierSampler), null, typeof(SignatureLoadModel), "Gaussian Fourier Sampler Executor", new string[] { "GaussianSamplerExecutor", "RandGaussFourierExec" })]
[assembly: LoadableClass(typeof(LaplacianFourierSampler), null, typeof(SignatureLoadModel), "Laplacian Fourier Sampler Executor", new string[] { "LaplacianSamplerExecutor", "RandLaplacianFourierExec" })]
[assembly: LoadableClass("Removes the selected slots from the column.", typeof(DropSlotsTransform), typeof(DropSlotsTransform.Arguments), typeof(SignatureDataTransform), "Drop Slots Transform", new string[] { "DropSlots", "DropSlotsTransform" })]
[assembly: LoadableClass("Removes the selected slots from the column.", typeof(DropSlotsTransform), null, typeof(SignatureLoadDataTransform), "Drop Slots Transform", new string[] { "DropSlotsTransform" })]
[assembly: LoadableClass("Selects the slots for which the count of non-default values is greater than or equal to a threshold.", typeof(IDataTransform), typeof(CountFeatureSelectionTransform), typeof(CountFeatureSelectionTransform.Arguments), typeof(SignatureDataTransform), "Count Feature Selection Transform", new string[] { "CountFeatureSelectionTransform", "CountFeatureSelection" })]
[assembly: LoadableClass(typeof(AnomalyDetectionEvaluator), typeof(AnomalyDetectionEvaluator), typeof(AnomalyDetectionEvaluator.Arguments), typeof(SignatureEvaluator), "Anomaly Detection Evaluator", new string[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })]
[assembly: LoadableClass(typeof(AnomalyDetectionMamlEvaluator), typeof(AnomalyDetectionMamlEvaluator), typeof(AnomalyDetectionMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Anomaly Detection Evaluator", new string[] { "AnomalyDetectionEvaluator", "AnomalyDetection", "Anomaly" })]
[assembly: LoadableClass(typeof(ClusteringEvaluator), typeof(ClusteringEvaluator), typeof(ClusteringEvaluator.Arguments), typeof(SignatureEvaluator), "Clustering Evaluator", new string[] { "ClusteringEvaluator", "Clustering" })]
[assembly: LoadableClass(typeof(ClusteringMamlEvaluator), typeof(ClusteringMamlEvaluator), typeof(ClusteringMamlEvaluator.Arguments), typeof(SignatureMamlEvaluator), "Clustering Evaluator", new string[] { "ClusteringEvaluator", "Clustering" })]
[assembly: LoadableClass(typeof(ClusteringPerInstanceEvaluator), null, typeof(SignatureLoadRowMapper), "", new string[] { "ClusteringPerInstance" })]
[assembly: LoadableClass("Copy a source column to a new column.", typeof(CopyColumnsTransform), typeof(CopyColumnsTransform.Arguments), typeof(SignatureDataTransform), "Copy Columns Transform", new string[] { "CopyColumns", "CopyColumnsTransform", "Copy" })]
[assembly: LoadableClass("Copy a source column to a new column.", typeof(CopyColumnsTransform), null, typeof(SignatureLoadDataTransform), "Copy Columns Transform", new string[] { "CopyTransform" })]
[assembly: LoadableClass(typeof(ClusteringScorer), typeof(ClusteringScorer.Arguments), typeof(SignatureDataScorer), "Clustering Scorer", new string[] { "ClusteringScorer", "Clustering" })]
[assembly: LoadableClass(typeof(ClusteringScorer), null, typeof(SignatureLoadDataTransform), "Clustering Scorer", new string[] { "ClusteringScoreTrans" })]
[assembly: LoadableClass(typeof(NAReplaceTransform), typeof(NAReplaceTransform.Arguments), typeof(SignatureDataTransform), "NA Replace Transform", new string[] { "NAReplaceTransform", "NAReplace", "NARep" })]
[assembly: LoadableClass(typeof(NAReplaceTransform), null, typeof(SignatureLoadDataTransform), "NA Replace Transform", new string[] { "NAReplaceTransform" })]
[assembly: LoadableClass("Removes NAs from vector columns.", typeof(NADropTransform), typeof(NADropTransform.Arguments), typeof(SignatureDataTransform), "NA Drop Transform", new string[] { "NADrop", "NADropTransform" })]
[assembly: LoadableClass("Removes NAs from vector columns.", typeof(NADropTransform), null, typeof(SignatureLoadDataTransform), "NA Drop Transform", new string[] { "NADropTransform" })]
[assembly: LoadableClass(typeof(KeyToValueTransform), typeof(KeyToValueTransform.Arguments), typeof(SignatureDataTransform), "Key To Value Transform", new string[] { "KeyToValueTransform", "KeyToValue", "KeyToVal", "Unterm" })]
[assembly: LoadableClass(typeof(KeyToValueTransform), null, typeof(SignatureLoadDataTransform), "Key To Value Transform", new string[] { "KeyToValueTransform" })]
[assembly: LoadableClass("Approximate bootstrap sampling.", typeof(BootstrapSampleTransform), typeof(BootstrapSampleTransform.Arguments), typeof(SignatureDataTransform), "Bootstrap Sample Transform", new string[] { "BootstrapSampleTransform", "BootstrapSample" })]
[assembly: LoadableClass("Approximate bootstrap sampling.", typeof(BootstrapSampleTransform), null, typeof(SignatureLoadDataTransform), "Bootstrap Sample Transform", new string[] { "BootstrapSampleTransform" })]
[assembly: AssemblyFileVersion("3.5.79.0")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("TLC Machine Learning Toolkit")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
