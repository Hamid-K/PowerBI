using System;

namespace Microsoft.Mashup.Engine1.Runtime
{
	// Token: 0x020016E0 RID: 5856
	internal class LibraryText
	{
		// Token: 0x04004F25 RID: 20261
		public const string Source = "// Copyright (c) Microsoft Corporation.  All rights reserved.\r\n    \r\nsection Text;\r\n\r\nshared RelativePosition.Type = Value.RemoveMetadata(Number.Type) meta [\r\n    Documentation.Name = \"RelativePosition.Type\",\r\n    Documentation.Description = LibraryModule!UICulture.GetString(\"RelativePositionTypeDescription\"),\r\n    Documentation.AllowedValues = { RelativePosition.FromStart, RelativePosition.FromEnd }\r\n];\r\nshared RelativePosition.FromStart = 0 meta [Documentation.Name = \"RelativePosition.FromStart\"];\r\nshared RelativePosition.FromEnd = 1 meta [Documentation.Name = \"RelativePosition.FromEnd\"];\r\n\r\nshared Text.AfterDelimiter = (text as nullable text, delimiter as text, optional index as any) =>\r\n    let\r\n        IndexAsList = GetDelimiterIndexAsList(index),\r\n        Index = IndexAsList{0},\r\n        IndexFrom = IndexAsList{1},\r\n        Parts = Splitter.SplitTextByDelimiter(delimiter, QuoteStyle.None)(text),\r\n        PartsToSkip = if IndexFrom = RelativePosition.FromEnd then List.Max({List.Count(Parts) - (Index + 1), 0}) else Index + 1,\r\n        RelevantParts = List.Skip(Parts, PartsToSkip),\r\n        Combined = Combiner.CombineTextByDelimiter(delimiter, QuoteStyle.None)(RelevantParts)\r\n    in\r\n        Combined;\r\n\r\nshared Text.BeforeDelimiter = (text as nullable text, delimiter as text, optional index as any) =>\r\n    let\r\n        IndexAsList = GetDelimiterIndexAsList(index),\r\n        Index = IndexAsList{0},\r\n        IndexFrom = IndexAsList{1},\r\n        Parts = Splitter.SplitTextByDelimiter(delimiter, QuoteStyle.None)(text),\r\n        PartsToTake = if IndexFrom = RelativePosition.FromEnd then List.Max({List.Count(Parts) - (Index + 1), 0}) else Index + 1,\r\n        RelevantParts = List.FirstN(Parts, PartsToTake),\r\n        Combined = Combiner.CombineTextByDelimiter(delimiter, QuoteStyle.None)(RelevantParts)\r\n    in\r\n        Combined;\r\n\r\nshared Text.BetweenDelimiters = (text as nullable text, startDelimiter as text, endDelimiter as text, optional startIndex as any, optional endIndex as any) =>\r\n    let\r\n        EndIndexFrom = GetDelimiterIndexAsList(endIndex){1},\r\n        Result = if EndIndexFrom = RelativePosition.FromStart then \r\n            Text.BeforeDelimiter(Text.AfterDelimiter(text, startDelimiter, startIndex), endDelimiter, endIndex)\r\n        else\r\n            Text.AfterDelimiter(Text.BeforeDelimiter(text, startDelimiter, startIndex), endDelimiter, endIndex)\r\n    in\r\n        Result;\r\n\r\nGetDelimiterIndexAsList = (index as any) as list =>\r\n    if index = null then\r\n        {0, RelativePosition.FromStart}\r\n    else if index is number then\r\n        {index, RelativePosition.FromStart}\r\n    else if index is list and List.Count(index) = 2 and index{0} is number and index{1} = RelativePosition.FromStart or index{1} = RelativePosition.FromEnd then\r\n        index\r\n    else\r\n        error Error.Record(\"Expression.Error\", LibraryModule!UICulture.GetString(\"InvalidDelimiterIndexParameter\"), index);\r\n\r\n    ";
	}
}
