using System;

namespace Microsoft.Mashup.Engine1.Library.Table
{
	// Token: 0x0200036D RID: 877
	internal class TableModuleSource
	{
		// Token: 0x04000B4C RID: 2892
		public const string Source = "// Copyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\nsection Table;\r\n\r\n//\r\n// Parameter helpers\r\n//\r\n\r\nColumnsSelector.CreateColumnsList = (value) =>\r\n    if (value is text) then {value}\r\n    else value;\r\n\r\nColumnsSelector.CreateListKeySelector = (value) =>\r\n    if (value is text) then each Record.Field(_, value)\r\n    else each Record.SelectFields(_, value);\r\n\r\nTableColumnTransformOperations.CreateTransformOperationsList = (value) =>\r\n    if (value is list and List.Count(value) = 2 and value{0} is text and value{1} is function) then {value}\r\n    else value;\r\n\r\nTableEquationCriteria.CreateListEquationCriteria = (value) =>\r\n    if (value is function) then value\r\n    else if (TableEquationCriterion.IsTableEquationCriterion(value)) then TableEquationCriterion.CreateListEquationCriterion(value)\r\n    else if (value is list and not List.IsEmpty(value) and value{0} is list) then List.Transform(value, TableEquationCriterion.CreateListEquationCriterion)\r\n    else ColumnsSelector.CreateListKeySelector(value);\r\n\r\nTableEquationCriterion.CreateListEquationCriterion = (value) =>\r\n    {ColumnsSelector.CreateListKeySelector(value{0}), value{1}};\r\n\r\nTableEquationCriterion.IsTableEquationCriterion = (value) =>\r\n    value is list and List.Count(value) = 2\r\n        and value{0} is text\r\n        and value{1} is function;\r\n\r\nTableEquationCriterion.Default = (row) =>\r\n    each try Record.SelectFields(_, Record.FieldNames(row)) otherwise _;\r\n\r\nTableRowReplacementOperation.CreateListReplacementOperation = (value) =>\r\n    value;\r\n\r\nTableRowReplacementOperation.IsTableRowReplacementOperation = (value) =>\r\n    value is list and List.Count(value) = 2\r\n        and value{0} is record\r\n        and value{1} is record;\r\n\r\nTableRowReplacementOperations.CreateListReplacementOperations = (value) =>\r\n    if (TableRowReplacementOperation.IsTableRowReplacementOperation(value)) then {TableRowReplacementOperation.CreateListReplacementOperation(value)}\r\n    else List.Transform(value, each TableRowReplacementOperation.CreateListReplacementOperation(_));\r\n\r\nRank.NoFunction = (x) =>\r\n    if x is function then error [Reason = \"Expression.Error\", Message = LibraryModule!UICulture.GetString(\"ComparisonCriteria_NoFunctions\"), Detail = x]\r\n    else x;\r\n\r\nRank.MakeComparisonItem = (item) =>\r\n    if item is text then {item, Order.Ascending}\r\n    else if item is list then\r\n        if List.Count(item) = 1 then {item{0}, Order.Ascending}\r\n        else if List.Count(item) = 2 then item\r\n        else Rank.NoFunction(item)\r\n    else Rank.NoFunction(item);\r\n\r\nRank.MakeComparisonCriteria = (c) =>\r\n    if c is text then {{c, Order.Ascending}}\r\n    else if c is list and c{1}? is number then {Rank.MakeComparisonItem(c)}\r\n    else if c is list then List.Transform(c, Rank.MakeComparisonItem)\r\n    else c;\r\n\r\nRank.ValidateComparison = (c) =>\r\n    if c is list and List.Count(c) > 0 and\r\n            List.AllTrue(List.Transform(c, (e) => e is list and List.Count(e) = 2 and e{0} is text and (e{1} = Order.Ascending or e{1} = Order.Descending)))\r\n        then c\r\n        else error [Reason = \"Expression.Error\", Message = LibraryModule!UICulture.GetString(\"TableSortInvalidSortCriteria\"), Detail = c];\r\n\r\n//\r\n// Information\r\n//\r\n\r\nshared Table.ColumnCount = (table as table) as number =>\r\n    List.Count(Table.ColumnNames(table));\r\n\r\n//\r\n// Row selection and access\r\n//\r\n\r\nshared Table.AlternateRows = TableModule!Function.PreserveTableLineage(\r\n    (table as table, offset as number, skip as number, take as number) as table =>\r\n        Table.FromRecords(List.Alternate(Table.ToRecords(table), skip, take, offset), Value.Type(table)));\r\n\r\nshared Table.InsertRows = (table as table, offset as number, rows as list) as table =>\r\n    Table.ReplaceRows(table, offset, 0, rows);\r\n\r\nshared Table.LastN = TableModule!Function.PreserveTableLineage(\r\n    (table as table, countOrCondition) as table =>\r\n        Table.FromRecords(List.LastN(Table.ToRecords(table), countOrCondition), Value.Type(table)));\r\n\r\nshared Table.Last = (table as table, optional default) =>\r\n    List.Last(Table.ToRecords(table), default);\r\n\r\nshared Table.MatchesAllRows = (table as table, condition as function) as logical =>\r\n    List.MatchesAll(Table.ToRecords(table), condition);\r\n\r\nshared Table.MatchesAnyRows = (table as table, condition as function) as logical =>\r\n    List.MatchesAny(Table.ToRecords(table), condition);\r\n\r\nshared Table.Partition = (table as table, column as text, groups as number, hash as function) as list => \r\n    List.Generate(\r\n        () => 0,\r\n        (i) => i < groups,\r\n        (i) => i + 1, \r\n        (i) => Table.SelectRows(table, (row) => Number.Mod(hash(Record.Field(row, column)), groups) = i));\r\n\r\nshared Table.Range = (table as table, offset as number, optional count as nullable number) as table =>\r\nlet\r\n    skippedInput = Table.Skip(table, offset)\r\nin\r\n    if (count = null) then skippedInput\r\n    else Table.FirstN(skippedInput, count);\r\n\r\nshared Table.RemoveRows = (table as table, offset as number, optional count as nullable number) as table =>\r\n    Table.ReplaceRows(table, offset, if (count = null) then 1 else count, {});\r\n\r\nshared Table.Repeat = (table as table, count as number) as table =>\r\n    Table.Combine(List.Repeat({table}, count));\r\n\r\nshared Table.ReplaceRows = TableModule!Function.PreserveTableLineage(\r\n    (table as table, offset as number, count as number, rows as list) as table =>\r\n        Table.FromRecords(List.ReplaceRange(Table.ToRecords(table), offset, count, rows), Type.ReplaceTableKeys(Value.Type(table), {})));\r\n\r\nshared Table.ReverseRows = TableModule!Function.PreserveTableLineage(\r\n    (table as table) as table =>\r\n        Table.FromRecords(List.Reverse(Table.ToRecords(table)), Value.Type(table)));\r\n\r\n//\r\n// Column selection and access\r\n//\r\n\r\nshared Table.HasColumns = (table as table, columns) as logical =>\r\n    List.ContainsAll(Table.ColumnNames(table), ColumnsSelector.CreateColumnsList(columns));\r\n\r\nshared Table.PrefixColumns = (table as table, prefix as text) as table =>\r\nlet\r\n    names = Table.ColumnNames(table),\r\n    renames = List.Transform(names, each {_, prefix & \".\" & _})\r\nin\r\n    Table.RenameColumns(table, renames);\r\n\r\nshared Table.ColumnsOfType = (table as table, listOfTypes as list) as list =>\r\nlet \r\n    columnsInfo = Record.ToTable(Type.RecordFields(Type.TableRow(Value.Type(table))))\r\nin\r\n    Table.SelectRows(columnsInfo, each\r\n        List.MatchesAny(listOfTypes,\r\n            (typeToCompare) => Type.Is([Value][Type], typeToCompare)))[Name];\r\n\r\n//\r\n// Transformation\r\n//\r\n\r\nshared Table.AddColumn =\r\n    (\r\n        table as table,\r\n        newColumnName as text,\r\n        columnGenerator as function,\r\n        optional columnType as nullable type\r\n    ) as table =>\r\n    let\r\n        newColumnType = if (columnType <> null) then columnType else Type.FunctionReturn(Value.Type(columnGenerator))\r\n    in\r\n        TableModule!Table.AddColumns(table, {newColumnName}, each {columnGenerator(_)}, {newColumnType});\r\n\r\nshared Table.DuplicateColumn = (\r\n    table as table,\r\n    columnName as text,\r\n    newColumnName as text,\r\n    optional columnType as nullable type\r\n) as table =>\r\nlet\r\n    newColumnType = if (columnType <> null) then columnType else Type.TableColumn(Value.Type(table), columnName)\r\nin\r\n    Table.AddColumn(table, newColumnName, each Record.Field(_, columnName), newColumnType);\r\n\r\nshared Table.FillUp = (table as table, columns as list) as table =>\r\n    Table.ReverseRows(Table.FillDown(Table.ReverseRows(table), columns));\r\n\r\nshared Table.RemoveLastN = (table as table, optional countOrCondition) as table => \r\n    Table.ReverseRows(Table.Skip(Table.ReverseRows(table), countOrCondition));\r\n\r\nshared Table.RemoveFirstN = Table.Skip;\r\n\r\nshared Table.ExpandListColumn = (table as table, column as text) as table =>\r\n        TableModule!Table.ExpandListColumn(table, column, /* singleOrDefault: */ false);\r\n\r\nshared Table.ExpandTableColumn = (\r\n    table as table,\r\n    column as text,\r\n    columnNames as list,\r\n    optional newColumnNames as nullable list\r\n) as table =>\r\nlet\r\n    newColumnNamesToUse =\r\n        if (newColumnNames <> null and List.Count(newColumnNames) <> List.Count(columnNames)) then\r\n            error [Reason = \"Expression.Error\", Message = LibraryModule!UICulture.GetString(\"TableExpandTableColumn_ColumnAndNewColumnNamesMustHaveSameCount\")]\r\n        else newColumnNames\r\nin\r\n    Table.ExpandRecordColumn(Table.ExpandListColumn(table, column), column, columnNames, newColumnNamesToUse);\r\n\r\nTable.UniqueName = (\r\n    table as table\r\n) =>\r\n    \"_\" & Text.Combine(Table.ColumnNames(table)); // TODO: More efficient unique name\r\n\r\nshared Table.TransformRows = (table as table, transform as function) as list =>\r\n    List.Transform(Table.ToRecords(table), transform);\r\n\r\nshared Table.Transpose = TableModule!Function.PreserveTableLineage(\r\n    (table as table, optional columns) as table =>\r\n        Table.FromColumns(Table.ToRows(table), columns));\r\n\r\nshared Table.DemoteHeaders = TableModule!Function.PreserveTableLineage(\r\n    (table as table) as table => \r\n        let\r\n            Result = Table.FromRows(List.Combine({{Table.ColumnNames(table)}, Table.ToRows(table)})),\r\n            WithInferType = Result meta [ShouldInferTableType = null]\r\n        in\r\n            WithInferType);\r\n\r\nshared Table.ToRows = (table as table) as list =>\r\n    List.Transform(Table.ToRecords(table), (record) => Record.FieldValues(record));\r\n\r\nshared Table.ToColumns = (table as table) as list =>\r\n    List.Transform(Table.ColumnNames(table), (column) => Table.Column(table, column));\r\n\r\nValidateOptions = (\r\n    options as nullable record,\r\n    functionName as text,\r\n    validOptions as list\r\n) as record =>\r\n    let\r\n        optionsRecord = options ?? [],\r\n        badOption = List.First(Record.FieldNames(Record.RemoveFields(optionsRecord, validOptions, MissingField.Ignore))),\r\n        validatedOptions = if badOption = null then optionsRecord else\r\n            error [Reason = \"Expression.Error\", Message = LibraryModule!UICulture.GetString(\"InvalidOption\", {badOption, functionName, Text.Combine(List.Sort(validOptions), \", \")})]\r\n    in\r\n        validatedOptions;\r\n\r\nshared Table.CombineColumnsToRecord = (\r\n        table as table,\r\n        newColumnName as text,\r\n        sourceColumns as list,\r\n        optional options as record\r\n    ) as table =>\r\n        let\r\n            validatedOptions = ValidateOptions(options, \"Table.CombineColumnsToRecord\", {\"DisplayNameColumn\", \"TypeName\"}),\r\n            uniqueName = Table.UniqueName(table),\r\n            tableType = Value.Type(table),\r\n            displayNameColumn = validatedOptions[DisplayNameColumn]?,\r\n            dni = Expression.Identifier(displayNameColumn),\r\n            getDisplayName = (v) => let dn = Record.FieldOrDefault(Value.Metadata(v), \"Documentation.DisplayName\", v) in\r\n                if dn is text or dn is null or dn is binary or dn is action or dn is function or dn is list or dn is table or dn is record or dn is type then dn else try Text.From(dn) otherwise dn,\r\n            valueMeta = if displayNameColumn = null then \"\"\r\n                else \" meta [Documentation.DisplayName = getDisplayName(row[\" & dni & \"])]\",\r\n            typeName = validatedOptions[TypeName]?,\r\n            typeMeta = if typeName = null then [] else [Documentation.TypeName = typeName],\r\n            addTypeName = if typeName = null then (x) => x\r\n                else (x) => \"let v = \" & x & \" in Value.ReplaceType(v, Value.Type(v) meta [Documentation.TypeName = \" & Expression.Constant(typeName) & \"])\"\r\n        in\r\n            Table.RenameColumns(\r\n                Table.RemoveColumns(\r\n                    Table.ReorderColumns(\r\n                        Table.AddColumn(\r\n                            table,\r\n                            uniqueName,\r\n                            Expression.Evaluate(\r\n                                \"(row) => \" & addTypeName(\"[\" & Text.Combine(\r\n                                    List.Transform(\r\n                                        sourceColumns,\r\n                                        (c) => Expression.Identifier(c) & \" = row[\" & Expression.Identifier(c) & \"]\"),\r\n                                    \",\") & \"] \" & valueMeta),\r\n                                [Value.Type = Value.Type, Value.ReplaceType = Value.ReplaceType, getDisplayName = getDisplayName]),\r\n                            Type.ForRecord(\r\n                                List.Accumulate(\r\n                                    sourceColumns,\r\n                                    [],\r\n                                    (r, c) => Record.AddField(\r\n                                        r,\r\n                                        c,\r\n                                        [Type = Type.TableColumn(tableType, c), Optional = false])),\r\n                                false)\r\n                                meta typeMeta),\r\n                        {uniqueName, List.Last(sourceColumns) ?? List.Last(Table.ColumnNames(table))}),\r\n                    if displayNameColumn = null then sourceColumns else List.Distinct(sourceColumns & {displayNameColumn})),\r\n                {uniqueName, newColumnName});\r\n\r\n//\r\n// Membership\r\n//\r\n\r\nGetListEquationCriteria = (equationCriteria) => \r\n    if (equationCriteria <> null) then TableEquationCriteria.CreateListEquationCriteria(equationCriteria)\r\n    else null;\r\n\r\nGetTableContainsEquationCriteria = (row, equationCriteria) => \r\n    if (equationCriteria <> null) then TableEquationCriteria.CreateListEquationCriteria(equationCriteria)\r\n    else TableEquationCriterion.Default(row);\r\n\r\nshared Table.Contains = (\r\n    table as table,\r\n    row as record,\r\n    optional equationCriteria\r\n) as logical =>\r\n    List.Contains(Table.ToRecords(table), row, GetTableContainsEquationCriteria(row, equationCriteria));\r\n\r\nshared Table.ContainsAll = (\r\n    table as table,\r\n    rows as list,\r\n    optional equationCriteria\r\n) as logical =>\r\n    List.AllTrue(List.Transform(rows, each Table.Contains(table, _, equationCriteria)));\r\n\r\nshared Table.ContainsAny = (\r\n    table as table,\r\n    rows as list,\r\n    optional equationCriteria\r\n) as logical =>\r\n    List.AnyTrue(List.Transform(rows, each Table.Contains(table, _, equationCriteria)));\r\n\r\nshared Table.IsDistinct = (table as table, optional comparisonCriteria) as logical =>\r\n    List.IsDistinct(Table.ToRecords(table), GetListEquationCriteria(comparisonCriteria));\r\n\r\nshared Table.PositionOf = (\r\n    table as table,\r\n    row as record,\r\n    optional occurrence,\r\n    optional equationCriteria\r\n) =>\r\n    List.PositionOf(Table.ToRecords(table), row, occurrence, GetListEquationCriteria(equationCriteria));\r\n\r\nshared Table.PositionOfAny = (\r\n    table as table,\r\n    rows as list,\r\n    optional occurrence as number,\r\n    optional equationCriteria\r\n) =>\r\n    List.PositionOfAny(Table.ToRecords(table), rows, occurrence, GetListEquationCriteria(equationCriteria));\r\n\r\nshared Table.RemoveMatchingRows = TableModule!Function.PreserveTableLineage(\r\n    (\r\n        table as table,\r\n        rows as list,\r\n        optional equationCriteria\r\n    ) as table =>\r\n        Table.FromRecords(List.RemoveMatchingItems(Table.ToRecords(table), rows, GetListEquationCriteria(equationCriteria)), Value.Type(table)));\r\n\r\nshared Table.ReplaceMatchingRows = TableModule!Function.PreserveTableLineage(\r\n    (\r\n        table as table,\r\n        replacements as list,\r\n        optional equationCriteria\r\n    ) as table =>\r\n        Table.FromRecords(List.ReplaceMatchingItems(\r\n            Table.ToRecords(table),\r\n            TableRowReplacementOperations.CreateListReplacementOperations(replacements),\r\n            GetListEquationCriteria(equationCriteria)), Value.Type(table)));\r\n\r\n//\r\n// Comparison\r\n//\r\n\r\nshared Table.Max = (\r\n    table as table,\r\n    comparisonCriteria,\r\n    optional default\r\n) =>\r\n    Table.First(TableModule!Table.SortDescending(table, comparisonCriteria), default);\r\n\r\nshared Table.MaxN = (\r\n    table as table,\r\n    comparisonCriteria,\r\n    countOrCondition\r\n) as table =>\r\n    Table.FirstN(TableModule!Table.SortDescending(table, comparisonCriteria), countOrCondition);\r\n\r\nshared Table.Min = (\r\n    table as table,\r\n    comparisonCriteria,\r\n    optional default\r\n) =>\r\n    Table.First(Table.Sort(table, comparisonCriteria), default);\r\n\r\nshared Table.MinN = (\r\n    table as table,\r\n    comparisonCriteria,\r\n    countOrCondition\r\n) as table =>\r\n    Table.FirstN(Table.Sort(table, comparisonCriteria), countOrCondition);\r\n\r\n//\r\n// Other\r\n//\r\n\r\nshared Table.FindText = TableModule!Function.PreserveTableLineage(\r\n    (table as table, text as text) as table =>\r\n        Table.FromRecords(List.FindText(Table.ToRecords(table), text), Value.Type(table)));\r\n\r\nshared Replacer.ReplaceValue = (value, old, new) =>\r\n    if (value = old) then new\r\n    else value;\r\n\r\nshared Replacer.ReplaceText =\r\n    Text.Replace;\r\n\r\nshared Table.ReplaceValue =\r\n    (\r\n        table as table,\r\n        oldValue,\r\n        newValue,\r\n        replacer as function,\r\n        columnsToSearch as list\r\n    ) as table =>\r\n        if (oldValue is function or newValue is function) then\r\n            Table.ReplaceValueSlow(table, oldValue, newValue, replacer, columnsToSearch, replacer = Replacer.ReplaceValue)\r\n        else\r\n            if replacer = Replacer.ReplaceValue then\r\n                Table.TransformColumns(table,\r\n                    List.Transform(columnsToSearch, (column) => { column,\r\n                        Value.ReplaceType((value) => replacer(value, oldValue, newValue),\r\n                            Type.ForFunction([ReturnType = Type.Union({Value.Type(newValue),\r\n                                Record.FieldOrDefault(Type.RecordFields(Type.TableRow(Value.Type(table))), column, [Type=type any])[Type]}),\r\n                                Parameters = [value = type any]], 1))}))\r\n            else\r\n                Table.TransformColumns(table,\r\n                    List.Transform(columnsToSearch, (column) => { column,\r\n                        Value.ReplaceType((value) => replacer(value, oldValue, newValue),\r\n                            Type.ForFunction([ReturnType = Type.FunctionReturn(Value.Type(replacer)), Parameters = [value = type any]], 1))}));\r\n\r\nTable.ReplaceValueSlow = (\r\n    table as table,\r\n    oldValue,\r\n    newValue,\r\n    replacer as function,\r\n    columnsToSearch as list,\r\n    usingReplacerReplaceValueFunction as logical // TODO (Bug 11397502): Remove need for parameter\r\n) as table =>\r\n    let\r\n        newType =\r\n            if not usingReplacerReplaceValueFunction then\r\n                Type.FunctionReturn(Value.Type(replacer))\r\n            else if newValue is function then\r\n                Type.FunctionReturn(Value.Type(newValue))\r\n            else\r\n                Value.Type(newValue),\r\n        getValueAsFunction = (searchValue) =>\r\n            if searchValue is function then\r\n                (row, value) => searchValue(row)\r\n            else\r\n                (row, value) => searchValue,\r\n        oldValueFn = getValueAsFunction(oldValue),\r\n        newValueFn = getValueAsFunction(newValue),\r\n        tableType = Value.Type(table),\r\n        fieldReplacer = (row, value) =>\r\n            try replacer(value, oldValueFn(row, value), newValueFn(row, value)) otherwise value,\r\n        pairs = List.Transform(columnsToSearch,\r\n            (columnName) as list =>\r\n            let\r\n                currentType = Type.TableColumn(tableType, columnName)\r\n            in\r\n                {columnName,\r\n                 Value.ReplaceType(fieldReplacer,\r\n                    Type.ForFunction([ReturnType = Type.Union({currentType, newType}),\r\n                                      Parameters = [row = type record, value = type any]], 2))})\r\n    in\r\n        // If any of the columns don't exist, then force a top-level error. (The else clause will never be executed.)\r\n        // Construct an empty table with the same type to avoid triggering folding.\r\n        if Table.SelectColumns(#table(Value.Type(table), {}), columnsToSearch, MissingField.Erro[...string is too long...]";
	}
}
