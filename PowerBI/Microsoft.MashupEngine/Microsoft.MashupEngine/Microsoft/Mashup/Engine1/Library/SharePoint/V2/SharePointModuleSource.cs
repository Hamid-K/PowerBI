using System;

namespace Microsoft.Mashup.Engine1.Library.SharePoint.V2
{
	// Token: 0x02000414 RID: 1044
	internal class SharePointModuleSource
	{
		// Token: 0x04000E57 RID: 3671
		public const string Source = "// Copyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\nsection SharePointImpl2;\r\n\r\nshared SharePointImpl2.Tables = (url as text, optional options as record) as table =>\r\nlet\r\n    validatedOptions = ValidateOptions(ValidOptionsMap, options),\r\n    response = GetResponse(GetListsUrl(url), RequestHeaderGet),\r\n    valueList = response[value],\r\n    isListEmpty = List.IsEmpty(valueList),\r\n    valueTable = Table.FromList(valueList, Splitter.SplitByNothing(), null, null, ExtraValues.Error),\r\n    keyColumns = {\"Id\"},\r\n    listsTable = if (not isListEmpty) then Table.ExpandRecordColumn(valueTable, \"Column1\", Record.FieldNames(valueTable[Column1]{0})) else #table(keyColumns, {}),\r\n    normalizedUrl = NormalizeUrl(url),\r\n    uriParts = Uri.Parts(normalizedUrl),\r\n    uriPathComponent = if (uriParts[Path] = \"/\") then \"/\" else \":/\" & uriParts[Path] & \":/\",\r\n    v2UriPrefix = uriParts[Scheme] & \"://\" & uriParts[Host] & \"/_api/v2.0/sites/\" & uriParts[Host] & uriPathComponent & \"lists(guid'\",\r\n    v2UriSuffix =  \"')/items?$expand=fields&$stop=\" & Text.From(Constants[V2SinglePageSize]),\r\n    listsTableWithData = Table.AddColumn(listsTable, \"Items\", each PredicatePushDownView(NormalizeUrl([odata.id]), v2UriPrefix & [Id] & v2UriSuffix, validatedOptions[ViewMode], validatedOptions[DisableAppendNoteColumns])),\r\n    listsTableWithIsLeaf = Table.AddColumn(listsTableWithData, \"IsLeaf\", each true),\r\n    listsTableWithItemKind = Table.AddColumn(listsTableWithIsLeaf, \"ItemKind\", each \"Table\"),\r\n    listsTableWithItemName = Table.AddColumn(listsTableWithItemKind, \"ItemName\", each \"Table\"),\r\n    navTable = Table.ToNavigationTable(listsTableWithItemName, keyColumns, \"Title\", \"Items\", \"ItemKind\", \"ItemName\", \"IsLeaf\")\r\nin\r\n    // force evaluation to validate options\r\n    if (validatedOptions <> null) then navTable else navTable;\r\n\r\nPredicatePushDownView = (url as text, v2Url as text, viewMode as nullable text, DisableAppendNoteColumns as nullable logical) as table =>\r\nlet\r\n    // delta token consists of two required, and 1 optional pieces of information\r\n    // 1. 'LastChangeToken' from Glcst api, this can be roughly thought of as a timepoint that sharepoint maintains.\r\n    // 2. 'LastInsertedItemId' is the Id value of the last inserted list item.\r\n    // LastInsertedItemId helps to determine the newly inserted items when querying delta (newly inserted items will have their id values greater than this value).\r\n    // 3. 'SchemaChange' is optional. It is set only when a schema change is detected. In the initial tag this will never happen.\r\n    InitialDeltaTag =\r\n    let\r\n        invariantCulture = Constants[InvariantCulture],\r\n        requestBody = [\r\n            query = [\r\n                ChangeToken = \"\",\r\n                RowLimit = \"1\",\r\n                ViewFields = \"<ViewFields><FieldRef Name='ID' /></ViewFields>\",\r\n                Query = \"<Query><OrderBy><FieldRef Name='ID' Ascending='FALSE' /></OrderBy></Query>\"]],\r\n        response = GetResponse(url & \"/GetListItemChangesSinceToken\", null, requestBody, true),\r\n        normalizedResponse = NormalizeGlcstResponse(response),\r\n        changeTableAttributes = normalizedResponse{[ListItems.Name=\"Changes\"]}[ListItems.Attributes],\r\n        lastChangeToken = changeTableAttributes{[Name = \"LastChangeToken\"]}[Value],\r\n        changeSetCount = Number.FromText(normalizedResponse{[ListItems.Name=\"data\"]}[ListItems.Attributes]{[Name=\"ItemCount\"]}[Value], invariantCulture),\r\n        dataTable = normalizedResponse{[ListItems.Name=\"data\"]}[ListItems.Value],\r\n        attributesPrefixedNames = List.Transform(Table.ColumnNames(dataTable[Attributes]{0}), each \"Attributes.\" & _),\r\n        dataTableWithExpandedAttributes = Table.ExpandTableColumn(dataTable, \"Attributes\", Table.ColumnNames(dataTable[Attributes]{0}), attributesPrefixedNames),\r\n        lastInsertedItemId = if (changeSetCount = 0) then 0 else Number.FromText(dataTableWithExpandedAttributes{[Attributes.Name = \"ows_ID\"]}[Attributes.Value], invariantCulture),\r\n        deltaTag = [LastChangeToken = lastChangeToken, LastInsertedItemId = lastInsertedItemId]\r\n    in\r\n        deltaTag,\r\n\r\n    // builds the delta table for all the changes that has happened since the delta tag of lastDeltaTag.\r\n    // returns an empty delta table when lastDeltaTag is null.\r\n    // The method queries Glcst api for to fetch only the Id values of the items in the delta. Subsequently,\r\n    // it queries the Rlds api to fetch the actual data for these ids. This is done to maintain the data format consistency\r\n    // of the connector between full enumeration mode and delta mode.\r\n    GetDeltaTable = (state as record, lastDeltaTag as nullable record) as table =>\r\n    let\r\n        // Glcst api to get only the Ids and ChangeType for those Ids\r\n        changeSetIdsTable = Table.Pagination.Glcst(url, lastDeltaTag),\r\n        // Rlds api to get the actual data for the Ids.\r\n        changeSetValues = GetDeltaValues(state, changeSetIdsTable),\r\n        newDeltaTag = if (lastDeltaTag = null) then InitialDeltaTag else Value.Metadata(changeSetIdsTable)[Delta.Tag],\r\n        deltaTable = if (lastDeltaTag = null) then #table({\"Path\", \"Value\"}, {}) else changeSetValues\r\n    in\r\n        deltaTable meta [Delta.Tag = newDeltaTag],\r\n\r\n    // takes in the table of changed ids, and constructs the delta table for them\r\n    GetDeltaValues = (state as record, changeSetIds as table) as table =>\r\n    let\r\n        changeSetIdsForInsert = Table.SelectRows(changeSetIds, each [ChangeType] = \"INS\")[ID],\r\n        changeSetIdsForUpdate = Table.SelectRows(changeSetIds, each [ChangeType] = \"UPD\")[ID],\r\n        changeSetIdsForDelete = Table.SelectRows(changeSetIds, each [ChangeType] = \"DEL\")[ID],\r\n        emptyDeltaTable = #table({\"Path\", \"Value\"}, {}),\r\n        deltaTableWithInsert = if (List.Count(changeSetIdsForInsert) = 0) then emptyDeltaTable else GetDeltaValuesInsert(state, changeSetIdsForInsert),\r\n        deltaTableWithUpdate = if (List.Count(changeSetIdsForUpdate) = 0) then deltaTableWithInsert else Table.Combine({deltaTableWithInsert, GetDeltaValuesUpdate(state, changeSetIdsForUpdate)}),\r\n        deltaTableWithDelete = if (List.Count(changeSetIdsForDelete) = 0) then deltaTableWithUpdate else Table.Combine({deltaTableWithUpdate, GetDeltaValuesDelete(state, changeSetIdsForDelete)})\r\n    in\r\n        deltaTableWithDelete,\r\n\r\n    GetDeltaValuesInsert = (state as record, insertedIds as list) as table =>\r\n    let\r\n        schemaType = GetSchemaTypeFromState(state),\r\n        result = GetRldsData(state & [ChangeSetIds = insertedIds]),\r\n        displayNames = Record.FieldNames(state[DisplayNameToInternalName]),\r\n        internalNames = Record.FieldValues(state[DisplayNameToInternalName]),\r\n        resultWithDisplayName = Table.RenameColumns(result, List.Zip({internalNames, displayNames}), MissingField.Ignore),\r\n        deltaTable = Table.FromRecords(Table.TransformRows(resultWithDisplayName, (row) =>\r\n            let\r\n                path = {{}},\r\n                value = Table.FromRecords({row}, schemaType)\r\n            in\r\n                [\r\n                    Path = path,\r\n                    Value = value\r\n                ]),\r\n            type table [Path = any, Value = any])\r\n    in\r\n        deltaTable,\r\n\r\n    GetDeltaValuesUpdate = (state as record, updatedIds as list) as table =>\r\n    let\r\n        schemaType = GetSchemaTypeFromState(state),\r\n        result = GetRldsData(state & [ChangeSetIds = updatedIds]),\r\n        displayNames = Record.FieldNames(state[DisplayNameToInternalName]),\r\n        internalNames = Record.FieldValues(state[DisplayNameToInternalName]),\r\n        resultWithDisplayName = Table.RenameColumns(result, List.Zip({internalNames, displayNames}), MissingField.Ignore),\r\n        deltaTable = Table.FromRecords(Table.TransformRows(resultWithDisplayName, (row) =>\r\n            let\r\n                path = {{row[ID]}},\r\n                value = Table.FromRecords({row}, schemaType)\r\n            in\r\n                [\r\n                    Path = path,\r\n                    Value = value\r\n                ]),\r\n            type table [Path = any, Value = any])\r\n    in\r\n        deltaTable,\r\n\r\n    GetDeltaValuesDelete = (state as record, deletedIds as list) as table =>\r\n    let\r\n        schemaType = GetSchemaTypeFromState(state),\r\n        transformedDeletedIds = List.Transform(deletedIds, each {{_}}),\r\n        deltaTable = Table.AddColumn(Table.FromList(transformedDeletedIds, Splitter.SplitByNothing(), {\"Path\"}, null, null), \"Value\", each #table(schemaType, {}))\r\n    in\r\n        deltaTable,\r\n\r\n    GetCamlFilter = (changeSetIds as nullable list) as text =>\r\n    let\r\n        // RLDS CAML doesn't support more then 500 items inside <In>.\r\n        // Workaround is to wrap groups of values within <Or> tags. e.g.\r\n        // <Or>\r\n        //      <Or>\r\n        //          <In>\r\n        //              <FieldRef Name=\\\"ID\\\" />\r\n        //              <Values>\r\n        //                  <Value Type=\\\"Counter\\\">0</Value>\r\n        //                  ...\r\n        //                  <Value Type=\\\"Counter\\\">499</Value>\r\n        //              </Values>\r\n        //          </In>\r\n        //          <In>\r\n        //              <FieldRef Name=\\\"ID\\\" />\r\n        //              <Values>\r\n        //                  <Value Type=\\\"Counter\\\">500</Value>\r\n        //                  ...\r\n        //                  <Value Type=\\\"Counter\\\">999</Value>\r\n        //              </Values>\r\n        //          </In>\r\n        //      </Or>\r\n        //      <In>\r\n        //          <FieldRef Name=\\\"ID\\\" />\r\n        //          <Values>\r\n        //              <Value Type=\\\"Counter\\\">1000</Value>\r\n        //              ...\r\n        //              <Value Type=\\\"Counter\\\">N</Value>\r\n        //          </Values>\r\n        //      </In>\r\n        // </Or>\r\n        threshold = 500,\r\n        transformedList = List.Transform(changeSetIds, each \"<Value Type=\"\"Counter\"\">\" & Number.ToText(_) & \"</Value>\"),\r\n        splitList = List.Split(transformedList, threshold),\r\n        combinedElements = List.Transform(splitList, each \"<In><FieldRef Name=\"\"ID\"\" /><Values>\" & Text.Combine(_) & \"</Values></In>\"),\r\n        filterClause = \"<Where>\" & List.Accumulate(combinedElements, \"\", (state, page) => if (state = \"\") then page else \"<Or>\" & state & page & \"</Or>\") & \"</Where>\",\r\n        caml = if (changeSetIds <> null and List.Count(changeSetIds) > 0) then \"<Query>\" & filterClause & \"</Query>\" else \"\"\r\n    in\r\n        caml,\r\n\r\n    GetCamlSelect = (columns as list) as text =>\r\n    let\r\n        transformed =  List.Transform(columns, each \"<FieldRef Name=\"\"\" & _ & \"\"\" />\"),\r\n        caml = \"<ViewFields>\"& Text.Combine(transformed) &\"</ViewFields>\"\r\n    in\r\n        caml,\r\n\r\n    // utility method that fetches data from Rlds api.\r\n    // it is used both during full-list-enumeration (Rlds) and delta modes (Glcst).\r\n    GetRldsData = (state as record) as table =>\r\n    let\r\n        schemaTable = GetSchemaTableFromState(state),\r\n        displayNameToInternalNameRecord = state[DisplayNameToInternalName],\r\n        displayNames = Record.FieldNames(displayNameToInternalNameRecord),\r\n        internalNames = Record.FieldValues(displayNameToInternalNameRecord),\r\n        // change the display names to real field names before data is fetched.\r\n        finalSchemaTable = Table.RenameColumns(schemaTable, List.Zip({displayNames, internalNames}), MissingField.Ignore),\r\n        // state should contain caml qrueries for individal operations, like select, filter, except for RowLimit.\r\n        // The caml for RowLimit is constructed downstream at the pagination step.\r\n        camlSelect = GetCamlSelect(Table.ColumnNames(finalSchemaTable)),\r\n        camlFilter = GetCamlFilter(state[ChangeSetIds]?),\r\n        finalState = state & [SchemaTable = finalSchemaTable, SpoLocale = SpoLocale, CamlSelect = camlSelect, CamlFilter = camlFilter],\r\n        result = Table.Pagination.Rlds(url & \"/RenderListDataAsStream\", v2Url, finalState, DisableAppendNoteColumns ?? false),\r\n        // change the real field names back to display names.\r\n        resultWithDisplayName = Table.RenameColumns(result, List.Zip({internalNames, displayNames}), MissingField.Ignore)\r\n    in\r\n        resultWithDisplayName,\r\n\r\n    // The function returns a record having the schema table of the spo list, display name to real field name mapping, and spo site locale.\r\n    // When displaying table columns in PowerBI, column names are rendered as display name.\r\n    // When sending caml query to sharepoint, display names are translated to the mapped RealFieldName names.\r\n    //\r\n    // For any list column, RLDS metadata has four types of 'Name' fields. In most scenarios these names will be same.The only name that can be modified by the user\r\n    // is the display name.\r\n    // 1. StaticName: This name can be ignored. This exists in the api for historical reasons.\r\n    // 2. RealFieldName: RealfieldName can be thought of as the actual underlying column that stores the data for other computed type columns to use. The computed columns depend\r\n    // on these columns for their actual data. For e.g. 'Title' column. There are three separately named columns 'LinkTitle', 'Title' 'LinkTitleNoMenu'.\r\n    // They point to the same RealFieldName, Title, and render the underlying data differently.\r\n    // 3. Name: Name is the internal name of the column. This is unique for every column within a list.\r\n    // 4. DisplayName: Display name is the column name that is displayed to the user. Multiple columns within a list can have the same display name. SPO's Web UI does not allow\r\n    // creation of multiple columns with same display name, but it can be done using SharePoint's APIs directly.\r\n    SpoListMetadata = \r\n    let\r\n        attachmentsFacet = Type.ReplaceFacets(Text.Type, Type.Facets(Text.Type) & [NativeTypeName=\"Attachments\"]),\r\n        choiceFacet = Type.ReplaceFacets(Text.Type, Type.Facets(Text.Type) & [NativeTypeName=\"Choice\"]),\r\n        computedFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"Computed\"]),\r\n        currencyFacet = Type.ReplaceFacets(Currency.Type, Type.Facets(Currency.Type) & [NativeTypeName=\"Currency\"]),\r\n        dateTimeFacet = Type.ReplaceFacets(DateTime.Type, Type.Facets(DateTime.Type) & [NativeTypeName=\"DateTime\"]),\r\n        geoLocationFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"GeoLocation\"]),\r\n        int64Facet = Type.ReplaceFacets(Int64.Type, Type.Facets(Int64.Type) & [NativeTypeName=\"Int64\"]),\r\n        locationFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"Location\"]),\r\n        logicalFacet = Type.ReplaceFacets(Logical.Type, Type.Facets(Logical.Type) & [NativeTypeName=\"Logical\"]),\r\n        lookupFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"Lookup\"]),\r\n        lookupmultiFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"LookupMulti\"]),\r\n        multichoiceFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"MultiChoice\"]),\r\n        noteFacet = Type.ReplaceFacets(Text.Type, Type.Facets(Text.Type) & [NativeTypeName=\"Note\"]),\r\n        numberFacet = Type.ReplaceFacets(Number.Type, Type.Facets(Number.Type) & [NativeTypeName=\"Number\"]),\r\n        taxonomyfieldtypeFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"TaxonomyFieldType\"]),\r\n        taxonomyfieldtypemultiFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"TaxonomyFieldTypeMulti\"]),\r\n        textFacet = Type.ReplaceFacets(Text.Type, Type.Facets(Text.Type) & [NativeTypeName=\"Text\"]),\r\n        thumbnailFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"Thumbnail\"]),\r\n        urlFacet = Type.ReplaceFacets(Uri.Type, Type.Facets(Uri.Type) & [NativeTypeName=\"Url\"]),\r\n        userFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"User\"]),\r\n        userMultiFacet = Type.ReplaceFacets(Any.Type, Type.Facets(Any.Type) & [NativeTypeName=\"UserMulti\"]),\r\n        TypeMap = [\r\n            attachments = type nullable attachmentsFacet,\r\n            boolean = type nullable logicalFacet,\r\n            choice = type nullable choiceFacet,\r\n            computed = type nullable computedFacet,\r\n            counter = type nullable int64Facet,\r\n            currency = type nullable currencyFacet,\r\n            datetime = type nullable dateTimeFacet,\r\n            geolocation = type nullable geoLocationFacet,\r\n            location = type nullable locationFacet,\r\n            lookup = type nullable lookupFacet,\r\n            lookupmulti = type nullable lookupmultiFacet,\r\n            multichoice = type nullable multichoiceFacet,\r\n            note = type nullable noteFacet,\r\n            number = type nullable numberFacet,\r\n            taxonomyfieldtype = type nullable taxonomyfieldtypeFacet,\r\n            taxonomyfieldtypemulti = type nullable taxonomyfieldtypemultiFacet,\r\n            text = type nullable textFacet,\r\n            thumbnail = type nullable thumbnailFacet,\r\n            url = type nullable urlFacet,\r\n            user = type nullable userFacet,\r\n            usermulti = type nullable userMultiFacet],\r\n        requestBody = [\r\n            parameters = [\r\n                AddAllFields = if (viewMode = \"Default\") then \"FALSE\" else \"TRUE\",\r\n                RenderOptions = 5707527]],\r\n        source = GetResponse(url & \"/RenderListDataAsStream\", null, requestBody),\r\n        spoLocale = source[ListSchema][Locale],\r\n        fieldlist = source[ListSchema][Field],\r\n        removeBadFields = List.Select(fieldlist, (x) => Record.HasFields(x, {\"RealFieldName\"})),\r\n        basetable =  Table.FromList(removeBadFields, Splitter.SplitByNothing(), null, null, ExtraValues.Error),\r\n        tableWithExpandedColumn = Table.ExpandRecordColumn(basetable, \"Column1\", {\"RealFieldName\", \"role\", \"DisplayName\"}),\r\n        // Remove multiple computed fields. This is in accordance with older spo connnector. Computed types are not the same as calculated types.\r\n        tableWithDistinctRealName = Table.Distinct(tableWithExpandedColumn, \"RealFieldName\"),\r\n        // ID column will be added, so we need to account for it when cleaning up duplicate display names\r\n        isIdColumnPresent = Table.Contains(tableWithDistinctRealName, [RealFieldName=\"ID\"]),\r\n        // Remove duplicate field names by replacing display names with RealFieldNames (which are always unique)\r\n        removeDuplicateFields = (fieldTable as table, idColumnPresent as logical) as table =>\r\n            let\r\n                countFields = Table.AddColumn(fieldTable, \"NameCount\", (row) => Table.RowCount(Table.SelectRows(fieldTable, each [DisplayName] = row[DisplayName]))),\r\n                addDisplayNames = Table.AddColumn(countFields, \"DisplayName1\", each if ([NameCount] = 1 and (idColumnPresent or not ([DisplayName] = \"ID\")) and [DisplayName] <> null and Text.Trim([DisplayName]) <> \"\") then [DisplayName] else [RealFieldName]),\r\n                RemoveOldNames = Table.RemoveColumns(addDisplayNames, {\"DisplayName\", \"NameCount\"}),\r\n                RenameColumn = Table.RenameColumns(RemoveOldNames, {{\"DisplayName1\", \"DisplayName\"}})\r\n            in\r\n                RenameColumn,\r\n        removeDuplicateFieldsCycle = (fieldTable as table, idColumnPresent as logical) as table =>\r\n            let\r\n                cycleTable = removeDuplicateFields(fieldTable, idColumnPresent)\r\n            in\r\n                if (Table.MatchesAllRows(cycleTable, each [DisplayName] = fieldTable{[RealFieldName=[RealFieldName]]}[DisplayName])) then cycleTable else @removeDuplicateFieldsCycle(cycleTable, idColumnPresent),\r\n        \r\n        tableWithActualDisplayNames = removeDuplicateFieldsCycle(tableWithDistinctRealName, isIdColumnPresent),\r\n        tableWithRenamedColumns = Table.RenameColumns(tableWithActualDisplayNames, {{\"RealFieldName\", \"Value\"}, {\"role\", \"SpType\"}, {\"DisplayName\", \"N[...string is too long...]";
	}
}
