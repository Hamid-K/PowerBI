using System;

namespace Microsoft.Mashup.Engine1.Library.SharePoint
{
	// Token: 0x02000413 RID: 1043
	internal class SharePointModuleSource
	{
		// Token: 0x04000E56 RID: 3670
		public const string Source = "// Copyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\nsection SharePoint15;\r\n\r\nshared SharePoint15.Tables = (url as text) as table =>\r\n    let\r\n        minProps = { \"Id\", \"Title\", \"Items\" },\r\n        lists = OData.Feed(url & \"/lists?$select=\" & Text.Combine(minProps, \",\")),\r\n        listsTable = Table.SelectColumns(lists, minProps),\r\n        result = ToNavigationTable(listsTable, {\"Id\"}, \"Title\", \"Items\", false)\r\n    in\r\n        result;\r\n\r\n shared SharePoint15.Contents = (url as text) as table =>\r\n    let\r\n        webUrl = url & \"/Folders\",\r\n        source = OData.Feed(webUrl),\r\n        folders = CreateContent(source, url, true)\r\n    in\r\n        Value.ReplaceType(folders, ContentSchema(DateTimeZone.Type, null, Any.Type meta [Preview.Delay=\"Table\"]));\r\n\r\nshared SharePoint15.Files = (url as text) as table =>\r\n    let\r\n        webUrl = url & \"/lists/?$filter=\" & Uri.EscapeDataString(\"Hidden eq false and BaseType eq 1 and ItemCount gt 0 and IsCatalog eq false and IsApplicationList eq false\"),\r\n        source = OData.Feed(webUrl),\r\n        files = CreateFiles(source, url)\r\n    in\r\n        files;\r\n\r\n//\r\n// Transformations\r\n//\r\n\r\nContentSchemaWithZone = ContentSchema(DateTimeZone.Type);\r\n\r\nCreateContent = (table as table, siteUrl as text, isTable as logical) as table =>\r\n    let\r\n        withSiteUrl = Table.TransformRows(table, (r) => Record.AddField(r, \"SiteUrl\", siteUrl)),\r\n        transformation = if isTable then TransformToFolder else TransformToFile,\r\n        result = Table.FromRecords(List.Transform(withSiteUrl, transformation), ContentSchemaWithZone)\r\n    in\r\n        result;\r\n\r\nCreateFiles = (table as table, apiUrl as text) as table =>\r\n    let\r\n        tablesList = List.Transform(Table.ToRecords(table), each TransformToFiles(_, apiUrl)),\r\n        files = Table.Combine(tablesList),\r\n        result = if Table.ColumnCount(files) = 0 then files else Value.ReplaceType(files, ContentSchema(DateTime.Type, {\"Name\", \"Folder Path\"}, Binary.Type meta [Preview.Delay=\"Binary\"]) meta [Table.Folder = true])\r\n    in\r\n        result;\r\n\r\nContentSchema = (dateType as type, optional keyColumns as list, optional contentType as type) =>\r\n    let\r\n        keys = if keyColumns = null then {\"Name\"} else keyColumns,\r\n        content = if contentType <> null then contentType else Any.Type,\r\n        schema = type table\r\n            [\r\n                Content=content,\r\n                Name=text,\r\n                Extension=text,\r\n                Date accessed=dateType,\r\n                Date modified=dateType,\r\n                Date created=dateType,\r\n                Attributes=record,\r\n                Folder Path=text\r\n            ]\r\n    in\r\n        Type.AddTableKey(schema, keys, true) meta [NavigationTable.NameColumn = \"Name\", NavigationTable.DataColumn = \"Content\"];\r\n\r\nCreateFolderContent = (row as record) as table =>\r\n    let\r\n        siteUrl = row[SiteUrl],\r\n        serverRelativeUrl = row[ServerRelativeUrl],\r\n        getRows = () => CreateContent(row[Folders], siteUrl, true) & CreateContent(row[Files], siteUrl, false)\r\n    in\r\n        Table.View(null,\r\n            [\r\n                GetRows = getRows,\r\n                GetType = () => ContentSchemaWithZone,\r\n                OnInsertRows = (rowsToInsert) =>\r\n                    let\r\n                        currentRows = getRows(),\r\n                        namesInserted = List.Transform(Table.ToRecords(rowsToInsert), each [Name]),\r\n                        targetTable = Table.SelectRows(currentRows, each List.Contains(namesInserted, [Name], Comparer.OrdinalIgnoreCase))\r\n                    in\r\n                        Action.Sequence(CreateActionsForRows(siteUrl, serverRelativeUrl, ValidatedFolderContentToInsert(rowsToInsert)) & { Action.Return(targetTable) })\r\n            ]);\r\n\r\nValidatedFolderContentToInsert = (rowsToInsert as table) as table =>\r\n    let\r\n        ValidateRowName = (rowName as text) as logical =>\r\n            (rowName is text and rowName = Text.Trim(rowName) and rowName <> \"\" and (not Text.Contains(rowName, \"/\"))) or\r\n                (error \"Invalid name in row \" & rowName),\r\n        ValidateRowContent = (rowContent as any) as logical =>\r\n            ((rowContent is table and @ValidatedFolderContentToInsert(rowContent) <> null) or (rowContent is binary)) or\r\n                (error \"Invalid row content, should be either a table or binary.\"),\r\n        OneValidatedRowToInsert = (row as record) as logical =>\r\n            (ValidateRowName(row[Name]) and ValidateRowContent(row[Content])) or\r\n                (error \"Row is invalid for insert.\"),\r\n        ValidatedRowsToInsert = (rows as list) as logical =>\r\n            List.Accumulate(rows, true, (result, row) => result and OneValidatedRowToInsert(row)) or\r\n                (error \"Rows have invalid content for insert.\")\r\n    in\r\n        if Table.ColumnNames(rowsToInsert) = {\"Name\", \"Content\"} and ValidatedRowsToInsert(Table.ToRecords(rowsToInsert))\r\n            then rowsToInsert\r\n            else error \"Invalid column names for rows being inserted.\";\r\n\r\nCreateFilesContent = (files as list, tableType as type, authority as text) as table =>\r\n    let\r\n        withSiteUrl = List.Transform(files, (r) => Record.AddField(r, \"SiteUrl\", authority)),\r\n        results = Table.FromRecords(List.Transform(withSiteUrl, TransfromFromFileList), tableType)\r\n    in\r\n        results;\r\n\r\nAsDateTimeZone = (x) => if x is null then null else if x is datetime then DateTime.AddZone(x, 0, 0) else DateTimeZone.From(x);\r\n\r\nTransformToFolder = (row as record) as record =>\r\n    let\r\n        ParentFolder = GetParentFolder(row[ServerRelativeUrl]),\r\n        FolderPath = NormalizeFolderPath(GetUrlAuthority(row[SiteUrl]) & ParentFolder),\r\n        Result = [\r\n            Content = CreateFolderContent(row),\r\n            Name = row[Name],\r\n            Extension = \"\",\r\n            Date accessed = null,\r\n            Date modified = AsDateTimeZone(row[TimeLastModified]),\r\n            Date created = AsDateTimeZone(row[TimeCreated]),\r\n            Attributes = [Size = null, Content Type = null, Kind = \"Folder\"],\r\n            Folder Path = FolderPath]\r\n    in\r\n        Result;\r\n\r\nTransformToFile = (row as record) as record =>\r\n    let\r\n        FilePath = row[SiteUrl] & \"/getfilebyserverrelativeurl('\" & Text.Replace(row[ServerRelativeUrl], \"'\", \"''\") & \"')\",\r\n        FileContentPath = FilePath & \"/$value\",\r\n        FolderPath = GetFileDirectory(GetUrlAuthority(row[SiteUrl]), row[ServerRelativeUrl]),\r\n        Content = Web.Contents(FileContentPath),\r\n        temp = Record.AddField(\r\n            [Size = row[Length]],\r\n            \"Content Type\",\r\n            () => Value.Metadata(Content)[Content.Type],\r\n            true),\r\n        Attributes = Record.AddField(\r\n            temp,\r\n            \"Kind\",\r\n            () => GetFileKind(Value.Metadata(Content)[Content.Type]),\r\n            true),\r\n        Result = [\r\n            Content = Binary.View(null,\r\n                [\r\n                    GetStream = () => Content,\r\n                    OnReplace = (value) => UpdateFileContentAction(value, FilePath)\r\n                ]) meta Value.Metadata(Content),\r\n            Name = row[Name],\r\n            Extension = GetFileExtension(row[Name]),\r\n            Date accessed = null,\r\n            Date modified = AsDateTimeZone(row[TimeLastModified]),\r\n            Date created = AsDateTimeZone(row[TimeCreated]),\r\n            Attributes = Attributes,\r\n            Folder Path = FolderPath]\r\n    in\r\n        Result;\r\n\r\nTransfromFromFileList = (row as record) as record =>\r\n    let\r\n        FilePath = row[SiteUrl] & row[FileRef],\r\n        FolderPath = GetFileDirectory(row[SiteUrl], row[FileRef]),\r\n        Content = Web.Contents(FilePath),\r\n        temp = Record.AddField(\r\n            [Size = row[File_x0020_Size]],\r\n            \"Content Type\",\r\n            () => Value.Metadata(Content)[Content.Type],\r\n            true),\r\n        Attributes = Record.AddField(\r\n            temp,\r\n            \"Kind\",\r\n            () => GetFileKind(Value.Metadata(Content)[Content.Type]),\r\n            true),\r\n        extension = NormalizeExtension(row[FileLeafRef.Suffix]),\r\n        Result = [\r\n            Content = Content,\r\n            Name = row[FileLeafRef],\r\n            Extension = extension,\r\n            Date accessed = null,\r\n            Date modified = DateTime.From(Record.FieldOrDefault(row, \"Modified.\", row[Modified])),\r\n            Date created = DateTime.From(Record.FieldOrDefault(row, \"Created.\", row[Created])),\r\n            Attributes = Attributes,\r\n            Folder Path = FolderPath]\r\n    in\r\n        Result;\r\n\r\n//\r\n// New files and folders\r\n//\r\n\r\nCreateActionsForRows = (siteUrl as text, serverRelativeUrl as text, rowsToInsert as table) as list =>\r\n    List.Combine(\r\n        Table.TransformRows(rowsToInsert, (r) =>\r\n            if r[Content] is table\r\n                then CreateNewFolderAction(siteUrl, serverRelativeUrl, r)\r\n                else CreateNewFileAction(siteUrl, serverRelativeUrl, r)));\r\n\r\nCreateNewFileAction = (siteUrl as text, serverRelativeUrl as text, row as record) =>\r\n    let\r\n        NormalizedServerRelativeUrl = NormalizeFolderPath(serverRelativeUrl),\r\n        CreateFileReq = siteUrl & \"/getfolderbyserverrelativeurl('\" & Text.Replace(NormalizedServerRelativeUrl, \"'\", \"''\") & \"')/files/add(url='\" & Text.Replace(row[Name], \"'\", \"''\") & \"',overwrite=false)\",\r\n        Headers = [\r\n            #\"Accept\" = \"application/json;odata=minimalmetadata\"\r\n        ]\r\n    in\r\n        { WebAction.Request(WebMethod.Post, CreateFileReq, [Headers=Headers, Content=row[Content]]) };\r\n\r\nCreateNewFolderAction = (siteUrl as text, serverRelativeUrl as text, row as record) =>\r\n    let\r\n        NormalizedServerRelativeUrl = NormalizeFolderPath(serverRelativeUrl),\r\n        CreateFolderReq = siteUrl & \"/getfolderbyserverrelativeurl('\" & Text.Replace(NormalizedServerRelativeUrl, \"'\", \"''\") & \"')/folders/add('\" & Text.Replace(row[Name], \"'\", \"''\") & \"')\",\r\n        Headers = [\r\n            #\"Accept\" = \"application/json;odata=minimalmetadata\"\r\n        ]\r\n    in\r\n        { WebAction.Request(WebMethod.Post, CreateFolderReq, [Headers=Headers, Content=#binary({})]) }\r\n        & CreateActionsForRows(siteUrl, NormalizedServerRelativeUrl & row[Name], row[Content]? ?? []);\r\n\r\nChunkSize = 1024 * 1024 * 4; // 4MB\r\n\r\nUpdateFileContentAction = (value as binary, filePath as text) =>\r\n    let\r\n        uploadId = Text.NewGuid(),\r\n        getMetadataAction = WebAction.Request(WebMethod.Get, filePath, [Headers=[Accept=\"application/json\"]]),\r\n        startUploadAction = Action.Sequence({\r\n            getMetadataAction,\r\n            (metadata) =>\r\n                let\r\n                    etag = Json.Document(metadata)[ETag],\r\n                    reqUrl = filePath & \"/startupload(uploadId=guid'\" & uploadId & \"')\"\r\n                in\r\n                    Action.Sequence({\r\n                        WebAction.Request(WebMethod.Post, reqUrl, [Content=#binary({})]),\r\n                        Action.Return(etag)\r\n                    })\r\n        }),\r\n        cancelUploadUrl = filePath & \"/cancelupload(uploadId=guid'\" & uploadId & \"')\",\r\n        cancelUploadAction = Action.Sequence({\r\n            WebAction.Request(WebMethod.Post, cancelUploadUrl, [Content=#binary({})]),\r\n            Action.Return(error \"ETag did not match.\")\r\n        }),\r\n        continueUploadAction = (chunk, offset) =>\r\n            let\r\n                continueUploadUrl = filePath & \"/continueupload(uploadId=guid'\" & uploadId & \"',fileOffset=\" & Number.ToText(offset) & \")\"\r\n            in\r\n                WebAction.Request(WebMethod.Post, continueUploadUrl, [Content=chunk]),\r\n        finishUploadAction = (offset) =>\r\n            let\r\n                completeUploadUrl = filePath & \"/finishupload(uploadId=guid'\" & uploadId & \"',fileOffset=\" & Number.ToText(offset) & \")\"\r\n            in\r\n                WebAction.Request(WebMethod.Post, completeUploadUrl, [Content=#binary({})]),\r\n        uploadedValueAction = WebAction.Request(WebMethod.Get, filePath & \"/$value\")\r\n    in\r\n        Action.Sequence({\r\n            startUploadAction,\r\n            (etag) =>\r\n                let\r\n                    next = (offset) => Action.Sequence({\r\n                        getMetadataAction,\r\n                        (metadata) =>\r\n                            let\r\n                                currentEtag = Json.Document(metadata)[ETag]\r\n                            in\r\n                                if etag <> currentEtag\r\n                                    then cancelUploadAction\r\n                                    else Action.Return(Binary.Range(value, offset, ChunkSize)),\r\n                        (chunk) =>\r\n                            if Binary.Length(chunk) = 0\r\n                                then Action.Sequence({\r\n                                    finishUploadAction(offset),\r\n                                    uploadedValueAction\r\n                                })\r\n                                else Action.Sequence({\r\n                                    continueUploadAction(chunk, offset),\r\n                                    @next(offset + Binary.Length(chunk))\r\n                                })\r\n                    })\r\n                in\r\n                    next(0)\r\n        });\r\n\r\n//\r\n// Paging\r\n//\r\n\r\nSinglePageSize = 1000;\r\n\r\nGetAllPagesByNextLink = (url as text) as table =>\r\n    Table.GenerateByPage((previous) =>\r\n        let\r\n            // if previous is null, then this is our first page of data\r\n            nextLink = if null = previous then url else Value.Metadata(previous)[NextLink]?,\r\n            // if NextLink was set to null by the previous call, we know we have no more data\r\n            page = if null = nextLink then null else GetPage(nextLink)\r\n        in\r\n            page\r\n    );\r\n\r\nTable.GenerateByPage = (getNextPage as function, optional tableType as type) as table =>\r\n    let\r\n        listOfPages = List.Generate(\r\n            () => getNextPage(null),\r\n            (lastPage) => lastPage <> null,\r\n            (lastPage) => getNextPage(lastPage)\r\n        ),\r\n        tableOfPages = Table.FromList(listOfPages, Splitter.SplitByNothing(), {\"Column1\"}),\r\n        firstRow = tableOfPages{0}?,\r\n        keys = if tableType = null then Table.ColumnNames(firstRow[Column1])\r\n            else Record.FieldNames(Type.RecordFields(Type.TableRow(tableType))),\r\n        appliedType = if tableType = null then Value.Type(firstRow[Column1]) else tableType\r\n    in\r\n        if tableType = null and firstRow = null then\r\n            Table.FromRows({})\r\n        else\r\n            Value.ReplaceType(\r\n                Table.ExpandTableColumn(tableOfPages, \"Column1\", keys),\r\n                appliedType);\r\n\r\nGetFormDigest = (url as text) as text =>\r\n    let\r\n        contextUrl = Text.BeforeDelimiter(url, \"/_api/\") & \"/_api/contextinfo\",\r\n        // SharePoint 2013 will return xml instead of json unless we specify odata=verbose in Accept header\r\n        requestHeaders = [#\"Content-Type\" = \"application/json;odata=verbose\", Accept = \"application/json; odata=verbose\" ],\r\n        requestBody = Text.ToBinary(\"{}\"),\r\n        request = [Headers = requestHeaders, Content = requestBody],\r\n        contents = Web.Contents(contextUrl, request),\r\n        jsonResponse = Json.Document(contents),\r\n        contextinfo = \r\n        [\r\n            FormDigestValue = jsonResponse[d][GetContextWebInformation][FormDigestValue],\r\n            LibraryVersion = jsonResponse[d][GetContextWebInformation][LibraryVersion]\r\n        ],\r\n        digest = if Text.StartsWith(contextinfo[LibraryVersion], \"15.\") \r\n                 then error Error.Record(\"DataSource.Error\", UICulture.GetString((\"SharePointNotSupportedApi\")))\r\n                 else contextinfo[FormDigestValue]\r\n    in\r\n        digest;\r\n\r\nGetPage = (url as text) as table =>\r\n    let\r\n        digestHeader = if (Extension.CurrentCredential()[AuthenticationKind] = \"Windows\") then [#\"X-RequestDigest\" = GetFormDigest(url)] else [],\r\n        requestHeaders = [#\"Content-Type\" = \"application/json;odata=verbose\"] & digestHeader,\r\n        requestBody = Text.ToBinary(\"{'parameters': {'__metadata': { 'type': 'SP.RenderListDataParameters' }, 'ViewXml': '<View Scope=\"\"RecursiveAll\"\"><Query><Where><Eq><FieldRef Name=\"\"FSObjType\"\" /><Value Type=\"\"Integer\"\">0</Value></Eq></Where></Query><RowLimit Paged=\"\"TRUE\"\">\"& Number.ToText(SinglePageSize) &\"</RowLimit><ViewFields><FieldRef Name=\"\"FSObjType\"\" /><FieldRef Name=\"\"LinkFilename\"\" /><FieldRef Name=\"\"Modified\"\" /><FieldRef Name=\"\"BaseName\"\" /><FieldRef Name=\"\"FileSizeDisplay\"\" /><FieldRef Name=\"\"Created\"\" /><FieldRef Name=\"\"FileLeafRef.Suffix\"\" /><FieldRef Name=\"\"FileRef\"\" /></ViewFields></View>', 'RenderOptions': 2}}\"),\r\n        request = [Headers = requestHeaders, Content = requestBody],\r\n        contents = Web.Contents(url, request),\r\n        jsonResponse = Json.Document(contents),\r\n        nextLink = GetNextLink(url, jsonResponse),\r\n        tableType = ContentSchema(DateTime.Type, {\"Name\", \"Folder Path\"}, Binary.Type),\r\n        data = CreateFilesContent(jsonResponse[Row], tableType, GetUrlAuthority(url)),\r\n        dataWithNextLink = data meta [NextLink = nextLink]\r\n    in\r\n        dataWithNextLink;\r\n\r\n// Utiliy function which recreates uri from its parts. The opposite of Uri.Parts(...)\r\nUri.FromParts = (parts) =>\r\n    let\r\n        port = if (parts[Scheme] = \"https\" and parts[Port] = 443) or (parts[Scheme] = \"http\" and parts[Port] = 80) then \"\" else \":\" & Text.From(parts[Port]),\r\n        div1 = if Record.FieldCount(parts[Query]) > 0 then \"?\" else \"\",\r\n        div2 = if Text.Length(parts[Fragment]) > 0 then \"#\" else \"\",\r\n        uri = Text.Combine({parts[Scheme], \"://\", parts[Host], port, parts[Path], div1, Uri.BuildQueryString(parts[Query]), div2, parts[Fragment]})\r\n    in\r\n        uri;\r\n\r\n// the method does not perform any sanity checks.\r\n// It is assumed that the input nextHref will have an View=00000000-0000-0000-0000-000000000000 as part of query string\r\nRemoveNullGuidFromQueryParam = (nextHref as text) as text =>\r\n    let\r\n        uriParts = Uri.Parts(nextHref),\r\n        queryRecord = uriParts[Query],\r\n        withRemovedQueryFromUriParts = Record.RemoveFields(uriParts, \"Query\"),\r\n        withRemovedViewIdFromQuery = Record.RemoveFields(queryRecord, \"View\", MissingField.Ignore),\r\n        withQueryAddedToUriParts = Record.AddField(withRemovedQueryFromUriParts , \"Query\", withRemovedViewIdFromQuery),\r\n        result = Uri.FromParts(withQueryAddedToUriParts)\r\n    in\r\n        result ;\r\n\r\nGetNextLink = (url as text, response as record) as nullable text =>\r\n    let\r\n        // SharePoint returns NextHref as a query string to replace the last queried URL\r\n        nextHref = response[NextHref]?,\r\n        // Note: Null Guids dont work with pagination for pre-2016 SP versions, even though the NextUrl returned by the source has it.\r\n        // So remove it from original query string\r\n        viewGuidNull = \"View=00000000-0000-0000-0000-000000000000\",\r\n        urlWithoutQuery = Text.BeforeDelimiter(url, \"?\"),\r\n        nextLink = if null = nextHref then null else urlWithoutQuery & nextHref,\r\n        nextLinkWithRemovedNullGuid = try   // Adding a ty guard incase the parsing fails because SP sends a malformed uri, we should send the uri as is.\r\n            if nextLink <> null and Text.PositionOf(nextHref, viewGuidNull) >= 0 then RemoveNullGuidFromQueryParam(nextLink) else nextLink\r\n            otherwise nextLink\r\n    in\r\n        nextLinkWithRemovedNullGuid;\r\n\r\nTransformToFiles = (row as record, apiUrl as text) as table =>\r\n    let\r\n        id = row[Id],\r\n        url = apiUrl & \"/lists/getbyid('\" & id & \"')/RenderListDataAsStream\",\r\n        tableType = ContentSchema(DateTime.Type, {\"Name\", \"Folder Path\"}, Binary.Type meta [Preview.Delay=\"Binary\"]),\r\n        Result = Table.View(null,\r\n        [\r\n            GetRows = () => GetAllPagesByNextLink(url),\r\n            GetType = () => tableType\r\n        ])\r\n    in\r\n        Result;\r\n\r\nGetFileExtension = (fil[...string is too long...]";
	}
}
